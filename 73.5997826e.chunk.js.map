{"version":3,"file":"73.5997826e.chunk.js","mappings":"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","sources":["webpack://cyb/webpack/runtime/chunk loaded","webpack://cyb/webpack/runtime/create fake namespace object","webpack://cyb/webpack/runtime/startup chunk dependencies","webpack://cyb/./src/services/ipfs/utils/cid.ts","webpack://cyb/./src/services/ipfs/config.ts","webpack://cyb/./src/services/ipfs/node/impl/kubo.ts","webpack://cyb/./src/services/ipfs/node/impl/helia.ts","webpack://cyb/./src/services/ipfs/node/impl/configs/jsIpfsConfig.ts","webpack://cyb/./src/services/ipfs/node/impl/js-ipfs.ts","webpack://cyb/./src/services/ipfs/utils/stream.ts","webpack://cyb/./src/services/ipfs/utils/content.ts","webpack://cyb/./src/db.js","webpack://cyb/./src/services/ipfs/utils/ipfsCacheDb.ts","webpack://cyb/./src/services/ipfs/utils/cluster.ts","webpack://cyb/./src/services/ipfs/utils/utils-ipfs.ts","webpack://cyb/./src/services/ipfs/node/factory.ts","webpack://cyb/./src/services/ipfs/node/mixins/withCybFeatures.ts","webpack://cyb/./src/services/QueueManager/QueueStrategy.ts","webpack://cyb/./src/services/QueueManager/QueueItemTimeoutError.ts","webpack://cyb/./src/features/particle/utils.tsx","webpack://cyb/./src/services/CozoDb/types/entities.ts","webpack://cyb/./src/features/sense/redux/sense.redux.ts","webpack://cyb/./src/services/backend/channels/BroadcastChannelSender.ts","webpack://cyb/./src/services/backend/channels/consts.ts","webpack://cyb/./src/services/QueueManager/QueueManager.ts","webpack://cyb/./src/utils/helpers.ts","webpack://cyb/./src/services/QueueManager/types.ts","webpack://cyb/./src/services/backend/workers/serializers.ts","webpack://cyb/./src/services/backend/workers/factoryMethods.ts","webpack://cyb/./src/services/backend/channels/broadcastStatus.ts","webpack://cyb/./src/utils/async/iterable.ts","webpack://cyb/./src/constants/app.ts","webpack://cyb/./src/services/backend/services/sync/services/consts.ts","webpack://cyb/./src/services/backend/services/sync/services/ParticlesResolverQueue/ParticlesResolverQueue.ts","webpack://cyb/./src/utils/date.ts","webpack://cyb/./src/services/CozoDb/mapping.ts","webpack://cyb/./src/utils/async/promise.ts","webpack://cyb/./src/constants/config.ts","webpack://cyb/./src/services/backend/services/indexer/types.ts","webpack://cyb/./src/services/blockchain/utils/mapping.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/utils/fetch.ts","webpack://cyb/./src/services/backend/services/indexer/utils.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/indexer.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/consts.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/links.ts","webpack://cyb/./src/services/backend/services/indexer/transactions.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/sense.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncTransactionsLoop/services/chat.ts","webpack://cyb/./src/services/backend/services/sync/services/ProgressTracker/ProgressTracker.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSync.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/rxjs/withInitializer.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSyncClient.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncTransactionsLoop/SyncTransactionsLoop.ts","webpack://cyb/./src/services/blockchain/websocket.ts","webpack://cyb/./src/utils/dto.ts","webpack://cyb/./src/services/backend/services/sync/utils.ts","webpack://cyb/./src/utils/exceptions/helpers.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSyncLoop.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/rxjs/loop.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncParticlesLoop/SyncParticlesLoop.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncMyFriendsLoop/SyncMyFriendsLoop.ts","webpack://cyb/./src/utils/ipfs/helpers.ts","webpack://cyb/./src/services/community/community.ts","webpack://cyb/./src/services/backend/services/lcd/lcd.ts","webpack://cyb/./src/services/backend/services/sync/sync.ts","webpack://cyb/./src/services/backend/services/sync/services/CommunitySync/CommunitySync.ts","webpack://cyb/./src/services/backend/services/DeferredDbSaver/DeferredDbSaver.ts","webpack://cyb/./src/services/backend/workers/background/worker.ts","webpack://cyb/./src/utils/logging/constants.ts","webpack://cyb/./src/utils/logging/cyblog.ts","webpack://cyb/webpack/bootstrap","webpack://cyb/webpack/runtime/amd options","webpack://cyb/webpack/runtime/compat get default export","webpack://cyb/webpack/runtime/define property getters","webpack://cyb/webpack/runtime/ensure chunk","webpack://cyb/webpack/runtime/get javascript chunk filename","webpack://cyb/webpack/runtime/get mini-css chunk filename","webpack://cyb/webpack/runtime/global","webpack://cyb/webpack/runtime/hasOwnProperty shorthand","webpack://cyb/webpack/runtime/make namespace object","webpack://cyb/webpack/runtime/node module decorator","webpack://cyb/webpack/runtime/publicPath","webpack://cyb/webpack/runtime/importScripts chunk loading","webpack://cyb/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });\n\t}\n\tdef['default'] = function() { return value; };\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([912,393,698,724].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","import { CID } from 'multiformats/cid';\n\nexport const stringToCid = (s: string) => CID.parse(s);\nexport const stringToIpfsPath = (s: string) => `/ipfs/${s}`;\n","import { IPFSNodes, IpfsOptsType } from './ipfs.d';\n\nexport const CYBER_NODE_SWARM_PEER_ID =\n  'QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB';\n\nexport const CYBERNODE_SWARM_ADDR_WSS = `/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/${CYBER_NODE_SWARM_PEER_ID}`;\nexport const CYBERNODE_SWARM_ADDR_TCP = `/ip4/88.99.105.146/tcp/4001/p2p/${CYBER_NODE_SWARM_PEER_ID}`;\n\nexport const IPFS_CLUSTER_URL = 'https://io.cybernode.ai';\n\nexport const CYBER_GATEWAY_URL = 'https://gateway.ipfs.cybernode.ai';\n\nexport const FILE_SIZE_DOWNLOAD = 20 * 10 ** 6;\n\nexport const getIpfsOpts = () => {\n  let ipfsOpts: IpfsOptsType = {\n    ipfsNodeType: IPFSNodes.HELIA,\n    urlOpts: '/ip4/127.0.0.1/tcp/5001', // default url\n    userGateway: 'http://127.0.0.1:8080',\n  };\n\n  // get type ipfs\n  const lsTypeIpfs = localStorage.getItem('ipfsState');\n  if (lsTypeIpfs !== null) {\n    const lsTypeIpfsData = JSON.parse(lsTypeIpfs);\n    ipfsOpts = { ...ipfsOpts, ...lsTypeIpfsData };\n  }\n\n  localStorage.setItem('ipfsState', JSON.stringify(ipfsOpts));\n\n  return ipfsOpts as IpfsOptsType;\n};\n","import { IPFSHTTPClient, create as createKuboClient } from 'kubo-rpc-client';\nimport { multiaddr } from '@multiformats/multiaddr';\n\nimport { stringToCid, stringToIpfsPath } from '../../utils/cid';\nimport {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  InitOptions,\n  IpfsFileStats,\n  IpfsNode,\n  IpfsNodePrperties,\n} from '../../ipfs';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nclass KuboNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'external';\n\n  private node?: IPFSHTTPClient;\n\n  private _config: IpfsNodePrperties = {};\n\n  get config() {\n    return this._config;\n  }\n\n  private _isStarted: boolean = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private async initConfig() {\n    const response = await this.node!.config.get('Addresses.Gateway');\n    if (!response) {\n      return { gatewayUrl: CYBER_GATEWAY_URL };\n    }\n    const address = multiaddr(response as string).nodeAddress();\n\n    return { gatewayUrl: `http://${address.address}:${address.port}` };\n  }\n\n  async init(options?: InitOptions) {\n    this.node = createKuboClient(options);\n    this._config = await this.initConfig();\n\n    if (typeof window !== 'undefined') {\n      window.node = this.node;\n      window.toCid = stringToCid;\n    }\n    console.log(\n      'IPFS - Kubo addrs',\n      (await this.node.swarm.localAddrs()).map((a) => a.toString())\n    );\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.node!.files.stat(stringToIpfsPath(cid), {\n      ...options,\n      withLocal: true,\n      size: true,\n    }).then((result) => {\n      const { type, size, sizeLocal, local, blocks } = result;\n      return {\n        type,\n        size: size || -1,\n        sizeLocal: sizeLocal || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.node!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    return (await this.node!.add(content, options)).cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    return (await this.node!.pin.add(stringToCid(cid), options)).toString();\n  }\n\n  async getPeers() {\n    return (await this.node!.swarm.peers()).map((c) => c.peer.toString());\n  }\n\n  async stop() {}\n  async start() {}\n\n  async connectPeer(address: string) {\n    const addr = multiaddr(address);\n    await this.node!.bootstrap.add(addr);\n\n    await this.node!.swarm.connect(addr);\n    return true;\n  }\n\n  ls() {\n    return this.node!.pin.ls();\n  }\n\n  async info() {\n    const { repoSize } = await this.node!.stats.repo();\n\n    const responseId = await this.node!.id();\n    const { agentVersion, id } = responseId;\n    return { id: id.toString(), agentVersion, repoSize };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default KuboNode;\n","import { Helia, Pin, createHelia } from 'helia';\nimport { IDBBlockstore } from 'blockstore-idb';\nimport { IDBDatastore } from 'datastore-idb';\nimport { Libp2p, createLibp2p } from 'libp2p';\nimport { noise } from '@chainsafe/libp2p-noise';\nimport { yamux } from '@chainsafe/libp2p-yamux';\n// import { mplex } from '@libp2p/mplex';\n\nimport { circuitRelayTransport } from 'libp2p/circuit-relay';\nimport { UnixFS, unixfs, AddOptions } from '@helia/unixfs';\nimport { bootstrap } from '@libp2p/bootstrap';\nimport { webRTC, webRTCDirect } from '@libp2p/webrtc';\nimport { webSockets } from '@libp2p/websockets';\nimport { webTransport } from '@libp2p/webtransport';\nimport { identifyService } from 'libp2p/identify';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport { LsResult } from 'ipfs-core-types/src/pin';\n\nimport {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  IpfsFileStats,\n  IpfsNode,\n} from '../../ipfs';\n// import { all } from '@libp2p/websockets/filters';\nimport { stringToCid } from '../../utils/cid';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nasync function* mapToLsResult(\n  iterable: AsyncIterable<Pin>\n): AsyncIterable<LsResult> {\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of iterable) {\n    const { cid, metadata } = item;\n    yield { cid: cid.toV0(), metadata, type: 'recursive' };\n  }\n}\n\nconst libp2pFactory = async (\n  datastore: IDBDatastore,\n  bootstrapList: string[] = []\n) => {\n  const libp2p = await createLibp2p({\n    datastore,\n    // addresses: {\n    //   listen: [\n    //     '/ip4/127.0.0.1/tcp/0',\n    //     '/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    //   ],\n    // },\n    transports: [\n      webSockets(),\n      webTransport(),\n      webRTC({\n        rtcConfiguration: {\n          iceServers: [\n            {\n              urls: [\n                'stun:stun.l.google.com:19302',\n                'stun:global.stun.twilio.com:3478',\n                'STUN:freestun.net:3479',\n                'STUN:stun.bernardoprovenzano.net:3478',\n                'STUN:stun.aa.net.uk:3478',\n              ],\n            },\n            {\n              credential: 'free',\n              username: 'free',\n              urls: ['TURN:freestun.net:3479', 'TURNS:freestun.net:5350'],\n            },\n          ],\n        },\n      }),\n      webRTCDirect(),\n      circuitRelayTransport({\n        discoverRelays: 1,\n      }),\n    ],\n    connectionEncryption: [noise()],\n    streamMuxers: [yamux()],\n    connectionGater: {\n      denyDialMultiaddr: () => {\n        return false;\n        // by default we refuse to dial local addresses from the browser since they\n        // are usually sent by remote peers broadcasting undialable multiaddrs but\n        // here we are explicitly connecting to a local node so do not deny dialing\n        // any discovered address\n      },\n    },\n    peerDiscovery: [\n      bootstrap({\n        list: bootstrapList,\n      }),\n    ],\n    services: {\n      identify: identifyService(),\n    },\n  });\n  return libp2p;\n};\n\nconst addOptionsV0: Partial<AddOptions> = {\n  cidVersion: 0,\n  rawLeaves: false,\n};\n\nclass HeliaNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'helia';\n\n  get config() {\n    return { gatewayUrl: CYBER_GATEWAY_URL };\n  }\n\n  private _isStarted = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private node?: Helia;\n\n  private fs?: UnixFS;\n\n  async init() {\n    const blockstore = new IDBBlockstore('helia-bs');\n    await blockstore.open();\n\n    const datastore = new IDBDatastore('helia-ds');\n    await datastore.open();\n\n    const bootstrapList = [\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n      '/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    ];\n    const libp2p = await libp2pFactory(datastore, bootstrapList);\n\n    this.node = await createHelia({ blockstore, datastore, libp2p });\n\n    this.fs = unixfs(this.node);\n\n    if (typeof window !== 'undefined') {\n      window.libp2p = libp2p;\n      window.node = this.node;\n      window.fs = this.fs;\n      window.toCid = stringToCid;\n    }\n\n    // DEBUG\n    libp2p.addEventListener('peer:connect', (evt) => {\n      const peerId = evt.detail.toString();\n      const conn = libp2p.getConnections(peerId) || [];\n      const transportsByAddr = Object.fromEntries(\n        conn.map((c) => [\n          c.remoteAddr.toString(),\n          c.remoteAddr.protoCodes().map((v) => protocols(v)?.name),\n        ])\n      );\n      console.debug(`Connected to ${peerId}`, transportsByAddr);\n\n      // console.log(\n      //   '---------ppppp',\n      //   peerId,\n      //   conn,\n      //   conn?.remoteAddr.protoCodes().map((v) => protocols(v)?.name)\n      // ); //.includes(WEBRTC_CODE)\n      // if (conn && conn.stat) {\n      //   const transport = conn.stat.transport; // This might vary based on libp2p version\n      //   console.log(`Connected to ${peerId} using transport ${transport}`);\n      // } else {\n      //   console.log(`Connected to ${peerId}`);\n      // }\n    });\n    libp2p.addEventListener('peer:disconnect', (evt) => {\n      console.debug(`Disconnected from ${evt.detail.toString()}`);\n    });\n    console.log(\n      'IPFS - Helia addrs',\n      libp2p.getMultiaddrs().map((a) => a.toString())\n    );\n    // const webrtcConn = await libp2p.dial(\n    //   multiaddr(\n    //     '/ip4/127.0.0.1/udp/4001/quic-v1/webtransport/certhash/uEiDHumbyZRFV1Av7qH9-2l5HGgU2a2UqM6eloqO0vYz5pQ/certhash/uEiDD_TuVgih5_ua31Z4MVbNq7WSw095UAQmZqdUFMDTVRA/p2p/12D3KooWEYGfgK4dEY3spfuDKVq6Jpiyj4KxP1r6HS5RFp5WHebz'\n    //   )\n    // );\n    // console.log('----webrtcConn', webrtcConn);\n\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.fs!.stat(stringToCid(cid), options).then((result) => {\n      const { type, fileSize, localFileSize, blocks, dagSize, mtime } = result;\n      return {\n        type,\n        size: fileSize || -1,\n        sizeLocal: localFileSize || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.fs!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    // Options to keep CID in V0 format 'Qm....';\n    const optionsV0 = {\n      ...options,\n      ...addOptionsV0,\n    } as Partial<AddOptions>;\n\n    let cid;\n\n    if (content instanceof File) {\n      const fileName = content.name;\n      const arrayBuffer = await content.arrayBuffer();\n      const data = new Uint8Array(arrayBuffer);\n      cid = await this.fs!.addFile(\n        { path: fileName, content: data },\n        optionsV0\n      );\n    } else {\n      const data = new TextEncoder().encode(content);\n      cid = await this.fs!.addBytes(data, optionsV0);\n    }\n    console.log('----added to helia', cid.toString());\n    this.pin(cid.toString(), options);\n    return cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    const cid_ = stringToCid(cid);\n    const isPinned = await this.node?.pins.isPinned(cid_, options);\n    if (!isPinned) {\n      const pinResult = (\n        await this.node?.pins.add(cid_, options)\n      )?.cid.toString();\n      // console.log('------pin', pinResult);\n    }\n    // console.log('------pinned', cid, isPinned);\n    return undefined;\n  }\n\n  async getPeers() {\n    return this.node!.libp2p!.getConnections().map((c) =>\n      c.remotePeer.toString()\n    );\n  }\n\n  async stop() {\n    await this.node?.stop();\n  }\n\n  async start() {\n    await this.node?.start();\n  }\n\n  async connectPeer(address: string) {\n    const conn = await this.node!.libp2p!.dial(multiaddr(address));\n    return true;\n  }\n\n  ls() {\n    const result = mapToLsResult(this.node!.pins.ls());\n    return result;\n  }\n\n  async info() {\n    const id = this.node!.libp2p.peerId.toString();\n    const agentVersion = this.node!.libp2p!.services!.identify!.host!\n      .agentVersion as string;\n    return { id, agentVersion, repoSize: -1 };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default HeliaNode;\n","// eslint-disable-next-line import/no-unresolved\nimport { webSockets } from '@libp2p/websockets';\nimport * as filters from '@libp2p/websockets/filters';\nimport { Options } from 'ipfs-core/dist/src/types';\n\nconst configIpfs = (): Options => ({\n  start: true,\n  repo: 'ipfs-repo-cyber-v2',\n  relay: {\n    enabled: false,\n    hop: {\n      enabled: false,\n    },\n  },\n  preload: {\n    enabled: false,\n  },\n  config: {\n    API: {\n      HTTPHeaders: {\n        'Access-Control-Allow-Methods': ['PUT', 'POST'],\n        'Access-Control-Allow-Origin': [\n          'http://localhost:3000',\n          'http://127.0.0.1:5001',\n          'http://127.0.0.1:8888',\n          'http://localhost:8888',\n        ],\n      },\n    },\n    Addresses: {\n      Gateway: '/ip4/127.0.0.1/tcp/8080',\n      Swarm: [\n        // '/dns4/ws-star.discovery.cybernode.ai/tcp/443/wss/p2p-webrtc-star',\n        // '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',\n        // '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star',\n      ],\n      Delegates: [\n        // '/dns4/node0.delegate.ipfs.io/tcp/443/https',\n        // '/dns4/node1.delegate.ipfs.io/tcp/443/https',\n        // '/dns4/node2.delegate.ipfs.io/tcp/443/https',\n      ],\n    },\n    Discovery: {\n      MDNS: {\n        Enabled: true,\n        Interval: 10,\n      },\n      webRTCStar: {\n        Enabled: false,\n      },\n    },\n    Bootstrap: [\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n      // '/dns4/ws-star.discovery.cybernode.ai/tcp/4430/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    ],\n    Pubsub: {\n      Enabled: false,\n    },\n    Swarm: {\n      ConnMgr: {\n        HighWater: 300,\n        LowWater: 50,\n      },\n      DisableNatPortMap: false,\n    },\n    Routing: {\n      Type: 'dhtclient',\n    },\n  },\n  libp2p: {\n    transports: [\n      // This is added for local demo!\n      // In a production environment the default filter should be used\n      // where only DNS + WSS addresses will be dialed by websockets in the browser.\n      webSockets({\n        filter: filters.dnsWss,\n      }),\n    ],\n    nat: {\n      enabled: false,\n    },\n  },\n  EXPERIMENTAL: {\n    ipnsPubsub: false,\n  },\n});\n\nexport default configIpfs;\n","import {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  IpfsFileStats,\n  IpfsNode,\n  IpfsNodePrperties,\n} from '../../ipfs';\nimport { create as createJsIpfsClient, IPFS } from 'ipfs-core';\nimport { stringToCid, stringToIpfsPath } from '../../utils/cid';\nimport { multiaddr } from '@multiformats/multiaddr';\n\nimport configIpfs from './configs/jsIpfsConfig';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nclass JsIpfsNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'embedded';\n\n  get config() {\n    return { gatewayUrl: CYBER_GATEWAY_URL };\n  }\n\n  private _isStarted: boolean = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private node?: IPFS;\n\n  async init() {\n    this.node = await createJsIpfsClient(configIpfs());\n    if (typeof window !== 'undefined') {\n      window.node = this.node;\n      window.toCid = stringToCid;\n    }\n\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.node!.files.stat(stringToIpfsPath(cid), {\n      ...options,\n      withLocal: true,\n      size: true,\n    }).then((result) => {\n      const { type, size, sizeLocal, local, blocks } = result;\n      return {\n        type,\n        size: size || -1,\n        sizeLocal: sizeLocal || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.node!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    return (await this.node!.add(content, options)).cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    return (await this.node!.pin.add(stringToCid(cid), options)).toString();\n  }\n\n  async getPeers() {\n    return (await this.node!.swarm.peers()).map((c) => c.peer.toString());\n  }\n\n  async stop() {}\n  async start() {}\n\n  async connectPeer(address: string) {\n    const addr = multiaddr(address);\n    await this.node!.bootstrap.add(addr);\n\n    await this.node!.swarm.connect(addr);\n    return true;\n  }\n\n  ls() {\n    return this.node!.pin.ls();\n  }\n\n  async info() {\n    const response = await this.node!.stats.repo();\n    const repoSize = Number(response.repoSize);\n\n    const responseId = await this.node!.id();\n    const { agentVersion, id } = responseId;\n    return { id: id.toString(), agentVersion, repoSize };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default JsIpfsNode;\n","/* eslint-disable valid-jsdoc */\n/* eslint-disable import/no-unused-modules */\nimport { fileTypeFromBuffer } from 'file-type';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { Uint8ArrayLike } from '../ipfs';\n\ntype ResultWithMime = {\n  result: Uint8ArrayLike;\n  mime: string | undefined;\n  firstChunk: Uint8Array | undefined;\n};\n\ntype StreamDoneCallback = (\n  chunks: Array<Uint8Array>,\n  mime: string | undefined\n) => Promise<void> | void;\n\n// interface AsyncIterableWithReturn<T> extends AsyncIterable<T> {\n//   return?: (value?: unknown) => Promise<IteratorResult<T>>;\n// }\n\nexport const getMimeFromUint8Array = async (\n  raw: Uint8Array | undefined\n): Promise<string | undefined> => {\n  if (!raw) {\n    return 'unknown';\n  }\n  // TODO: try to pass only first N-bytes\n  const fileType = await fileTypeFromBuffer(raw);\n\n  return fileType?.mime || 'text/plain';\n};\n\nexport async function toAsyncIterableWithMime(\n  stream: ReadableStream<Uint8Array>,\n  flush?: StreamDoneCallback\n): Promise<ResultWithMime> {\n  const [firstChunkStream, fullStream] = stream.tee();\n  const chunks: Array<Uint8Array> = []; // accumulate all the data to pim/save\n\n  // Read the first chunk from the stream\n  const firstReader = firstChunkStream.getReader();\n  const { value } = await firstReader.read();\n  const mime = value ? await getMimeFromUint8Array(value) : undefined;\n\n  const restReader = fullStream.getReader();\n\n  const asyncIterable: AsyncIterable<Uint8Array> = {\n    async *[Symbol.asyncIterator]() {\n      while (true) {\n        const { done, value } = await restReader.read();\n        if (done) {\n          flush && flush(chunks, mime);\n          return; // Exit the loop when done\n        }\n        flush && chunks.push(value);\n        yield value; // Yield the value to the consumer\n      }\n    },\n  };\n\n  return { mime, result: asyncIterable, firstChunk: value };\n}\n\nexport async function toReadableStreamWithMime(\n  stream: ReadableStream<Uint8Array>,\n  flush?: StreamDoneCallback\n): Promise<ResultWithMime> {\n  const [firstChunkStream, fullStream] = stream.tee();\n  const chunks: Array<Uint8Array> = []; // accumulate all the data to pim/save\n\n  // Read the first chunk from the stream\n  const firstReader = firstChunkStream.getReader();\n  const { value } = await firstReader.read();\n  const mime = value ? await getMimeFromUint8Array(value) : undefined;\n\n  const modifiedStream = new ReadableStream<Uint8Array>({\n    async pull(controller) {\n      const restReader = fullStream.getReader();\n      const { done, value } = await restReader.read();\n      if (done) {\n        controller.close();\n        flush && flush(chunks, mime);\n      } else {\n        controller.enqueue(value);\n        flush && chunks.push(value);\n      }\n      restReader.releaseLock();\n    },\n    cancel() {\n      firstChunkStream.cancel();\n      fullStream.cancel();\n    },\n  });\n\n  return { mime, result: modifiedStream, firstChunk: value };\n}\n\nexport type onProgressCallback = (progress: number) => void;\n\nexport const getResponseResult = async (\n  response: Uint8ArrayLike,\n  onProgress?: onProgressCallback\n) => {\n  let bytesDownloaded = 0;\n  try {\n    if (response instanceof Uint8Array) {\n      onProgress && onProgress(response.byteLength);\n      return response;\n    }\n    const chunks: Array<Uint8Array> = [];\n\n    if (response instanceof ReadableStream) {\n      const reader = response.getReader();\n\n      const readStream = async ({\n        done,\n        value,\n      }: ReadableStreamReadResult<Uint8Array>): Promise<Uint8Array> => {\n        if (done) {\n          return uint8ArrayConcat(chunks);\n        }\n\n        chunks.push(value!);\n        bytesDownloaded += value!.byteLength;\n        onProgress && onProgress(bytesDownloaded);\n        return reader.read().then(readStream);\n      };\n\n      const readArray: Uint8Array = await reader.read().then(readStream);\n\n      return readArray;\n    }\n\n    const reader = response[Symbol.asyncIterator]();\n\n    // if (cid === 'QmRqms6Utkk6L4mtyLQXY2spcQ8Pk7fBBTNjvxa9jTNrXp') {\n    //   debugger;\n    // }\n    // eslint-disable-next-line no-restricted-syntax\n    for await (const chunk of reader) {\n      if (chunk instanceof Uint8Array) {\n        chunks.push(chunk);\n        bytesDownloaded += chunk.byteLength;\n        onProgress && onProgress(bytesDownloaded);\n      }\n    }\n    const result = uint8ArrayConcat(chunks);\n    return result;\n  } catch (error) {\n    console.error(\n      `Error reading stream/iterable.\\r\\n Probably Hot reload error!`,\n      error\n    );\n\n    return undefined;\n  }\n};\n","import { toString as uint8ArrayToAsciiString } from 'uint8arrays/to-string';\nimport isSvg from 'is-svg';\nimport { IPFSContentDetails, IPFSContentMaybe, IpfsContentType } from '../ipfs';\nimport { getResponseResult, onProgressCallback } from './stream';\n\n// TODO: fix to get working inside web worker, REFACTOR\n// import { PATTERN_HTTP, PATTERN_IPFS_HASH } from '../config';\nconst PATTERN_IPFS_HASH = /^Qm[a-zA-Z0-9]{44}$/g;\nconst PATTERN_HTTP = /^https:\\/\\/|^http:\\/\\//g;\n\nfunction createObjectURL(rawData: Uint8Array, type: string) {\n  const blob = new Blob([rawData], { type });\n  return URL.createObjectURL(blob);\n}\n\nfunction createImgData(rawData: Uint8Array, type: string) {\n  const imgBase64 = uint8ArrayToAsciiString(rawData, 'base64');\n  const file = `data:${type};base64,${imgBase64}`;\n  return file;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport const detectContentType = (\n  mime: string | undefined\n): IpfsContentType => {\n  if (mime) {\n    if (mime.includes('video')) {\n      return 'video';\n    }\n\n    if (mime.includes('audio')) {\n      return 'audio';\n    }\n  }\n  return 'other';\n};\n\nconst basic = /\\s?<!doctype html>|(<html\\b[^>]*>|<body\\b[^>]*>|<x-[^>]+>)+/i;\n\nfunction isHtml(string) {\n  const newString = string.trim().slice(0, 1000);\n  return basic.test(newString);\n}\n\nfunction shortenString(string: string, length = 300) {\n  return string.length > length ? `${string.slice(0, length)}...` : string;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport const chunksToBlob = (\n  chunks: Array<Uint8Array>,\n  mime: string | undefined\n) => new Blob(chunks, mime ? { type: mime } : {});\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport const parseArrayLikeToDetails = async (\n  content: IPFSContentMaybe,\n  // rawDataResponse: Uint8ArrayLike | undefined,\n  // mime: string | undefined,\n  cid: string,\n  onProgress?: onProgressCallback\n): Promise<IPFSContentDetails> => {\n  try {\n    // console.log('------parseArrayLikeToDetails', cid, content);\n    const mime = content?.meta?.mime;\n    const response: IPFSContentDetails = {\n      link: `/ipfs/${cid}`,\n      gateway: false,\n      cid,\n    };\n    const initialType = detectContentType(mime);\n    if (['video', 'audio'].indexOf(initialType) > -1) {\n      return { ...response, type: initialType, gateway: true };\n    }\n\n    const rawData = content?.result\n      ? await getResponseResult(content.result, onProgress)\n      : undefined;\n\n    // console.log(rawData);\n\n    if (!mime) {\n      response.text = `Can't detect MIME for ${cid.toString()}`;\n      response.gateway = true; // ???\n    } else if (\n      mime.indexOf('text/plain') !== -1 ||\n      mime.indexOf('application/xml') !== -1\n    ) {\n      if (isSvg(Buffer.from(rawData))) {\n        response.type = 'image';\n        response.content = createImgData(rawData, 'image/svg+xml'); // file\n      } else {\n        const dataBase64 = uint8ArrayToAsciiString(rawData);\n        // TODO: search can bel longer for 42???!\n        // also cover ipns links\n        response.link =\n          dataBase64.length > 42 ? `/ipfs/${cid}` : `/search/${dataBase64}`;\n\n        if (dataBase64.match(PATTERN_IPFS_HASH)) {\n          response.gateway = true;\n          response.type = 'other';\n          response.content = dataBase64;\n          response.link = `/ipfs/${cid}`;\n        } else if (dataBase64.match(PATTERN_HTTP)) {\n          response.type = 'link';\n          response.gateway = false;\n          response.content = dataBase64;\n          response.link = `/ipfs/${cid}`;\n        } else if (isHtml(dataBase64)) {\n          response.type = 'other';\n          response.gateway = true;\n          response.content = cid.toString();\n        } else {\n          response.type = 'text';\n          response.content = dataBase64;\n          response.text = shortenString(dataBase64);\n        }\n      }\n    } else if (mime.indexOf('image') !== -1) {\n      response.content = createImgData(rawData, mime); // file\n      response.type = 'image';\n      response.gateway = false;\n    } else if (mime.indexOf('application/pdf') !== -1) {\n      response.type = 'pdf';\n      response.content = createObjectURL(rawData, mime); // file\n      response.gateway = true; // ???\n    }\n\n    return response;\n  } catch (e) {\n    console.log('----parseRawIpfsData', e, cid);\n    return undefined;\n  }\n};\n\nexport const contentToUint8Array = async (\n  content: File | string\n): Promise<Uint8Array> => {\n  return new Uint8Array(\n    typeof content === 'string'\n      ? Buffer.from(content)\n      : await content.arrayBuffer()\n  );\n};\n\nexport const createTextPreview = (\n  array: Uint8Array | undefined,\n  mime?: string,\n  previewLength = 150\n) => {\n  return array && mime && mime === 'text/plain'\n    ? uint8ArrayToAsciiString(array).slice(0, previewLength)\n    : undefined;\n};\n","import Dexie from 'dexie';\n\nconst db = new Dexie('cyber-page-cash');\ndb.version(3).stores({\n  cid: 'cid',\n  following: 'cid',\n});\n\nexport default db;\n","import db from 'src/db';\n\nconst ipfsCacheDb = () => {\n  const add = async (cid: string, raw: Uint8Array): Promise<void> => {\n    const dbValue = await db.table('cid').get({ cid });\n\n    if (!dbValue) {\n      const ipfsContentAddtToInddexdDB = {\n        cid,\n        data: raw,\n      };\n      db.table('cid').add(ipfsContentAddtToInddexdDB);\n    }\n  };\n\n  const get = async (cid: string): Promise<Uint8Array | undefined> => {\n    // TODO: use cursor\n    const dbValue = await db.table('cid').get({ cid });\n\n    // backward compatibility\n    return dbValue?.data || dbValue?.content;\n  };\n\n  return { add, get };\n};\n\nexport default ipfsCacheDb();\n","import {\n  AddResponse,\n  PinResponse,\n} from '@nftstorage/ipfs-cluster/dist/src/interface';\n\nimport { Cluster } from '@nftstorage/ipfs-cluster';\nimport { IPFS_CLUSTER_URL } from '../config';\n\nconst cyberCluster = () => {\n  const cluster = new Cluster(IPFS_CLUSTER_URL);\n\n  const add = async (\n    file: File | string\n  ): Promise<AddResponse | PinResponse | undefined> => {\n    const dataFile =\n      typeof file === 'string' ? new File([file], 'file.txt') : file;\n    return cluster.add(dataFile, { cidVersion: 0, rawLeaves: false });\n  };\n\n  const status = async (cid: string) => cluster.status(cid);\n  return { add, status };\n};\n\nexport default cyberCluster();\n","/* eslint-disable import/no-unused-modules */\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\n\nimport { Option } from 'src/types';\nimport {\n  // getIpfsUserGatewanAndNodeType,\n  IPFSContentMaybe,\n  IPFSContentMeta,\n  CallBackFuncStatus,\n  IpfsContentSource,\n  IpfsNode,\n} from '../ipfs';\n\nimport { getMimeFromUint8Array, toAsyncIterableWithMime } from './stream';\n\nimport ipfsCacheDb from './ipfsCacheDb';\nimport cyberCluster from './cluster';\n\nimport { contentToUint8Array, createTextPreview } from './content';\n\nimport {\n  // CYBERNODE_SWARM_ADDR_WSS,\n  // CYBERNODE_SWARM_ADDR_TCP,\n  // CYBER_NODE_SWARM_PEER_ID,\n  CYBER_GATEWAY_URL,\n  FILE_SIZE_DOWNLOAD,\n} from '../config';\n\n// import { convertTimeToMilliseconds } from '../helpers';\n// import { CYBER } from '../config';\n\n// TODO: fix to get working inside web worker, REFACTOR\n\n// Get IPFS node from local storage\n// TODO: refactor\n// const getIpfsUserGatewanAndNode = (): getIpfsUserGatewanAndNodeType => {\n//   const LS_IPFS_STATE = localStorage.getItem('ipfsState');\n\n//   if (LS_IPFS_STATE !== null) {\n//     const lsTypeIpfsData = JSON.parse(LS_IPFS_STATE);\n//     if (lsTypeIpfsData?.userGateway) {\n//       const { userGateway, ipfsNodeType } = lsTypeIpfsData;\n//       return { userGateway, ipfsNodeType };\n//     }\n//   }\n\n//   return { ipfsNodeType: undefined, userGateway: undefined };\n// };\n\n// Get data by CID from local storage\nconst loadIPFSContentFromDb = async (\n  cid: string\n): Promise<IPFSContentMaybe> => {\n  // TODO: enable, disabled for tests\n\n  // TODO: use cursor\n  const data = await ipfsCacheDb.get(cid);\n  if (data && data.length) {\n    // TODO: use cursor\n    const mime = await getMimeFromUint8Array(data);\n    const textPreview = createTextPreview(data, mime);\n\n    const meta: IPFSContentMeta = {\n      type: 'file', // `TODO: ipfs refactor dir support ?\n      size: data.length,\n      sizeLocal: data.length,\n      mime,\n    };\n    return { result: data, cid, meta, source: 'db', textPreview };\n  }\n\n  return undefined;\n};\n\nconst emptyMeta: IPFSContentMeta = {\n  type: 'file',\n  size: undefined,\n  local: undefined,\n  sizeLocal: undefined,\n};\n\nconst fetchIPFSContentMeta = async (\n  cid: string,\n  node?: IpfsNode,\n  signal?: AbortSignal\n): Promise<IPFSContentMeta> => {\n  if (node) {\n    const meta = await node.stat(cid, { signal });\n    return meta;\n  }\n  return emptyMeta;\n};\n\nconst fetchIPFSContentFromNode = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController\n): Promise<IPFSContentMaybe> => {\n  const controllerLegacy = controller || new AbortController();\n  const { signal } = controllerLegacy;\n  let timer: NodeJS.Timeout | undefined;\n\n  if (!node) {\n    console.log('--------fetchIPFSContentFromNode NO NODE INTIALIZED--------');\n    return undefined;\n  }\n\n  if (!controller) {\n    timer = setTimeout(() => {\n      controllerLegacy.abort();\n    }, 1000 * 60 * 1);\n  } // 1 min\n\n  // TODO: cover ipns case\n  try {\n    // const stat = await node.files.stat(path, { signal });\n    const startTime = Date.now();\n    const meta = await fetchIPFSContentMeta(cid, node, signal);\n    const statsDoneTime = Date.now();\n    meta.statsTime = statsDoneTime - startTime;\n    const allowedSize = meta.size ? meta.size < FILE_SIZE_DOWNLOAD : false;\n    timer && clearTimeout(timer);\n\n    switch (meta.type) {\n      case 'directory': {\n        // TODO: return directory structure\n        return { cid, availableDownload: true, source: 'node', meta };\n      }\n      default: {\n        // Get sample of content\n        const { value: firstChunk, done } = await node\n          .cat(cid, { signal, length: 2048, offset: 0 })\n          [Symbol.asyncIterator]()\n          .next();\n\n        const mime = await getMimeFromUint8Array(firstChunk);\n        const fullyDownloaded =\n          meta.size && meta.size > -1 && firstChunk.length >= meta.size;\n\n        const textPreview = createTextPreview(firstChunk, mime);\n\n        if (fullyDownloaded) {\n          await ipfsCacheDb.add(cid, uint8ArrayConcat(firstChunk));\n        }\n\n        // If all content fits in first chunk return byte-array instead iterable\n        const stream = fullyDownloaded\n          ? firstChunk\n          : allowedSize\n          ? node.cat(cid, { signal })\n          : undefined;\n\n        meta.catTime = Date.now() - statsDoneTime;\n\n        // TODO: add to db flag that content is pinned TO local node\n        // if already pinned skip pin\n        if (!meta.local && allowedSize) {\n          node.pin(cid);\n\n          meta.pinTime = Date.now() - meta.catTime;\n        } else {\n          meta.pinTime = -1;\n        }\n\n        return {\n          result: stream,\n          textPreview,\n          cid,\n          meta: { ...meta, mime },\n          source: 'node',\n        };\n        // }\n      }\n    }\n  } catch (error) {\n    console.debug('error fetchIPFSContentFromNode', error);\n    return { cid, availableDownload: true, source: 'node', meta: emptyMeta };\n  }\n};\n\nconst fetchIPFSContentFromGateway = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController\n): Promise<IPFSContentMaybe> => {\n  // TODO: Should we use Cyber Gateway?\n  // const { userGateway } = getIpfsUserGatewanAndNode();\n\n  // fetch META only from external node(toooo slow), TODO: fetch meta from cybernode\n  const isExternalNode = node?.nodeType === 'external';\n  const meta = isExternalNode\n    ? await fetchIPFSContentMeta(cid, node, controller?.signal)\n    : emptyMeta;\n\n  const contentUrl = `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n  const response = await fetch(contentUrl, {\n    method: 'GET',\n    signal: controller?.signal,\n  });\n\n  if (response && response.body) {\n    // fetch doesn't provide any headers in our case :(\n\n    // const contentLength = parseInt(\n    //   response.headers['content-length'] || '-1',\n    //   10\n    // );\n    // const contentType = response.headers['content-type'];\n\n    // Extract meta if ipfs prob/node not started yet\n    // if (!meta.mime) {\n    //   meta = { ...meta, mime: contentType };\n    // }\n\n    // TODO: fix\n    const flushResults = (chunks: Uint8Array[]) =>\n      !isExternalNode\n        ? ipfsCacheDb.add(cid, uint8ArrayConcat(chunks))\n        : Promise.resolve();\n\n    const { mime, result, firstChunk } = await toAsyncIterableWithMime(\n      response.body,\n      flushResults\n    );\n\n    const textPreview = createTextPreview(firstChunk, mime);\n    return {\n      cid,\n      textPreview,\n      meta: { ...meta, mime },\n      result,\n      source: 'gateway',\n      contentUrl,\n    };\n  }\n\n  return undefined;\n};\n\ntype fetchContentOptions = {\n  controller?: AbortController;\n  node?: IpfsNode;\n};\n\nasync function fetchIpfsContent(\n  cid: string,\n  source: IpfsContentSource,\n  options: fetchContentOptions\n): Promise<IPFSContentMaybe> {\n  const { node, controller } = options;\n\n  try {\n    switch (source) {\n      case 'db':\n        return loadIPFSContentFromDb(cid);\n      case 'node':\n        return fetchIPFSContentFromNode(cid, node, controller);\n      case 'gateway':\n        return fetchIPFSContentFromGateway(cid, node, controller);\n      default:\n        return undefined;\n    }\n  } catch (e) {\n    console.log('----fetchIpfsContent error', e);\n    return undefined;\n  }\n}\n\nconst getIPFSContent = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController,\n  callBackFuncStatus?: CallBackFuncStatus\n): Promise<IPFSContentMaybe> => {\n  const dataRsponseDb = await loadIPFSContentFromDb(cid);\n  if (dataRsponseDb !== undefined) {\n    return dataRsponseDb;\n  }\n\n  if (node) {\n    callBackFuncStatus && callBackFuncStatus('trying to get with a node');\n    // console.log('----Fetch from node', cid);\n    const ipfsContent = await fetchIPFSContentFromNode(cid, node, controller);\n\n    return ipfsContent;\n  }\n\n  callBackFuncStatus && callBackFuncStatus('trying to get with a gatway');\n  // console.log('----Fetch from gateway', cid);\n  const respnseGateway = await fetchIPFSContentFromGateway(\n    cid,\n    node,\n    controller\n  );\n\n  return respnseGateway;\n};\n\nconst catIPFSContentFromNode = (\n  cid: string,\n  node?: IpfsNode,\n  offset?: number,\n  controller?: AbortController\n): AsyncIterable<Uint8Array> | undefined => {\n  if (!node) {\n    console.log(\n      '--------fetchIPFSContentFromNode NO NODE INTIALIZED TODO: cover case--------'\n    );\n    return undefined;\n  }\n\n  // TODO: cover ipns case\n\n  return node.cat(cid, { offset, signal: controller?.signal });\n};\n\n// const nodeContentFindProvs = async (\n//   node: AppIPFS,\n//   cid: string,\n//   offset: number,\n//   controller?: AbortController\n// ): AsyncIterable<number> | undefined => {\n//   if (!node) {\n//     console.log(\n//       '--------fetchIPFSContentFromNode NO NODE INTIALIZED TODO: cover case--------'\n//     );\n//     return undefined;\n//   }\n\n//   // TODO: cover ipns case\n//   const path = `/ipfs/${cid}`;\n\n//   const providers = node.dht.findProvs(path, {\n//     signal: controller?.signal,\n//   });\n\n//   let count = 0;\n//   for await (const provider of providers) {\n//     //  console.log(provider.id.toString())\n//     //  id: PeerId\n//     // multiaddrs: Multiaddr[]\n//     // protocols: string[]\n//     count++;\n//   }\n\n//   return count;\n// };\n\nconst addContenToIpfs = async (\n  node: IpfsNode,\n  content: File | string\n): Promise<Option<string>> => {\n  let cid;\n  if (node) {\n    cid = await node.add(content);\n  }\n  // TODO: TMP solution make cluster call non-awaitable\n  cyberCluster.add(content);\n  // const pinResponse = await cyberCluster.add(content);\n  // cid = cid || pinResponse?.cid;\n\n  cid && (await ipfsCacheDb.add(cid, await contentToUint8Array(content)));\n  return cid;\n};\n\n// '/dns4/swarm.io.cybernode.ai/tcp/4001/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB';\n\n// const connectToSwarm = async (node, address) => {\n//   const multiaddrSwarm = multiaddr(address);\n//   // console.log(`Connecting to swarm ${address}`, node);\n//   if (node.nodeType === 'helia') {\n//     // node.libp2p.bootstrap.add(multiaddrSwarm);\n//     node.libp2p.dial(multiaddrSwarm);\n//     return;\n//   }\n\n//   await node.bootstrap.add(multiaddrSwarm);\n\n//   node?.swarm\n//     .connect(multiaddrSwarm)\n//     .then((resp) => {\n//       console.log(`Welcome to swarm ${address} `);\n//       // node.swarm.peers().then((peers) => console.log('---peeers', peers));\n//     })\n//     .catch((err) => {\n//       console.log(\n//         'Error object properties:',\n//         Object.getOwnPropertyNames(err),\n//         err.stack,\n//         err.errors,\n//         err.message\n//       );\n//       console.log(`Can't connect to swarm ${address}: ${err.message}`);\n//     });\n// };\n\n// const connectToCyberSwarm = async (node: AppIPFS) => {\n//   const cyberNodeAddr =\n//     node.nodeType === 'embedded'\n//       ? CYBERNODE_SWARM_ADDR_WSS\n//       : CYBERNODE_SWARM_ADDR_TCP;\n//   await connectToSwarm(node, cyberNodeAddr);\n// };\n\n// const reconnectToCyberSwarm = async (node?: IpfsNode, lastCallTime: 0) => {\n//   if (!node) {\n//     return;\n//   }\n//   const isHelia = node.nodeType === 'helia';\n//   const cyberNodeAddr =\n//     node.nodeType !== 'external'\n//       ? CYBERNODE_SWARM_ADDR_WSS\n//       : CYBERNODE_SWARM_ADDR_TCP;\n\n//   const isSwarmConnected = isHelia\n//     ? node!.libp2p\n//         .getConnections()\n//         .find((c) => c.remotePeer.toString() === CYBER_NODE_SWARM_PEER_ID)\n//     : (await node!.swarm.peers()).find(\n//         (p) => p.peer.toString() === CYBER_NODE_SWARM_PEER_ID\n//       );\n\n//   // console.log('autoDialTime', await getNodeAutoDialInterval(node));\n//   // console.log('lastCallTime', lastCallTime, Date.now() - lastCallTime);\n\n//   // console.log('---isConnected', true, peers.length);\n\n//   if (!isSwarmConnected) {\n//     // TODO: refactor using timeout for node\n//     const needToReconnect =\n//       Date.now() - lastCallTime < (node.connMgrGracePeriod || 20);\n//     if (needToReconnect) {\n//       await connectToSwarm(node, cyberNodeAddr);\n//     }\n//   }\n// };\n\n// const DEFAULT_AUTO_DIAL_INTERVAL = 10000;\n// const GET_CONFIG_TIMEOUT = 3000;\n// TODO: REFACTOR\n// const getNodeAutoDialInterval = async (node: IpfsNode) => {\n//   try {\n//     const autoDialTime = convertTimeToMilliseconds(\n//       ((await node.config.get('Swarm.ConnMgr.GracePeriod', {\n//         timeout: GET_CONFIG_TIMEOUT,\n//       })) as string) || DEFAULT_AUTO_DIAL_INTERVAL\n//     );\n\n//     return autoDialTime;\n//   } catch {\n//     return DEFAULT_AUTO_DIAL_INTERVAL;\n//   }\n// };\n\n// const getIpfsGatewayUrl = async (node: IpfsNode, cid: string) => {\n//   if (node.nodeType !== 'external') {\n//     return `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n//   }\n\n//   const response = await node.config.get('Addresses.Gateway');\n//   const address = multiaddr(response).nodeAddress();\n\n//   try {\n//     return `http://${address.address}:${address.port}/ipfs/${cid}`;\n//   } catch (error) {\n//     return `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n//   }\n// };\n\nexport {\n  getIPFSContent,\n  catIPFSContentFromNode,\n  fetchIpfsContent,\n  addContenToIpfs,\n  // reconnectToCyberSwarm,\n  // getIpfsGatewayUrl,\n  // getNodeAutoDialInterval,\n};\n","// import { getNodeAutoDialInterval } from './utils-ipfs';\nimport { IpfsNodeType, IpfsNode, CybIpfsNode, IpfsOptsType } from '../ipfs';\nimport KuboNode from './impl/kubo';\nimport HeliaNode from './impl/helia';\nimport JsIpfsNode from './impl/js-ipfs';\n// import EnhancedIpfsNode from './node/enhancedNode';\nimport {\n  CYBERNODE_SWARM_ADDR_TCP,\n  CYBERNODE_SWARM_ADDR_WSS,\n  CYBER_NODE_SWARM_PEER_ID,\n} from '../config';\nimport { withCybFeatures } from './mixins/withCybFeatures';\n\nconst nodeClassMap: Record<IpfsNodeType, new () => IpfsNode> = {\n  helia: HeliaNode,\n  embedded: JsIpfsNode,\n  external: KuboNode,\n};\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport async function initIpfsNode(\n  options: IpfsOptsType\n): Promise<CybIpfsNode> {\n  const { ipfsNodeType, ...restOptions } = options;\n\n  const swarmPeerId = CYBER_NODE_SWARM_PEER_ID;\n\n  const swarmPeerAddress =\n    ipfsNodeType === 'external'\n      ? CYBERNODE_SWARM_ADDR_TCP\n      : CYBERNODE_SWARM_ADDR_WSS;\n\n  const EnhancedClass = withCybFeatures(nodeClassMap[ipfsNodeType], {\n    swarmPeerId,\n    swarmPeerAddress,\n  });\n\n  const instance = new EnhancedClass();\n\n  await instance.init({ url: restOptions.urlOpts });\n  // TODO: REFACT\n  //   instance.connMgrGracePeriod = await getNodeAutoDialInterval(instance);\n  // window.ipfs = instance;\n\n  console.log('----init', ipfsNodeType);\n\n  await instance.reconnectToSwarm();\n  return instance;\n}\n","import { IpfsNode, CybIpfsNode, IpfsContentType } from '../../ipfs';\nimport { parseArrayLikeToDetails } from '../../utils/content';\nimport { addContenToIpfs, getIPFSContent } from '../../utils/utils-ipfs';\n\ntype WithCybFeaturesOptions = {\n  swarmPeerId: string;\n  swarmPeerAddress: string;\n};\n\nfunction withCybFeatures<TBase extends new (...args: any[]) => IpfsNode>(\n  Base: TBase,\n  options: WithCybFeaturesOptions\n) {\n  return class CybIpfsNodeMixin extends Base implements CybIpfsNode {\n    async fetchWithDetails(cid: string, parseAs?: IpfsContentType) {\n      const response = await getIPFSContent(cid, this);\n      const details = await parseArrayLikeToDetails(response, cid);\n\n      return !parseAs\n        ? details\n        : details?.type === parseAs\n        ? details\n        : undefined;\n    }\n\n    async addContent(content: File | string) {\n      return addContenToIpfs(this, content);\n    }\n\n    async isConnectedToSwarm() {\n      return !!(await super.getPeers()).find(\n        (peerId) => peerId === options.swarmPeerId\n      );\n    }\n\n    async reconnectToSwarm(lastConnectedTimestamp?: number) {\n      if (!(await this.isConnectedToSwarm())) {\n        // TODO: refactor using timeout for node config\n\n        //   const needToReconnect =\n        //     Date.now() - lastConnectedTimestamp <\n        //     DEFAULT_CONNECTION_LIFETIME_SECONDS;\n        super\n          .connectPeer(options.swarmPeerAddress)\n          .then(() => {\n            console.log(` connected to swarm - ${options.swarmPeerAddress}`);\n            return true;\n          })\n          .catch((err) => {\n            console.log(\n              `Can't connect to swarm ${options.swarmPeerAddress}: ${err.message}`\n            );\n            return false;\n          });\n      }\n    }\n  };\n}\n\nexport { withCybFeatures };\n","import { IQueueStrategy, QueueSettings, QueueSource } from './types';\n\nexport class QueueStrategy implements IQueueStrategy {\n  settings: QueueSettings;\n\n  order: QueueSource[];\n\n  constructor(settings: QueueSettings, order: QueueSource[]) {\n    this.settings = settings;\n    this.order = order;\n  }\n\n  getNextSource(source: QueueSource): QueueSource | undefined {\n    const index = this.order.indexOf(source);\n    return index < this.order.length ? this.order[index + 1] : undefined;\n  }\n}\n","export class QueueItemTimeoutError extends Error {\n  constructor(timeoutMs: number) {\n    super(`Timeout after ${timeoutMs}`);\n    Object.setPrototypeOf(this, QueueItemTimeoutError.prototype);\n  }\n}\n","export function isParticle(value: string) {\n  // copied from src/utils/config.ts , to prevent crash in worker, need refactor\n  // import { PATTERN_IPFS_HASH } from 'src/utils/config';\n  return Boolean(value.match(/^Qm[a-zA-Z0-9]{44}$/g));\n}\n","import { PinType } from 'ipfs-core-types/src/pin';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { Transaction } from 'src/services/backend/services/indexer/types';\nimport {\n  SenseChatExtension,\n  SenseLinkMeta,\n  SenseListItemtMeta,\n  SenseTransactionMeta,\n} from 'src/services/backend/types/sense';\nimport { IpfsContentType } from 'src/services/ipfs/ipfs';\nimport { NeuronAddress, ParticleCid, TransactionHash } from 'src/types/base';\nimport { DtoToEntity } from 'src/types/dto';\n\ntype PinEntryType = Exclude<PinType, 'all'>;\n// example of db optimization for classifiers\n\nexport const PinTypeMap: Record<PinEntryType, number> = {\n  indirect: -1,\n  direct: 0,\n  recursive: 1,\n};\n\nexport enum EntryType {\n  transactions = 1,\n  particle = 2,\n  chat = 3,\n}\n\n// Transaction if formed by frontend\n// Should be replaced after sync\n\nexport type PinDbEntity = {\n  cid: string;\n  type: keyof typeof PinTypeMap;\n};\n\nexport type TransactionDbEntity = {\n  hash: string;\n  index: number;\n  type: string;\n  timestamp: number;\n  block_height: number;\n  value: Transaction['value'];\n  success: boolean;\n  memo: string;\n  neuron: NeuronAddress;\n};\n\ntype SyncItemMeta = DtoToEntity<\n  (SenseLinkMeta | SenseTransactionMeta) & SenseChatExtension\n>;\n\nexport type SyncStatusDbEntity = {\n  entry_type: EntryType;\n  id: NeuronAddress | ParticleCid;\n  owner_id: NeuronAddress;\n  timestamp_update: number;\n  timestamp_read: number;\n  disabled: boolean;\n  unread_count: number;\n  meta: SyncItemMeta;\n};\n\nexport type ParticleDbEntity = {\n  id: ParticleCid;\n  size: number;\n  size_local: number;\n  blocks: number;\n  mime: string;\n  type: IpfsContentType;\n  text: string;\n};\n\nexport type LinkDbEntity = {\n  from: ParticleCid;\n  to: ParticleCid;\n  neuron: NeuronAddress;\n  timestamp: number;\n  transaction_hash: string;\n};\n\nexport type ConfigDbEntity = {\n  key: string;\n  group_key: string;\n  value: NonNullable<unknown>;\n};\n\nexport enum SyncQueueStatus {\n  pending = 0,\n  executing = 1,\n  done = 2,\n  error = -1,\n}\n\nexport type SyncQueueDbEntity = {\n  id: string;\n  status: SyncQueueStatus;\n  priority: QueuePriority | number;\n};\n\nexport type CommunityDbEntity = {\n  ownerId: NeuronAddress;\n  particle: ParticleCid;\n  neuron: NeuronAddress;\n  name: string;\n  following: boolean;\n  follower: boolean;\n};\n\nexport type DbEntity =\n  | TransactionDbEntity\n  | ParticleDbEntity\n  | SyncStatusDbEntity\n  | ConfigDbEntity\n  | SyncQueueDbEntity;\n","import {\n  createAsyncThunk,\n  createSelector,\n  createSlice,\n  PayloadAction,\n} from '@reduxjs/toolkit';\nimport { SenseApi } from 'src/contexts/backend/services/senseApi';\nimport {\n  SenseItemLinkMeta,\n  SenseListItem,\n  SenseListItemTransactionMeta,\n  SenseUnread,\n} from 'src/services/backend/types/sense';\nimport { isParticle } from '../../particle/utils';\nimport { SenseItemId } from '../types/sense';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport {\n  MsgMultiSendValue,\n  MsgSendValue,\n} from 'src/services/backend/services/indexer/types';\nimport { RootState } from 'src/redux/store';\n\n// similar to blockchain/tx/message type\nexport type SenseItem = {\n  id: SenseItemId;\n  transactionHash: string;\n\n  // add normal type\n  type: string;\n\n  meta: SenseListItem['meta'];\n  timestamp: string;\n  memo: string | undefined;\n  from: string;\n\n  // for optimistic update\n  status?: 'pending' | 'error';\n  fromLog?: boolean;\n};\n\ntype Chat = {\n  id: SenseItemId;\n  isLoading: boolean;\n  error: string | undefined;\n  data: SenseItem[];\n  unreadCount: number;\n};\n\ntype SliceState = {\n  list: {\n    isLoading: boolean;\n    data: string[];\n    error: string | undefined;\n  };\n  chats: {\n    [key in SenseItemId]?: Chat;\n  };\n  summary: {\n    unreadCount: {\n      total: number;\n      particles: number;\n      neurons: number;\n    };\n  };\n};\n\nconst initialState: SliceState = {\n  list: {\n    isLoading: false,\n    data: [],\n    error: undefined,\n  },\n  chats: {},\n  summary: {\n    unreadCount: {\n      total: 0,\n      particles: 0,\n      neurons: 0,\n    },\n  },\n};\n\nfunction formatApiData(item: SenseListItem): SenseItem {\n  if (item.entryType === EntryType.chat && item.meta.to) {\n    item.entryType = EntryType.particle;\n  }\n\n  const { meta } = item;\n\n  const formatted: SenseItem = {\n    timestamp: new Date(meta.timestamp).toISOString(),\n\n    // lol\n    transactionHash:\n      item.transactionHash ||\n      item.hash ||\n      item.meta.transaction_hash ||\n      item.meta.hash ||\n      item.meta.transactionHash,\n\n    memo: item.memo || meta.memo,\n\n    senseChatId: item.id,\n    // not good\n    unreadCount: item.unreadCount || 0,\n  };\n\n  switch (item.entryType) {\n    case EntryType.chat:\n    case EntryType.transactions: {\n      const meta = item.meta as SenseListItemTransactionMeta;\n      const { type } = meta;\n\n      let from = item.ownerId;\n\n      if (type === 'cosmos.bank.v1beta1.MsgSend') {\n        const value = meta.value as MsgSendValue;\n        from = value.fromAddress;\n      } else if (type === 'cosmos.bank.v1beta1.MsgMultiSend') {\n        const value = meta.value as MsgMultiSendValue;\n\n        from = value.inputs[0].address;\n      }\n\n      Object.assign(formatted, {\n        type,\n        from,\n        meta: item.meta.value,\n      });\n\n      break;\n    }\n\n    case EntryType.particle: {\n      const meta = item.meta as SenseItemLinkMeta;\n\n      Object.assign(formatted, {\n        type: 'cyber.graph.v1beta1.MsgCyberlink',\n        from: meta.neuron,\n        meta: meta,\n        fromLog: true,\n      });\n\n      break;\n    }\n\n    default:\n      // sholdn't be\n      debugger;\n      return {};\n  }\n\n  return formatted;\n}\n\nconst getSenseList = createAsyncThunk(\n  'sense/getSenseList',\n  async (senseApi: SenseApi) => {\n    const data = await senseApi!.getList();\n    return data.map(formatApiData);\n  }\n);\n\nconst getSenseChat = createAsyncThunk(\n  'sense/getSenseChat',\n  async ({ id, senseApi }: { id: SenseItemId; senseApi: SenseApi }) => {\n    const particle = isParticle(id);\n\n    if (particle) {\n      const links = await senseApi!.getLinks(id);\n      const formattedLinks = links.map((item) => {\n        if (item.timestamp === 0) {\n          // FIXME:\n          return;\n        }\n        return formatApiData({\n          ...item,\n          id,\n          entryType: EntryType.particle,\n          meta: item,\n        });\n      });\n\n      return formattedLinks.filter(Boolean);\n    }\n\n    const data = await senseApi!.getFriendItems(id);\n    const formattedData = data.map((item) => {\n      const entryType = item.to ? EntryType.particle : EntryType.chat;\n      return formatApiData({\n        ...item,\n        entryType,\n        id,\n        meta: item,\n      });\n    });\n\n    return formattedData;\n  }\n);\n\nconst markAsRead = createAsyncThunk(\n  'sense/markAsRead',\n  async ({ id, senseApi }: { id: SenseItemId; senseApi: SenseApi }) => {\n    return senseApi!.markAsRead(id);\n  }\n);\n\nconst newChatStructure: Chat = {\n  id: '',\n  isLoading: false,\n  data: [],\n  error: undefined,\n  unreadCount: 0,\n};\n\nfunction checkIfMessageExists(chat: Chat, newMessage: SenseItem) {\n  const lastMessages = chat.data.slice(-5);\n\n  const isMessageExists = lastMessages.some((msg) => {\n    return msg.transactionHash === newMessage.transactionHash;\n  });\n\n  return isMessageExists;\n}\n\nconst slice = createSlice({\n  name: 'sense',\n  initialState,\n  reducers: {\n    // backend may push this action\n    updateSenseList: {\n      reducer: (state, action: PayloadAction<SenseItem[]>) => {\n        const data = action.payload;\n\n        data.forEach((message) => {\n          const { senseChatId: id } = message;\n\n          if (!state.chats[id]) {\n            state.chats[id] = { ...newChatStructure };\n          }\n\n          const chat = state.chats[id]!;\n\n          Object.assign(chat, {\n            id,\n            // fix ts\n            unreadCount: message.unreadCount || 0,\n          });\n\n          if (!checkIfMessageExists(chat, message)) {\n            chat.data = chat.data.concat(message);\n          }\n        });\n\n        slice.caseReducers.orderSenseList(state);\n      },\n      prepare: (data: SenseListItem[]) => {\n        return {\n          payload: data.map(formatApiData),\n        };\n      },\n    },\n    // optimistic update\n    addSenseItem(\n      state,\n      action: PayloadAction<{ id: SenseItemId; item: SenseItem }>\n    ) {\n      const { id, item } = action.payload;\n      const chat = state.chats[id]!;\n\n      chat.data.push({\n        ...item,\n        meta: item.meta,\n        status: 'pending',\n      });\n\n      const newList = state.list.data.filter((item) => item !== id);\n      newList.unshift(id);\n      state.list.data = newList;\n    },\n    // optimistic confirm/error\n    updateSenseItem(\n      state,\n      action: PayloadAction<{\n        chatId: SenseItemId;\n        txHash: string;\n        isSuccess: boolean;\n      }>\n    ) {\n      const { chatId, txHash, isSuccess } = action.payload;\n      const chat = state.chats[chatId]!;\n\n      const item = chat.data.find((item) => item.transactionHash === txHash);\n\n      if (item) {\n        if (isSuccess) {\n          delete item.status;\n        } else {\n          item.status = 'error';\n        }\n      }\n    },\n    orderSenseList(state) {\n      const chatsLastMessage = Object.keys(state.chats).reduce<\n        {\n          id: string;\n          lastMsg: SenseItem;\n        }[]\n      >((acc, id) => {\n        const chat = state.chats[id]!;\n\n        // may be loading this moment, no data\n        if (!chat.data.length) {\n          return acc;\n        }\n\n        const lastMsg = chat.data[chat.data.length - 1];\n        acc.push({ id, lastMsg });\n\n        return acc;\n      }, []);\n\n      const sorted = chatsLastMessage.sort((a, b) => {\n        return (\n          Date.parse(b.lastMsg.timestamp) - Date.parse(a.lastMsg.timestamp)\n        );\n      });\n\n      state.list.data = sorted.map((i) => i.id);\n    },\n    reset() {\n      return initialState;\n    },\n  },\n\n  extraReducers: (builder) => {\n    builder.addCase(getSenseList.pending, (state) => {\n      state.list.isLoading = true;\n    });\n\n    builder.addCase(getSenseList.fulfilled, (state, action) => {\n      state.list.isLoading = false;\n\n      const newList: SliceState['list']['data'] = [];\n\n      action.payload.forEach((message) => {\n        const { senseChatId: id } = message;\n\n        if (!state.chats[id]) {\n          state.chats[id] = { ...newChatStructure };\n        }\n\n        const chat = state.chats[id]!;\n\n        Object.assign(chat, {\n          id,\n          // fix\n          unreadCount: message.unreadCount || 0,\n        });\n\n        if (!checkIfMessageExists(chat, message)) {\n          chat.data = chat.data.concat(message);\n        }\n\n        newList.push(id);\n      });\n\n      state.list.data = newList;\n    });\n    builder.addCase(getSenseList.rejected, (state, action) => {\n      console.error(action);\n\n      state.list.isLoading = false;\n      state.list.error = action.error.message;\n    });\n\n    builder.addCase(getSenseChat.pending, (state, action) => {\n      const { id } = action.meta.arg;\n\n      if (!state.chats[id]) {\n        state.chats[id] = { ...newChatStructure };\n      }\n\n      // don't understand why ts warning\n      state.chats[id].isLoading = true;\n    });\n\n    builder.addCase(getSenseChat.fulfilled, (state, action) => {\n      const { id } = action.meta.arg;\n      const chat = state.chats[id]!;\n      chat.isLoading = false;\n\n      chat.id = id;\n\n      chat.data = action.payload;\n    });\n    builder.addCase(getSenseChat.rejected, (state, action) => {\n      console.error(action);\n\n      const chat = state.chats[action.meta.arg.id]!;\n      chat.isLoading = false;\n      chat.error = action.error.message;\n    });\n\n    // maybe add .pending, .rejected\n    // can be optimistic\n    builder.addCase(markAsRead.fulfilled, (state, action) => {\n      const { id } = action.meta.arg;\n      const chat = state.chats[id]!;\n\n      const particle = isParticle(id);\n\n      const { unreadCount } = chat;\n\n      state.summary.unreadCount.total -= unreadCount;\n      if (particle) {\n        state.summary.unreadCount.particles -= unreadCount;\n      } else {\n        state.summary.unreadCount.neurons -= unreadCount;\n      }\n\n      chat.unreadCount = 0;\n    });\n  },\n});\n\nconst selectUnreadCounts = createSelector(\n  (state: RootState) => state.sense.chats,\n  (chats) => {\n    let unreadCountParticle = 0;\n    let unreadCountNeuron = 0;\n\n    Object.values(chats).forEach(({ id, unreadCount }) => {\n      const particle = isParticle(id);\n\n      if (particle) {\n        unreadCountParticle += unreadCount;\n      } else {\n        unreadCountNeuron += unreadCount;\n      }\n    });\n\n    const total = unreadCountParticle + unreadCountNeuron;\n\n    return {\n      total,\n      particles: unreadCountParticle,\n      neurons: unreadCountNeuron,\n    };\n  }\n);\n\nexport const { addSenseItem, updateSenseItem, updateSenseList, reset } =\n  slice.actions;\n\nexport { getSenseList, getSenseChat, markAsRead };\n\n// selectors\nexport { selectUnreadCounts };\n\nexport default slice.reducer;\n","import { updateSenseList } from 'src/features/sense/redux/sense.redux';\nimport { SenseListItem } from '../types/sense';\nimport {\n  BroadcastChannelMessage,\n  ServiceName,\n  ServiceStatus,\n  SyncEntryName,\n  SyncProgress,\n} from '../types/services';\nimport { CYB_BROADCAST_CHANNEL } from './consts';\n\nclass BroadcastChannelSender {\n  private channel: BroadcastChannel;\n\n  constructor() {\n    this.channel = new BroadcastChannel(CYB_BROADCAST_CHANNEL);\n  }\n\n  public postServiceStatus(\n    name: ServiceName,\n    status: ServiceStatus,\n    message?: string\n  ) {\n    this.channel.postMessage({\n      type: 'service_status',\n      value: { name, status, message },\n    });\n  }\n\n  public postSyncEntryProgress(entry: SyncEntryName, state: SyncProgress) {\n    // console.log('postSyncEntryProgress', entry, state);\n    this.channel.postMessage({ type: 'sync_entry', value: { entry, state } });\n  }\n\n  public postSenseUpdate(senseList: SenseListItem[]) {\n    // console.log('postSenseUpdate', senseList);\n    if (senseList.length > 0) {\n      this.channel.postMessage(updateSenseList(senseList));\n    }\n  }\n\n  post(msg: BroadcastChannelMessage) {\n    this.channel.postMessage(msg);\n  }\n}\n\nexport default BroadcastChannelSender;\n","export const CYB_BROADCAST_CHANNEL = 'cyb-broadcast-channel';\n","import {\n  BehaviorSubject,\n  map,\n  timeout,\n  throwError,\n  of,\n  catchError,\n  EMPTY,\n  Observable,\n  mergeMap,\n  debounceTime,\n  merge,\n  tap,\n  interval,\n  filter,\n} from 'rxjs';\n\nimport * as R from 'ramda';\n\nimport { fetchIpfsContent } from 'src/services/ipfs/utils/utils-ipfs';\nimport { CybIpfsNode, IpfsContentSource } from 'src/services/ipfs/ipfs';\nimport { ParticleCid } from 'src/types/base';\n\nimport { promiseToObservable } from '../../utils/helpers';\n\nimport type {\n  QueueItem,\n  QueueItemResult,\n  QueueItemCallback,\n  QueueItemOptions,\n  QueueStats,\n  QueueSource,\n  IDeferredDbSaver,\n  QueueItemAsyncResult,\n} from './types';\n\nimport { QueueStrategy } from './QueueStrategy';\n\nimport { QueueItemTimeoutError } from './QueueItemTimeoutError';\nimport BroadcastChannelSender from '../backend/channels/BroadcastChannelSender';\n\nconst QUEUE_DEBOUNCE_MS = 33;\nconst CONNECTION_KEEPER_RETRY_MS = 5000;\n\nfunction getQueueItemTotalPriority(item: QueueItem): number {\n  return (item.priority || 0) + (item.viewPortPriority || 0);\n}\n\nconst debugCid = (cid: ParticleCid, prefix: string, ...args) => {\n  console.log(`>>> ${prefix}: ${cid}`, ...args);\n};\n\nconst strategies = {\n  external: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 60 * 1000, maxConcurrentExecutions: 50 },\n      gateway: { timeout: 21000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'node', 'gateway']\n  ),\n  embedded: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 60 * 1000, maxConcurrentExecutions: 50 },\n      gateway: { timeout: 21000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'gateway', 'node']\n  ),\n  helia: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 6 * 1000, maxConcurrentExecutions: 50 }, //TODO: set to 60\n      gateway: { timeout: 3 * 1000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'node', 'gateway']\n  ),\n};\n\ntype QueueMap = Map<ParticleCid, QueueItem>;\n\nclass QueueManager {\n  private queue$ = new BehaviorSubject<QueueMap>(new Map());\n\n  private node: CybIpfsNode | undefined = undefined;\n\n  private defferedDbSaver?: IDeferredDbSaver;\n\n  private strategy: QueueStrategy;\n\n  private queueDebounceMs: number;\n\n  private lastNodeCallTime: number = Date.now();\n\n  private channel = new BroadcastChannelSender();\n\n  private executing: Record<QueueSource, Set<ParticleCid>> = {\n    db: new Set(),\n    node: new Set(),\n    gateway: new Set(),\n  };\n\n  private switchStrategy(strategy: QueueStrategy): void {\n    this.strategy = strategy;\n  }\n\n  public async setNode(node: CybIpfsNode, customStrategy?: QueueStrategy) {\n    console.log(`switch node from ${this.node?.nodeType} to ${node.nodeType}`);\n    this.node = node;\n    this.switchStrategy(customStrategy || strategies[node.nodeType]);\n  }\n\n  private getItemBySourceAndPriority(queue: QueueMap) {\n    const pendingItems = [...queue.values()].filter(\n      (i) => i.status === 'pending'\n    );\n\n    const pendingBySource = R.groupBy((i) => i.source, pendingItems);\n\n    const itemsToExecute: QueueItem[] = [];\n    // eslint-disable-next-line no-loop-func, no-restricted-syntax\n    for (const [queueSource, items] of Object.entries(pendingBySource)) {\n      const settings = this.strategy.settings[queueSource as IpfsContentSource];\n\n      const executeCount =\n        settings.maxConcurrentExecutions -\n        this.executing[queueSource as IpfsContentSource].size;\n\n      const itemsByPriority = items\n        .sort(\n          (a, b) => getQueueItemTotalPriority(b) - getQueueItemTotalPriority(a)\n        )\n        .slice(0, executeCount);\n\n      // console.log('---itemsByPriority', itemsByPriority);\n\n      itemsToExecute.push(...itemsByPriority);\n    }\n\n    return itemsToExecute;\n  }\n\n  private postSummary() {\n    const summary = `(total: ${this.queue$.value.size} |  db - ${this.executing.db.size} node - ${this.executing.node.size} gateway - ${this.executing.gateway.size})`;\n\n    this.channel.postServiceStatus('ipfs', 'started', summary);\n  }\n\n  private fetchData$(item: QueueItem) {\n    const { cid, source, callbacks, controller } = item;\n    // const abortController = controller || new AbortController();\n    const settings = this.strategy.settings[source];\n    this.executing[source].add(cid);\n    this.postSummary();\n    const queueItem = this.queue$.value.get(cid);\n    // Mutate item without next\n    this.queue$.value.set(cid, {\n      ...queueItem,\n      status: 'executing',\n      executionTime: Date.now(),\n      controller: new AbortController(),\n    } as QueueItem);\n    // debugCid(cid, 'fetchData', cid, source);\n    callbacks.map((callback) => callback(cid, 'executing', source));\n\n    return promiseToObservable(async () => {\n      try {\n        const res = await fetchIpfsContent(cid, source, {\n          controller,\n          node: this.node,\n        }).then((content) => {\n          this.defferedDbSaver?.enqueueIpfsContent(content);\n\n          return content;\n        });\n        return res;\n      } catch (e) {\n        // console.log('---promtoo', e);\n        throw e;\n      }\n    }).pipe(\n      timeout({\n        each: settings.timeout,\n        with: () =>\n          throwError(() => {\n            controller?.abort('timeout');\n            return new QueueItemTimeoutError(settings.timeout);\n          }),\n      }),\n      map((result): QueueItemResult => {\n        return {\n          item,\n          status: result ? 'completed' : 'error',\n          source,\n          result,\n        };\n      }),\n      catchError((error): Observable<QueueItemResult> => {\n        // debugCid(cid, 'fetchData - fetchIpfsContent catchErr', error);\n        if (error instanceof QueueItemTimeoutError) {\n          return of({\n            item,\n            status: 'timeout',\n            source,\n          });\n        }\n\n        if (error?.name === 'AbortError') {\n          return of({ item, status: 'cancelled', source });\n        }\n        return of({ item, status: 'error', source });\n      })\n    );\n  }\n\n  /**\n   * Mutate queue item, and return new queue\n   * @param cid\n   * @param changes\n   * @returns\n   */\n  private mutateQueueItem(cid: string, changes: Partial<QueueItem>) {\n    const queue = this.queue$.value;\n    const item = queue.get(cid);\n    if (item) {\n      queue.set(cid, { ...item, ...changes });\n    }\n\n    return this.queue$.next(queue);\n  }\n\n  private removeAndNext(cid: string): void {\n    const queue = this.queue$.value;\n    queue.delete(cid);\n    this.queue$.next(queue);\n  }\n\n  // reset status and switch to next source\n  private switchSourceAndNext(item: QueueItem, nextSource: QueueSource): void {\n    item.callbacks.map((callback) => callback(item.cid, 'pending', nextSource));\n\n    this.mutateQueueItem(item.cid, { status: 'pending', source: nextSource });\n  }\n\n  private cancelDeprioritizedItems(queue: QueueMap): QueueMap {\n    (['node', 'gateway'] as IpfsContentSource[]).forEach((source) => {\n      Array.from(this.executing[source]).forEach((cid) => {\n        const item = queue.get(cid);\n        if (item && getQueueItemTotalPriority(item) < 0 && item.controller) {\n          // abort request and move to pending\n          item.controller.abort('cancelled');\n          item.callbacks.map((callback) =>\n            callback(item.cid, 'pending', item.source)\n          );\n\n          queue.set(cid, { ...item, status: 'pending' });\n          // console.log('-----cancel item', item, queue);\n\n          this.executing[source].delete(cid);\n        }\n      });\n    });\n\n    return queue;\n  }\n\n  private releaseExecution(cid: string) {\n    // eslint-disable-next-line no-restricted-syntax\n    Object.keys(this.executing).forEach((key) =>\n      this.executing[key as IpfsContentSource].delete(cid)\n    );\n  }\n\n  constructor(\n    ipfsInstance$: Observable<CybIpfsNode | undefined>,\n    {\n      strategy,\n      queueDebounceMs,\n      defferedDbSaver,\n    }: {\n      strategy?: QueueStrategy;\n      queueDebounceMs?: number;\n      defferedDbSaver?: IDeferredDbSaver;\n    }\n  ) {\n    ipfsInstance$.subscribe((node) => {\n      if (node) {\n        this.setNode(node);\n      }\n    });\n\n    this.strategy = strategy || strategies.embedded;\n    this.queueDebounceMs = queueDebounceMs || QUEUE_DEBOUNCE_MS;\n    this.defferedDbSaver = defferedDbSaver;\n\n    // Little hack to handle keep-alive connection to swarm cyber node\n    // Fix some lag with node peers(when it shown swarm node in peers but not  connected anymore)\n    interval(CONNECTION_KEEPER_RETRY_MS)\n      .pipe(filter(() => this.queue$.value.size > 0 && !!this.node))\n      .subscribe(() => this.node!.reconnectToSwarm(this.lastNodeCallTime));\n\n    this.queue$\n      .pipe(\n        // tap(() => console.log('----QUEUE')),\n        debounceTime(this.queueDebounceMs),\n        map((queue) => this.cancelDeprioritizedItems(queue)),\n        mergeMap((queue) => {\n          const workItems = this.getItemBySourceAndPriority(queue);\n          // console.log('---workItems', workItems);\n          if (workItems.length > 0) {\n            // wake up connnection to swarm cyber node\n            this.node?.reconnectToSwarm(this.lastNodeCallTime);\n\n            return merge(...workItems.map((item) => this.fetchData$(item)));\n          }\n          return EMPTY;\n        })\n      )\n      .subscribe(({ item, status, source, result }) => {\n        const { cid } = item;\n        const callbacks = this.queue$.value.get(cid)?.callbacks || [];\n        // fix to process dublicated items\n        // debugCid(cid, 'subscribe', cid, source, status, result, callbacks);\n\n        callbacks.map((callback) => callback(cid, status, source, result));\n\n        // HACK to use with GracePeriod for reconnection\n        if (source === 'node') {\n          this.lastNodeCallTime = Date.now();\n        }\n\n        this.executing[source].delete(cid);\n\n        // success execution -> next\n        if (status === 'completed' || status === 'cancelled') {\n          // debugCid(cid, '------done', item, status, source, result);\n          this.removeAndNext(cid);\n        } else {\n          // debugCid(cid, '------error', item, status, source, result);\n\n          // Retry -> (next sources) or -> next\n          const nextSource = this.strategy.getNextSource(source);\n\n          if (nextSource) {\n            this.switchSourceAndNext(item, nextSource);\n          } else {\n            this.removeAndNext(cid);\n            // notify thatn nothing found from all sources\n            callbacks.map((callback) =>\n              callback(cid, 'not_found', source, result)\n            );\n          }\n        }\n\n        this.postSummary();\n      });\n  }\n\n  public enqueue(\n    cid: string,\n    callback: QueueItemCallback,\n    options: QueueItemOptions = {}\n  ): void {\n    const queue = this.queue$.value;\n    const existingItem = queue.get(cid);\n    // debugCid(cid, '----/--enqueue ', cid, existingItem);\n\n    // In case if item already in queue,\n    // just attach one more callback to quieued item\n    if (existingItem) {\n      this.mutateQueueItem(cid, {\n        callbacks: [...existingItem.callbacks, callback],\n      });\n    } else {\n      const source = options.initialSource || this.strategy.order[0];\n      const item: QueueItem = {\n        cid,\n        callbacks: [callback],\n        source, // initial method to fetch\n        status: 'pending',\n        postProcessing: true, // by default rune-post-processing enabled\n        ...options,\n      };\n\n      callback(cid, 'pending', source);\n\n      queue.set(cid, item);\n      this.queue$.next(queue);\n    }\n  }\n\n  public enqueueAndWait(\n    cid: string,\n    options: QueueItemOptions = {}\n  ): Promise<QueueItemAsyncResult> {\n    return new Promise((resolve) => {\n      const callback = ((cid, status, source, result) => {\n        if (status === 'completed' || status === 'not_found') {\n          resolve({ status, source, result });\n        }\n      }) as QueueItemCallback;\n\n      this.enqueue(cid, callback, options);\n    });\n  }\n\n  public updateViewPortPriority(cid: string, viewPortPriority: number) {\n    this.mutateQueueItem(cid, { viewPortPriority });\n  }\n\n  public cancel(cid: string): void {\n    const queue = this.queue$.value;\n    const item = queue.get(cid);\n    // console.log('-----cancel item', item, item?.controller);\n    if (item) {\n      // If item has no abortController we can just remove it,\n      // otherwise abort&keep-to-finalize\n      if (!item.controller) {\n        this.removeAndNext(cid);\n      } else {\n        item.controller.abort('cancelled');\n      }\n    }\n  }\n\n  public cancelByParent(parent: string): void {\n    const queue = this.queue$.value;\n\n    queue.forEach((item, cid) => {\n      if (item.parent === parent) {\n        this.releaseExecution(cid);\n        item.controller?.abort('cancelled');\n        queue.delete(cid);\n      }\n    });\n\n    this.queue$.next(queue);\n  }\n\n  public clear(): void {\n    const queue = this.queue$.value;\n\n    queue.forEach((item, cid) => {\n      this.releaseExecution(cid);\n      item.controller?.abort('cancelled');\n      queue.delete(cid);\n    });\n\n    this.queue$.next(new Map());\n  }\n\n  public getQueueMap(): QueueMap {\n    return this.queue$.value;\n  }\n\n  public getQueueList(): QueueItem[] {\n    return Array.from(this.queue$.value.values());\n  }\n\n  public getStats(): QueueStats[] {\n    const fn = R.pipe(\n      R.countBy<QueueItem>(R.prop('status')),\n      R.toPairs,\n      R.map(R.zipObj(['status', 'count']))\n    );\n\n    return fn(this.getQueueList()) as QueueStats[];\n  }\n}\n\n// TODO: MOVE TO SEPARATE FILE AS GLOBAL VARIABLE\n// const queueManager = new QueueManager<IPFSContentMaybe>();\n\n// if (typeof window !== 'undefined') {\n//   window.qm = queueManager;\n// }\n\n// export { queueManager };\nexport default QueueManager;\n","import { Observable } from 'rxjs';\n\n/**\n * Promise will be rejected after timeout.\n *\n * @param promise\n * @param timeout ms\n * @param abortController trigger abort\n * @returns\n */\nasync function withTimeout<T>(\n  promise: Promise<T>,\n  timeout: number,\n  abortController?: AbortController\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      const timer = setTimeout(() => {\n        abortController?.abort('timeout');\n        clearTimeout(timer);\n        reject(new DOMException('timeout', 'AbortError'));\n      }, timeout);\n    }),\n  ]);\n}\n\n/**\n * Convert promise to observable\n * @param promiseFactory\n * @returns\n */\nexport function promiseToObservable<T>(promiseFactory: () => Promise<T>) {\n  return new Observable<T>((observer) => {\n    promiseFactory()\n      .then((response) => {\n        observer.next(response);\n        observer.complete();\n      })\n      .catch((error) => {\n        console.debug('----promiseToObservable error', error); //, error\n        observer.error(error);\n      });\n  });\n}\n\nexport function convertTimeToMilliseconds(timeValue: string | number): number {\n  if (typeof timeValue === 'number') {\n    return timeValue;\n  }\n  const numericValue = parseFloat(timeValue);\n\n  const unit = timeValue\n    .replace(numericValue.toString(), '')\n    .trim()\n    .toLowerCase();\n\n  switch (unit) {\n    case 'ms':\n    case '':\n      return numericValue;\n    case 's':\n      return numericValue * 1000;\n    case 'm':\n      return numericValue * 60 * 1000;\n    case 'h':\n      return numericValue * 60 * 60 * 1000;\n    case 'd':\n      return numericValue * 24 * 60 * 60 * 1000;\n    default:\n      throw new Error(`Invalid time unit: ${unit}`);\n  }\n}\n\nexport function debounce(func, timeout = 300) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      func.apply(this, args);\n    }, timeout);\n  };\n}\n","import { IPFSContentMaybe, IpfsContentSource } from '../ipfs/ipfs';\nimport { LinkDbEntity } from '../CozoDb/types/entities';\nimport { LinkDto } from '../CozoDb/types/dto';\n\n/* eslint-disable import/no-unused-modules */\nexport type QueueItemStatus =\n  | 'pending'\n  | 'executing'\n  | 'timeout'\n  | 'completed'\n  | 'cancelled'\n  | 'error'\n  | 'not_found';\n\nexport type QueueSourceSettings = {\n  timeout: number;\n  maxConcurrentExecutions: number;\n};\n\nexport type QueueSource = IpfsContentSource;\n\nexport type QueueSettings = Record<QueueSource, QueueSourceSettings>;\n\nexport interface IQueueStrategy {\n  settings: QueueSettings;\n  order: QueueSource[];\n  getNextSource(source: QueueSource): QueueSource | undefined;\n}\n\nexport type QueueStats = {\n  status: QueueItemStatus;\n  count: number;\n};\n\nexport enum QueuePriority {\n  ZERO = 0,\n  LOW = 0.1,\n  MEDIUM = 0.5,\n  HIGH = 0.9,\n  URGENT = 1,\n}\nexport type QueueItemOptions = {\n  parent?: string;\n  priority?: QueuePriority | number;\n  viewPortPriority?: number;\n  initialSource?: QueueSource;\n  postProcessing?: boolean;\n};\n\nexport type QueueItemCallback = (\n  cid: string,\n  status: QueueItemStatus,\n  source: QueueSource,\n  result?: IPFSContentMaybe\n) => void;\n\nexport type QueueItem = {\n  cid: string;\n  source: QueueSource;\n  status: QueueItemStatus;\n  callbacks: QueueItemCallback[];\n  controller?: AbortController;\n  executionTime?: number;\n} & Omit<QueueItemOptions, 'initialSource'>;\n\nexport type QueueItemResult = {\n  item: QueueItem;\n  status: QueueItemStatus;\n  source: QueueSource;\n  result?: IPFSContentMaybe;\n};\n\nexport type QueueItemAsyncResult = Omit<QueueItemResult, 'item'>;\n\nexport type QueueItemPostProcessor = (\n  content: IPFSContentMaybe\n) => Promise<IPFSContentMaybe>;\n\nexport interface IDeferredDbSaver {\n  // postProcess: (content: IPFSContentMaybe) => Promise<IPFSContentMaybe>;\n  enqueueIpfsContent: (content: IPFSContentMaybe) => void;\n  enqueueLinks: (links: LinkDto[]) => void;\n}\n\nexport type FetchParticleAsync = (\n  cid: string,\n  options?: QueueItemOptions\n) => Promise<QueueItemAsyncResult>;\n","import type { TransferHandler } from 'comlink';\nimport { IPFSContent } from 'src/services/ipfs/ipfs';\n\ntype IPFSContentTransferable = Omit<IPFSContent, 'result'> & {\n  port: MessagePort;\n};\n\nfunction createAsyncIterable(port: MessagePort): AsyncIterable<Uint8Array> {\n  return {\n    async *[Symbol.asyncIterator](): AsyncGenerator<\n      Uint8Array,\n      void,\n      undefined\n    > {\n      let done = false;\n      while (!done) {\n        // eslint-disable-next-line no-loop-func\n        const promise = new Promise<Uint8Array | null>((resolve) => {\n          // resolve = res;\n          port.onmessage = (event: MessageEvent) => {\n            if (event.data === null) {\n              done = true;\n              resolve(null);\n            } else {\n              resolve(event.data);\n            }\n          };\n        });\n        // eslint-disable-next-line no-await-in-loop\n        const value = await promise;\n        // eslint-disable-next-line no-await-in-loop\n        if (value !== null) {\n          yield value;\n        }\n      }\n    },\n  };\n}\n\nconst IPFSContentTransferHandler: TransferHandler<\n  IPFSContent | undefined,\n  IPFSContentTransferable | null\n> = {\n  canHandle: (obj: IPFSContent | undefined) =>\n    obj && obj.result && typeof obj.result[Symbol.asyncIterator] === 'function',\n  serialize(obj: IPFSContent) {\n    if (obj === undefined) {\n      return [null, []];\n    }\n    const { result, ...rest } = obj;\n    const { port1, port2 } = new MessageChannel();\n    if (result) {\n      (async () => {\n        // eslint-disable-next-line no-restricted-syntax\n        for await (const value of result) {\n          port1.postMessage(value);\n        }\n        port1.postMessage(null); // Send  \"end\" message\n\n        port1.close();\n      })();\n    }\n    return [{ ...rest, port: port2 }, [port2]];\n  },\n  deserialize(serializedObj: IPFSContentTransferable | null) {\n    if (!serializedObj) {\n      return undefined;\n    }\n    const { port, ...rest } = serializedObj;\n\n    return {\n      ...rest,\n      result: createAsyncIterable(port),\n    };\n  },\n};\n\nexport { IPFSContentTransferHandler };\n","import { wrap, Remote, expose, transferHandlers } from 'comlink';\nimport { IPFSContentTransferHandler } from './serializers';\n\ntype WorkerType = SharedWorker | Worker;\n\nconst isSharedWorkersSupported = typeof SharedWorker !== 'undefined';\n\nconst isSharedWorkerUsed = isSharedWorkersSupported && !process.env.IS_DEV;\n\n// apply serializers for custom types\nfunction installTransferHandlers() {\n  transferHandlers.set('IPFSContent', IPFSContentTransferHandler);\n}\n\nfunction safeStringify(obj: any): string {\n  try {\n    return JSON.stringify(obj);\n  } catch (error) {\n    return String(obj);\n  }\n}\n\n// Override console.log to send logs to main thread\nfunction overrideLogging(worker: Worker | MessagePort) {\n  const consoleLogMap = {\n    log: { original: console.log },\n    error: { original: console.error },\n    warn: { original: console.warn },\n  };\n  const replaceConsoleLog = (method: keyof typeof consoleLogMap) => {\n    const { original } = consoleLogMap[method];\n\n    consoleLogMap[method].original = console[method];\n\n    console[method] = (...args) => {\n      original.apply(console, args);\n      const serializableArgs = args.map((arg) => safeStringify(arg));\n\n      worker.postMessage({ type: 'console', method, args: serializableArgs });\n    };\n  };\n\n  Object.keys(consoleLogMap).forEach((method) =>\n    replaceConsoleLog(method as keyof typeof consoleLogMap)\n  );\n}\n\n// Install handlers for logging from worker\nfunction installLoggingHandler(worker: Worker | MessagePort, name: string) {\n  // Add event listener\n  worker.addEventListener('message', (event) => {\n    if (event.data.type === 'console') {\n      const { method, args } = event.data;\n\n      console[method](name, ...args);\n    }\n  });\n}\n\n// Create Shared Worker with fallback to usual Worker(in case of DEV too)\nexport function createWorkerApi<T>(\n  workerUrl: URL,\n  workerName: string\n): { worker: WorkerType; workerApiProxy: Remote<T> } {\n  installTransferHandlers();\n  //&& !process.env.IS_DEV\n  if (isSharedWorkerUsed) {\n    const worker = new SharedWorker(workerUrl, { name: workerName });\n    installLoggingHandler(worker.port, workerName);\n    return { worker, workerApiProxy: wrap<T>(worker.port) };\n  }\n\n  const worker = new Worker(workerUrl);\n  // installLoggingHandler(worker, workerName);\n  return { worker, workerApiProxy: wrap<T>(worker) };\n}\n\nexport function exposeWorkerApi<T>(worker: WorkerType, api: T) {\n  installTransferHandlers();\n  if (typeof worker.onconnect !== 'undefined') {\n    worker.onconnect = (e) => {\n      const port = e.ports[0];\n      overrideLogging(port);\n\n      expose(api, port);\n    };\n  } else {\n    // overrideLogging(worker);\n    expose(api);\n  }\n}\n","import { createCyblogChannel } from 'src/utils/logging/cyblog';\nimport {\n  ProgressTracking,\n  SyncEntryName,\n  SyncProgress,\n} from '../types/services';\nimport BroadcastChannelSender from './BroadcastChannelSender';\n\nexport const broadcastStatus = (\n  name: SyncEntryName,\n  channelApi: BroadcastChannelSender\n) => {\n  // const cyblogCh = createCyblogChannel({ thread: 'bckd', module: name });\n  return {\n    sendStatus: (\n      status: SyncProgress['status'],\n      message?: string,\n      progress?: ProgressTracking\n    ) => {\n      // cyblogCh.info(`>>>$ sync ${name} status: ${status} message: ${message}`);\n      channelApi.postSyncEntryProgress(name, {\n        status,\n        message,\n        progress,\n        done: ['active', 'error', 'listen'].some((s) => s === status),\n      });\n    },\n  };\n};\n","async function* arrayToAsyncIterable<T>(array: T[]): AsyncIterable<T> {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const item of array) {\n    yield item;\n  }\n}\n\nasync function asyncIterableBatchProcessor<T, K>(\n  items: AsyncIterable<T> | Iterable<T>,\n  batchProcess: (arg: T[]) => Promise<K>,\n  batchSize = 10\n): Promise<void> {\n  let batch = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of items) {\n    batch.push(item);\n    if (batch.length === batchSize) {\n      await batchProcess(batch);\n      batch = [];\n    }\n  }\n  // process the rest\n  if (batch.length > 0) {\n    await batchProcess(batch);\n  }\n}\n\nasync function asyncIterableToArray<T>(asyncIterable: AsyncIterable<T>) {\n  const resultArray = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of asyncIterable) {\n    resultArray.push(item);\n  }\n  return resultArray;\n}\n// Create a helper function to create AsyncIterable from a list and iterate one by one\nfunction createAsyncIterable<T>(data: T[]): AsyncIterable<T> {\n  let index = 0;\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next(): Promise<IteratorResult<T>> {\n          if (index < data.length) {\n            return Promise.resolve({ done: false, value: data[index++] });\n          }\n          return Promise.resolve({ done: true, value: undefined as any });\n        },\n      };\n    },\n  };\n}\n\nexport {\n  arrayToAsyncIterable,\n  asyncIterableBatchProcessor,\n  asyncIterableToArray,\n  createAsyncIterable,\n};\n","// export const CID_AVATAR = 'Qmf89bXkJH9jw4uaLkHmZkxQ51qGKfUPtAMxA8rTwBrmTs';\nexport const CID_TWEET = 'QmbdH2WBamyKLPE5zu4mJ9v49qvY8BFfoumoVPMR5V4Rvx';\nexport const CID_FOLLOW = 'QmPLSA5oPqYxgc8F7EwrM8WS9vKrr1zPoDniSRFh8HSrxx';\n\nexport const BECH32_PREFIX_ACC_ADDR_CYBER = 'bostrom';\n\nexport const PATTERN_CYBER = new RegExp(\n  `^${BECH32_PREFIX_ACC_ADDR_CYBER}[a-zA-Z0-9]{39}$`,\n  'g'\n);\nexport const PATTERN_IPFS_HASH = /^Qm[a-zA-Z0-9]{44}$/g;\n","import { CID_FOLLOW, CID_TWEET } from 'src/constants/app';\nimport { SyncEntryName } from 'src/services/backend/types/services';\n\nexport const MY_PARTICLES_SYNC_INTERVAL = 5 * 60 * 1000; // 60 sec\nexport const MY_FRIENDS_SYNC_INTERVAL = 5 * 60 * 1000; // 60 sec\nexport const IPFS_SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutes\n\nexport const MAX_DATABASE_PUT_SIZE = 500;\n\nexport const MAX_LINKS_RESOLVE_BATCH = 20;\n\nexport const DAY_IN_MS = 24 * 60 * 60 * 1000;\n\nexport const SENSE_FRIEND_PARTICLES = [CID_TWEET, CID_FOLLOW];\n\nexport const SYNC_ENTRIES_TO_TRACK_PROGRESS = [\n  'my-friends',\n  'particles',\n  'transactions',\n] as SyncEntryName[];\n","import {\n  BehaviorSubject,\n  Observable,\n  filter,\n  mergeMap,\n  tap,\n  map,\n  combineLatest,\n  share,\n  EMPTY,\n} from 'rxjs';\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { broadcastStatus } from 'src/services/backend/channels/broadcastStatus';\nimport { ParticleCid } from 'src/types/base';\nimport { SyncQueueStatus } from 'src/services/CozoDb/types/entities';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\n\nimport DbApi from '../../../dataSource/indexedDb/dbApiWrapper';\n\nimport { FetchIpfsFunc } from '../../types';\nimport { ServiceDeps } from '../types';\nimport { SyncQueueItem } from './types';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\n\nconst QUEUE_BATCH_SIZE = 100;\n\nclass ParticlesResolverQueue {\n  public isInitialized$: Observable<boolean>;\n\n  private db: DbApi | undefined;\n\n  private waitForParticleResolve: FetchIpfsFunc;\n\n  private statusApi = broadcastStatus('resolver', new BroadcastChannelSender());\n\n  private _syncQueue$ = new BehaviorSubject<Map<ParticleCid, SyncQueueItem>>(\n    new Map()\n  );\n\n  public get queue(): Map<ParticleCid, SyncQueueItem> {\n    return this._syncQueue$.getValue();\n  }\n\n  private _loop$: Observable<any> | undefined;\n\n  public get loop$(): Observable<any> | undefined {\n    return this._loop$;\n  }\n\n  constructor(deps: ServiceDeps) {\n    if (!deps.waitForParticleResolve) {\n      throw new Error('waitForParticleResolve is not defined');\n    }\n\n    this.waitForParticleResolve = deps.waitForParticleResolve;\n\n    deps.dbInstance$.subscribe(async (db) => {\n      this.db = db;\n      await this.loadSyncQueue();\n    });\n\n    this.isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.ipfsInstance$,\n    ]).pipe(\n      map(([dbInstance, ipfsInstance]) => !!ipfsInstance && !!dbInstance)\n    );\n  }\n\n  private async processSyncQueue(pendingItems: SyncQueueItem[]) {\n    // console.log('------processSyncQueue ', pendingItems);\n\n    const batchSize = pendingItems.length;\n\n    this.statusApi.sendStatus(\n      'in-progress',\n      `processing batch ${batchSize}/${batchSize} batch. ${this.queue.size} pending...`\n    );\n\n    let i = batchSize;\n    await Promise.all(\n      pendingItems.map(async (item) => {\n        const { id } = item;\n        // eslint-disable-next-line no-await-in-loop\n        return this.waitForParticleResolve(id, QueuePriority.MEDIUM).then(\n          async (result) => {\n            if (result.status === 'not_found') {\n              await this.db!.updateSyncQueue({\n                id,\n                status: SyncQueueStatus.error,\n              });\n            } else {\n              await this.db!.removeSyncQueue(id);\n            }\n\n            const queue = this._syncQueue$.value;\n            queue.delete(id);\n            i--;\n            this._syncQueue$.next(queue);\n\n            this.statusApi.sendStatus(\n              'in-progress',\n              `processing batch ${batchSize - i}/${batchSize} batch. ${\n                this.queue.size\n              } pending...`\n            );\n          }\n        );\n      })\n    );\n  }\n\n  start() {\n    const source$ = this.isInitialized$.pipe(\n      tap((q) => console.log(`sync queue isInitialized - ${q}`)),\n      filter((isInitialized) => isInitialized === true),\n      mergeMap(() => this._syncQueue$), // Merge the queue$ stream here.\n      // tap((q) => console.log(`sync queue - ${q.size}`)),\n      filter((q) => q.size > 0),\n      mergeMap((queue) => {\n        const list = [...queue.values()];\n\n        const executingCount = list.filter(\n          (i) => i.status === SyncQueueStatus.executing\n        ).length;\n\n        const batchSize = QUEUE_BATCH_SIZE - executingCount;\n\n        if (batchSize > 0) {\n          const pendingItems = list\n            .filter((i) => i.status === SyncQueueStatus.pending)\n            .sort((a, b) => {\n              return a.priority - b.priority;\n            })\n            .slice(0, batchSize);\n\n          if (pendingItems.length > 0) {\n            pendingItems.forEach((i) => {\n              queue.set(i.id, {\n                ...i,\n                status: SyncQueueStatus.executing,\n              });\n            });\n\n            this._syncQueue$.next(queue);\n\n            this.statusApi.sendStatus('in-progress', `starting...`);\n            return this.processSyncQueue(pendingItems);\n          }\n        }\n\n        return EMPTY;\n      })\n    );\n\n    this._loop$ = source$.pipe(share());\n\n    this._loop$.subscribe({\n      next: (result) => {\n        this.statusApi.sendStatus('active');\n      },\n      error: (err) => this.statusApi.sendStatus('error', err.toString()),\n    });\n\n    return this;\n  }\n\n  public async fetchDirect(cid: ParticleCid) {\n    return this.waitForParticleResolve(cid, QueuePriority.URGENT);\n  }\n\n  public async enqueueBatch(cids: ParticleCid[], priority: QueuePriority) {\n    return asyncIterableBatchProcessor(\n      cids,\n      (cids) =>\n        this.enqueue(\n          cids.map((cid) => ({\n            id: cid /* from is tweet */,\n            priority,\n          }))\n        ),\n      MAX_DATABASE_PUT_SIZE\n    );\n  }\n\n  public async enqueue(items: SyncQueueItem[]) {\n    if (items.length === 0) {\n      return;\n    }\n    await this.db!.putSyncQueue(items);\n    const queue = this._syncQueue$.value;\n\n    items.forEach((item) =>\n      queue.set(item.id, { ...item, status: SyncQueueStatus.pending })\n    );\n    this._syncQueue$.next(queue);\n  }\n\n  private async loadSyncQueue() {\n    const queue = await this.db!.getSyncQueue({\n      statuses: [SyncQueueStatus.pending],\n    }).then((items) => new Map(items.map((item) => [item.id, item])));\n\n    this._syncQueue$.next(new Map([...queue, ...this.queue]));\n  }\n}\n\nexport default ParticlesResolverQueue;\n","import dateFormat from 'dateformat';\n\nexport const numberToUtcDate = (timestamp: number) =>\n  dateFormat(new Date(timestamp), 'yyyy-mm-dd\"T\"HH:MM:ss.l', true);\n\nexport const dateToUtcNumber = (isoString: string) =>\n  Date.parse(isoString.endsWith('Z') ? isoString : `${isoString}Z`);\n\nexport const getNowUtcNumber = (): number => {\n  return Date.now(); //dateToUtcNumber(new Date().toISOString());\n};\n//\nfunction roundMilliseconds(dateTimeString: string) {\n  const date = new Date(dateTimeString);\n  const roundedMilliseconds = Math.round(date.getMilliseconds() / 1000) * 1000;\n  date.setMilliseconds(roundedMilliseconds);\n  return dateFormat(date, 'yyyy-mm-dd\"T\"HH:MM:ss.l');\n}\nfunction getCurrentTimezoneOffset() {\n  const now = new Date();\n  return -now.getTimezoneOffset() / 60;\n}\n\nfunction numberToDateWithTimezone(timestamp: number, timezoneOffset?: number) {\n  // Convert timestamp from milliseconds to a Date object\n  const date = new Date(timestamp);\n\n  const tzOffset = timezoneOffset || getCurrentTimezoneOffset();\n  console.log('---tzOffset', tzOffset);\n  // Adjust the date for the timezone offset\n  // The timezoneOffset is in hours for the target timezone relative to UTC\n  const localTime = date.getTime();\n  const localOffset = date.getTimezoneOffset() * 60000; // in milliseconds\n  const utc = localTime + localOffset;\n  const timezoneDate = new Date(utc + 3600000 * tzOffset);\n\n  // Format the date using dateFormat\n  return dateFormat(timezoneDate, 'yyyy-mm-dd HH:MM:ss');\n}\n\nfunction pluralizeUnit(quantity: number, unit: string): string {\n  return quantity === 1 ? unit : `${unit}s`;\n}\n\nconst minuteInMs = 60000; // 60 seconds * 1000 milliseconds\nconst hourInMs = 3600000; // 60 minutes * 60 seconds * 1000 milliseconds\nconst dayInMs = 86400000; // 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\n\nfunction convertTimestampToString(timestamp: number): string {\n  if (timestamp < minuteInMs) {\n    const seconds = Math.floor(timestamp / 1000);\n    return `${seconds} ${pluralizeUnit(seconds, 'second')}`;\n  }\n  if (timestamp < hourInMs) {\n    const minutes = Math.floor(timestamp / minuteInMs);\n    return `${minutes} ${pluralizeUnit(minutes, 'minute')}`;\n  }\n  if (timestamp < dayInMs) {\n    const hours = Math.floor(timestamp / hourInMs);\n    return `${hours} ${pluralizeUnit(hours, 'hour')}`;\n  }\n\n  const days = Math.floor(timestamp / dayInMs);\n  return `${days} ${pluralizeUnit(days, 'day')}`;\n}\n\nexport {\n  roundMilliseconds,\n  numberToDateWithTimezone,\n  convertTimestampToString,\n};\n","import { LsResult } from 'ipfs-core-types/src/pin';\nimport { dateToUtcNumber } from 'src/utils/date';\nimport { NeuronAddress, ParticleCid, TransactionHash } from 'src/types/base';\nimport { IPFSContent } from '../ipfs/ipfs';\nimport { LinkDbEntity, PinTypeMap } from './types/entities';\nimport { Transaction } from '../backend/services/indexer/types';\nimport { LinkDto, ParticleDto, PinDto, TransactionDto } from './types/dto';\nimport { CyberlinksByParticleResponse } from '../backend/services/dataSource/blockchain/indexer';\n\nexport const mapParticleToEntity = (particle: IPFSContent): ParticleDto => {\n  const { cid, result, meta, textPreview } = particle;\n  const { size, mime, type, blocks, sizeLocal } = meta;\n  // hack to fix string command\n  const text = textPreview?.replace(/\"/g, \"'\") || '';\n  return {\n    cid,\n    size: size || 0,\n    mime: mime || 'unknown',\n    type,\n    text,\n    size_local: sizeLocal || -1,\n    blocks: blocks || 0,\n  };\n};\n\n//TODO: REFACTOR\nexport const mapPinToEntity = (pin: LsResult): PinDto => ({\n  cid: pin.cid.toString(),\n  type: PinTypeMap[pin.type],\n});\n\nexport const mapIndexerTransactionToEntity = (\n  neuron: string,\n  tx: Transaction\n): TransactionDto => {\n  const {\n    transaction_hash,\n    index,\n    transaction: {\n      memo,\n      block: { timestamp, height },\n      success,\n    },\n    type,\n    value,\n  } = tx;\n  return {\n    hash: transaction_hash,\n    index,\n    type,\n    timestamp: dateToUtcNumber(timestamp),\n    // value: JSON.stringify(value),\n    memo,\n    value,\n    success,\n    neuron,\n    blockHeight: height,\n  };\n};\n\n// export const mapSyncStatusToEntity = (\n//   id: NeuronAddress | ParticleCid,\n//   entryType: EntryType,\n//   unreadCount: number,\n//   timestampUpdate: number,\n//   lastId: TransactionHash | ParticleCid = '',\n//   timestampRead: number = timestampUpdate,\n//   meta: Object = {}\n// ): SyncStatusDbEntity => {\n//   return {\n//     entry_type: entryType,\n//     id,\n//     timestamp_update: timestampUpdate,\n//     timestamp_read: timestampRead,\n//     unread_count: unreadCount,\n//     disabled: false,\n//     last_id: lastId,\n//     meta,\n//   };\n// };\n\nexport const mapLinkToEntity = (\n  from: ParticleCid,\n  to: ParticleCid,\n  neuron: NeuronAddress = '',\n  timestamp: number = 0\n): LinkDbEntity => ({\n  from,\n  to,\n  neuron,\n  timestamp,\n});\n\nexport const mapLinkFromIndexerToDto = ({\n  from,\n  to,\n  neuron,\n  timestamp,\n  transaction_hash,\n}: CyberlinksByParticleResponse['cyberlinks'][0]): LinkDto => ({\n  from,\n  to,\n  neuron,\n  timestamp: dateToUtcNumber(timestamp),\n  transactionHash: transaction_hash,\n});\n","export async function waitUntil(cond: () => boolean, timeoutDuration = 60000) {\n  if (cond()) {\n    return true;\n  }\n\n  const waitPromise = new Promise((resolve) => {\n    const interval = setInterval(() => {\n      if (cond()) {\n        clearInterval(interval);\n        resolve(true);\n      }\n    }, 10);\n  });\n\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error('waitUntil timed out!'));\n    }, timeoutDuration);\n  });\n\n  return Promise.race([waitPromise, timeoutPromise]);\n}\n\nexport function executeSequentially<T>(\n  promiseFunctions: (() => Promise<T>)[]\n): Promise<T[]> {\n  return promiseFunctions.reduce((promiseChain, currentFunction) => {\n    return promiseChain.then((chainResults) =>\n      currentFunction().then((currentResult) => [\n        ...chainResults,\n        currentResult,\n      ])\n    );\n  }, Promise.resolve([] as T[]));\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport function makeCancellable<T extends (...args: any[]) => Promise<any>>(\n  func: T,\n  signal: AbortSignal\n): (...funcArgs: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    // Promise that listens for the abort signal\n    const abortPromise = new Promise<ReturnType<T>>((_, reject) => {\n      const abortHandler = () => {\n        signal.removeEventListener('abort', abortHandler); // Clean up the event listener\n        reject(new DOMException('The operation was aborted.', 'AbortError'));\n      };\n      signal.addEventListener('abort', abortHandler, { once: true });\n    });\n\n    // Wrapping the original function in a promise\n    const taskPromise = new Promise<ReturnType<T>>(async (resolve, reject) => {\n      try {\n        const result = await func(...args);\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n\n    // Using Promise.race to handle cancellation\n    return Promise.race([taskPromise, abortPromise]);\n  };\n}\n\nexport function throwIfAborted<T extends (...args: any[]) => Promise<any>>(\n  func: T,\n  signal: AbortSignal\n): (...funcArgs: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    if (signal.aborted) {\n      throw new DOMException('The operation was aborted.', 'AbortError');\n    }\n    return func(...args);\n  };\n}\n","export const CYBER_NODE_URL_LCD =\n  process.env.CYBER_NODE_URL_LCD || 'https://lcd.bostrom.cybernode.ai';\nexport const CYBER_INDEX_HTTPS =\n  process.env.CYBER_INDEX_HTTPS ||\n  'https://index.bostrom.cybernode.ai/v1/graphql';\n\nexport const CYBER_INDEX_WSS =\n  process.env.CYBER_INDEX_WSS || 'wss://index.bostrom.cybernode.ai/v1/graphql';\n\nexport const CYBER_NODE_URL_WS =\n  process.env.CYBER_NODE_URL_WS || 'wss://rpc.bostrom.cybernode.ai/websocket';\n","import { Coin } from 'cosmjs-types/cosmos/base/v1beta1/coin';\nimport { CyberLinkSimple, NeuronAddress } from 'src/types/base';\n\ninterface GenericIndexerTransaction<T> {\n  value: T;\n  type: string;\n  transaction_hash: string;\n  index: number;\n  transaction: {\n    memo?: string;\n    success: boolean;\n    block: {\n      timestamp: string;\n    };\n  };\n}\nexport const MSG_SEND_TRANSACTION_TYPE = 'cosmos.bank.v1beta1.MsgSend';\n\nexport const MSG_MULTI_SEND_TRANSACTION_TYPE =\n  'cosmos.bank.v1beta1.MsgMultiSend';\n\nexport const CYBER_LINK_TRANSACTION_TYPE = 'cyber.graph.v1beta1.MsgCyberlink';\n\nconst DELEGATION_TRANSACTION_TYPE = 'cosmos.staking.v1beta1.MsgDelegate';\n\ninterface Input {\n  address: NeuronAddress;\n  coins: Coin[];\n}\n\ninterface Output {\n  address: NeuronAddress;\n  coins: Coin[];\n}\n\nexport interface MsgMultiSendValue {\n  inputs: Input[];\n  outputs: Output[];\n}\n\nexport interface MsgSendValue {\n  amount: Coin[];\n  from_address: NeuronAddress;\n  to_address: NeuronAddress;\n}\n\ninterface MsgDelegateValue {\n  amount: Coin;\n  delegator_address: NeuronAddress;\n  validator_address: NeuronAddress;\n}\n\nexport interface CyberLinkValue {\n  neuron: NeuronAddress;\n  links: CyberLinkSimple[];\n}\n\ninterface DelegateTransaction\n  extends GenericIndexerTransaction<MsgDelegateValue> {\n  type: typeof DELEGATION_TRANSACTION_TYPE;\n}\n\nexport interface CyberLinkTransaction\n  extends GenericIndexerTransaction<CyberLinkValue> {\n  type: typeof CYBER_LINK_TRANSACTION_TYPE;\n}\n\nexport interface MsgMultiSendTransaction\n  extends GenericIndexerTransaction<MsgMultiSendValue> {\n  type: typeof MSG_MULTI_SEND_TRANSACTION_TYPE;\n}\n\nexport interface MsgSendTransaction\n  extends GenericIndexerTransaction<MsgSendValue> {\n  type: typeof MSG_SEND_TRANSACTION_TYPE;\n}\n\nexport type Transaction =\n  // | DelegateTransaction\n  CyberLinkTransaction | MsgMultiSendTransaction | MsgSendTransaction;\n\nexport type GqlType = 'query' | 'subscription';\n","import { Tx } from 'cosmjs-types/cosmos/tx/v1beta1/tx';\nimport { MsgSend, MsgMultiSend } from 'cosmjs-types/cosmos/bank/v1beta1/tx';\n\nimport { fromBase64 } from '@cosmjs/encoding';\nimport {\n  MSG_MULTI_SEND_TRANSACTION_TYPE,\n  MSG_SEND_TRANSACTION_TYPE,\n} from 'src/services/backend/services/indexer/types';\nimport { NeuronAddress } from 'src/types/base';\nimport { TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { getNowUtcNumber } from 'src/utils/date';\n\n// eslint-disable-next-line import/no-unused-modules\nexport const extractTxData = (data: string) => {\n  const result = Tx.decode(fromBase64(data));\n  const memo = result.body?.memo;\n  const messages = result.body?.messages\n    .map((message) => {\n      const msgType = message.typeUrl.slice(1);\n      if (msgType === MSG_SEND_TRANSACTION_TYPE) {\n        return MsgSend.decode(message.value);\n      }\n\n      if (msgType === MSG_MULTI_SEND_TRANSACTION_TYPE) {\n        return MsgMultiSend.decode(message.value);\n      }\n      return undefined;\n    })\n    .filter((message) => message !== undefined);\n\n  return { memo, messages };\n};\n\n// eslint-disable-next-line import/no-unused-modules\nexport const mapWebsocketTxToTransactions = (\n  neuron: NeuronAddress,\n  result: any\n) => {\n  const { data, events } = result;\n\n  const hash = events['tx.hash'][0];\n  const transactionType = events['message.action'][0].slice(1);\n  const timestamp = getNowUtcNumber();\n  const blockHeight = events['tx.height'][0];\n\n  const { memo = '', messages } = extractTxData(data.value.TxResult.tx);\n\n  const transactions: TransactionDto[] = [];\n  messages!.forEach((message, index) => {\n    transactions.push({\n      hash,\n      index,\n      type: transactionType,\n      timestamp,\n      success: true,\n      value: message!,\n      memo,\n      neuron,\n      blockHeight,\n    });\n  });\n\n  return transactions;\n};\n","// eslint-disable-next-line import/prefer-default-export\nexport async function* fetchIterable<T, P>(\n  fetchFunction: (params: P & { offset: number }) => Promise<T[]>,\n  params: P\n): AsyncGenerator<T[], void, undefined> {\n  let offset = 0;\n  while (true) {\n    // eslint-disable-next-line no-await-in-loop\n    const items = await fetchFunction({ ...params, offset });\n\n    if (items.length === 0) {\n      break;\n    }\n\n    yield items;\n\n    offset += items.length;\n  }\n}\n","import { ApolloClient, DocumentNode, InMemoryCache } from '@apollo/client';\n\nimport {\n  GraphQLWsLink,\n  Observable as ApolloObservable,\n} from '@apollo/client/link/subscriptions';\nimport { GraphQLClient } from 'graphql-request';\nimport { createClient } from 'graphql-ws';\nimport { Observable } from 'rxjs';\nimport { CYBER_INDEX_HTTPS, CYBER_INDEX_WSS } from 'src/constants/config';\n\nconst cyberGraphQLWsLink = new GraphQLWsLink(\n  createClient({\n    url: CYBER_INDEX_WSS,\n    shouldRetry: (errOrCloseEvent: unknown) => true,\n    retryAttempts: 10,\n    retryWait: async (retries: number): Promise<void> => {\n      setTimeout(() => Promise.resolve(), Math.min(1000 * 2 ** retries, 10000));\n    },\n    // on: {\n    //   error: (err) => {\n    //     console.log('---ws errr', err);\n    //   },\n    //   message: (msg) => {\n    //     console.log('---ws message', msg);\n    //   },\n    //   // Handle connection opened event\n    //   opened: () => {\n    //     console.log('---ws opened');\n    //   },\n    //   // Handle connection closed event\n    //   closed: () => {\n    //     console.log('---ws closed');\n    //   },\n    // },\n  })\n);\n\nexport const createIndexerClient = (abortSignal: AbortSignal) =>\n  new GraphQLClient(CYBER_INDEX_HTTPS, {\n    signal: abortSignal,\n  });\n\n// eslint-disable-next-line import/no-unused-modules\nexport function createIndexerWebsocket<T>(\n  query: DocumentNode,\n  variables: object\n): Observable<T> {\n  const client = new ApolloClient({\n    link: cyberGraphQLWsLink,\n    cache: new InMemoryCache(),\n  });\n  const apolloObservable = client.subscribe({ query, variables });\n  return new Observable((subscriber) => {\n    const subscription = apolloObservable.subscribe({\n      next(result) {\n        subscriber.next(result.data as T);\n      },\n      error(err) {\n        subscriber.error(err);\n      },\n      complete() {\n        subscriber.complete();\n      },\n    });\n\n    // Cleanup subscription on unsubscribe\n    return () => subscription.unsubscribe();\n  });\n}\n","/* eslint-disable import/no-unused-modules */\nimport { request } from 'graphql-request';\n\nimport { gql } from '@apollo/client';\n\nimport { Cyberlink, ParticleCid, NeuronAddress } from 'src/types/base';\nimport { dateToUtcNumber, numberToUtcDate } from 'src/utils/date';\nimport { CYBER_INDEX_HTTPS } from 'src/constants/config';\n\nimport { CYBERLINKS_BATCH_LIMIT } from './consts';\nimport { fetchIterable } from './utils/fetch';\nimport { createIndexerClient } from '../../indexer/utils';\n\ntype CyberlinksCountResponse = {\n  cyberlinks_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n};\n\ntype CyberlinksSyncStatsResponse = {\n  cyberlinks_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n  first: {\n    timestamp: string;\n  }[];\n  last: {\n    timestamp: string;\n    to: ParticleCid;\n    from: ParticleCid;\n  }[];\n};\n\nexport type CyberlinksByParticleResponse = {\n  cyberlinks: (Omit<Cyberlink, 'timestamp'> & {\n    timestamp: string;\n    neuron: NeuronAddress;\n    transaction_hash: string;\n  })[];\n};\nconst cyberlinksByParticle = gql(`\nquery Cyberlinks($limit: Int, $offset: Int, $orderBy: [cyberlinks_order_by!], $where: cyberlinks_bool_exp) {\n  cyberlinks(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {\n    from: particle_from\n    to: particle_to\n    timestamp\n    neuron\n    transaction_hash\n  }\n}\n`);\n\nconst cyberlinksSyncStats = gql(`\n  query Cyberlinks($where: cyberlinks_bool_exp) {\n    cyberlinks_aggregate(where: $where) {\n      aggregate {\n        count\n      }\n    }\n    first: cyberlinks(limit: 1, order_by: { timestamp: asc }, where: $where) {\n      timestamp\n    }\n    last: cyberlinks(limit: 1, order_by: { timestamp: desc }, where: $where) {\n      timestamp,\n      to: particle_to,\n      from: particle_from\n    }\n  }\n`);\n\nconst cyberlinksCountByNeuron = gql(`\n  query MyQuery($address: String, $particles_from: [String!], $timestamp: timestamp) {\n    cyberlinks_aggregate(where: {\n        _and: [\n          { neuron: {_eq: $address}},\n          { particle_from: {_in: $particles_from}},\n          { timestamp: {_gt: $timestamp}}\n        ]\n      }) {\n      aggregate {\n        count\n      }\n    }\n  }\n  `);\n\nconst fetchCyberlinks = async ({\n  particleCid,\n  timestampFrom,\n  offset = 0,\n  abortSignal,\n}: {\n  particleCid: ParticleCid;\n  timestampFrom: number;\n  offset?: number;\n  abortSignal: AbortSignal;\n}) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksByParticleResponse>(cyberlinksByParticle, {\n    limit: CYBERLINKS_BATCH_LIMIT,\n    offset,\n    orderBy: [\n      {\n        timestamp: 'asc',\n      },\n    ],\n    where: {\n      _or: [\n        {\n          particle_to: {\n            _eq: particleCid,\n          },\n        },\n        {\n          particle_from: {\n            _eq: particleCid,\n          },\n        },\n      ],\n      timestamp: {\n        _gt: numberToUtcDate(timestampFrom),\n      },\n    },\n  });\n  return res.cyberlinks;\n};\n\nconst fetchCyberlinksCount = async (\n  address: NeuronAddress,\n  particlesFrom: ParticleCid[],\n  timestampFrom: number,\n  abortSignal?: AbortSignal\n) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksCountResponse>(cyberlinksCountByNeuron, {\n    address,\n    particles_from: particlesFrom,\n    timestamp: numberToUtcDate(timestampFrom),\n  });\n\n  return res?.cyberlinks_aggregate.aggregate.count;\n};\n\nconst fetchCyberlinksByNeroun = async ({\n  neuron,\n  particlesFrom,\n  timestampFrom,\n  batchSize,\n  offset = 0,\n  abortSignal,\n}: {\n  neuron: NeuronAddress;\n  particlesFrom: ParticleCid[];\n  timestampFrom: number;\n  batchSize: number;\n  offset?: number;\n  abortSignal?: AbortSignal;\n}) => {\n  const where = {\n    _and: [\n      {\n        timestamp: {\n          _gt: numberToUtcDate(timestampFrom),\n        },\n      },\n      {\n        neuron: {\n          _eq: neuron,\n        },\n      },\n      { particle_from: { _in: particlesFrom } },\n    ],\n  };\n\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksByParticleResponse>(cyberlinksByParticle, {\n    limit: batchSize,\n    offset,\n    orderBy: [\n      {\n        timestamp: 'asc',\n      },\n    ],\n    where,\n  });\n\n  return res.cyberlinks;\n};\n\nexport const fetchCyberlinksByNerounIterable = async (\n  neuron: NeuronAddress,\n  particlesFrom: ParticleCid[],\n  timestampFrom: number,\n  batchSize: number,\n  abortSignal?: AbortSignal\n) =>\n  fetchIterable(fetchCyberlinksByNeroun, {\n    neuron,\n    particlesFrom,\n    timestampFrom,\n    batchSize,\n    abortSignal,\n  });\n\nconst fetchCyberlinksIterable = (\n  particleCid: ParticleCid,\n  timestampFrom: number,\n  abortSignal: AbortSignal\n) =>\n  fetchIterable(fetchCyberlinks, { particleCid, timestampFrom, abortSignal });\n\nexport { fetchCyberlinksIterable, fetchCyberlinksCount };\n","const TRANSACTIONS_BATCH_LIMIT = 500;\nconst CYBERLINKS_BATCH_LIMIT = 200;\n\nexport { TRANSACTIONS_BATCH_LIMIT, CYBERLINKS_BATCH_LIMIT };\n","import { CyberLinkSimple, CyberlinkTxHash, ParticleCid } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { CID_TWEET } from 'src/constants/app';\nimport { LinkDto, TransactionDto } from 'src/services/CozoDb/types/dto';\n\nimport { fetchCyberlinksIterable } from '../../../dataSource/blockchain/indexer';\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { MAX_LINKS_RESOLVE_BATCH } from '../consts';\nimport {\n  CYBER_LINK_TRANSACTION_TYPE,\n  CyberLinkValue,\n} from '../../../indexer/types';\n\nconst getUniqueParticlesFromLinks = (links: CyberLinkSimple[]) =>\n  [\n    ...new Set([\n      ...links.map((link) => link.to),\n      ...links.map((link) => link.from),\n    ]),\n  ] as ParticleCid[];\n\n// eslint-disable-next-line import/no-unused-modules\nexport const fetchCyberlinksAndResolveParticles = async (\n  cid: ParticleCid,\n  timestampUpdate: number,\n  particlesResolver: ParticlesResolverQueue,\n  queuePriority: QueuePriority,\n  abortSignal: AbortSignal\n) => {\n  const cyberlinksIterable = fetchCyberlinksIterable(\n    cid,\n    timestampUpdate,\n    abortSignal\n  );\n  const links = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const batch of cyberlinksIterable) {\n    links.push(...batch);\n    const particles = getUniqueParticlesFromLinks(batch);\n    if (particles.length > 0) {\n      await asyncIterableBatchProcessor(\n        particles,\n        (cids: ParticleCid[]) =>\n          particlesResolver!.enqueueBatch(cids, queuePriority),\n        MAX_LINKS_RESOLVE_BATCH\n      );\n    }\n  }\n\n  return links;\n};\n\nexport function extractCybelinksFromTransaction(batch: TransactionDto[]) {\n  const cyberlinks = batch.filter(\n    (l) => l.type === CYBER_LINK_TRANSACTION_TYPE\n  );\n  const particlesFound = new Set<string>();\n  const links: LinkDto[] = [];\n  // Get links: only from TWEETS\n  const tweets: Record<ParticleCid, LinkDto> = cyberlinks.reduce<\n    Record<ParticleCid, LinkDto>\n  >((acc, { value, hash, timestamp }: TransactionDto) => {\n    (value as CyberLinkValue).links.forEach((link) => {\n      particlesFound.add(link.to);\n      particlesFound.add(link.from);\n      const txLink = {\n        ...link,\n        timestamp,\n        neuron: (value as CyberLinkValue).neuron,\n        transactionHash: hash,\n      };\n      links.push(txLink);\n\n      if (link.from === CID_TWEET) {\n        acc[txLink.to] = txLink;\n      }\n    });\n    return acc;\n  }, {});\n\n  return {\n    tweets,\n    particlesFound: [...particlesFound],\n    links,\n  };\n}\n","import { NeuronAddress } from 'src/types/base';\nimport { GqlType, Transaction } from './types';\n\nimport { gql } from '@apollo/client';\n\nimport { numberToUtcDate } from 'src/utils/date';\nimport {\n  MessagesByAddressVariables,\n  gqlMessagesByAddress,\n} from '../../indexer/transactions';\nimport {\n  TransactionsByAddressResponse,\n  fetchTransactions,\n} from './transactions';\nimport { createIndexerClient } from './utils';\nimport {\n  MessagesByAddressVariables,\n  gqlMessagesByAddress,\n} from './transactions';\nimport { camelToSnake } from 'src/utils/dto';\nimport { fetchIterable } from '../dataSource/blockchain/utils/fetch';\n\ntype OrderDirection = 'desc' | 'asc';\ntype Abortable = { abortSignal?: AbortSignal };\n\nexport type MessagesByAddressVariables = {\n  neuron: NeuronAddress;\n  timestampFrom: number;\n  offset?: number;\n  types: Transaction['type'][];\n  orderDirection: OrderDirection;\n  limit: number;\n} & Abortable;\n\nexport const mapMessagesByAddressVariables = ({\n  neuron,\n  timestampFrom,\n  offset = 0,\n  types = [],\n  orderDirection = 'desc',\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) => ({\n  address: `{${neuron}}`,\n  limit,\n  timestamp_from: numberToUtcDate(timestampFrom),\n  offset,\n  types: `{${types.map((t) => `\"${t}\"`).join(' ,')}}`,\n  order_direction: orderDirection,\n});\n\nexport const gqlMessagesByAddress = (type: GqlType) =>\n  gql(`\n${type} MyQuery($address: _text, $limit: bigint, $offset: bigint, $timestamp_from: timestamp, $types: _text, $order_direction: order_by) {\n  messages_by_address(\n    args: {addresses: $address, limit: $limit, offset: $offset, types: $types},\n    order_by: {transaction: {block: {timestamp: $order_direction}}},\n    where: {transaction: {block: {timestamp: {_gt: $timestamp_from}}}}\n    ) {\n    transaction_hash\n    index\n    value\n    transaction {\n      success\n      block {\n        timestamp,\n        height\n      }\n      memo\n    }\n    type\n  }\n}\n`);\n\nconst fetchTransactions = async ({\n  neuron,\n  timestampFrom,\n  offset = 0,\n  types = [],\n  orderDirection = 'desc',\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<TransactionsByAddressResponse>(\n    gqlMessagesByAddress('query'),\n    mapMessagesByAddressVariables({\n      neuron,\n      timestampFrom,\n      offset,\n      types,\n      orderDirection,\n      limit,\n      abortSignal,\n    })\n  );\n\n  return res?.messages_by_address;\n};\n\nexport type TransactionsByAddressResponse = {\n  messages_by_address: Transaction[];\n};\ntype MessagesCountResponse = {\n  messages_by_address_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n};\nconst transactionsCountByNeuron = gql(`\n  query MyQuery($address: _text, $timestamp: timestamp) {\n    messages_by_address_aggregate(\n      args: {addresses: $address, limit: \"100000000\", offset: \"0\", types: \"{}\"},\n      where: {transaction: {block: {timestamp: {_gt: $timestamp}}}}) {\n        aggregate {\n          count\n        }\n      }\n  }\n  `);\nexport const fetchTransactionMessagesCount = async (\n  address: NeuronAddress,\n  timestampFrom: number,\n  abortSignal: AbortSignal\n) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<MessagesCountResponse>(transactionsCountByNeuron, {\n    address: `{${address}}`,\n    timestamp: numberToUtcDate(timestampFrom),\n  });\n\n  return res?.messages_by_address_aggregate.aggregate.count;\n};\n\nexport const fetchTransactionsIterable = ({\n  neuron,\n  timestampFrom,\n  types,\n  orderDirection,\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) =>\n  fetchIterable(fetchTransactions, {\n    neuron,\n    timestampFrom,\n    types,\n    orderDirection,\n    limit,\n    abortSignal,\n  });\n","import { TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { SenseChat } from 'src/services/backend/types/sense';\nimport { NeuronAddress } from 'src/types/base';\nimport { Coin } from 'cosmjs-types/cosmos/base/v1beta1/coin';\n\nimport {\n  MSG_SEND_TRANSACTION_TYPE,\n  MSG_MULTI_SEND_TRANSACTION_TYPE,\n  MsgSendTransaction,\n} from '../../../indexer/types';\n\nexport const extractSenseChats = (\n  myAddress: NeuronAddress,\n  transactions: TransactionDto[]\n) => {\n  const sendTransactions =\n    transactions!.filter(\n      (t) =>\n        t.type === MSG_SEND_TRANSACTION_TYPE ||\n        t.type === MSG_MULTI_SEND_TRANSACTION_TYPE\n    ) || [];\n\n  if (sendTransactions.length === 0) {\n    return [];\n  }\n  const chats = new Map<NeuronAddress, SenseChat>();\n  transactions.forEach((t) => {\n    let userAddress = '';\n    if (t.type === MSG_MULTI_SEND_TRANSACTION_TYPE) {\n      const { inputs, outputs } = t.value;\n      const isSender = inputs.find((i) => i.address === myAddress);\n      const userMessages = isSender ? outputs : inputs;\n      userMessages.forEach((msg) =>\n        updateSenseChat(chats, msg.address, t, msg.coins, isSender)\n      );\n    } else if (t.type === MSG_SEND_TRANSACTION_TYPE) {\n      const { fromAddress, toAddress, amount } =\n        t.value as MsgSendTransaction['value'];\n      const isSender = fromAddress === myAddress;\n      userAddress = isSender ? toAddress : fromAddress;\n      updateSenseChat(chats, userAddress, t, amount, isSender);\n    }\n  });\n\n  return chats;\n};\n\nconst updateSenseChat = (\n  chats: Map<NeuronAddress, SenseChat>,\n  addr: string,\n  t: TransactionDto,\n  amount: Coin[],\n  isSender: boolean\n): Map<string, SenseChat> => {\n  const chat = chats.get(addr);\n  const transactions = chat?.transactions || [];\n\n  transactions.push(t);\n  chats.set(addr, {\n    userAddress: addr,\n    lastSendTimestamp: isSender ? t.timestamp : chat?.lastSendTimestamp || 0,\n    last: { amount, memo: t.memo, direction: isSender ? 'to' : 'from' },\n    transactions,\n  });\n  return chats;\n};\n","import { EntryType } from 'src/services/CozoDb/types/entities';\nimport DbApiWrapper from 'src/services/backend/services/dataSource/indexedDb/dbApiWrapper';\nimport { NeuronAddress } from 'src/types/base';\nimport {\n  SenseListItem,\n  SenseTransactionMeta,\n} from 'src/services/backend/types/sense';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport { extractSenseChats } from '../../utils/sense';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const syncMyChats = async (\n  db: DbApiWrapper,\n  myAddress: NeuronAddress,\n  timestampFrom: number,\n  signal: AbortSignal,\n  shouldUpdateTimestamp = true\n) => {\n  const syncItems = await db.findSyncStatus({\n    ownerId: myAddress,\n    entryType: EntryType.chat,\n  });\n\n  const syncItemsMap = new Map(syncItems?.map((i) => [i.id, i]));\n\n  const myTransactions = await db.getTransactions(myAddress, {\n    order: 'asc',\n    timestampFrom,\n  });\n\n  const myChats = extractSenseChats(myAddress, myTransactions!);\n\n  const results: SenseListItem[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const chat of myChats.values()) {\n    const syncItem = syncItemsMap.get(chat.userAddress);\n    const lastTransaction = chat.transactions.at(-1)!;\n\n    const { timestamp: transactionTimestamp, hash, index } = lastTransaction;\n    const syncItemHeader = {\n      entryType: EntryType.chat,\n      ownerId: myAddress,\n      meta: {\n        transactionHash: hash,\n        index,\n      } as SenseTransactionMeta,\n    };\n\n    // if no sync item(first message/initial)\n    if (!syncItem) {\n      const unreadCount = chat.transactions.filter(\n        (t) => t.timestamp > chat.lastSendTimestamp\n      ).length; // uread count on top of my last send message\n\n      const newItem = {\n        ...syncItemHeader,\n        id: chat.userAddress,\n        unreadCount,\n        // if 'fast' then no shift update poiter till 'slow' reupdate\n        timestampUpdate: shouldUpdateTimestamp ? transactionTimestamp : 0,\n        timestampRead: chat.lastSendTimestamp,\n        disabled: false,\n      };\n\n      // eslint-disable-next-line no-await-in-loop\n      await throwIfAborted(db.putSyncStatus.bind(db), signal)(newItem);\n\n      results.push({ ...newItem, meta: lastTransaction });\n    } else {\n      const {\n        id,\n        timestampRead,\n        timestampUpdate,\n        meta,\n        unreadCount: prevUnreadCount,\n      } = syncItem;\n\n      const lastTimestampRead = Math.max(\n        timestampRead!,\n        chat.lastSendTimestamp\n      );\n      const { timestampUpdateContent = 0, timestampUpdateChat = 0 } = meta;\n      const timestampUnreadFrom = Math.max(\n        chat.lastSendTimestamp,\n        timestampUpdateChat\n      );\n      const unreadCount =\n        prevUnreadCount +\n        chat.transactions.filter((t) => t.timestamp > timestampUnreadFrom) // + new messages count\n          .length;\n\n      if (timestampUpdate < transactionTimestamp) {\n        // if message source is 'fast' then no update till 'slow' reupdate\n        const newTimestampUpdateChat = shouldUpdateTimestamp\n          ? transactionTimestamp\n          : timestampUpdateChat;\n\n        const syncStatusChanges = {\n          ...syncItemHeader,\n          id: id!,\n          unreadCount,\n          timestampRead: lastTimestampRead,\n          // show max timestamp to use in sorting, in sense list\n          // real timestamp shold be resynced with 'slow' data source by timestampUpdateChat\n          timestampUpdate: Math.max(\n            transactionTimestamp,\n            timestampUpdateContent,\n            newTimestampUpdateChat\n          ),\n\n          meta: {\n            ...syncItemHeader.meta,\n            timestampUpdateChat: newTimestampUpdateChat,\n            timestampUpdateContent,\n          },\n        };\n\n        // eslint-disable-next-line no-await-in-loop\n        await throwIfAborted(\n          db.updateSyncStatus.bind(db),\n          signal\n        )(syncStatusChanges);\n\n        results.push({\n          ...syncItem,\n          ...syncStatusChanges,\n          meta: lastTransaction,\n        } as SenseListItem);\n      }\n    }\n  }\n  return results;\n};\n","import { ProgressTracking } from 'src/services/backend/types/services';\n\nconst ROLLING_WINDOW = 10;\n\ntype onProgressUpdateFunc = (progress: ProgressTracking) => void;\n\ntype RequestRecord = {\n  timestamp: number;\n  itemCount: number;\n};\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport class ProgressTracker {\n  private requestRecords: RequestRecord[] = [];\n\n  private totalRequests = 0;\n\n  private completedRequests = 0;\n\n  private estimatedTime = -1;\n\n  private batchSize = 1;\n\n  private onProgressUpdate?: onProgressUpdateFunc;\n\n  public get progress(): ProgressTracking {\n    return {\n      totalCount: this.totalRequests,\n      completeCount: this.completedRequests,\n      estimatedTime: this.estimatedTime,\n    };\n  }\n\n  constructor(onProgressUpdate?: onProgressUpdateFunc) {\n    this.onProgressUpdate = onProgressUpdate;\n  }\n\n  public start(totalRequests: number, batchSize = 1) {\n    this.totalRequests = totalRequests;\n    this.requestRecords = [];\n    this.completedRequests = 0;\n    this.estimatedTime = -1;\n    this.batchSize = batchSize;\n\n    return this.progress;\n  }\n\n  public add(extraRequests: number) {\n    this.totalRequests += extraRequests;\n\n    return this.progress;\n  }\n\n  public trackProgress(processedCount: number) {\n    this.addRequestRecord(processedCount);\n\n    if (this.requestRecords.length > ROLLING_WINDOW) {\n      this.requestRecords.shift();\n    }\n\n    if (this.requestRecords.length > 1) {\n      const averageTimePerItem = this.calculateAverageTimePerItem();\n      const remainingRequests = this.totalRequests - this.completedRequests;\n      const estimatedRemainingItems = remainingRequests * processedCount; // Assuming remaining requests will process the same number of items\n      const estimatedRemainingTime =\n        averageTimePerItem * estimatedRemainingItems;\n\n      this.completedRequests += processedCount;\n      this.estimatedTime = Math.round(estimatedRemainingTime); // Convert to seconds;\n      this.onProgressUpdate && this.onProgressUpdate(this.progress);\n    }\n\n    return this.progress;\n  }\n\n  private addRequestRecord(itemCount: number) {\n    this.requestRecords.push({ timestamp: Date.now(), itemCount });\n  }\n\n  private calculateAverageTimePerItem(): number {\n    let totalDiff = 0;\n    let totalItems = 0;\n\n    for (let i = 1; i < this.requestRecords.length; i++) {\n      const timeDiff =\n        this.requestRecords[i].timestamp - this.requestRecords[i - 1].timestamp;\n      const { itemCount } = this.requestRecords[i];\n\n      totalDiff += timeDiff * itemCount;\n      totalItems += itemCount;\n    }\n\n    return totalItems === 0 ? 0 : totalDiff / totalItems;\n  }\n}\n","import {\n  Observable,\n  filter,\n  distinctUntilChanged,\n  map,\n  switchMap,\n  take,\n  tap,\n} from 'rxjs';\n\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { broadcastStatus } from 'src/services/backend/channels/broadcastStatus';\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { CyblogChannel, createCyblogChannel } from 'src/utils/logging/cyblog';\n\nimport DbApiWrapper from '../../../dataSource/indexedDb/dbApiWrapper';\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ProgressTracker } from '../ProgressTracker/ProgressTracker';\nimport { ServiceDeps } from '../types';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSync {\n  protected name: string;\n\n  protected abortController: AbortController;\n\n  protected db: DbApiWrapper | undefined;\n\n  protected progressTracker = new ProgressTracker();\n\n  protected channelApi = new BroadcastChannelSender();\n\n  protected particlesResolver: ParticlesResolverQueue | undefined;\n\n  protected statusApi: ReturnType<typeof broadcastStatus>;\n\n  protected params: SyncServiceParams = {\n    myAddress: null,\n  };\n\n  protected readonly isInitialized$: Observable<boolean>;\n\n  protected cyblogCh: CyblogChannel;\n\n  constructor(\n    name: SyncEntryName,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue\n  ) {\n    this.name = name;\n\n    this.abortController = new AbortController();\n\n    this.statusApi = broadcastStatus(name, this.channelApi);\n    this.particlesResolver = particlesResolver;\n    this.cyblogCh = createCyblogChannel({ thread: 'bckd', module: name });\n    if (!deps.params$) {\n      throw new Error('params$ is not defined');\n    }\n\n    deps.dbInstance$.subscribe((db) => {\n      this.db = db;\n    });\n\n    this.particlesResolver = particlesResolver;\n\n    this.isInitialized$ = this.createIsInitializedObserver(deps);\n\n    this.isInitialized$.subscribe((isInitialized) => {\n      this.cyblogCh.info(\n        `>>> ${this.name} - ${isInitialized ? 'initialized' : 'inactive'}`\n      );\n      this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n    });\n\n    this.isInitialized$\n      .pipe(switchMap(() => deps.params$!))\n      .subscribe((params) => {\n        this.params = params;\n        this.cyblogCh.info(`>>> ${this.name} - params updated`, {\n          data: params,\n        });\n      });\n\n    // Restart observer\n    this.isInitialized$\n      .pipe(\n        filter((isInitialized) => !!isInitialized),\n        switchMap(() => this.createRestartObserver(deps.params$!))\n      )\n      .subscribe(() => {\n        this.restart();\n      });\n  }\n\n  protected initAbortController() {\n    this.abortController = new AbortController();\n  }\n\n  protected abstract createIsInitializedObserver(\n    deps: ServiceDeps\n  ): Observable<boolean>;\n\n  // eslint-disable-next-line class-methods-use-this\n  protected createRestartObserver(params$: Observable<SyncServiceParams>) {\n    return params$.pipe(\n      map((params) => params.myAddress),\n      distinctUntilChanged((addrBefore, addrAfter) => addrBefore === addrAfter),\n      map((v) => !!v),\n      filter((v) => !!v)\n    );\n  }\n\n  public abstract restart(): void;\n\n  public abstract start(): void;\n}\n\nexport default BaseSync;\n","/* eslint-disable import/prefer-default-export */\nimport {\n  distinctUntilChanged,\n  filter,\n  Observable,\n  share,\n  switchMap,\n  tap,\n} from 'rxjs';\n\nexport const switchWhenInitialized = (\n  isInitialized$: Observable<boolean>,\n  actionObservable$: Observable<any>,\n  onChange?: (isInitialized: boolean) => void\n) =>\n  isInitialized$.pipe(\n    distinctUntilChanged(),\n    tap((isInitialized) => onChange?.(isInitialized)),\n    filter((initialized) => initialized),\n    switchMap(() => actionObservable$),\n    share()\n  );\n","import { Observable, Subject, from, startWith, switchMap, tap } from 'rxjs';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ServiceDeps } from '../types';\nimport BaseSync from './BaseSync';\nimport { switchWhenInitialized } from '../utils/rxjs/withInitializer';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSyncClient extends BaseSync {\n  protected readonly source$: Observable<any>;\n\n  protected readonly reloadTrigger$ = new Subject<void>();\n\n  constructor(\n    name: SyncEntryName,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue\n  ) {\n    super(name, deps, particlesResolver);\n\n    const source$ = switchWhenInitialized(\n      this.isInitialized$!,\n      this.reloadTrigger$.pipe(\n        startWith(null),\n        tap(() => {\n          // initialize abort conteoller for restart strategy\n          this.initAbortController();\n        }),\n        switchMap(() =>\n          this.createInitObservable().pipe(\n            switchMap((timestampFrom: number) =>\n              this.createClientObservable(timestampFrom).pipe(\n                tap(() => this.statusApi.sendStatus('listen')),\n                switchMap((data) => from(this.onUpdate(data, this.params)))\n              )\n            )\n          )\n        )\n      ),\n      (isInitialized) => {\n        console.log(`>>> ${name} isInitialized`, isInitialized);\n        this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n      }\n    );\n\n    source$.subscribe({\n      next: () => {\n        this.statusApi.sendStatus('listen');\n      },\n      error: (err) => {\n        this.statusApi.sendStatus('error', err);\n      },\n    });\n    this.source$ = source$;\n  }\n\n  protected abstract createClientObservable(\n    timestampFrom: number\n  ): Observable<any>;\n\n  protected abstract createInitObservable(): Observable<number>;\n\n  public restart() {\n    this.abortController?.abort();\n    this.reloadTrigger$.next();\n    console.log(`>>> ${this.name} client restart`);\n  }\n\n  protected abstract onUpdate(\n    data: any,\n    params: SyncServiceParams\n  ): Promise<void>;\n\n  public start() {\n    this.source$.subscribe(() => {\n      // dummy subscriber to keep pipeline running - don't remove\n    });\n    return this;\n  }\n}\n\nexport default BaseSyncClient;\n","/* eslint-disable camelcase */\nimport {\n  map,\n  combineLatest,\n  Observable,\n  from,\n  defer,\n  distinctUntilChanged,\n  merge,\n  filter,\n} from 'rxjs';\nimport { isEmpty } from 'lodash';\n\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport { mapIndexerTransactionToEntity } from 'src/services/CozoDb/mapping';\nimport { numberToUtcDate } from 'src/utils/date';\nimport { NeuronAddress } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { SyncStatusDto, TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport {\n  createNodeWebsocketObservable,\n  getIncomingTransfersQuery,\n} from 'src/services/blockchain/websocket';\nimport { mapWebsocketTxToTransactions } from 'src/services/blockchain/utils/mapping';\n\nimport { ServiceDeps } from '../types';\nimport { extractCybelinksFromTransaction } from '../utils/links';\n\nimport {\n  fetchTransactionsIterable,\n  mapMessagesByAddressVariables,\n  fetchTransactionMessagesCount,\n  gqlMessagesByAddress,\n  TransactionsByAddressResponse,\n} from '../../../indexer/transactions';\nimport { syncMyChats } from './services/chat';\nimport { TRANSACTIONS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncClient from '../BaseSyncLoop/BaseSyncClient';\nimport { createIndexerWebsocket } from '../../../indexer/utils';\nimport { SyncServiceParams } from '../../types';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\n\ntype DataStreamResult = {\n  source: 'indexer' | 'node';\n  transactions: TransactionDto[];\n};\n\nclass SyncTransactionsLoop extends BaseSyncClient {\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.params$!.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      ),\n      this.particlesResolver!.isInitialized$,\n    ]).pipe(\n      map(\n        ([dbInstance, myAddress, syncQueueInitialized]) =>\n          !!dbInstance && !!syncQueueInitialized && !!myAddress\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected createClientObservable(\n    timestampFrom: number\n  ): Observable<DataStreamResult> {\n    const { myAddress } = this.params;\n    this.cyblogCh.info(\n      `>>> ${this.name} subscribe ${myAddress} from ${numberToUtcDate(\n        timestampFrom\n      )}`\n    );\n\n    const variables = mapMessagesByAddressVariables({\n      neuron: myAddress!,\n      timestampFrom,\n      types: [],\n      orderDirection: 'desc',\n      limit: 100,\n    });\n\n    const indexerObservable$ =\n      createIndexerWebsocket<TransactionsByAddressResponse>(\n        gqlMessagesByAddress('subscription'),\n        variables\n      ).pipe(\n        map((response: TransactionsByAddressResponse) => {\n          return {\n            source: 'indexer',\n            transactions: response.messages_by_address.map((i) =>\n              mapIndexerTransactionToEntity(myAddress!, i)\n            ),\n          };\n        })\n      );\n\n    const nodeObservample$ = createNodeWebsocketObservable(\n      myAddress!,\n      getIncomingTransfersQuery(myAddress!),\n      (message, ctx) => this.cyblogCh.info(message, { unit: 'node-ws', ...ctx })\n    ).pipe(\n      filter((data) => !isEmpty(data)),\n      map((data) => {\n        return {\n          source: 'node',\n          transactions: mapWebsocketTxToTransactions(myAddress!, data),\n        };\n      })\n    );\n\n    return merge(\n      indexerObservable$,\n      nodeObservample$\n    ) as Observable<DataStreamResult>;\n  }\n\n  protected createInitObservable() {\n    return defer(() => from(this.initSync()));\n    // return from(this.initSync());\n  }\n\n  public async initSync() {\n    const { myAddress } = this.params;\n    const { signal } = this.abortController;\n    const syncItem = await this.db!.getSyncStatus(myAddress!, myAddress!);\n\n    const lastTransactionTimestamp = await this.syncTransactions(\n      myAddress!,\n      myAddress!,\n      syncItem\n    );\n\n    this.statusApi.sendStatus('in-progress', `sync my chats`);\n    const syncStatusItems = await syncMyChats(\n      this.db!,\n      myAddress!,\n      syncItem.timestampUpdate,\n      signal\n    );\n\n    this.channelApi.postSenseUpdate(syncStatusItems);\n    this.statusApi.sendStatus('active');\n\n    return lastTransactionTimestamp;\n  }\n\n  protected async onUpdate(\n    { source, transactions }: DataStreamResult,\n    params: SyncServiceParams\n  ) {\n    const { myAddress } = params;\n    const { signal } = this.abortController;\n    if (transactions.length === 0) {\n      this.cyblogCh.info(`>>> ${this.name} ${myAddress} recived 0 updates `);\n      return;\n    }\n    const syncItem = await this.db!.getSyncStatus(myAddress!, myAddress!);\n\n    await this.processBatchTransactions(\n      myAddress!,\n      myAddress!,\n      transactions,\n      syncItem,\n      source\n    );\n\n    this.statusApi.sendStatus('in-progress', `sync my chats`);\n    const syncStatusItems = await syncMyChats(\n      this.db!,\n      myAddress!,\n      syncItem.timestampUpdate,\n      signal,\n      source !== 'node'\n    );\n\n    this.channelApi.postSenseUpdate(syncStatusItems);\n    this.statusApi.sendStatus('listen');\n  }\n\n  public async processBatchTransactions(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    transactions: TransactionDto[],\n    { timestampRead, unreadCount, timestampUpdate }: SyncStatusDto,\n    source: DataStreamResult['source']\n  ) {\n    const { signal } = this.abortController;\n\n    // node transaction is limited by incoming messages,\n    // to prevent missing of other msg types let's avoid to change ts\n    const shouldUpdateTimestamp = source !== 'node';\n\n    this.cyblogCh.info('--------syncTransactions batch ', {\n      data: [\n        myAddress,\n        address,\n        transactions.length,\n        transactions.at(0)?.timestamp,\n        transactions.at(-1)?.timestamp,\n        source,\n      ],\n    });\n\n    // save transaction\n    await throwIfAborted(this.db!.putTransactions, signal)(transactions);\n\n    // save links\n    this.syncLinks(transactions, signal);\n\n    const {\n      hash,\n      index,\n\n      timestamp,\n    } = transactions.at(-1)!;\n\n    const lastTimestampFrom = timestamp;\n\n    // Update transaction sync items\n    const newSyncItem = {\n      ownerId: myAddress,\n      entryType: EntryType.transactions,\n      id: address,\n      timestampUpdate: shouldUpdateTimestamp\n        ? lastTimestampFrom\n        : timestampUpdate!,\n      unreadCount: unreadCount! + transactions.length,\n      timestampRead: timestampRead || 0,\n      disabled: false,\n      meta: {\n        transactionHash: hash,\n        index,\n      },\n    };\n\n    await throwIfAborted(this.db!.putSyncStatus, signal)(newSyncItem);\n\n    return lastTimestampFrom;\n  }\n\n  public async syncTransactions(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    syncItem: SyncStatusDto\n  ) {\n    const { unreadCount, timestampUpdate } = syncItem;\n    const timestampFrom = timestampUpdate + 1; // ofsset + 1 to fix milliseconds precision bug\n\n    this.statusApi.sendStatus('estimating');\n\n    const totalMessageCount = await fetchTransactionMessagesCount(\n      address,\n      timestampFrom,\n      this.abortController!.signal\n    );\n\n    this.cyblogCh.info(\n      `>>> syncTransactions - start ${address},  count: ${totalMessageCount}, from: ${timestampFrom}`\n    );\n\n    if (totalMessageCount === 0) {\n      return timestampFrom;\n    }\n\n    this.statusApi.sendStatus(\n      'in-progress',\n      `sync ${address}...`,\n      this.progressTracker.start(\n        Math.ceil(totalMessageCount / TRANSACTIONS_BATCH_LIMIT)\n      )\n    );\n\n    const transactionsAsyncIterable = fetchTransactionsIterable({\n      neuron: address,\n      timestampFrom,\n      types: [], // SENSE_TRANSACTIONS,\n      orderDirection: 'asc',\n      limit: TRANSACTIONS_BATCH_LIMIT,\n      abortSignal: this.abortController?.signal,\n    });\n\n    let transactionCount = 0;\n    let lastTimestampFrom = timestampFrom;\n\n    // eslint-disable-next-line no-restricted-syntax\n    for await (const batch of transactionsAsyncIterable) {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `sync ${address}...`,\n        this.progressTracker.trackProgress(1)\n      );\n\n      transactionCount += batch.length;\n\n      const transactions = batch.map((i) =>\n        mapIndexerTransactionToEntity(address, i)\n      );\n\n      lastTimestampFrom = await this.processBatchTransactions(\n        myAddress,\n        address,\n        transactions,\n        {\n          ...syncItem,\n          unreadCount: unreadCount + transactionCount,\n        },\n        'indexer'\n      );\n    }\n\n    return lastTimestampFrom;\n  }\n\n  private async syncLinks(batch: TransactionDto[], signal: AbortSignal) {\n    const { tweets, particlesFound, links } =\n      extractCybelinksFromTransaction(batch);\n    if (links.length > 0) {\n      await asyncIterableBatchProcessor(\n        links,\n        (links) => throwIfAborted(this.db!.putCyberlinks, signal)(links),\n        MAX_DATABASE_PUT_SIZE\n      );\n    }\n\n    const tweetParticles = Object.keys(tweets);\n\n    const nonTweetParticles = particlesFound.filter(\n      (cid) => !tweetParticles.includes(cid)\n    );\n\n    // pre-resolve 'tweets' particles\n    await this.particlesResolver!.enqueueBatch(\n      tweetParticles,\n      QueuePriority.HIGH\n    );\n\n    // pre-resolve all the rest particles\n    if (nonTweetParticles.length > 0) {\n      await this.particlesResolver!.enqueueBatch(\n        nonTweetParticles,\n        QueuePriority.LOW\n      );\n    }\n  }\n}\n\nexport default SyncTransactionsLoop;\n","import { Observable } from 'rxjs';\nimport { CYBER_NODE_URL_WS } from 'src/constants/config';\nimport { NeuronAddress } from 'src/types/base';\nimport { LogFunc } from 'src/utils/logging/cyblog';\n\nexport const getIncomingTransfersQuery = (address: NeuronAddress) =>\n  `tm.event='Tx' AND transfer.recipient='${address}'`;\n\n// eslint-disable-next-line import/no-unused-modules\nexport function createNodeWebsocketObservable(\n  address: NeuronAddress,\n  query: string,\n  log: LogFunc\n) {\n  return new Observable((subscriber) => {\n    const ws = new WebSocket(CYBER_NODE_URL_WS);\n\n    ws.onopen = () => {\n      log(`node ws connected to ${CYBER_NODE_URL_WS} with ${query}`);\n      ws.send(\n        JSON.stringify({\n          jsonrpc: '2.0',\n          method: 'subscribe',\n          id: '0',\n          params: { query },\n        })\n      );\n    };\n\n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      log(`node ws ${address} onmessage`, message);\n      subscriber.next(message.result);\n    };\n\n    ws.onerror = (event) => {\n      log(`node ws ${address} error`, { error: event });\n      subscriber.error(event);\n    };\n\n    ws.onclose = () => {\n      log(`node ws ${address} closed`);\n      subscriber.complete();\n    };\n\n    return () => {\n      ws.close();\n    };\n  });\n}\n","import { EntityToDto, DtoToEntity } from 'src/types/dto';\n\nexport const snakeToCamel = (str: string) =>\n  str.replace(/([-_][a-z])/g, (group) =>\n    group.toUpperCase().replace('-', '').replace('_', '')\n  );\n\nexport const camelToSnake = (str: string) =>\n  str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n// Function to transform a DB entity to a DTO\n\n// eslint-disable-next-line import/no-unused-modules\nexport function entityToDto<T extends Record<string, any>>(\n  dbEntity: T\n): EntityToDto<T> {\n  if (!dbEntity || typeof dbEntity !== 'object') {\n    return dbEntity;\n  }\n  const dto: Record<string, any> = {}; // Specify the type for dto\n  Object.keys(dbEntity).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(dbEntity, key)) {\n      const camelCaseKey = snakeToCamel(key);\n      let value = dbEntity[key];\n      if (Array.isArray(dbEntity[key])) {\n        value = dbEntity[key].map((item) => entityToDto(item));\n      } else if (typeof dbEntity[key] === 'object') {\n        value = entityToDto(dbEntity[key]);\n      }\n      dto[camelCaseKey] = value;\n    }\n  });\n  return dto as EntityToDto<T>;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport function dtoToEntity<T extends Record<string, any>>(\n  dto: T\n): DtoToEntity<T> {\n  // in case of recursive calls\n  if (!dto || typeof dto !== 'object') {\n    return dto;\n  }\n  const dbEntity: any = {};\n\n  Object.keys(dto).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(dto, key)) {\n      const snakeCaseKey = camelToSnake(key);\n      let value = dto[key];\n      if (Array.isArray(dto[key])) {\n        value = dto[key].map((item) => dtoToEntity(item));\n      } else if (typeof dto[key] === 'object') {\n        value = dtoToEntity(dto[key]);\n      }\n      dbEntity[snakeCaseKey] = value;\n    }\n  });\n  return dbEntity as DtoToEntity<T>; // Replace T with the appropriate DB Entity type if known\n}\n\nexport function dtoListToEntity<T extends Record<string, any>>(\n  array: T[]\n): DtoToEntity<T>[] {\n  return array.map((dto) => dtoToEntity(dto));\n}\n\nexport function entityListToDto<T extends Record<string, any>>(\n  array: T[]\n): EntityToDto<T>[] {\n  return array.map((dto) => entityToDto(dto));\n}\n\nexport function removeUndefinedFields(entity: Record<string, any>) {\n  Object.keys(entity).forEach((key) => {\n    if (entity[key] === undefined) {\n      delete entity[key];\n    }\n  });\n  return entity;\n}\n","import { NeuronAddress } from 'src/types/base';\nimport { LinkDto, SyncStatusDto } from 'src/services/CozoDb/types/dto';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\n\nimport { findLastIndex } from 'lodash';\nimport { entityToDto } from 'src/utils/dto';\n\nimport { SenseItemLinkMeta } from '../../types/sense';\nimport { SyncEntryName } from '../../types/services';\n\n// export function extractLinkData(\n//   cid: ParticleCid,\n//   links: CyberlinksByParticleResponse['cyberlinks']\n// ) {\n//   return {\n//     lastLink: links[0],\n//     count: links.length,\n//     lastTimestamp: dateToUtcNumber(links[0].timestamp),\n//     firstTimestamp: dateToUtcNumber(links[links.length - 1].timestamp),\n//   };\n// }\n\nexport function getLastReadInfo(\n  links: LinkDto[],\n  ownerId: NeuronAddress,\n  prevTimestampRead = 0,\n  prevUnreadCount = 0\n) {\n  const lastUnreadLinks = links.filter(\n    (link) => link.timestamp > prevTimestampRead\n  );\n  const lastMyLinkIndex = findLastIndex(\n    lastUnreadLinks,\n    (link) => link.neuron === ownerId\n  );\n\n  const unreadCount =\n    lastMyLinkIndex < 0\n      ? prevUnreadCount + lastUnreadLinks.length\n      : lastUnreadLinks.length - lastMyLinkIndex - 1;\n\n  const timestampRead =\n    lastMyLinkIndex < 0 ? prevTimestampRead : links[lastMyLinkIndex].timestamp;\n\n  return {\n    timestampRead,\n    unreadCount,\n  };\n}\n\nexport function changeParticleSyncStatus(\n  syncStatus: Partial<SyncStatusDto>,\n  links: LinkDto[],\n  ownerId: NeuronAddress,\n  shouldUpdateTimestamp = true\n) {\n  const { timestampRead, unreadCount } = getLastReadInfo(\n    links,\n    ownerId,\n    syncStatus.timestampRead,\n    syncStatus.unreadCount\n  );\n\n  const lastLink = entityToDto(links[links.length - 1]);\n  const timestampUpdate = lastLink.timestamp;\n  return {\n    ...syncStatus,\n    ownerId,\n    entryType: EntryType.particle,\n    disabled: false,\n    unreadCount,\n    meta: {\n      ...lastLink,\n      timestamp: timestampUpdate,\n    } as SenseItemLinkMeta,\n    timestampRead,\n    timestampUpdate: shouldUpdateTimestamp\n      ? timestampUpdate\n      : syncStatus.timestampUpdate,\n  } as SyncStatusDto;\n}\n\nconst mapSyncEntryReadable: Record<SyncEntryName, string> = {\n  'my-friends': \"friend's logs\",\n  particles: 'log cyberlinks',\n  resolver: 'particles',\n  transactions: 'transactions',\n  pin: 'ipfs pins',\n};\n\nexport const syncEntryNameToReadable = (name: SyncEntryName) =>\n  mapSyncEntryReadable[name] || name;\n","export const isAbortException = (e: Error) =>\n  e instanceof DOMException && e.name === 'AbortError';\n","import { Observable, defer, filter, from, tap } from 'rxjs';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { isAbortException } from 'src/utils/exceptions/helpers';\nimport { clone } from 'ramda';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ServiceDeps } from '../types';\nimport { createLoopObservable } from '../utils/rxjs/loop';\nimport BaseSync from './BaseSync';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSyncLoop extends BaseSync {\n  private restartLoop: (() => void) | undefined;\n\n  public readonly loop$: Observable<boolean>;\n\n  constructor(\n    name: SyncEntryName,\n    intervalMs: number,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue,\n    {\n      warmupMs,\n    }: {\n      warmupMs: number;\n    } = { warmupMs: 0 }\n  ) {\n    super(name, deps, particlesResolver);\n\n    const { loop$, restartLoop } = createLoopObservable(\n      this.isInitialized$,\n      // defer(() => from(this.sync())),\n      defer(() => from(this.doSync())),\n      {\n        intervalMs,\n        warmupMs,\n        // onStartInterval: () => this.initAbortController(),\n        onError: (error) => {\n          this.cyblogCh.info(`>>> ${name} error`, error.toString());\n          this.statusApi.sendStatus('error', error.toString());\n        },\n        onChange: (isInitialized) => {\n          this.cyblogCh.info(`>>> ${name} initialized: ${isInitialized}`);\n          this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n        },\n      }\n    );\n\n    this.loop$ = loop$;\n    this.restartLoop = restartLoop;\n  }\n\n  public restart() {\n    this.abortController?.abort();\n    this.restartLoop?.();\n    this.cyblogCh.info(`>>> ${this.name} loop restart`);\n  }\n\n  public start() {\n    this.loop$.subscribe(() => this.statusApi.sendStatus('active'));\n    return this;\n  }\n\n  private async doSync() {\n    const params = clone(this.params);\n    this.initAbortController();\n    try {\n      await this.sync(params);\n    } catch (e) {\n      const isAborted = isAbortException(e);\n      this.cyblogCh.info(\n        `>>> ${this.name} ${params.myAddress} sync error [abrt:${isAborted}]:`,\n        {\n          error: e,\n        }\n      );\n\n      if (!isAborted) {\n        throw e;\n      }\n    }\n  }\n\n  protected abstract sync(params: SyncServiceParams): Promise<void>;\n}\n\nexport default BaseSyncLoop;\n","/* eslint-disable import/prefer-default-export */\nimport {\n  Observable,\n  switchMap,\n  interval,\n  startWith,\n  tap,\n  retry,\n  delay,\n  exhaustMap,\n  Subject,\n} from 'rxjs';\nimport { switchWhenInitialized } from './withInitializer';\n\ntype LoopObservableOptions = {\n  warmupMs?: number;\n  retryDelayMs?: number;\n  onStartInterval?: () => void;\n  onError?: (error: any) => void;\n  onChange?: (isInitialized: boolean) => void;\n  intervalMs?: number;\n};\n\nexport const createLoopObservable = (\n  isInitialized$: Observable<boolean>,\n  actionObservable$: Observable<any>,\n  options: LoopObservableOptions = {}\n) => {\n  const {\n    intervalMs,\n    warmupMs = 0,\n    onStartInterval,\n    onError,\n    retryDelayMs = 0,\n    onChange,\n  } = options;\n\n  const restartTrigger$ = new Subject<void>();\n\n  const intervalOrRestart$ = restartTrigger$.pipe(\n    startWith(null),\n    switchMap(() => interval(intervalMs).pipe(startWith(0), delay(warmupMs)))\n  );\n\n  const source$ = switchWhenInitialized(\n    isInitialized$,\n    intervalOrRestart$.pipe(\n      tap(() => onStartInterval && onStartInterval()),\n      exhaustMap(() =>\n        actionObservable$.pipe(\n          retry({\n            delay: (error) => {\n              console.log('retry', error);\n              onError && onError(error);\n              return interval(retryDelayMs);\n            },\n          })\n        )\n      )\n    ),\n    (isInitialized) => onChange?.(isInitialized)\n  );\n\n  return {\n    loop$: source$,\n    restartLoop: () => {\n      // console.log('>>> createLoopObservable restart');\n      // Trigger a restart by emitting a new value\n      restartTrigger$.next();\n    },\n  };\n};\n","import { map, combineLatest, distinctUntilChanged } from 'rxjs';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport { SyncStatusDto } from 'src/services/CozoDb/types/dto';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { NeuronAddress } from 'src/types/base';\n\nimport { mapLinkFromIndexerToDto } from 'src/services/CozoDb/mapping';\nimport { CID_TWEET } from 'src/constants/app';\nimport { dateToUtcNumber } from 'src/utils/date';\nimport { SenseListItem } from 'src/services/backend/types/sense';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport { entityToDto } from 'src/utils/dto';\n\nimport { ServiceDeps } from '../types';\nimport { fetchCyberlinksAndResolveParticles } from '../utils/links';\n\nimport { changeParticleSyncStatus } from '../../utils';\nimport {\n  fetchCyberlinksByNerounIterable,\n  fetchCyberlinksCount,\n} from '../../../dataSource/blockchain/indexer';\nimport { CYBERLINKS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncLoop from '../BaseSyncLoop/BaseSyncLoop';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\nimport { SyncServiceParams } from '../../types';\n\nclass SyncParticlesLoop extends BaseSyncLoop {\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.ipfsInstance$,\n      deps.params$!.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      ),\n      this.particlesResolver!.isInitialized$,\n    ]).pipe(\n      map(\n        ([dbInstance, ipfsInstance, myAddress, particleResolverInitialized]) =>\n          !!ipfsInstance &&\n          !!dbInstance &&\n          !!particleResolverInitialized &&\n          !!myAddress\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  protected async sync(params: SyncServiceParams): Promise<void> {\n    const { myAddress } = params;\n    const { signal } = this.abortController;\n    this.statusApi.sendStatus('estimating');\n\n    const syncItemParticles = await this.db!.findSyncStatus({\n      ownerId: myAddress!,\n      entryType: EntryType.particle,\n    });\n\n    const timestampUpdate = syncItemParticles.at(0)?.timestampUpdate || 0;\n\n    // Get count of new links after last update\n    const newLinkCount = await fetchCyberlinksCount(\n      myAddress!,\n      [CID_TWEET],\n      timestampUpdate,\n      signal\n    );\n\n    this.cyblogCh.info(\n      `>>> syncMyParticles ${myAddress} count ${newLinkCount}`\n    );\n    this.progressTracker.start(newLinkCount + syncItemParticles.length);\n    this.statusApi.sendStatus(\n      'in-progress',\n      'preparing...',\n      this.progressTracker.progress\n    );\n\n    if (newLinkCount > 0) {\n      // fetch and save new particles\n      const newSyncItemParticles = await this.fetchNewTweets(\n        myAddress!,\n        timestampUpdate,\n        signal\n      );\n\n      // add to fetch-sync linked particles\n      syncItemParticles.push(...newSyncItemParticles);\n    }\n    await this.syncParticles(myAddress!, syncItemParticles, signal);\n  }\n\n  private async fetchNewTweets(\n    myAddress: NeuronAddress,\n    timestampUpdate: number,\n    signal: AbortSignal\n  ) {\n    const tweetsAsyncIterable = await fetchCyberlinksByNerounIterable(\n      myAddress,\n      [CID_TWEET],\n      timestampUpdate,\n      CYBERLINKS_BATCH_LIMIT,\n      this.abortController?.signal\n    );\n\n    const newTweets: SyncStatusDto[] = [];\n    const existingParticles = await this.db!.findSyncStatus({\n      ownerId: myAddress,\n      entryType: EntryType.particle,\n    });\n    const existingParticlesMap = new Map(\n      existingParticles.map((i) => [i.id, i])\n    );\n    // eslint-disable-next-line no-await-in-loop, no-restricted-syntax\n    for await (const tweetsBatch of tweetsAsyncIterable) {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `fetching new tweets...`,\n        this.progressTracker.trackProgress(1)\n      );\n      const syncStatusEntities = tweetsBatch.map(entityToDto).map((item) => {\n        const { timestamp, to } = item;\n        const timestampUpdate = dateToUtcNumber(timestamp);\n\n        // In case my tweet already linked from other neuron, resync from beginning\n        const timestampSyncFrom = existingParticlesMap.get(to)\n          ? dateToUtcNumber(timestamp)\n          : 0;\n\n        // Initial state\n        return {\n          ownerId: myAddress,\n          id: to,\n          entryType: EntryType.particle,\n          timestampUpdate: timestampSyncFrom,\n          timestampRead: timestampUpdate,\n          unreadCount: 0,\n          disabled: false,\n          meta: { ...item, timestamp: timestampUpdate },\n        } as SyncStatusDto;\n      });\n\n      if (syncStatusEntities.length > 0) {\n        await throwIfAborted(\n          this.db!.putSyncStatus,\n          signal\n        )(syncStatusEntities);\n        newTweets.push(...syncStatusEntities);\n      }\n    }\n\n    return newTweets;\n  }\n\n  private async syncParticles(\n    myAddress: NeuronAddress,\n    syncItems: SyncStatusDto[],\n    signal: AbortSignal\n  ) {\n    const updatedSyncItems: SyncStatusDto[] = [];\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const syncItem of syncItems) {\n      const { id, timestampUpdate } = syncItem;\n\n      this.statusApi.sendStatus(\n        'in-progress',\n        `fetching tweet updates...`,\n        this.progressTracker.trackProgress(1)\n      );\n      // eslint-disable-next-line no-await-in-loop\n      const linksIndexer = await fetchCyberlinksAndResolveParticles(\n        id,\n        timestampUpdate,\n        this.particlesResolver!,\n        QueuePriority.MEDIUM,\n        this.abortController?.signal\n      );\n\n      if (linksIndexer.length > 0) {\n        const links = linksIndexer.map(mapLinkFromIndexerToDto);\n\n        // save links\n        // eslint-disable-next-line no-await-in-loop\n        await asyncIterableBatchProcessor(\n          links,\n          (links) => throwIfAborted(this.db!.putCyberlinks, signal)(links),\n          MAX_DATABASE_PUT_SIZE\n        );\n\n        const newItem = changeParticleSyncStatus(syncItem, links, myAddress);\n\n        updatedSyncItems.push(newItem);\n      }\n    }\n\n    if (updatedSyncItems.length > 0) {\n      await throwIfAborted(this.db!.putSyncStatus, signal)(updatedSyncItems);\n    }\n    this.channelApi.postSenseUpdate(updatedSyncItems as SenseListItem[]);\n  }\n}\n\nexport default SyncParticlesLoop;\n","/* eslint-disable camelcase */\nimport {\n  map,\n  combineLatest,\n  distinctUntilChanged,\n  BehaviorSubject,\n} from 'rxjs';\n\nimport { EntryType } from 'src/services/CozoDb/types/entities';\n\nimport { NeuronAddress } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { isAbortException } from 'src/utils/exceptions/helpers';\n\nimport { mapLinkFromIndexerToDto } from 'src/services/CozoDb/mapping';\nimport { throwIfAborted } from 'src/utils/async/promise';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { SenseItemLinkMeta } from 'src/services/backend/types/sense';\nimport { entityToDto } from 'src/utils/dto';\nimport { ServiceDeps } from '../types';\n\nimport { fetchCyberlinksByNerounIterable } from '../../../dataSource/blockchain/indexer';\nimport { CYBERLINKS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncLoop from '../BaseSyncLoop/BaseSyncLoop';\nimport { SyncServiceParams } from '../../types';\nimport { getLastReadInfo } from '../../utils';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { SENSE_FRIEND_PARTICLES } from '../consts';\n\nclass SyncMyFriendsLoop extends BaseSyncLoop {\n  protected followings: NeuronAddress[] = [];\n\n  constructor(\n    name: SyncEntryName,\n    intervalMs: number,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue,\n    { warmupMs }: { warmupMs: number } = { warmupMs: 0 }\n  ) {\n    if (!deps.followings$) {\n      throw new Error('followings$ is required');\n    }\n\n    super(name, intervalMs, deps, particlesResolver, {\n      warmupMs,\n    });\n  }\n\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const followingsInitialized$ = new BehaviorSubject<boolean>(false);\n    deps.params$\n      ?.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      )\n      .subscribe(() => {\n        followingsInitialized$.next(false);\n      });\n\n    deps.followings$!.subscribe((followings) => {\n      this.followings = followings;\n      followingsInitialized$.next(true);\n\n      this.restart();\n    });\n\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.params$!,\n      this.particlesResolver!.isInitialized$,\n      followingsInitialized$!,\n    ]).pipe(\n      map(\n        ([dbInstance, params, syncQueueInitialized, followingsInitialized]) =>\n          !!dbInstance &&\n          !!params.myAddress &&\n          !!syncQueueInitialized &&\n          followingsInitialized\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  protected async sync(params: SyncServiceParams) {\n    const { signal } = this.abortController;\n\n    this.statusApi.sendStatus('in-progress', 'preparing...');\n    const { myAddress } = params;\n\n    const { followings } = this;\n\n    this.statusApi.sendStatus('estimating');\n\n    this.cyblogCh.info(\n      `>>> syncMyFriends ${myAddress} count ${followings.length}`,\n      {\n        unit: 'friends-sync',\n        data: followings,\n      }\n    );\n\n    this.progressTracker.start(followings.length);\n    this.statusApi.sendStatus(\n      'in-progress',\n      `sync...`,\n      this.progressTracker.progress\n    );\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const addr of followings) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.syncLinks(myAddress!, addr, signal);\n    }\n  }\n\n  public async syncLinks(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    signal: AbortSignal\n  ) {\n    let syncUpdates = [];\n    try {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `starting sync ${address}...`,\n        this.progressTracker.progress\n      );\n      const { timestampRead, unreadCount, meta } = await this.db!.getSyncStatus(\n        myAddress,\n        address\n      );\n\n      const { timestampUpdateChat = 0, timestampUpdateContent = 0 } =\n        meta || {};\n\n      const timestampFrom = timestampUpdateContent + 1; // ofsset + 1 to fix milliseconds precision bug\n\n      const linksAsyncIterable = await fetchCyberlinksByNerounIterable(\n        address,\n        SENSE_FRIEND_PARTICLES,\n        timestampFrom,\n        CYBERLINKS_BATCH_LIMIT,\n        signal\n      );\n\n      // eslint-disable-next-line no-restricted-syntax\n      for await (const linksBatch of linksAsyncIterable) {\n        this.statusApi.sendStatus(\n          'in-progress',\n          `sync ${address}...`,\n          this.progressTracker.trackProgress(1)\n        );\n\n        const links = linksBatch.map(mapLinkFromIndexerToDto);\n\n        const { timestampRead: newTimestampRead, unreadCount: newUnreadCount } =\n          getLastReadInfo(links, myAddress, timestampRead, unreadCount);\n\n        // const unreadItemsCount = unreadCount + links.length;\n\n        if (links.length > 0) {\n          const lastLink = entityToDto(links.at(-1)!);\n          const newTimestampUpdateContent = lastLink!.timestamp;\n\n          await throwIfAborted(this.db!.putCyberlinks, signal)(links);\n\n          const particles = links.map((t) => t.to);\n          await this.particlesResolver!.enqueueBatch(\n            particles,\n            QueuePriority.HIGH\n          );\n\n          const newSyncItem = {\n            ownerId: myAddress,\n            entryType: EntryType.chat,\n            id: address,\n            timestampUpdate: Math.max(\n              newTimestampUpdateContent,\n              timestampUpdateChat\n            ),\n            unreadCount: newUnreadCount,\n            timestampRead: newTimestampRead,\n            disabled: false,\n            meta: {\n              ...lastLink!,\n              timestampUpdateContent: newTimestampUpdateContent,\n              timestampUpdateChat,\n            } as SenseItemLinkMeta,\n          };\n          // Update transaction\n          await throwIfAborted(this.db!.putSyncStatus, signal)(newSyncItem);\n\n          syncUpdates.push(newSyncItem);\n        }\n      }\n    } catch (err) {\n      this.cyblogCh.error(`>>> SyncMyFriends ${address} error`, {\n        error: err,\n      });\n      if (!isAbortException(err)) {\n        this.statusApi.sendStatus('error', err.toString());\n      } else {\n        syncUpdates = [];\n        throw err;\n      }\n    } finally {\n      // console.log('-----syncUpdates with redux', syncUpdates);\n      this.channelApi.postSenseUpdate(syncUpdates);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  // protected createRestartObserver(\n  //   params$: Observable<SyncServiceParams>\n  // ): Observable<boolean> {\n  //   return super\n  //     .createRestartObserver(params$)\n  //     .pipe(switchMap((addressChanged) => this.isInitialized$));\n  // }\n}\n\nexport default SyncMyFriendsLoop;\n","import Unixfs from 'ipfs-unixfs';\nimport { DAGNode, util as DAGUtil } from 'ipld-dag-pb';\nimport { isString } from 'lodash';\nimport { IpfsApi } from 'src/services/backend/workers/background/worker';\nimport { ParticleCid } from 'src/types/base';\nimport { PATTERN_IPFS_HASH } from 'src/constants/app';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const getIpfsHash = (string: string): Promise<ParticleCid> =>\n  new Promise((resolve, reject) => {\n    const unixFsFile = new Unixfs('file', Buffer.from(string));\n\n    const buffer = unixFsFile.marshal();\n    DAGNode.create(buffer, (err, dagNode) => {\n      if (err) {\n        reject(new Error('Cannot create ipfs DAGNode'));\n      }\n\n      DAGUtil.cid(dagNode, (error, cid) => {\n        resolve(cid.toBaseEncodedString());\n      });\n    });\n  });\nexport const addIfpsMessageOrCid = async (\n  message: string | ParticleCid | File,\n  { ipfsApi }: { ipfsApi: IpfsApi | null }\n) => {\n  if (!ipfsApi) {\n    throw Error('IpfsApi is not initialized');\n  }\n\n  return (\n    isString(message) && message.match(PATTERN_IPFS_HASH)\n      ? message\n      : ((await ipfsApi!.addContent(message)) as string)\n  ) as ParticleCid;\n};\n","import { NeuronAddress, ParticleCid } from 'src/types/base';\nimport { getIpfsHash } from 'src/utils/ipfs/helpers';\nimport { PATTERN_CYBER } from 'src/constants/app';\nimport { Subject, Observable } from 'rxjs';\n\nimport DbApiWrapper from '../backend/services/dataSource/indexedDb/dbApiWrapper';\nimport { getFollowsAsCid, getFollowers } from '../backend/services/lcd/lcd';\nimport { FetchParticleAsync, QueuePriority } from '../QueueManager/types';\nimport { CommunityDto } from '../CozoDb/types/dto';\nimport { FetchIpfsFunc } from '../backend/services/sync/types';\nimport { createCyblogChannel } from 'src/utils/logging/cyblog';\n\nexport type SyncCommunityResult = {\n  action: 'reset' | 'add' | 'complete';\n  items: CommunityDto[];\n};\n\nconst cyblogCh = createCyblogChannel({\n  thread: 'bckd',\n  unit: 'fetchStoredSyncCommunity',\n});\n\n// eslint-disable-next-line import/prefer-default-export, import/no-unused-modules\nexport const fetchStoredSyncCommunity$ = (\n  dbApi: DbApiWrapper,\n  address: NeuronAddress,\n  fetchParticleAsync?: FetchIpfsFunc,\n  signal?: AbortSignal\n): Observable<SyncCommunityResult> => {\n  return new Observable<SyncCommunityResult>((subscriber) => {\n    subscriber.next({ action: 'reset', items: [] });\n\n    (async () => {\n      const storedCommunity = await dbApi.getCommunity(address);\n\n      subscriber.next({ action: 'add', items: storedCommunity });\n\n      const communityUpdatesMap = new Map<ParticleCid, CommunityDto>(\n        storedCommunity.map((c) => [c.particle, c])\n      );\n\n      const getExistingOrDefault = (cid: ParticleCid): Partial<CommunityDto> =>\n        communityUpdatesMap.get(cid) || {\n          ownerId: address,\n          name: '',\n          following: false,\n          follower: false,\n        };\n\n      const followsCids = await getFollowsAsCid(address, signal);\n      const followers = await getFollowers(address, signal);\n\n      const newFollowerCids = followsCids.filter(\n        (cid) => !storedCommunity.some((i) => i.particle === cid && i.following)\n      );\n\n      const newFollowingNeurons = followers.filter(\n        (addr) => !storedCommunity.some((i) => i.neuron === addr && i.follower)\n      );\n\n      cyblogCh.info(\n        `>>>$ sync community ${address} processing, stored ${storedCommunity.length} new followers: ${newFollowerCids.length} new following: ${newFollowingNeurons.length}`\n      );\n\n      const followersCommunity = await Promise.all(\n        newFollowingNeurons.map(async (neuron) => {\n          const cid = await getIpfsHash(neuron);\n\n          const communityItem = {\n            ...getExistingOrDefault(cid),\n            particle: cid,\n            neuron,\n            follower: true,\n          } as CommunityDto;\n\n          await dbApi.putCommunity(communityItem);\n          communityUpdatesMap.set(cid, communityItem);\n          return communityItem;\n        })\n      );\n\n      subscriber.next({ action: 'add', items: followersCommunity });\n\n      await Promise.all(\n        newFollowerCids.map(async (cid: ParticleCid) => {\n          const neuron = (await fetchParticleAsync!(cid, QueuePriority.URGENT))\n            ?.result?.textPreview;\n          if (neuron && neuron.match(PATTERN_CYBER)) {\n            const communityItem = {\n              ...getExistingOrDefault(cid),\n              neuron,\n              particle: cid,\n              following: true,\n            } as CommunityDto;\n\n            await dbApi.putCommunity(communityItem);\n            communityUpdatesMap.set(cid, communityItem);\n            subscriber.next({ action: 'add', items: [communityItem] });\n          }\n        })\n      );\n\n      cyblogCh.info(`>>>$ sync community ${address}, done`);\n      // const communityUpdates = [...communityUpdatesMap.values()];\n\n      // if (communityUpdates.length > 0) {\n      //   subscriber.next(communityUpdates);\n      // }\n      subscriber.next({ action: 'complete', items: [] });\n\n      subscriber.complete();\n    })().catch((err) => {\n      cyblogCh.error(`>>>$ sync community ${address}, error`, { error: err });\n      subscriber.error(err);\n    });\n  });\n};\n\n// eslint-disable-next-line import/no-unused-modules\nexport const fetchCommunity = async (\n  address: NeuronAddress,\n  fetchParticleAsync?: FetchParticleAsync,\n  onResolve?: (community: CommunityDto[]) => void,\n  signal?: AbortSignal\n) => {\n  const communityUpdatesMap = new Map<ParticleCid, CommunityDto>();\n\n  const getExistingOrDefault = (cid: ParticleCid): Partial<CommunityDto> =>\n    communityUpdatesMap.get(cid) || {\n      ownerId: address,\n      name: '',\n      following: false,\n      follower: false,\n    };\n\n  const followsCids = await getFollowsAsCid(address, signal);\n  const followers = await getFollowers(address, signal);\n\n  console.log(`>>> sync community ${address} processing without store`);\n\n  const followsPromise = Promise.all(\n    followsCids.map(async (cid) => {\n      const neuron = (await fetchParticleAsync!(cid))?.result?.textPreview;\n      if (neuron && neuron.match(PATTERN_CYBER)) {\n        const communityItem = {\n          ...getExistingOrDefault(cid),\n          neuron,\n          particle: cid,\n          following: true,\n        } as CommunityDto;\n        communityUpdatesMap.set(cid, communityItem);\n        onResolve && !signal?.aborted && onResolve([communityItem]);\n      }\n    })\n  );\n\n  const followersPromise = Promise.all(\n    followers.map(async (neuron) => {\n      const cid = await getIpfsHash(neuron);\n\n      const communityItem = {\n        ...getExistingOrDefault(cid),\n        particle: cid,\n        neuron,\n        follower: true,\n      } as CommunityDto;\n\n      communityUpdatesMap.set(cid, communityItem);\n      onResolve && !signal?.aborted && onResolve([communityItem]);\n    })\n  );\n\n  await Promise.all([followersPromise, followsPromise]);\n};\n","import axios from 'axios';\nimport { CYBER_NODE_URL_LCD } from 'src/constants/config';\nimport { NeuronAddress, ParticleCid } from 'src/types/base';\nimport { CID_FOLLOW } from 'src/constants/app';\nimport { getIpfsHash } from 'src/utils/ipfs/helpers';\n\nexport const getFollowsAsCid = async (\n  address: NeuronAddress,\n  signal?: AbortSignal\n): Promise<ParticleCid[]> => {\n  const response = await axios({\n    method: 'get',\n    url: `${CYBER_NODE_URL_LCD}/txs?cyberlink.neuron=${address}&cyberlink.particleFrom=${CID_FOLLOW}&limit=1000000000`,\n    signal,\n  });\n\n  if (!response.data.txs) {\n    return [];\n  }\n  return response.data.txs.map(\n    (item) => item.tx.value.msg[0].value.links[0].to\n  );\n};\n\nexport const getFollowers = async (\n  address: NeuronAddress,\n  signal?: AbortSignal\n): Promise<NeuronAddress[]> => {\n  const addressHash = await getIpfsHash(address);\n\n  const response = await axios({\n    method: 'get',\n    url: `${CYBER_NODE_URL_LCD}/txs?cyberlink.particleFrom=${CID_FOLLOW}&cyberlink.particleTo=${addressHash}&limit=1000000000`,\n    signal,\n  });\n  // console.log(\n  //   '-----getFollowers',\n  //   `${CYBER_NODE_URL_LCD}/txs?cyberlink.particleFrom=${CID_FOLLOW}&cyberlink.particleTo=${addressHash}&limit=1000000000`,\n  //   response.data\n  // );\n  if (!response.data.txs) {\n    return [];\n  }\n  return response.data.txs.map((item) => item.tx.value.msg[0].value.neuron);\n};\n\nexport async function getTransaction(txHash: string) {\n  // https://lcd.bostrom.cybernode.ai/cosmos/tx/v1beta1/txs/67FD87EBCC1633B779C154C1CAFD48DE71350074A04F742DAD418F69F1D05BB0\n  const response = axios.get(\n    `${CYBER_NODE_URL_LCD}/cosmos/tx/v1beta1/txs/${txHash}`\n  );\n  return response;\n}\n","/* eslint-disable no-restricted-syntax */\nimport { Observable, combineLatest } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport BroadcastChannelSender from '../../channels/BroadcastChannelSender';\n\nimport ParticlesResolverQueue from './services/ParticlesResolverQueue/ParticlesResolverQueue';\n\n// import SyncIpfsLoop from './services/SyncIpfsLoop/SyncIpfsLoop';\nimport SyncTransactionsLoop from './services/SyncTransactionsLoop/SyncTransactionsLoop';\nimport SyncParticlesLoop from './services/SyncParticlesLoop/SyncParticlesLoop';\n\nimport { ServiceDeps } from './services/types';\nimport {\n  MY_FRIENDS_SYNC_INTERVAL,\n  MY_PARTICLES_SYNC_INTERVAL,\n} from './services/consts';\nimport SyncMyFriendsLoop from './services/SyncMyFriendsLoop/SyncMyFriendsLoop';\nimport { SyncEntryName } from '../../types/services';\nimport BaseSyncLoop from './services/BaseSyncLoop/BaseSyncLoop';\nimport createCommunitySync$ from './services/CommunitySync/CommunitySync';\nimport { createCyblogChannel } from 'src/utils/logging/cyblog';\n\nconst cyblogCh = createCyblogChannel({ thread: 'bckd' });\n\n// eslint-disable-next-line import/prefer-default-export\nexport class SyncService {\n  private isInitialized$: Observable<boolean>;\n\n  private channelApi = new BroadcastChannelSender();\n\n  private loops: Partial<Record<SyncEntryName, BaseSyncLoop>> = {};\n\n  constructor(deps: ServiceDeps) {\n    const { dbInstance$, ipfsInstance$ } = deps;\n    this.isInitialized$ = combineLatest([dbInstance$, ipfsInstance$]).pipe(\n      map(([dbInstance, ipfsInstance]) => !!dbInstance && !!ipfsInstance)\n    );\n    // subscribe when started\n    this.isInitialized$.subscribe({\n      next: (result) => {\n        return result && this.channelApi.postServiceStatus('sync', 'started');\n      },\n      error: (err) => this.channelApi.postServiceStatus('sync', 'error', err),\n    });\n\n    const particlesResolver = new ParticlesResolverQueue(deps).start();\n\n    const communitySync$ = createCommunitySync$(deps);\n    communitySync$.subscribe((community) => {\n      cyblogCh.info('--> community fetched', {\n        unit: 'community',\n        data: community,\n      });\n    });\n\n    const followings$ = communitySync$.pipe(\n      map((c) => c.filter((i) => i.following)),\n      map((c) => c.map((i) => i.neuron))\n    );\n\n    // new SyncIpfsLoop(deps, particlesResolver).start();\n\n    new SyncTransactionsLoop('transactions', deps, particlesResolver).start();\n\n    new SyncParticlesLoop(\n      'particles',\n      MY_PARTICLES_SYNC_INTERVAL,\n      deps,\n      particlesResolver\n    ).start();\n\n    new SyncMyFriendsLoop(\n      'my-friends',\n      MY_FRIENDS_SYNC_INTERVAL,\n      { ...deps, followings$ },\n      particlesResolver\n      // { warmupMs: 1000 }\n    ).start();\n  }\n\n  public restart(name: SyncEntryName) {\n    this.loops[name]?.restart();\n  }\n}\n","import {\n  Observable,\n  combineLatest,\n  defer,\n  distinctUntilChanged,\n  filter,\n  map,\n  switchMap,\n} from 'rxjs';\n\nimport {\n  SyncCommunityResult,\n  fetchStoredSyncCommunity$,\n} from 'src/services/community/community';\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { CommunityDto } from 'src/services/CozoDb/types/dto';\nimport { ServiceDeps } from '../types';\n\n// eslint-disable-next-line import/no-unused-modules\nexport default function createCommunitySync$(\n  deps: ServiceDeps\n): Observable<CommunityDto[]> {\n  const { dbInstance$, ipfsInstance$, params$ } = deps;\n  const channel = new BroadcastChannelSender();\n\n  return combineLatest([\n    dbInstance$,\n    params$!.pipe(\n      map((params) => params.myAddress),\n      distinctUntilChanged()\n    ),\n    ipfsInstance$,\n  ]).pipe(\n    filter(\n      ([dbInstance, myAddress, ipfsInstance]) =>\n        !!dbInstance && !!ipfsInstance && !!myAddress\n    ),\n    switchMap(([dbApi, myAddress, ipfsInstance]) => {\n      const { waitForParticleResolve } = deps;\n      let community: CommunityDto[] = []; // Fix: Add type declaration for community array\n      return new Observable<CommunityDto[]>((observer) => {\n        observer.next([]);\n\n        fetchStoredSyncCommunity$(\n          dbApi!,\n          myAddress!,\n          waitForParticleResolve!\n        ).subscribe(({ action, items }: SyncCommunityResult) => {\n          channel.post({ type: 'load_community', value: { action, items } });\n\n          if (action === 'reset') {\n            community = [];\n          } else if (['add', 'complete'].some((s) => s === action)) {\n            community.push(...items);\n          }\n\n          if (action === 'complete') {\n            observer.next(community);\n            observer.complete();\n          }\n        });\n      });\n    })\n  );\n}\n","import {\n  BehaviorSubject,\n  defer,\n  Observable,\n  filter,\n  from,\n  mergeMap,\n  tap,\n} from 'rxjs';\nimport { IDeferredDbSaver } from 'src/services/QueueManager/types';\nimport { IPFSContent, IPFSContentMaybe } from 'src/services/ipfs/ipfs';\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { ParticleCid } from 'src/types/base';\nimport { mapParticleToEntity } from 'src/services/CozoDb/mapping';\nimport DbApi from '../dataSource/indexedDb/dbApiWrapper';\nimport { LinkDto } from 'src/services/CozoDb/types/dto';\n\ntype QueueItem = {\n  content?: IPFSContent;\n  links?: LinkDto[];\n};\n\ntype QueueMap = Map<ParticleCid | typeof uuidv4, QueueItem>;\n\nclass DeferredDbSaver implements IDeferredDbSaver {\n  private queue$ = new BehaviorSubject<QueueMap>(new Map());\n\n  private dbApi: DbApi | undefined;\n\n  public get queue(): QueueMap {\n    return this.queue$.getValue();\n  }\n\n  constructor(dbInstance$: Observable<DbApi | undefined>) {\n    dbInstance$.subscribe((db) => {\n      this.dbApi = db;\n    });\n\n    dbInstance$\n      .pipe(\n        filter((dbInstance) => !!dbInstance),\n        tap(() => cyblog.info('DeferredDbSaver - initialized')),\n        mergeMap(() => this.queue$), // Merge the queue$ stream here.\n        filter((queue) => queue.size > 0),\n        mergeMap((queue) => defer(() => from(this.processQueue(queue))))\n      )\n      .subscribe({\n        // next: () => console.log('Queue processed'),\n        error: (err) => console.error('Error processing IPFS queue', err),\n      });\n  }\n\n  public enqueueIpfsContent(content: IPFSContentMaybe) {\n    if (!content) {\n      return;\n    }\n    const { cid } = content;\n\n    this.queue$.next(new Map(this.queue$.value).set(cid, { content }));\n  }\n\n  public enqueueLinks(links: LinkDto[]) {\n    if (!links || !links.length) {\n      return;\n    }\n    const id = uuidv4();\n    this.queue$.next(new Map(this.queue$.value).set(id, { links }));\n  }\n\n  private async processQueue(queue: QueueMap) {\n    // const processingQueue = new Map(this.queue$.value); // Snapshot of the current queue\n    this.queue$.next(new Map());\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [cid, item] of queue) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.processQueueItem(item);\n      // console.log(' deffered DB done ', cid, item);\n\n      queue.delete(cid);\n    }\n    // this.queue$.next(queue);\n  }\n\n  private async processQueueItem(queueItem: QueueItem) {\n    const { content, links } = queueItem;\n    // console.log(`PostProcessing queue item: ${cid}`, item);\n    if (content) {\n      // eslint-disable-next-line no-await-in-loop\n      const entity = mapParticleToEntity(content);\n      await this.dbApi!.putParticles(entity);\n    }\n\n    if (links && links.length > 0) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.dbApi!.putCyberlinks(links);\n    }\n  }\n}\n\nexport default DeferredDbSaver;\n","import { ProxyMarked, Remote, proxy } from 'comlink';\n\nimport { initIpfsNode } from 'src/services/ipfs/node/factory';\n\nimport {\n  CybIpfsNode,\n  IpfsContentType,\n  IpfsOptsType,\n} from 'src/services/ipfs/ipfs';\n\nimport QueueManager from 'src/services/QueueManager/QueueManager';\n\n// import { CozoDbWorkerApi } from 'src/services/backend/workers/db/worker';\n\nimport {\n  QueueItemCallback,\n  QueueItemOptions,\n  QueuePriority,\n} from 'src/services/QueueManager/types';\nimport { ParticleCid } from 'src/types/base';\nimport { LinkDto } from 'src/services/CozoDb/types/dto';\nimport { BehaviorSubject, Subject } from 'rxjs';\n\nimport { exposeWorkerApi } from '../factoryMethods';\n\nimport { SyncService } from '../../services/sync/sync';\nimport { SyncServiceParams } from '../../services/sync/types';\n\nimport DbApi from '../../services/dataSource/indexedDb/dbApiWrapper';\n\nimport BroadcastChannelSender from '../../channels/BroadcastChannelSender';\nimport DeferredDbSaver from '../../services/DeferredDbSaver/DeferredDbSaver';\nimport { SyncEntryName } from '../../types/services';\n\nconst createBackgroundWorkerApi = () => {\n  const dbInstance$ = new Subject<DbApi | undefined>();\n\n  const ipfsInstance$ = new BehaviorSubject<CybIpfsNode | undefined>(undefined);\n\n  const params$ = new BehaviorSubject<SyncServiceParams>({\n    myAddress: null,\n  });\n\n  let ipfsNode: CybIpfsNode | undefined;\n  const defferedDbSaver = new DeferredDbSaver(dbInstance$);\n\n  const ipfsQueue = new QueueManager(ipfsInstance$, {\n    defferedDbSaver,\n  });\n  const broadcastApi = new BroadcastChannelSender();\n\n  // service to sync updates about cyberlinks, transactions, swarm etc.\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const syncService = new SyncService({\n    waitForParticleResolve: async (\n      cid: ParticleCid,\n      priority: QueuePriority = QueuePriority.MEDIUM\n    ) => ipfsQueue.enqueueAndWait(cid, { postProcessing: true, priority }),\n    dbInstance$,\n    ipfsInstance$,\n    params$,\n  });\n\n  const init = async (dbApiProxy: DbApi & ProxyMarked) => {\n    dbInstance$.next(dbApiProxy);\n  };\n\n  const stopIpfs = async () => {\n    if (ipfsNode) {\n      await ipfsNode.stop();\n    }\n    ipfsInstance$.next(undefined);\n    broadcastApi.postServiceStatus('ipfs', 'inactive');\n  };\n\n  const startIpfs = async (ipfsOpts: IpfsOptsType) => {\n    try {\n      if (ipfsNode) {\n        console.log('Ipfs node already started!');\n        await ipfsNode.stop();\n      }\n      broadcastApi.postServiceStatus('ipfs', 'starting');\n      ipfsNode = await initIpfsNode(ipfsOpts);\n\n      ipfsInstance$.next(ipfsNode);\n\n      setTimeout(() => broadcastApi.postServiceStatus('ipfs', 'started'), 0);\n      return true;\n    } catch (err) {\n      console.log('----ipfs node init error ', err);\n      const msg = err instanceof Error ? err.message : (err as string);\n      broadcastApi.postServiceStatus('ipfs', 'error', msg);\n      throw Error(msg);\n    }\n  };\n\n  const defferedDbApi = {\n    importCyberlinks: (links: LinkDto[]) => {\n      defferedDbSaver.enqueueLinks(links);\n    },\n  };\n\n  const ipfsApi = {\n    start: startIpfs,\n    stop: stopIpfs,\n    getIpfsNode: async () => ipfsNode && proxy(ipfsNode),\n    config: async () => ipfsNode?.config,\n    info: async () => ipfsNode?.info(),\n    fetchWithDetails: async (cid: string, parseAs?: IpfsContentType) =>\n      ipfsNode?.fetchWithDetails(cid, parseAs),\n    enqueue: async (\n      cid: string,\n      callback: QueueItemCallback,\n      options: QueueItemOptions\n    ) => ipfsQueue!.enqueue(cid, callback, options),\n    enqueueAndWait: async (cid: string, options?: QueueItemOptions) =>\n      ipfsQueue!.enqueueAndWait(cid, options),\n    dequeue: async (cid: string) => ipfsQueue.cancel(cid),\n    dequeueByParent: async (parent: string) => ipfsQueue.cancelByParent(parent),\n    clearQueue: async () => ipfsQueue.clear(),\n    addContent: async (content: string | File) => ipfsNode?.addContent(content),\n  };\n\n  return {\n    init,\n    isInitialized: () => !!ipfsInstance$.value,\n    // syncDrive,\n    ipfsApi: proxy(ipfsApi),\n    defferedDbApi: proxy(defferedDbApi),\n    ipfsQueue: proxy(ipfsQueue),\n    restartSync: (name: SyncEntryName) => syncService.restart(name),\n    setParams: (params: Partial<SyncServiceParams>) =>\n      params$.next({ ...params$.value, ...params }),\n  };\n};\n\nconst backgroundWorker = createBackgroundWorkerApi();\nexport type IpfsApi = Remote<typeof backgroundWorker.ipfsApi>;\nexport type BackgroundWorker = typeof backgroundWorker;\n\n// Expose the API to the main thread as shared/regular worker\nexposeWorkerApi(self, backgroundWorker);\n","export const CYBLOG_LOG_SHOW = 'cyblog_show';\n\nexport const CYBLOG_BROADCAST_CHANNEL_NAME = 'CYBLOG_BROADCST_CHANNEL';\n\nexport const CYBLOG_CONSOLE_PARAMS_DEFAULT = {\n  thread: 'all',\n  unit: 'all',\n  module: 'all',\n};\n","import _, { isEmpty } from 'lodash';\nimport { ConsoleLogParams, LogContext, LogItem, LogLevel } from './types';\nimport { CYBLOG_BROADCAST_CHANNEL_NAME } from './constants';\n\nconst logList: LogItem[] = [];\n\nfunction createCybLog<T>(defaultContext: Partial<LogContext<T>> = {}) {\n  function appendLog(logItem: LogItem, truncate = true) {\n    logList.push(logItem);\n\n    while (truncate && logList.length > 1000) {\n      logList.shift(); // Remove the first element to keep the list size <= 1000\n    }\n  }\n  let consoleLogParams = {} as ConsoleLogParams;\n\n  const channel = new BroadcastChannel(CYBLOG_BROADCAST_CHANNEL_NAME);\n\n  channel.onmessage = (event) => {\n    if (event.data.type === 'params') {\n      consoleLogParams = { ...consoleLogParams, ...event.data.value };\n    }\n  };\n\n  const getConsoleLogParams = () => consoleLogParams;\n\n  function consoleLog<T>(\n    level: LogLevel,\n    message: T,\n    context: Partial<LogContext<T>>\n  ) {\n    const ctx = _.omit(context, [\n      'formatter',\n      'thread',\n      'module',\n      'unit',\n      'data',\n    ]);\n    const { thread = '', module = '', unit = '', data = '' } = context;\n    const ctxItem = isEmpty(ctx) ? '' : ctx;\n\n    if (Array.isArray(message)) {\n      console[level](...message, ctxItem);\n      return;\n    }\n\n    if (context?.formatter) {\n      console[level](context?.formatter(message), ctxItem);\n      return;\n    }\n\n    console[level](`[${thread}:${module}:${unit}] ${message}`, data, ctxItem);\n  }\n\n  // eslint-disable-next-line import/no-unused-modules\n  function log<T>(\n    level: LogLevel,\n    message: string | T,\n    context: LogContext<any> = defaultContext\n  ) {\n    try {\n      const formattedMessage = context?.formatter\n        ? context?.formatter(message)\n        : message;\n\n      const logEntry = {\n        timestamp: new Date(),\n        level,\n        message: formattedMessage,\n        stacktrace: context?.stacktrace,\n        context: _.omit(context, ['formatter', 'stacktrace']),\n      };\n\n      appendLog(logEntry);\n      // !!localStorage.getItem(LOCAL_STORAGE_USE_CONSOLE_LOG_KEY) &&\n      const showConsoleLog = Object.keys(consoleLogParams).reduce(\n        (acc: boolean, key: string) => {\n          const params = consoleLogParams[key];\n          const contextItem = context[key];\n          if (params && contextItem) {\n            return (\n              acc ||\n              params === 'all' ||\n              params.length === 0 ||\n              params.some((p) => p === contextItem)\n            );\n          }\n          return acc;\n        },\n        false\n      );\n\n      if (showConsoleLog) {\n        consoleLog(level, message, context);\n      }\n    } catch (error) {\n      console.log('cyblog error', error);\n    }\n  }\n\n  function info<T>(message: T, context?: LogContext<string | T>) {\n    return log('info', message, context);\n  }\n\n  function error<T>(message: T, context?: LogContext<string | T>) {\n    return log('error', message, context);\n  }\n\n  function warn<T>(message: T, context?: LogContext<string | T>) {\n    return log('warn', message, context);\n  }\n\n  function trace<T>(message: T, context?: LogContext<string | T>) {\n    return log('warn', message, context);\n  }\n\n  function normalizeLog() {\n    return logList.map((logItem) => {\n      const { context, ...rest } = logItem;\n      const {\n        unit = '',\n        module = '',\n        thread = '',\n        data = '',\n        error = '',\n        stacktrace = '',\n      } = context || {};\n      return {\n        ...rest,\n        unit,\n        module,\n        thread,\n        data, //: JSON.stringify(data),\n        error,\n        stacktrace,\n      };\n    });\n  }\n\n  return {\n    log,\n    info,\n    error,\n    warn,\n    trace,\n    logList,\n    getLogs: () => normalizeLog(),\n    clear: () => logList.splice(0, logList.length),\n    getConsoleLogParams,\n  };\n}\n\nexport const createCyblogChannel = (\n  defaultContext: Partial<LogContext<T>> = {}\n) => {\n  const channel = new BroadcastChannel(CYBLOG_BROADCAST_CHANNEL_NAME);\n\n  function postLogToChannel<T>(\n    level: LogLevel,\n    message: T,\n    context?: LogContext<string | T>\n  ) {\n    const ctx = { ...defaultContext, ...context };\n    if (context?.error) {\n      ctx.error = JSON.stringify(context.error);\n    }\n    channel.postMessage({\n      type: 'log',\n      value: { level, message, context: ctx },\n    });\n  }\n\n  function info<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('info', message, context);\n  }\n\n  function error<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('error', message, context);\n  }\n\n  function warn<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('warn', message, context);\n  }\n\n  function trace<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('warn', message, context);\n  }\n\n  return { info, error, warn, trace };\n};\n\nconst cyblog = createCybLog({ thread: 'main' });\n\nexport type LogFunc = (message: T, context?: LogContext<string | T>) => void;\n\nexport type CyblogChannel = ReturnType<typeof createCyblogChannel>;\n\nexport default cyblog;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [912,393,698,724], function() { return __webpack_require__(60427); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdO = {};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"393\":\"d8cfa458\",\"698\":\"4fa3266d\",\"724\":\"0892e360\",\"827\":\"89ce62da\",\"912\":\"ecb020b3\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t73: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkcyb\"] = self[\"webpackChunkcyb\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","stringToCid","s","stringToIpfsPath","CYBER_NODE_SWARM_PEER_ID","CYBERNODE_SWARM_ADDR_WSS","CYBERNODE_SWARM_ADDR_TCP","CYBER_GATEWAY_URL","nodeType","_config","_isStarted","config","this","isStarted","response","node","get","gatewayUrl","address","nodeAddress","port","async","options","initConfig","window","toCid","console","log","swarm","localAddrs","map","a","toString","cid","files","stat","withLocal","size","then","result","type","sizeLocal","local","blocks","cat","content","add","pin","peers","c","peer","addr","bootstrap","connect","ls","repoSize","stats","repo","responseId","id","agentVersion","addOptionsV0","cidVersion","rawLeaves","blockstore","open","datastore","libp2p","bootstrapList","transports","rtcConfiguration","iceServers","urls","credential","username","discoverRelays","connectionEncryption","streamMuxers","connectionGater","denyDialMultiaddr","peerDiscovery","list","services","identify","libp2pFactory","fs","addEventListener","evt","peerId","detail","conn","getConnections","transportsByAddr","Object","fromEntries","remoteAddr","protoCodes","v","name","debug","getMultiaddrs","fileSize","localFileSize","dagSize","mtime","optionsV0","File","fileName","arrayBuffer","data","Uint8Array","addFile","path","TextEncoder","encode","addBytes","cid_","pins","isPinned","remotePeer","stop","start","dial","iterable","item","metadata","toV0","mapToLsResult","host","relay","enabled","hop","preload","API","HTTPHeaders","Addresses","Gateway","Swarm","Delegates","Discovery","MDNS","Enabled","Interval","webRTCStar","Bootstrap","Pubsub","ConnMgr","HighWater","LowWater","DisableNatPortMap","Routing","Type","filter","filters","nat","EXPERIMENTAL","ipnsPubsub","Number","getMimeFromUint8Array","raw","fileType","mime","PATTERN_HTTP","createImgData","rawData","basic","parseArrayLikeToDetails","onProgress","meta","link","gateway","initialType","includes","detectContentType","indexOf","bytesDownloaded","byteLength","chunks","ReadableStream","reader","getReader","readStream","done","value","push","read","Symbol","asyncIterator","chunk","error","getResponseResult","Buffer","from","dataBase64","length","match","string","newString","trim","slice","test","isHtml","text","shortenString","blob","Blob","URL","createObjectURL","e","createTextPreview","array","previewLength","db","version","stores","following","ipfsContentAddtToInddexdDB","dbValue","cluster","file","dataFile","status","loadIPFSContentFromDb","textPreview","source","emptyMeta","fetchIPFSContentMeta","signal","fetchIPFSContentFromNode","controller","controllerLegacy","AbortController","timer","setTimeout","abort","startTime","Date","now","statsDoneTime","statsTime","allowedSize","clearTimeout","availableDownload","firstChunk","offset","fullyDownloaded","stream","catTime","pinTime","fetchIPFSContentFromGateway","isExternalNode","contentUrl","fetch","method","body","flushResults","Promise","resolve","flush","firstChunkStream","fullStream","tee","firstReader","restReader","asyncIterable","toAsyncIterableWithMime","getIPFSContent","callBackFuncStatus","dataRsponseDb","addContenToIpfs","contentToUint8Array","nodeClassMap","helia","embedded","external","initIpfsNode","ipfsNodeType","restOptions","EnhancedClass","Base","parseAs","details","super","getPeers","find","swarmPeerId","lastConnectedTimestamp","isConnectedToSwarm","connectPeer","swarmPeerAddress","catch","err","message","withCybFeatures","instance","init","url","urlOpts","reconnectToSwarm","QueueStrategy","constructor","settings","order","getNextSource","index","QueueItemTimeoutError","Error","timeoutMs","setPrototypeOf","prototype","isParticle","Boolean","EntryType","SyncQueueStatus","initialState","isLoading","chats","summary","unreadCount","total","particles","neurons","formatApiData","entryType","chat","to","particle","formatted","timestamp","toISOString","transactionHash","hash","transaction_hash","memo","senseChatId","transactions","ownerId","fromAddress","inputs","assign","neuron","fromLog","getSenseList","senseApi","getList","getSenseChat","getLinks","getFriendItems","markAsRead","newChatStructure","checkIfMessageExists","newMessage","some","msg","reducers","updateSenseList","reducer","state","action","payload","forEach","concat","caseReducers","orderSenseList","prepare","addSenseItem","newList","unshift","updateSenseItem","chatId","txHash","isSuccess","sorted","keys","reduce","acc","lastMsg","sort","b","parse","i","reset","extraReducers","builder","addCase","pending","fulfilled","rejected","arg","sense","unreadCountParticle","unreadCountNeuron","values","actions","channel","BroadcastChannel","postServiceStatus","postMessage","postSyncEntryProgress","entry","postSenseUpdate","senseList","post","getQueueItemTotalPriority","priority","viewPortPriority","strategies","timeout","maxConcurrentExecutions","ipfsInstance$","strategy","queueDebounceMs","defferedDbSaver","queue$","BehaviorSubject","Map","lastNodeCallTime","executing","Set","subscribe","setNode","interval","pipe","debounceTime","queue","cancelDeprioritizedItems","mergeMap","workItems","getItemBySourceAndPriority","merge","fetchData$","E","callbacks","callback","delete","removeAndNext","nextSource","switchSourceAndNext","postSummary","switchStrategy","customStrategy","pendingItems","pendingBySource","itemsToExecute","queueSource","items","entries","executeCount","itemsByPriority","queueItem","set","executionTime","promiseFactory","res","fetchIpfsContent","enqueueIpfsContent","Observable","observer","complete","each","with","throwError","catchError","of","mutateQueueItem","changes","Array","releaseExecution","key","enqueue","existingItem","initialSource","postProcessing","enqueueAndWait","updateViewPortPriority","cancel","cancelByParent","parent","clear","getQueueMap","getQueueList","getStats","fn","QueuePriority","createAsyncIterable","promise","onmessage","event","IPFSContentTransferHandler","canHandle","obj","serialize","rest","port1","port2","MessageChannel","close","deserialize","serializedObj","SharedWorker","process","env","IS_DEV","installTransferHandlers","overrideLogging","worker","consoleLogMap","original","warn","replaceConsoleLog","args","apply","serializableArgs","JSON","stringify","String","safeStringify","broadcastStatus","channelApi","sendStatus","progress","asyncIterableBatchProcessor","batchProcess","batchSize","batch","CID_TWEET","CID_FOLLOW","RegExp","SENSE_FRIEND_PARTICLES","deps","statusApi","_syncQueue$","waitForParticleResolve","dbInstance$","loadSyncQueue","isInitialized$","combineLatest","dbInstance","ipfsInstance","getValue","loop$","_loop$","all","MEDIUM","updateSyncQueue","removeSyncQueue","source$","tap","q","isInitialized","processSyncQueue","share","URGENT","cids","putSyncQueue","getSyncQueue","statuses","numberToUtcDate","dateToUtcNumber","isoString","endsWith","mapIndexerTransactionToEntity","tx","transaction","block","height","success","blockHeight","mapLinkFromIndexerToDto","throwIfAborted","func","aborted","DOMException","CYBER_NODE_URL_LCD","CYBER_INDEX_WSS","CYBER_NODE_URL_WS","MSG_SEND_TRANSACTION_TYPE","MSG_MULTI_SEND_TRANSACTION_TYPE","mapWebsocketTxToTransactions","events","transactionType","messages","Tx","msgType","typeUrl","MsgSend","MsgMultiSend","extractTxData","TxResult","fetchIterable","fetchFunction","params","cyberGraphQLWsLink","shouldRetry","errOrCloseEvent","retryAttempts","retryWait","retries","Math","min","createIndexerClient","abortSignal","cyberlinksByParticle","cyberlinksCountByNeuron","fetchCyberlinks","particleCid","timestampFrom","request","limit","orderBy","where","_or","particle_to","_eq","particle_from","_gt","cyberlinks","fetchCyberlinksByNeroun","particlesFrom","_and","_in","fetchCyberlinksByNerounIterable","getUniqueParticlesFromLinks","links","fetchCyberlinksAndResolveParticles","timestampUpdate","particlesResolver","queuePriority","cyberlinksIterable","fetchCyberlinksIterable","enqueueBatch","mapMessagesByAddressVariables","types","orderDirection","timestamp_from","t","join","order_direction","gqlMessagesByAddress","fetchTransactions","messages_by_address","transactionsCountByNeuron","updateSenseChat","amount","isSender","userAddress","lastSendTimestamp","last","direction","syncMyChats","myAddress","shouldUpdateTimestamp","syncItems","findSyncStatus","syncItemsMap","myChats","outputs","coins","toAddress","extractSenseChats","getTransactions","results","syncItem","lastTransaction","at","transactionTimestamp","syncItemHeader","timestampRead","prevUnreadCount","lastTimestampRead","max","timestampUpdateContent","timestampUpdateChat","timestampUnreadFrom","newTimestampUpdateChat","syncStatusChanges","updateSyncStatus","bind","newItem","disabled","putSyncStatus","ProgressTracker","onProgressUpdate","requestRecords","totalRequests","completedRequests","estimatedTime","totalCount","completeCount","extraRequests","trackProgress","processedCount","addRequestRecord","shift","estimatedRemainingTime","calculateAverageTimePerItem","round","itemCount","totalDiff","totalItems","timeDiff","progressTracker","abortController","cyblogCh","thread","module","params$","createIsInitializedObserver","info","switchMap","createRestartObserver","restart","initAbortController","distinctUntilChanged","addrBefore","addrAfter","switchWhenInitialized","actionObservable$","onChange","initialized","reloadTrigger$","Subject","startWith","createInitObservable","createClientObservable","onUpdate","syncQueueInitialized","variables","indexerObservable$","query","apolloObservable","ApolloClient","cache","subscriber","subscription","unsubscribe","createIndexerWebsocket","nodeObservample$","ws","WebSocket","onopen","send","jsonrpc","onerror","onclose","createNodeWebsocketObservable","ctx","unit","isEmpty","defer","initSync","getSyncStatus","lastTransactionTimestamp","syncTransactions","syncStatusItems","processBatchTransactions","putTransactions","syncLinks","lastTimestampFrom","newSyncItem","totalMessageCount","messages_by_address_aggregate","aggregate","count","fetchTransactionMessagesCount","ceil","transactionsAsyncIterable","fetchTransactionsIterable","transactionCount","tweets","particlesFound","l","txLink","extractCybelinksFromTransaction","putCyberlinks","tweetParticles","nonTweetParticles","HIGH","LOW","snakeToCamel","str","replace","group","toUpperCase","entityToDto","dbEntity","dto","hasOwnProperty","call","camelCaseKey","isArray","getLastReadInfo","prevTimestampRead","lastUnreadLinks","lastMyLinkIndex","findLastIndex","changeParticleSyncStatus","syncStatus","lastLink","isAbortException","intervalMs","warmupMs","restartLoop","onStartInterval","onError","retryDelayMs","restartTrigger$","intervalOrRestart$","delay","exhaustMap","retry","createLoopObservable","doSync","sync","isAborted","particleResolverInitialized","syncItemParticles","newLinkCount","particles_from","cyberlinks_aggregate","fetchCyberlinksCount","newSyncItemParticles","fetchNewTweets","syncParticles","tweetsAsyncIterable","newTweets","existingParticles","existingParticlesMap","tweetsBatch","syncStatusEntities","timestampSyncFrom","updatedSyncItems","linksIndexer","followings$","followings","followingsInitialized$","followingsInitialized","syncUpdates","linksAsyncIterable","linksBatch","newTimestampRead","newUnreadCount","newTimestampUpdateContent","reject","buffer","marshal","DAGNode","dagNode","toBaseEncodedString","fetchStoredSyncCommunity$","dbApi","fetchParticleAsync","storedCommunity","getCommunity","communityUpdatesMap","getExistingOrDefault","follower","followsCids","txs","followers","addressHash","newFollowerCids","newFollowingNeurons","followersCommunity","communityItem","putCommunity","SyncService","loops","communitySync$","community","createCommunitySync$","processQueue","enqueueLinks","processQueueItem","entity","size_local","mapParticleToEntity","putParticles","backgroundWorker","ipfsNode","ipfsQueue","broadcastApi","syncService","defferedDbApi","importCyberlinks","ipfsApi","ipfsOpts","getIpfsNode","fetchWithDetails","dequeue","dequeueByParent","clearQueue","addContent","dbApiProxy","restartSync","setParams","createBackgroundWorkerApi","api","self","onconnect","ports","CYBLOG_BROADCAST_CHANNEL_NAME","logList","createCyblogChannel","defaultContext","postLogToChannel","level","context","trace","cyblog","consoleLogParams","formattedMessage","formatter","logItem","truncate","appendLog","stacktrace","contextItem","p","ctxItem","consoleLog","getLogs","splice","getConsoleLogParams","createCybLog","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","loaded","__webpack_modules__","m","x","__webpack_exports__","O","amdO","chunkIds","notFulfilled","Infinity","j","every","r","n","getter","__esModule","d","getPrototypeOf","__proto__","mode","ns","create","def","current","getOwnPropertyNames","definition","o","defineProperty","enumerable","f","chunkId","promises","u","miniCssF","g","globalThis","Function","prop","toStringTag","nmd","paths","children","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","pop"],"sourceRoot":""}