{"version":3,"file":"280.cc391039.chunk.js","mappings":"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","sources":["webpack://cyb/webpack/runtime/chunk loaded","webpack://cyb/webpack/runtime/create fake namespace object","webpack://cyb/webpack/runtime/startup chunk dependencies","webpack://cyb/./src/services/ipfs/utils/cid.ts","webpack://cyb/./src/services/ipfs/config.ts","webpack://cyb/./src/services/ipfs/node/impl/kubo.ts","webpack://cyb/./src/services/ipfs/node/impl/helia.ts","webpack://cyb/./src/services/ipfs/node/impl/configs/jsIpfsConfig.ts","webpack://cyb/./src/services/ipfs/node/impl/js-ipfs.ts","webpack://cyb/./src/services/ipfs/utils/stream.ts","webpack://cyb/./src/services/ipfs/utils/content.ts","webpack://cyb/./src/db.js","webpack://cyb/./src/services/ipfs/utils/ipfsCacheDb.ts","webpack://cyb/./src/services/ipfs/utils/cluster.ts","webpack://cyb/./src/services/ipfs/utils/utils-ipfs.ts","webpack://cyb/./src/services/ipfs/node/factory.ts","webpack://cyb/./src/services/ipfs/node/mixins/withCybFeatures.ts","webpack://cyb/./src/services/QueueManager/QueueStrategy.ts","webpack://cyb/./src/services/QueueManager/QueueItemTimeoutError.ts","webpack://cyb/./src/features/particle/utils.tsx","webpack://cyb/./src/services/CozoDb/types/entities.ts","webpack://cyb/./src/features/sense/redux/sense.redux.ts","webpack://cyb/./src/constants/localStorageKeys.ts","webpack://cyb/./src/types/networks.ts","webpack://cyb/./src/utils/config.ts","webpack://cyb/./src/redux/features/pocket.ts","webpack://cyb/./src/services/backend/channels/BroadcastChannelSender.ts","webpack://cyb/./src/services/backend/channels/consts.ts","webpack://cyb/./src/services/QueueManager/QueueManager.ts","webpack://cyb/./src/utils/helpers.ts","webpack://cyb/./src/services/QueueManager/types.ts","webpack://cyb/./src/services/backend/workers/serializers.ts","webpack://cyb/./src/services/backend/workers/factoryMethods.ts","webpack://cyb/./src/services/backend/channels/broadcastStatus.ts","webpack://cyb/./src/utils/async/iterable.ts","webpack://cyb/./src/constants/app.ts","webpack://cyb/./src/services/backend/services/sync/services/consts.ts","webpack://cyb/./src/services/backend/services/sync/services/ParticlesResolverQueue/ParticlesResolverQueue.ts","webpack://cyb/./src/utils/date.ts","webpack://cyb/./src/services/CozoDb/mapping.ts","webpack://cyb/./src/utils/async/promise.ts","webpack://cyb/./src/constants/config.ts","webpack://cyb/./src/services/backend/services/indexer/types.ts","webpack://cyb/./src/services/blockchain/utils/mapping.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/utils/fetch.ts","webpack://cyb/./src/services/backend/services/indexer/utils.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/indexer.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/consts.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/links.ts","webpack://cyb/./src/services/backend/services/indexer/transactions.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/sense.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncTransactionsLoop/services/chat.ts","webpack://cyb/./src/services/backend/services/sync/services/ProgressTracker/ProgressTracker.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSync.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/rxjs/withInitializer.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSyncClient.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncTransactionsLoop/SyncTransactionsLoop.ts","webpack://cyb/./src/services/blockchain/websocket.ts","webpack://cyb/./src/utils/dto.ts","webpack://cyb/./src/services/backend/services/sync/utils.ts","webpack://cyb/./src/utils/exceptions/helpers.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSyncLoop.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/rxjs/loop.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncParticlesLoop/SyncParticlesLoop.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncMyFriendsLoop/SyncMyFriendsLoop.ts","webpack://cyb/./src/utils/ipfs/helpers.ts","webpack://cyb/./src/services/community/community.ts","webpack://cyb/./src/services/backend/services/lcd/lcd.ts","webpack://cyb/./src/services/backend/services/sync/sync.ts","webpack://cyb/./src/services/backend/services/sync/services/CommunitySync/CommunitySync.ts","webpack://cyb/./src/services/backend/services/DeferredDbSaver/DeferredDbSaver.ts","webpack://cyb/./src/services/backend/workers/background/worker.ts","webpack://cyb/./src/utils/logging/constants.ts","webpack://cyb/./src/utils/logging/cyblog.ts","webpack://cyb/webpack/bootstrap","webpack://cyb/webpack/runtime/amd options","webpack://cyb/webpack/runtime/compat get default export","webpack://cyb/webpack/runtime/define property getters","webpack://cyb/webpack/runtime/ensure chunk","webpack://cyb/webpack/runtime/get javascript chunk filename","webpack://cyb/webpack/runtime/get mini-css chunk filename","webpack://cyb/webpack/runtime/global","webpack://cyb/webpack/runtime/hasOwnProperty shorthand","webpack://cyb/webpack/runtime/make namespace object","webpack://cyb/webpack/runtime/node module decorator","webpack://cyb/webpack/runtime/publicPath","webpack://cyb/webpack/runtime/importScripts chunk loading","webpack://cyb/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });\n\t}\n\tdef['default'] = function() { return value; };\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([598,393,698,724].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","import { CID } from 'multiformats/cid';\n\nexport const stringToCid = (s: string) => CID.parse(s);\nexport const stringToIpfsPath = (s: string) => `/ipfs/${s}`;\n","import { IPFSNodes, IpfsOptsType } from './ipfs.d';\n\nexport const CYBER_NODE_SWARM_PEER_ID =\n  'QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB';\n\nexport const CYBERNODE_SWARM_ADDR_WSS = `/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/${CYBER_NODE_SWARM_PEER_ID}`;\nexport const CYBERNODE_SWARM_ADDR_TCP = `/ip4/88.99.105.146/tcp/4001/p2p/${CYBER_NODE_SWARM_PEER_ID}`;\n\nexport const IPFS_CLUSTER_URL = 'https://io.cybernode.ai';\n\nexport const CYBER_GATEWAY_URL = 'https://gateway.ipfs.cybernode.ai';\n\nexport const FILE_SIZE_DOWNLOAD = 20 * 10 ** 6;\n\nexport const getIpfsOpts = () => {\n  let ipfsOpts: IpfsOptsType = {\n    ipfsNodeType: IPFSNodes.HELIA,\n    urlOpts: '/ip4/127.0.0.1/tcp/5001', // default url\n    userGateway: 'http://127.0.0.1:8080',\n  };\n\n  // get type ipfs\n  const lsTypeIpfs = localStorage.getItem('ipfsState');\n  if (lsTypeIpfs !== null) {\n    const lsTypeIpfsData = JSON.parse(lsTypeIpfs);\n    ipfsOpts = { ...ipfsOpts, ...lsTypeIpfsData };\n  }\n\n  localStorage.setItem('ipfsState', JSON.stringify(ipfsOpts));\n\n  return ipfsOpts as IpfsOptsType;\n};\n","import { IPFSHTTPClient, create as createKuboClient } from 'kubo-rpc-client';\nimport { multiaddr } from '@multiformats/multiaddr';\n\nimport { stringToCid, stringToIpfsPath } from '../../utils/cid';\nimport {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  InitOptions,\n  IpfsFileStats,\n  IpfsNode,\n  IpfsNodePrperties,\n} from '../../ipfs';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nclass KuboNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'external';\n\n  private node?: IPFSHTTPClient;\n\n  private _config: IpfsNodePrperties = {};\n\n  get config() {\n    return this._config;\n  }\n\n  private _isStarted: boolean = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private async initConfig() {\n    const response = await this.node!.config.get('Addresses.Gateway');\n    if (!response) {\n      return { gatewayUrl: CYBER_GATEWAY_URL };\n    }\n    const address = multiaddr(response as string).nodeAddress();\n\n    return { gatewayUrl: `http://${address.address}:${address.port}` };\n  }\n\n  async init(options?: InitOptions) {\n    this.node = createKuboClient(options);\n    this._config = await this.initConfig();\n\n    if (typeof window !== 'undefined') {\n      window.node = this.node;\n      window.toCid = stringToCid;\n    }\n    console.log(\n      'IPFS - Kubo addrs',\n      (await this.node.swarm.localAddrs()).map((a) => a.toString())\n    );\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.node!.files.stat(stringToIpfsPath(cid), {\n      ...options,\n      withLocal: true,\n      size: true,\n    }).then((result) => {\n      const { type, size, sizeLocal, local, blocks } = result;\n      return {\n        type,\n        size: size || -1,\n        sizeLocal: sizeLocal || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.node!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    return (await this.node!.add(content, options)).cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    return (await this.node!.pin.add(stringToCid(cid), options)).toString();\n  }\n\n  async getPeers() {\n    return (await this.node!.swarm.peers()).map((c) => c.peer.toString());\n  }\n\n  async stop() {}\n  async start() {}\n\n  async connectPeer(address: string) {\n    const addr = multiaddr(address);\n    await this.node!.bootstrap.add(addr);\n\n    await this.node!.swarm.connect(addr);\n    return true;\n  }\n\n  ls() {\n    return this.node!.pin.ls();\n  }\n\n  async info() {\n    const { repoSize } = await this.node!.stats.repo();\n\n    const responseId = await this.node!.id();\n    const { agentVersion, id } = responseId;\n    return { id: id.toString(), agentVersion, repoSize };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default KuboNode;\n","import { Helia, Pin, createHelia } from 'helia';\nimport { IDBBlockstore } from 'blockstore-idb';\nimport { IDBDatastore } from 'datastore-idb';\nimport { Libp2p, createLibp2p } from 'libp2p';\nimport { noise } from '@chainsafe/libp2p-noise';\nimport { yamux } from '@chainsafe/libp2p-yamux';\n// import { mplex } from '@libp2p/mplex';\n\nimport { circuitRelayTransport } from 'libp2p/circuit-relay';\nimport { UnixFS, unixfs, AddOptions } from '@helia/unixfs';\nimport { bootstrap } from '@libp2p/bootstrap';\nimport { webRTC, webRTCDirect } from '@libp2p/webrtc';\nimport { webSockets } from '@libp2p/websockets';\nimport { webTransport } from '@libp2p/webtransport';\nimport { identifyService } from 'libp2p/identify';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport { LsResult } from 'ipfs-core-types/src/pin';\n\nimport {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  IpfsFileStats,\n  IpfsNode,\n} from '../../ipfs';\n// import { all } from '@libp2p/websockets/filters';\nimport { stringToCid } from '../../utils/cid';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nasync function* mapToLsResult(\n  iterable: AsyncIterable<Pin>\n): AsyncIterable<LsResult> {\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of iterable) {\n    const { cid, metadata } = item;\n    yield { cid: cid.toV0(), metadata, type: 'recursive' };\n  }\n}\n\nconst libp2pFactory = async (\n  datastore: IDBDatastore,\n  bootstrapList: string[] = []\n) => {\n  const libp2p = await createLibp2p({\n    datastore,\n    // addresses: {\n    //   listen: [\n    //     '/ip4/127.0.0.1/tcp/0',\n    //     '/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    //   ],\n    // },\n    transports: [\n      webSockets(),\n      webTransport(),\n      webRTC({\n        rtcConfiguration: {\n          iceServers: [\n            {\n              urls: [\n                'stun:stun.l.google.com:19302',\n                'stun:global.stun.twilio.com:3478',\n                'STUN:freestun.net:3479',\n                'STUN:stun.bernardoprovenzano.net:3478',\n                'STUN:stun.aa.net.uk:3478',\n              ],\n            },\n            {\n              credential: 'free',\n              username: 'free',\n              urls: ['TURN:freestun.net:3479', 'TURNS:freestun.net:5350'],\n            },\n          ],\n        },\n      }),\n      webRTCDirect(),\n      circuitRelayTransport({\n        discoverRelays: 1,\n      }),\n    ],\n    connectionEncryption: [noise()],\n    streamMuxers: [yamux()],\n    connectionGater: {\n      denyDialMultiaddr: () => {\n        return false;\n        // by default we refuse to dial local addresses from the browser since they\n        // are usually sent by remote peers broadcasting undialable multiaddrs but\n        // here we are explicitly connecting to a local node so do not deny dialing\n        // any discovered address\n      },\n    },\n    peerDiscovery: [\n      bootstrap({\n        list: bootstrapList,\n      }),\n    ],\n    services: {\n      identify: identifyService(),\n    },\n  });\n  return libp2p;\n};\n\nconst addOptionsV0: Partial<AddOptions> = {\n  cidVersion: 0,\n  rawLeaves: false,\n};\n\nclass HeliaNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'helia';\n\n  get config() {\n    return { gatewayUrl: CYBER_GATEWAY_URL };\n  }\n\n  private _isStarted = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private node?: Helia;\n\n  private fs?: UnixFS;\n\n  async init() {\n    const blockstore = new IDBBlockstore('helia-bs');\n    await blockstore.open();\n\n    const datastore = new IDBDatastore('helia-ds');\n    await datastore.open();\n\n    const bootstrapList = [\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n      '/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    ];\n    const libp2p = await libp2pFactory(datastore, bootstrapList);\n\n    this.node = await createHelia({ blockstore, datastore, libp2p });\n\n    this.fs = unixfs(this.node);\n\n    if (typeof window !== 'undefined') {\n      window.libp2p = libp2p;\n      window.node = this.node;\n      window.fs = this.fs;\n      window.toCid = stringToCid;\n    }\n\n    // DEBUG\n    libp2p.addEventListener('peer:connect', (evt) => {\n      const peerId = evt.detail.toString();\n      const conn = libp2p.getConnections(peerId) || [];\n      const transportsByAddr = Object.fromEntries(\n        conn.map((c) => [\n          c.remoteAddr.toString(),\n          c.remoteAddr.protoCodes().map((v) => protocols(v)?.name),\n        ])\n      );\n      console.debug(`Connected to ${peerId}`, transportsByAddr);\n\n      // console.log(\n      //   '---------ppppp',\n      //   peerId,\n      //   conn,\n      //   conn?.remoteAddr.protoCodes().map((v) => protocols(v)?.name)\n      // ); //.includes(WEBRTC_CODE)\n      // if (conn && conn.stat) {\n      //   const transport = conn.stat.transport; // This might vary based on libp2p version\n      //   console.log(`Connected to ${peerId} using transport ${transport}`);\n      // } else {\n      //   console.log(`Connected to ${peerId}`);\n      // }\n    });\n    libp2p.addEventListener('peer:disconnect', (evt) => {\n      console.debug(`Disconnected from ${evt.detail.toString()}`);\n    });\n    console.log(\n      'IPFS - Helia addrs',\n      libp2p.getMultiaddrs().map((a) => a.toString())\n    );\n    // const webrtcConn = await libp2p.dial(\n    //   multiaddr(\n    //     '/ip4/127.0.0.1/udp/4001/quic-v1/webtransport/certhash/uEiDHumbyZRFV1Av7qH9-2l5HGgU2a2UqM6eloqO0vYz5pQ/certhash/uEiDD_TuVgih5_ua31Z4MVbNq7WSw095UAQmZqdUFMDTVRA/p2p/12D3KooWEYGfgK4dEY3spfuDKVq6Jpiyj4KxP1r6HS5RFp5WHebz'\n    //   )\n    // );\n    // console.log('----webrtcConn', webrtcConn);\n\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.fs!.stat(stringToCid(cid), options).then((result) => {\n      const { type, fileSize, localFileSize, blocks, dagSize, mtime } = result;\n      return {\n        type,\n        size: fileSize || -1,\n        sizeLocal: localFileSize || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.fs!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    // Options to keep CID in V0 format 'Qm....';\n    const optionsV0 = {\n      ...options,\n      ...addOptionsV0,\n    } as Partial<AddOptions>;\n\n    let cid;\n\n    if (content instanceof File) {\n      const fileName = content.name;\n      const arrayBuffer = await content.arrayBuffer();\n      const data = new Uint8Array(arrayBuffer);\n      cid = await this.fs!.addFile(\n        { path: fileName, content: data },\n        optionsV0\n      );\n    } else {\n      const data = new TextEncoder().encode(content);\n      cid = await this.fs!.addBytes(data, optionsV0);\n    }\n    console.log('----added to helia', cid.toString());\n    this.pin(cid.toString(), options);\n    return cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    const cid_ = stringToCid(cid);\n    const isPinned = await this.node?.pins.isPinned(cid_, options);\n    if (!isPinned) {\n      const pinResult = (\n        await this.node?.pins.add(cid_, options)\n      )?.cid.toString();\n      // console.log('------pin', pinResult);\n    }\n    // console.log('------pinned', cid, isPinned);\n    return undefined;\n  }\n\n  async getPeers() {\n    return this.node!.libp2p!.getConnections().map((c) =>\n      c.remotePeer.toString()\n    );\n  }\n\n  async stop() {\n    await this.node?.stop();\n  }\n\n  async start() {\n    await this.node?.start();\n  }\n\n  async connectPeer(address: string) {\n    const conn = await this.node!.libp2p!.dial(multiaddr(address));\n    return true;\n  }\n\n  ls() {\n    const result = mapToLsResult(this.node!.pins.ls());\n    return result;\n  }\n\n  async info() {\n    const id = this.node!.libp2p.peerId.toString();\n    const agentVersion = this.node!.libp2p!.services!.identify!.host!\n      .agentVersion as string;\n    return { id, agentVersion, repoSize: -1 };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default HeliaNode;\n","// eslint-disable-next-line import/no-unresolved\nimport { webSockets } from '@libp2p/websockets';\nimport * as filters from '@libp2p/websockets/filters';\nimport { Options } from 'ipfs-core/dist/src/types';\n\nconst configIpfs = (): Options => ({\n  start: true,\n  repo: 'ipfs-repo-cyber-v2',\n  relay: {\n    enabled: false,\n    hop: {\n      enabled: false,\n    },\n  },\n  preload: {\n    enabled: false,\n  },\n  config: {\n    API: {\n      HTTPHeaders: {\n        'Access-Control-Allow-Methods': ['PUT', 'POST'],\n        'Access-Control-Allow-Origin': [\n          'http://localhost:3000',\n          'http://127.0.0.1:5001',\n          'http://127.0.0.1:8888',\n          'http://localhost:8888',\n        ],\n      },\n    },\n    Addresses: {\n      Gateway: '/ip4/127.0.0.1/tcp/8080',\n      Swarm: [\n        // '/dns4/ws-star.discovery.cybernode.ai/tcp/443/wss/p2p-webrtc-star',\n        // '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',\n        // '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star',\n      ],\n      Delegates: [\n        // '/dns4/node0.delegate.ipfs.io/tcp/443/https',\n        // '/dns4/node1.delegate.ipfs.io/tcp/443/https',\n        // '/dns4/node2.delegate.ipfs.io/tcp/443/https',\n      ],\n    },\n    Discovery: {\n      MDNS: {\n        Enabled: true,\n        Interval: 10,\n      },\n      webRTCStar: {\n        Enabled: false,\n      },\n    },\n    Bootstrap: [\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n      // '/dns4/ws-star.discovery.cybernode.ai/tcp/4430/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    ],\n    Pubsub: {\n      Enabled: false,\n    },\n    Swarm: {\n      ConnMgr: {\n        HighWater: 300,\n        LowWater: 50,\n      },\n      DisableNatPortMap: false,\n    },\n    Routing: {\n      Type: 'dhtclient',\n    },\n  },\n  libp2p: {\n    transports: [\n      // This is added for local demo!\n      // In a production environment the default filter should be used\n      // where only DNS + WSS addresses will be dialed by websockets in the browser.\n      webSockets({\n        filter: filters.dnsWss,\n      }),\n    ],\n    nat: {\n      enabled: false,\n    },\n  },\n  EXPERIMENTAL: {\n    ipnsPubsub: false,\n  },\n});\n\nexport default configIpfs;\n","import {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  IpfsFileStats,\n  IpfsNode,\n  IpfsNodePrperties,\n} from '../../ipfs';\nimport { create as createJsIpfsClient, IPFS } from 'ipfs-core';\nimport { stringToCid, stringToIpfsPath } from '../../utils/cid';\nimport { multiaddr } from '@multiformats/multiaddr';\n\nimport configIpfs from './configs/jsIpfsConfig';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nclass JsIpfsNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'embedded';\n\n  get config() {\n    return { gatewayUrl: CYBER_GATEWAY_URL };\n  }\n\n  private _isStarted: boolean = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private node?: IPFS;\n\n  async init() {\n    this.node = await createJsIpfsClient(configIpfs());\n    if (typeof window !== 'undefined') {\n      window.node = this.node;\n      window.toCid = stringToCid;\n    }\n\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.node!.files.stat(stringToIpfsPath(cid), {\n      ...options,\n      withLocal: true,\n      size: true,\n    }).then((result) => {\n      const { type, size, sizeLocal, local, blocks } = result;\n      return {\n        type,\n        size: size || -1,\n        sizeLocal: sizeLocal || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.node!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    return (await this.node!.add(content, options)).cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    return (await this.node!.pin.add(stringToCid(cid), options)).toString();\n  }\n\n  async getPeers() {\n    return (await this.node!.swarm.peers()).map((c) => c.peer.toString());\n  }\n\n  async stop() {}\n  async start() {}\n\n  async connectPeer(address: string) {\n    const addr = multiaddr(address);\n    await this.node!.bootstrap.add(addr);\n\n    await this.node!.swarm.connect(addr);\n    return true;\n  }\n\n  ls() {\n    return this.node!.pin.ls();\n  }\n\n  async info() {\n    const response = await this.node!.stats.repo();\n    const repoSize = Number(response.repoSize);\n\n    const responseId = await this.node!.id();\n    const { agentVersion, id } = responseId;\n    return { id: id.toString(), agentVersion, repoSize };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default JsIpfsNode;\n","/* eslint-disable valid-jsdoc */\n/* eslint-disable import/no-unused-modules */\nimport { fileTypeFromBuffer } from 'file-type';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { Uint8ArrayLike } from '../ipfs';\n\ntype ResultWithMime = {\n  result: Uint8ArrayLike;\n  mime: string | undefined;\n  firstChunk: Uint8Array | undefined;\n};\n\ntype StreamDoneCallback = (\n  chunks: Array<Uint8Array>,\n  mime: string | undefined\n) => Promise<void> | void;\n\n// interface AsyncIterableWithReturn<T> extends AsyncIterable<T> {\n//   return?: (value?: unknown) => Promise<IteratorResult<T>>;\n// }\n\nexport const getMimeFromUint8Array = async (\n  raw: Uint8Array | undefined\n): Promise<string | undefined> => {\n  if (!raw) {\n    return 'unknown';\n  }\n  // TODO: try to pass only first N-bytes\n  const fileType = await fileTypeFromBuffer(raw);\n\n  return fileType?.mime || 'text/plain';\n};\n\nexport async function toAsyncIterableWithMime(\n  stream: ReadableStream<Uint8Array>,\n  flush?: StreamDoneCallback\n): Promise<ResultWithMime> {\n  const [firstChunkStream, fullStream] = stream.tee();\n  const chunks: Array<Uint8Array> = []; // accumulate all the data to pim/save\n\n  // Read the first chunk from the stream\n  const firstReader = firstChunkStream.getReader();\n  const { value } = await firstReader.read();\n  const mime = value ? await getMimeFromUint8Array(value) : undefined;\n\n  const restReader = fullStream.getReader();\n\n  const asyncIterable: AsyncIterable<Uint8Array> = {\n    async *[Symbol.asyncIterator]() {\n      while (true) {\n        const { done, value } = await restReader.read();\n        if (done) {\n          flush && flush(chunks, mime);\n          return; // Exit the loop when done\n        }\n        flush && chunks.push(value);\n        yield value; // Yield the value to the consumer\n      }\n    },\n  };\n\n  return { mime, result: asyncIterable, firstChunk: value };\n}\n\nexport async function toReadableStreamWithMime(\n  stream: ReadableStream<Uint8Array>,\n  flush?: StreamDoneCallback\n): Promise<ResultWithMime> {\n  const [firstChunkStream, fullStream] = stream.tee();\n  const chunks: Array<Uint8Array> = []; // accumulate all the data to pim/save\n\n  // Read the first chunk from the stream\n  const firstReader = firstChunkStream.getReader();\n  const { value } = await firstReader.read();\n  const mime = value ? await getMimeFromUint8Array(value) : undefined;\n\n  const modifiedStream = new ReadableStream<Uint8Array>({\n    async pull(controller) {\n      const restReader = fullStream.getReader();\n      const { done, value } = await restReader.read();\n      if (done) {\n        controller.close();\n        flush && flush(chunks, mime);\n      } else {\n        controller.enqueue(value);\n        flush && chunks.push(value);\n      }\n      restReader.releaseLock();\n    },\n    cancel() {\n      firstChunkStream.cancel();\n      fullStream.cancel();\n    },\n  });\n\n  return { mime, result: modifiedStream, firstChunk: value };\n}\n\nexport type onProgressCallback = (progress: number) => void;\n\nexport const getResponseResult = async (\n  response: Uint8ArrayLike,\n  onProgress?: onProgressCallback\n) => {\n  let bytesDownloaded = 0;\n  try {\n    if (response instanceof Uint8Array) {\n      onProgress && onProgress(response.byteLength);\n      return response;\n    }\n    const chunks: Array<Uint8Array> = [];\n\n    if (response instanceof ReadableStream) {\n      const reader = response.getReader();\n\n      const readStream = async ({\n        done,\n        value,\n      }: ReadableStreamReadResult<Uint8Array>): Promise<Uint8Array> => {\n        if (done) {\n          return uint8ArrayConcat(chunks);\n        }\n\n        chunks.push(value!);\n        bytesDownloaded += value!.byteLength;\n        onProgress && onProgress(bytesDownloaded);\n        return reader.read().then(readStream);\n      };\n\n      const readArray: Uint8Array = await reader.read().then(readStream);\n\n      return readArray;\n    }\n\n    const reader = response[Symbol.asyncIterator]();\n\n    // if (cid === 'QmRqms6Utkk6L4mtyLQXY2spcQ8Pk7fBBTNjvxa9jTNrXp') {\n    //   debugger;\n    // }\n    // eslint-disable-next-line no-restricted-syntax\n    for await (const chunk of reader) {\n      if (chunk instanceof Uint8Array) {\n        chunks.push(chunk);\n        bytesDownloaded += chunk.byteLength;\n        onProgress && onProgress(bytesDownloaded);\n      }\n    }\n    const result = uint8ArrayConcat(chunks);\n    return result;\n  } catch (error) {\n    console.error(\n      `Error reading stream/iterable.\\r\\n Probably Hot reload error!`,\n      error\n    );\n\n    return undefined;\n  }\n};\n","import { toString as uint8ArrayToAsciiString } from 'uint8arrays/to-string';\nimport isSvg from 'is-svg';\nimport { IPFSContentDetails, IPFSContentMaybe, IpfsContentType } from '../ipfs';\nimport { getResponseResult, onProgressCallback } from './stream';\n\n// TODO: fix to get working inside web worker, REFACTOR\n// import { PATTERN_HTTP, PATTERN_IPFS_HASH } from '../config';\nconst PATTERN_IPFS_HASH = /^Qm[a-zA-Z0-9]{44}$/g;\nconst PATTERN_HTTP = /^https:\\/\\/|^http:\\/\\//g;\n\nfunction createObjectURL(rawData: Uint8Array, type: string) {\n  const blob = new Blob([rawData], { type });\n  return URL.createObjectURL(blob);\n}\n\nfunction createImgData(rawData: Uint8Array, type: string) {\n  const imgBase64 = uint8ArrayToAsciiString(rawData, 'base64');\n  const file = `data:${type};base64,${imgBase64}`;\n  return file;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport const detectContentType = (\n  mime: string | undefined\n): IpfsContentType => {\n  if (mime) {\n    if (mime.includes('video')) {\n      return 'video';\n    }\n\n    if (mime.includes('audio')) {\n      return 'audio';\n    }\n  }\n  return 'other';\n};\n\nconst basic = /\\s?<!doctype html>|(<html\\b[^>]*>|<body\\b[^>]*>|<x-[^>]+>)+/i;\n\nfunction isHtml(string) {\n  const newString = string.trim().slice(0, 1000);\n  return basic.test(newString);\n}\n\nfunction shortenString(string: string, length = 300) {\n  return string.length > length ? `${string.slice(0, length)}...` : string;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport const chunksToBlob = (\n  chunks: Array<Uint8Array>,\n  mime: string | undefined\n) => new Blob(chunks, mime ? { type: mime } : {});\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport const parseArrayLikeToDetails = async (\n  content: IPFSContentMaybe,\n  // rawDataResponse: Uint8ArrayLike | undefined,\n  // mime: string | undefined,\n  cid: string,\n  onProgress?: onProgressCallback\n): Promise<IPFSContentDetails> => {\n  try {\n    // console.log('------parseArrayLikeToDetails', cid, content);\n    const mime = content?.meta?.mime;\n    const response: IPFSContentDetails = {\n      link: `/ipfs/${cid}`,\n      gateway: false,\n      cid,\n    };\n    const initialType = detectContentType(mime);\n    if (['video', 'audio'].indexOf(initialType) > -1) {\n      return { ...response, type: initialType, gateway: true };\n    }\n\n    const rawData = content?.result\n      ? await getResponseResult(content.result, onProgress)\n      : undefined;\n\n    // console.log(rawData);\n\n    if (!mime) {\n      response.text = `Can't detect MIME for ${cid.toString()}`;\n      response.gateway = true; // ???\n    } else if (\n      mime.indexOf('text/plain') !== -1 ||\n      mime.indexOf('application/xml') !== -1\n    ) {\n      if (isSvg(Buffer.from(rawData))) {\n        response.type = 'image';\n        response.content = createImgData(rawData, 'image/svg+xml'); // file\n      } else {\n        const dataBase64 = uint8ArrayToAsciiString(rawData);\n        // TODO: search can bel longer for 42???!\n        // also cover ipns links\n        response.link =\n          dataBase64.length > 42 ? `/ipfs/${cid}` : `/search/${dataBase64}`;\n\n        if (dataBase64.match(PATTERN_IPFS_HASH)) {\n          response.gateway = true;\n          response.type = 'other';\n          response.content = dataBase64;\n          response.link = `/ipfs/${cid}`;\n        } else if (dataBase64.match(PATTERN_HTTP)) {\n          response.type = 'link';\n          response.gateway = false;\n          response.content = dataBase64;\n          response.link = `/ipfs/${cid}`;\n        } else if (isHtml(dataBase64)) {\n          response.type = 'other';\n          response.gateway = true;\n          response.content = cid.toString();\n        } else {\n          response.type = 'text';\n          response.content = dataBase64;\n          response.text = shortenString(dataBase64);\n        }\n      }\n    } else if (mime.indexOf('image') !== -1) {\n      response.content = createImgData(rawData, mime); // file\n      response.type = 'image';\n      response.gateway = false;\n    } else if (mime.indexOf('application/pdf') !== -1) {\n      response.type = 'pdf';\n      response.content = createObjectURL(rawData, mime); // file\n      response.gateway = true; // ???\n    }\n\n    return response;\n  } catch (e) {\n    console.log('----parseRawIpfsData', e, cid);\n    return undefined;\n  }\n};\n\nexport const contentToUint8Array = async (\n  content: File | string\n): Promise<Uint8Array> => {\n  return new Uint8Array(\n    typeof content === 'string'\n      ? Buffer.from(content)\n      : await content.arrayBuffer()\n  );\n};\n\nexport const createTextPreview = (\n  array: Uint8Array | undefined,\n  mime?: string,\n  previewLength = 150\n) => {\n  return array && mime && mime === 'text/plain'\n    ? uint8ArrayToAsciiString(array).slice(0, previewLength)\n    : undefined;\n};\n","import Dexie from 'dexie';\n\nconst db = new Dexie('cyber-page-cash');\ndb.version(3).stores({\n  cid: 'cid',\n  following: 'cid',\n});\n\nexport default db;\n","import db from 'src/db';\n\nconst ipfsCacheDb = () => {\n  const add = async (cid: string, raw: Uint8Array): Promise<void> => {\n    const dbValue = await db.table('cid').get({ cid });\n\n    if (!dbValue) {\n      const ipfsContentAddtToInddexdDB = {\n        cid,\n        data: raw,\n      };\n      db.table('cid').add(ipfsContentAddtToInddexdDB);\n    }\n  };\n\n  const get = async (cid: string): Promise<Uint8Array | undefined> => {\n    // TODO: use cursor\n    const dbValue = await db.table('cid').get({ cid });\n\n    // backward compatibility\n    return dbValue?.data || dbValue?.content;\n  };\n\n  return { add, get };\n};\n\nexport default ipfsCacheDb();\n","import {\n  AddResponse,\n  PinResponse,\n} from '@nftstorage/ipfs-cluster/dist/src/interface';\n\nimport { Cluster } from '@nftstorage/ipfs-cluster';\nimport { IPFS_CLUSTER_URL } from '../config';\n\nconst cyberCluster = () => {\n  const cluster = new Cluster(IPFS_CLUSTER_URL);\n\n  const add = async (\n    file: File | string\n  ): Promise<AddResponse | PinResponse | undefined> => {\n    const dataFile =\n      typeof file === 'string' ? new File([file], 'file.txt') : file;\n    return cluster.add(dataFile, { cidVersion: 0, rawLeaves: false });\n  };\n\n  const status = async (cid: string) => cluster.status(cid);\n  return { add, status };\n};\n\nexport default cyberCluster();\n","/* eslint-disable import/no-unused-modules */\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\n\nimport { Option } from 'src/types';\nimport {\n  // getIpfsUserGatewanAndNodeType,\n  IPFSContentMaybe,\n  IPFSContentMeta,\n  CallBackFuncStatus,\n  IpfsContentSource,\n  IpfsNode,\n} from '../ipfs';\n\nimport { getMimeFromUint8Array, toAsyncIterableWithMime } from './stream';\n\nimport ipfsCacheDb from './ipfsCacheDb';\nimport cyberCluster from './cluster';\n\nimport { contentToUint8Array, createTextPreview } from './content';\n\nimport {\n  // CYBERNODE_SWARM_ADDR_WSS,\n  // CYBERNODE_SWARM_ADDR_TCP,\n  // CYBER_NODE_SWARM_PEER_ID,\n  CYBER_GATEWAY_URL,\n  FILE_SIZE_DOWNLOAD,\n} from '../config';\n\n// import { convertTimeToMilliseconds } from '../helpers';\n// import { CYBER } from '../config';\n\n// TODO: fix to get working inside web worker, REFACTOR\n\n// Get IPFS node from local storage\n// TODO: refactor\n// const getIpfsUserGatewanAndNode = (): getIpfsUserGatewanAndNodeType => {\n//   const LS_IPFS_STATE = localStorage.getItem('ipfsState');\n\n//   if (LS_IPFS_STATE !== null) {\n//     const lsTypeIpfsData = JSON.parse(LS_IPFS_STATE);\n//     if (lsTypeIpfsData?.userGateway) {\n//       const { userGateway, ipfsNodeType } = lsTypeIpfsData;\n//       return { userGateway, ipfsNodeType };\n//     }\n//   }\n\n//   return { ipfsNodeType: undefined, userGateway: undefined };\n// };\n\n// Get data by CID from local storage\nconst loadIPFSContentFromDb = async (\n  cid: string\n): Promise<IPFSContentMaybe> => {\n  // TODO: enable, disabled for tests\n\n  // TODO: use cursor\n  const data = await ipfsCacheDb.get(cid);\n  if (data && data.length) {\n    // TODO: use cursor\n    const mime = await getMimeFromUint8Array(data);\n    const textPreview = createTextPreview(data, mime);\n\n    const meta: IPFSContentMeta = {\n      type: 'file', // `TODO: ipfs refactor dir support ?\n      size: data.length,\n      sizeLocal: data.length,\n      mime,\n    };\n    return { result: data, cid, meta, source: 'db', textPreview };\n  }\n\n  return undefined;\n};\n\nconst emptyMeta: IPFSContentMeta = {\n  type: 'file',\n  size: undefined,\n  local: undefined,\n  sizeLocal: undefined,\n};\n\nconst fetchIPFSContentMeta = async (\n  cid: string,\n  node?: IpfsNode,\n  signal?: AbortSignal\n): Promise<IPFSContentMeta> => {\n  if (node) {\n    const meta = await node.stat(cid, { signal });\n    return meta;\n  }\n  return emptyMeta;\n};\n\nconst fetchIPFSContentFromNode = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController\n): Promise<IPFSContentMaybe> => {\n  const controllerLegacy = controller || new AbortController();\n  const { signal } = controllerLegacy;\n  let timer: NodeJS.Timeout | undefined;\n\n  if (!node) {\n    console.log('--------fetchIPFSContentFromNode NO NODE INTIALIZED--------');\n    return undefined;\n  }\n\n  if (!controller) {\n    timer = setTimeout(() => {\n      controllerLegacy.abort();\n    }, 1000 * 60 * 1);\n  } // 1 min\n\n  // TODO: cover ipns case\n  try {\n    // const stat = await node.files.stat(path, { signal });\n    const startTime = Date.now();\n    const meta = await fetchIPFSContentMeta(cid, node, signal);\n    const statsDoneTime = Date.now();\n    meta.statsTime = statsDoneTime - startTime;\n    const allowedSize = meta.size ? meta.size < FILE_SIZE_DOWNLOAD : false;\n    timer && clearTimeout(timer);\n\n    switch (meta.type) {\n      case 'directory': {\n        // TODO: return directory structure\n        return { cid, availableDownload: true, source: 'node', meta };\n      }\n      default: {\n        // Get sample of content\n        const { value: firstChunk, done } = await node\n          .cat(cid, { signal, length: 2048, offset: 0 })\n          [Symbol.asyncIterator]()\n          .next();\n\n        const mime = await getMimeFromUint8Array(firstChunk);\n        const fullyDownloaded =\n          meta.size && meta.size > -1 && firstChunk.length >= meta.size;\n\n        const textPreview = createTextPreview(firstChunk, mime);\n\n        if (fullyDownloaded) {\n          await ipfsCacheDb.add(cid, uint8ArrayConcat(firstChunk));\n        }\n\n        // If all content fits in first chunk return byte-array instead iterable\n        const stream = fullyDownloaded\n          ? firstChunk\n          : allowedSize\n          ? node.cat(cid, { signal })\n          : undefined;\n\n        meta.catTime = Date.now() - statsDoneTime;\n\n        // TODO: add to db flag that content is pinned TO local node\n        // if already pinned skip pin\n        if (!meta.local && allowedSize) {\n          node.pin(cid);\n\n          meta.pinTime = Date.now() - meta.catTime;\n        } else {\n          meta.pinTime = -1;\n        }\n\n        return {\n          result: stream,\n          textPreview,\n          cid,\n          meta: { ...meta, mime },\n          source: 'node',\n        };\n        // }\n      }\n    }\n  } catch (error) {\n    console.debug('error fetchIPFSContentFromNode', error);\n    return { cid, availableDownload: true, source: 'node', meta: emptyMeta };\n  }\n};\n\nconst fetchIPFSContentFromGateway = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController\n): Promise<IPFSContentMaybe> => {\n  // TODO: Should we use Cyber Gateway?\n  // const { userGateway } = getIpfsUserGatewanAndNode();\n\n  // fetch META only from external node(toooo slow), TODO: fetch meta from cybernode\n  const isExternalNode = node?.nodeType === 'external';\n  const meta = isExternalNode\n    ? await fetchIPFSContentMeta(cid, node, controller?.signal)\n    : emptyMeta;\n\n  const contentUrl = `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n  const response = await fetch(contentUrl, {\n    method: 'GET',\n    signal: controller?.signal,\n  });\n\n  if (response && response.body) {\n    // fetch doesn't provide any headers in our case :(\n\n    // const contentLength = parseInt(\n    //   response.headers['content-length'] || '-1',\n    //   10\n    // );\n    // const contentType = response.headers['content-type'];\n\n    // Extract meta if ipfs prob/node not started yet\n    // if (!meta.mime) {\n    //   meta = { ...meta, mime: contentType };\n    // }\n\n    // TODO: fix\n    const flushResults = (chunks: Uint8Array[]) =>\n      !isExternalNode\n        ? ipfsCacheDb.add(cid, uint8ArrayConcat(chunks))\n        : Promise.resolve();\n\n    const { mime, result, firstChunk } = await toAsyncIterableWithMime(\n      response.body,\n      flushResults\n    );\n\n    const textPreview = createTextPreview(firstChunk, mime);\n    return {\n      cid,\n      textPreview,\n      meta: { ...meta, mime },\n      result,\n      source: 'gateway',\n      contentUrl,\n    };\n  }\n\n  return undefined;\n};\n\ntype fetchContentOptions = {\n  controller?: AbortController;\n  node?: IpfsNode;\n};\n\nasync function fetchIpfsContent(\n  cid: string,\n  source: IpfsContentSource,\n  options: fetchContentOptions\n): Promise<IPFSContentMaybe> {\n  const { node, controller } = options;\n\n  try {\n    switch (source) {\n      case 'db':\n        return loadIPFSContentFromDb(cid);\n      case 'node':\n        return fetchIPFSContentFromNode(cid, node, controller);\n      case 'gateway':\n        return fetchIPFSContentFromGateway(cid, node, controller);\n      default:\n        return undefined;\n    }\n  } catch (e) {\n    console.log('----fetchIpfsContent error', e);\n    return undefined;\n  }\n}\n\nconst getIPFSContent = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController,\n  callBackFuncStatus?: CallBackFuncStatus\n): Promise<IPFSContentMaybe> => {\n  const dataRsponseDb = await loadIPFSContentFromDb(cid);\n  if (dataRsponseDb !== undefined) {\n    return dataRsponseDb;\n  }\n\n  if (node) {\n    callBackFuncStatus && callBackFuncStatus('trying to get with a node');\n    // console.log('----Fetch from node', cid);\n    const ipfsContent = await fetchIPFSContentFromNode(cid, node, controller);\n\n    return ipfsContent;\n  }\n\n  callBackFuncStatus && callBackFuncStatus('trying to get with a gatway');\n  // console.log('----Fetch from gateway', cid);\n  const respnseGateway = await fetchIPFSContentFromGateway(\n    cid,\n    node,\n    controller\n  );\n\n  return respnseGateway;\n};\n\nconst catIPFSContentFromNode = (\n  cid: string,\n  node?: IpfsNode,\n  offset?: number,\n  controller?: AbortController\n): AsyncIterable<Uint8Array> | undefined => {\n  if (!node) {\n    console.log(\n      '--------fetchIPFSContentFromNode NO NODE INTIALIZED TODO: cover case--------'\n    );\n    return undefined;\n  }\n\n  // TODO: cover ipns case\n\n  return node.cat(cid, { offset, signal: controller?.signal });\n};\n\n// const nodeContentFindProvs = async (\n//   node: AppIPFS,\n//   cid: string,\n//   offset: number,\n//   controller?: AbortController\n// ): AsyncIterable<number> | undefined => {\n//   if (!node) {\n//     console.log(\n//       '--------fetchIPFSContentFromNode NO NODE INTIALIZED TODO: cover case--------'\n//     );\n//     return undefined;\n//   }\n\n//   // TODO: cover ipns case\n//   const path = `/ipfs/${cid}`;\n\n//   const providers = node.dht.findProvs(path, {\n//     signal: controller?.signal,\n//   });\n\n//   let count = 0;\n//   for await (const provider of providers) {\n//     //  console.log(provider.id.toString())\n//     //  id: PeerId\n//     // multiaddrs: Multiaddr[]\n//     // protocols: string[]\n//     count++;\n//   }\n\n//   return count;\n// };\n\nconst addContenToIpfs = async (\n  node: IpfsNode,\n  content: File | string\n): Promise<Option<string>> => {\n  let cid;\n  if (node) {\n    cid = await node.add(content);\n  }\n  // TODO: TMP solution make cluster call non-awaitable\n  cyberCluster.add(content);\n  // const pinResponse = await cyberCluster.add(content);\n  // cid = cid || pinResponse?.cid;\n\n  cid && (await ipfsCacheDb.add(cid, await contentToUint8Array(content)));\n  return cid;\n};\n\n// '/dns4/swarm.io.cybernode.ai/tcp/4001/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB';\n\n// const connectToSwarm = async (node, address) => {\n//   const multiaddrSwarm = multiaddr(address);\n//   // console.log(`Connecting to swarm ${address}`, node);\n//   if (node.nodeType === 'helia') {\n//     // node.libp2p.bootstrap.add(multiaddrSwarm);\n//     node.libp2p.dial(multiaddrSwarm);\n//     return;\n//   }\n\n//   await node.bootstrap.add(multiaddrSwarm);\n\n//   node?.swarm\n//     .connect(multiaddrSwarm)\n//     .then((resp) => {\n//       console.log(`Welcome to swarm ${address} `);\n//       // node.swarm.peers().then((peers) => console.log('---peeers', peers));\n//     })\n//     .catch((err) => {\n//       console.log(\n//         'Error object properties:',\n//         Object.getOwnPropertyNames(err),\n//         err.stack,\n//         err.errors,\n//         err.message\n//       );\n//       console.log(`Can't connect to swarm ${address}: ${err.message}`);\n//     });\n// };\n\n// const connectToCyberSwarm = async (node: AppIPFS) => {\n//   const cyberNodeAddr =\n//     node.nodeType === 'embedded'\n//       ? CYBERNODE_SWARM_ADDR_WSS\n//       : CYBERNODE_SWARM_ADDR_TCP;\n//   await connectToSwarm(node, cyberNodeAddr);\n// };\n\n// const reconnectToCyberSwarm = async (node?: IpfsNode, lastCallTime: 0) => {\n//   if (!node) {\n//     return;\n//   }\n//   const isHelia = node.nodeType === 'helia';\n//   const cyberNodeAddr =\n//     node.nodeType !== 'external'\n//       ? CYBERNODE_SWARM_ADDR_WSS\n//       : CYBERNODE_SWARM_ADDR_TCP;\n\n//   const isSwarmConnected = isHelia\n//     ? node!.libp2p\n//         .getConnections()\n//         .find((c) => c.remotePeer.toString() === CYBER_NODE_SWARM_PEER_ID)\n//     : (await node!.swarm.peers()).find(\n//         (p) => p.peer.toString() === CYBER_NODE_SWARM_PEER_ID\n//       );\n\n//   // console.log('autoDialTime', await getNodeAutoDialInterval(node));\n//   // console.log('lastCallTime', lastCallTime, Date.now() - lastCallTime);\n\n//   // console.log('---isConnected', true, peers.length);\n\n//   if (!isSwarmConnected) {\n//     // TODO: refactor using timeout for node\n//     const needToReconnect =\n//       Date.now() - lastCallTime < (node.connMgrGracePeriod || 20);\n//     if (needToReconnect) {\n//       await connectToSwarm(node, cyberNodeAddr);\n//     }\n//   }\n// };\n\n// const DEFAULT_AUTO_DIAL_INTERVAL = 10000;\n// const GET_CONFIG_TIMEOUT = 3000;\n// TODO: REFACTOR\n// const getNodeAutoDialInterval = async (node: IpfsNode) => {\n//   try {\n//     const autoDialTime = convertTimeToMilliseconds(\n//       ((await node.config.get('Swarm.ConnMgr.GracePeriod', {\n//         timeout: GET_CONFIG_TIMEOUT,\n//       })) as string) || DEFAULT_AUTO_DIAL_INTERVAL\n//     );\n\n//     return autoDialTime;\n//   } catch {\n//     return DEFAULT_AUTO_DIAL_INTERVAL;\n//   }\n// };\n\n// const getIpfsGatewayUrl = async (node: IpfsNode, cid: string) => {\n//   if (node.nodeType !== 'external') {\n//     return `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n//   }\n\n//   const response = await node.config.get('Addresses.Gateway');\n//   const address = multiaddr(response).nodeAddress();\n\n//   try {\n//     return `http://${address.address}:${address.port}/ipfs/${cid}`;\n//   } catch (error) {\n//     return `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n//   }\n// };\n\nexport {\n  getIPFSContent,\n  catIPFSContentFromNode,\n  fetchIpfsContent,\n  addContenToIpfs,\n  // reconnectToCyberSwarm,\n  // getIpfsGatewayUrl,\n  // getNodeAutoDialInterval,\n};\n","// import { getNodeAutoDialInterval } from './utils-ipfs';\nimport { IpfsNodeType, IpfsNode, CybIpfsNode, IpfsOptsType } from '../ipfs';\nimport KuboNode from './impl/kubo';\nimport HeliaNode from './impl/helia';\nimport JsIpfsNode from './impl/js-ipfs';\n// import EnhancedIpfsNode from './node/enhancedNode';\nimport {\n  CYBERNODE_SWARM_ADDR_TCP,\n  CYBERNODE_SWARM_ADDR_WSS,\n  CYBER_NODE_SWARM_PEER_ID,\n} from '../config';\nimport { withCybFeatures } from './mixins/withCybFeatures';\n\nconst nodeClassMap: Record<IpfsNodeType, new () => IpfsNode> = {\n  helia: HeliaNode,\n  embedded: JsIpfsNode,\n  external: KuboNode,\n};\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport async function initIpfsNode(\n  options: IpfsOptsType\n): Promise<CybIpfsNode> {\n  const { ipfsNodeType, ...restOptions } = options;\n\n  const swarmPeerId = CYBER_NODE_SWARM_PEER_ID;\n\n  const swarmPeerAddress =\n    ipfsNodeType === 'external'\n      ? CYBERNODE_SWARM_ADDR_TCP\n      : CYBERNODE_SWARM_ADDR_WSS;\n\n  const EnhancedClass = withCybFeatures(nodeClassMap[ipfsNodeType], {\n    swarmPeerId,\n    swarmPeerAddress,\n  });\n\n  const instance = new EnhancedClass();\n\n  await instance.init({ url: restOptions.urlOpts });\n  // TODO: REFACT\n  //   instance.connMgrGracePeriod = await getNodeAutoDialInterval(instance);\n  // window.ipfs = instance;\n\n  console.log('----init', ipfsNodeType);\n\n  await instance.reconnectToSwarm();\n  return instance;\n}\n","import { IpfsNode, CybIpfsNode, IpfsContentType } from '../../ipfs';\nimport { parseArrayLikeToDetails } from '../../utils/content';\nimport { addContenToIpfs, getIPFSContent } from '../../utils/utils-ipfs';\n\ntype WithCybFeaturesOptions = {\n  swarmPeerId: string;\n  swarmPeerAddress: string;\n};\n\nfunction withCybFeatures<TBase extends new (...args: any[]) => IpfsNode>(\n  Base: TBase,\n  options: WithCybFeaturesOptions\n) {\n  return class CybIpfsNodeMixin extends Base implements CybIpfsNode {\n    async fetchWithDetails(cid: string, parseAs?: IpfsContentType) {\n      const response = await getIPFSContent(cid, this);\n      const details = await parseArrayLikeToDetails(response, cid);\n\n      return !parseAs\n        ? details\n        : details?.type === parseAs\n        ? details\n        : undefined;\n    }\n\n    async addContent(content: File | string) {\n      return addContenToIpfs(this, content);\n    }\n\n    async isConnectedToSwarm() {\n      return !!(await super.getPeers()).find(\n        (peerId) => peerId === options.swarmPeerId\n      );\n    }\n\n    async reconnectToSwarm(lastConnectedTimestamp?: number) {\n      if (!(await this.isConnectedToSwarm())) {\n        // TODO: refactor using timeout for node config\n\n        //   const needToReconnect =\n        //     Date.now() - lastConnectedTimestamp <\n        //     DEFAULT_CONNECTION_LIFETIME_SECONDS;\n        super\n          .connectPeer(options.swarmPeerAddress)\n          .then(() => {\n            console.log(` connected to swarm - ${options.swarmPeerAddress}`);\n            return true;\n          })\n          .catch((err) => {\n            console.log(\n              `Can't connect to swarm ${options.swarmPeerAddress}: ${err.message}`\n            );\n            return false;\n          });\n      }\n    }\n  };\n}\n\nexport { withCybFeatures };\n","import { IQueueStrategy, QueueSettings, QueueSource } from './types';\n\nexport class QueueStrategy implements IQueueStrategy {\n  settings: QueueSettings;\n\n  order: QueueSource[];\n\n  constructor(settings: QueueSettings, order: QueueSource[]) {\n    this.settings = settings;\n    this.order = order;\n  }\n\n  getNextSource(source: QueueSource): QueueSource | undefined {\n    const index = this.order.indexOf(source);\n    return index < this.order.length ? this.order[index + 1] : undefined;\n  }\n}\n","export class QueueItemTimeoutError extends Error {\n  constructor(timeoutMs: number) {\n    super(`Timeout after ${timeoutMs}`);\n    Object.setPrototypeOf(this, QueueItemTimeoutError.prototype);\n  }\n}\n","export function isParticle(value: string) {\n  // copied from src/utils/config.ts , to prevent crash in worker, need refactor\n  // import { PATTERN_IPFS_HASH } from 'src/utils/config';\n  return Boolean(value.match(/^Qm[a-zA-Z0-9]{44}$/g));\n}\n","import { PinType } from 'ipfs-core-types/src/pin';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { Transaction } from 'src/services/backend/services/indexer/types';\nimport {\n  SenseChatExtension,\n  SenseLinkMeta,\n  SenseListItemtMeta,\n  SenseTransactionMeta,\n} from 'src/services/backend/types/sense';\nimport { IpfsContentType } from 'src/services/ipfs/ipfs';\nimport { NeuronAddress, ParticleCid, TransactionHash } from 'src/types/base';\nimport { DtoToEntity } from 'src/types/dto';\n\ntype PinEntryType = Exclude<PinType, 'all'>;\n// example of db optimization for classifiers\n\nexport const PinTypeMap: Record<PinEntryType, number> = {\n  indirect: -1,\n  direct: 0,\n  recursive: 1,\n};\n\nexport enum EntryType {\n  transactions = 1,\n  particle = 2,\n  chat = 3,\n}\n\n// Transaction if formed by frontend\n// Should be replaced after sync\n\nexport type PinDbEntity = {\n  cid: string;\n  type: keyof typeof PinTypeMap;\n};\n\nexport type TransactionDbEntity = {\n  hash: string;\n  index: number;\n  type: string;\n  timestamp: number;\n  block_height: number;\n  value: Transaction['value'];\n  success: boolean;\n  memo: string;\n  neuron: NeuronAddress;\n};\n\ntype SyncItemMeta = DtoToEntity<\n  (SenseLinkMeta | SenseTransactionMeta) & SenseChatExtension\n>;\n\nexport type SyncStatusDbEntity = {\n  entry_type: EntryType;\n  id: NeuronAddress | ParticleCid;\n  owner_id: NeuronAddress;\n  timestamp_update: number;\n  timestamp_read: number;\n  disabled: boolean;\n  unread_count: number;\n  meta: SyncItemMeta;\n};\n\nexport type ParticleDbEntity = {\n  id: ParticleCid;\n  size: number;\n  size_local: number;\n  blocks: number;\n  mime: string;\n  type: IpfsContentType;\n  text: string;\n};\n\nexport type LinkDbEntity = {\n  from: ParticleCid;\n  to: ParticleCid;\n  neuron: NeuronAddress;\n  timestamp: number;\n  transaction_hash: string;\n};\n\nexport type ConfigDbEntity = {\n  key: string;\n  group_key: string;\n  value: NonNullable<unknown>;\n};\n\nexport enum SyncQueueStatus {\n  pending = 0,\n  executing = 1,\n  done = 2,\n  error = -1,\n}\n\nexport type SyncQueueDbEntity = {\n  id: string;\n  status: SyncQueueStatus;\n  priority: QueuePriority | number;\n};\n\nexport type CommunityDbEntity = {\n  ownerId: NeuronAddress;\n  particle: ParticleCid;\n  neuron: NeuronAddress;\n  name: string;\n  following: boolean;\n  follower: boolean;\n};\n\nexport type DbEntity =\n  | TransactionDbEntity\n  | ParticleDbEntity\n  | SyncStatusDbEntity\n  | ConfigDbEntity\n  | SyncQueueDbEntity;\n","import {\n  createAsyncThunk,\n  createSelector,\n  createSlice,\n  PayloadAction,\n} from '@reduxjs/toolkit';\nimport { SenseApi } from 'src/contexts/backend/services/senseApi';\nimport {\n  SenseItemLinkMeta,\n  SenseListItem,\n  SenseListItemTransactionMeta,\n  SenseUnread,\n} from 'src/services/backend/types/sense';\nimport { isParticle } from '../../particle/utils';\nimport { SenseItemId } from '../types/sense';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport {\n  MsgMultiSendValue,\n  MsgSendValue,\n} from 'src/services/backend/services/indexer/types';\nimport { RootState } from 'src/redux/store';\n\n// similar to blockchain/tx/message type\nexport type SenseItem = {\n  id: SenseItemId;\n  transactionHash: string;\n\n  // add normal type\n  type: string;\n\n  meta: SenseListItem['meta'];\n  timestamp: string;\n  memo: string | undefined;\n  from: string;\n\n  // for optimistic update\n  status?: 'pending' | 'error';\n  fromLog?: boolean;\n};\n\ntype Chat = {\n  id: SenseItemId;\n  isLoading: boolean;\n  error: string | undefined;\n  data: SenseItem[];\n  unreadCount: number;\n};\n\ntype SliceState = {\n  list: {\n    isLoading: boolean;\n    data: string[];\n    error: string | undefined;\n  };\n  chats: {\n    [key in SenseItemId]?: Chat;\n  };\n  summary: {\n    unreadCount: {\n      total: number;\n      particles: number;\n      neurons: number;\n    };\n  };\n};\n\nconst initialState: SliceState = {\n  list: {\n    isLoading: false,\n    data: [],\n    error: undefined,\n  },\n  chats: {},\n  summary: {\n    unreadCount: {\n      total: 0,\n      particles: 0,\n      neurons: 0,\n    },\n  },\n};\n\nfunction formatApiData(item: SenseListItem): SenseItem {\n  if (item.entryType === EntryType.chat && item.meta.to) {\n    item.entryType = EntryType.particle;\n  }\n\n  const { meta } = item;\n\n  const formatted: SenseItem = {\n    timestamp: new Date(meta.timestamp).toISOString(),\n\n    // lol\n    transactionHash:\n      item.transactionHash ||\n      item.hash ||\n      item.meta.transaction_hash ||\n      item.meta.hash ||\n      item.meta.transactionHash,\n\n    memo: item.memo || meta.memo,\n\n    senseChatId: item.id,\n    // not good\n    unreadCount: item.unreadCount || 0,\n  };\n\n  switch (item.entryType) {\n    case EntryType.chat:\n    case EntryType.transactions: {\n      const meta = item.meta as SenseListItemTransactionMeta;\n      const { type } = meta;\n\n      let from = item.ownerId;\n\n      if (type === 'cosmos.bank.v1beta1.MsgSend') {\n        const value = meta.value as MsgSendValue;\n        from = value.fromAddress;\n      } else if (type === 'cosmos.bank.v1beta1.MsgMultiSend') {\n        const value = meta.value as MsgMultiSendValue;\n\n        from = value.inputs[0].address;\n      }\n\n      Object.assign(formatted, {\n        type,\n        from,\n        meta: item.meta.value,\n      });\n\n      break;\n    }\n\n    case EntryType.particle: {\n      const meta = item.meta as SenseItemLinkMeta;\n\n      Object.assign(formatted, {\n        type: 'cyber.graph.v1beta1.MsgCyberlink',\n        from: meta.neuron,\n        meta: meta,\n        fromLog: true,\n      });\n\n      break;\n    }\n\n    default:\n      // sholdn't be\n      debugger;\n      return {};\n  }\n\n  return formatted;\n}\n\nconst getSenseList = createAsyncThunk(\n  'sense/getSenseList',\n  async (senseApi: SenseApi) => {\n    const data = await senseApi!.getList();\n    return data.map(formatApiData);\n  }\n);\n\nconst getSenseChat = createAsyncThunk(\n  'sense/getSenseChat',\n  async ({ id, senseApi }: { id: SenseItemId; senseApi: SenseApi }) => {\n    const particle = isParticle(id);\n\n    if (particle) {\n      const links = await senseApi!.getLinks(id);\n      const formattedLinks = links.map((item) => {\n        if (item.timestamp === 0) {\n          // FIXME:\n          return;\n        }\n        return formatApiData({\n          ...item,\n          id,\n          entryType: EntryType.particle,\n          meta: item,\n        });\n      });\n\n      return formattedLinks.filter(Boolean);\n    }\n\n    const data = await senseApi!.getFriendItems(id);\n    const formattedData = data.map((item) => {\n      const entryType = item.to ? EntryType.particle : EntryType.chat;\n      return formatApiData({\n        ...item,\n        entryType,\n        id,\n        meta: item,\n      });\n    });\n\n    return formattedData;\n  }\n);\n\nconst markAsRead = createAsyncThunk(\n  'sense/markAsRead',\n  async ({ id, senseApi }: { id: SenseItemId; senseApi: SenseApi }) => {\n    return senseApi!.markAsRead(id);\n  }\n);\n\nconst newChatStructure: Chat = {\n  id: '',\n  isLoading: false,\n  data: [],\n  error: undefined,\n  unreadCount: 0,\n};\n\nfunction checkIfMessageExists(chat: Chat, newMessage: SenseItem) {\n  const lastMessages = chat.data.slice(-5);\n\n  const isMessageExists = lastMessages.some((msg) => {\n    return msg.transactionHash === newMessage.transactionHash;\n  });\n\n  return isMessageExists;\n}\n\nconst slice = createSlice({\n  name: 'sense',\n  initialState,\n  reducers: {\n    // backend may push this action\n    updateSenseList: {\n      reducer: (state, action: PayloadAction<SenseItem[]>) => {\n        const data = action.payload;\n\n        data.forEach((message) => {\n          const { senseChatId: id } = message;\n\n          if (!state.chats[id]) {\n            state.chats[id] = { ...newChatStructure };\n          }\n\n          const chat = state.chats[id]!;\n\n          Object.assign(chat, {\n            id,\n            // fix ts\n            unreadCount: message.unreadCount || 0,\n          });\n\n          if (!checkIfMessageExists(chat, message)) {\n            chat.data = chat.data.concat(message);\n          }\n        });\n\n        slice.caseReducers.orderSenseList(state);\n      },\n      prepare: (data: SenseListItem[]) => {\n        return {\n          payload: data.map(formatApiData),\n        };\n      },\n    },\n    // optimistic update\n    addSenseItem(\n      state,\n      action: PayloadAction<{ id: SenseItemId; item: SenseItem }>\n    ) {\n      const { id, item } = action.payload;\n      const chat = state.chats[id]!;\n\n      chat.data.push({\n        ...item,\n        meta: item.meta,\n        status: 'pending',\n      });\n\n      const newList = state.list.data.filter((item) => item !== id);\n      newList.unshift(id);\n      state.list.data = newList;\n    },\n    // optimistic confirm/error\n    updateSenseItem(\n      state,\n      action: PayloadAction<{\n        chatId: SenseItemId;\n        txHash: string;\n        isSuccess: boolean;\n      }>\n    ) {\n      const { chatId, txHash, isSuccess } = action.payload;\n      const chat = state.chats[chatId]!;\n\n      const item = chat.data.find((item) => item.transactionHash === txHash);\n\n      if (item) {\n        if (isSuccess) {\n          delete item.status;\n        } else {\n          item.status = 'error';\n        }\n      }\n    },\n    orderSenseList(state) {\n      const chatsLastMessage = Object.keys(state.chats).reduce<\n        {\n          id: string;\n          lastMsg: SenseItem;\n        }[]\n      >((acc, id) => {\n        const chat = state.chats[id]!;\n\n        // may be loading this moment, no data\n        if (!chat.data.length) {\n          return acc;\n        }\n\n        const lastMsg = chat.data[chat.data.length - 1];\n        acc.push({ id, lastMsg });\n\n        return acc;\n      }, []);\n\n      const sorted = chatsLastMessage.sort((a, b) => {\n        return (\n          Date.parse(b.lastMsg.timestamp) - Date.parse(a.lastMsg.timestamp)\n        );\n      });\n\n      state.list.data = sorted.map((i) => i.id);\n    },\n    reset() {\n      return initialState;\n    },\n  },\n\n  extraReducers: (builder) => {\n    builder.addCase(getSenseList.pending, (state) => {\n      state.list.isLoading = true;\n    });\n\n    builder.addCase(getSenseList.fulfilled, (state, action) => {\n      state.list.isLoading = false;\n\n      const newList: SliceState['list']['data'] = [];\n\n      action.payload.forEach((message) => {\n        const { senseChatId: id } = message;\n\n        if (!state.chats[id]) {\n          state.chats[id] = { ...newChatStructure };\n        }\n\n        const chat = state.chats[id]!;\n\n        Object.assign(chat, {\n          id,\n          // fix\n          unreadCount: message.unreadCount || 0,\n        });\n\n        if (!checkIfMessageExists(chat, message)) {\n          chat.data = chat.data.concat(message);\n        }\n\n        newList.push(id);\n      });\n\n      state.list.data = newList;\n    });\n    builder.addCase(getSenseList.rejected, (state, action) => {\n      console.error(action);\n\n      state.list.isLoading = false;\n      state.list.error = action.error.message;\n    });\n\n    builder.addCase(getSenseChat.pending, (state, action) => {\n      const { id } = action.meta.arg;\n\n      if (!state.chats[id]) {\n        state.chats[id] = { ...newChatStructure };\n      }\n\n      // don't understand why ts warning\n      state.chats[id].isLoading = true;\n    });\n\n    builder.addCase(getSenseChat.fulfilled, (state, action) => {\n      const { id } = action.meta.arg;\n      const chat = state.chats[id]!;\n      chat.isLoading = false;\n\n      chat.id = id;\n\n      chat.data = action.payload;\n    });\n    builder.addCase(getSenseChat.rejected, (state, action) => {\n      console.error(action);\n\n      const chat = state.chats[action.meta.arg.id]!;\n      chat.isLoading = false;\n      chat.error = action.error.message;\n    });\n\n    // maybe add .pending, .rejected\n    // can be optimistic\n    builder.addCase(markAsRead.fulfilled, (state, action) => {\n      const { id } = action.meta.arg;\n      const chat = state.chats[id]!;\n\n      const particle = isParticle(id);\n\n      const { unreadCount } = chat;\n\n      state.summary.unreadCount.total -= unreadCount;\n      if (particle) {\n        state.summary.unreadCount.particles -= unreadCount;\n      } else {\n        state.summary.unreadCount.neurons -= unreadCount;\n      }\n\n      chat.unreadCount = 0;\n    });\n  },\n});\n\nconst selectUnreadCounts = createSelector(\n  (state: RootState) => state.sense.chats,\n  (chats) => {\n    let unreadCountParticle = 0;\n    let unreadCountNeuron = 0;\n\n    Object.values(chats).forEach(({ id, unreadCount }) => {\n      const particle = isParticle(id);\n\n      if (particle) {\n        unreadCountParticle += unreadCount;\n      } else {\n        unreadCountNeuron += unreadCount;\n      }\n    });\n\n    const total = unreadCountParticle + unreadCountNeuron;\n\n    return {\n      total,\n      particles: unreadCountParticle,\n      neurons: unreadCountNeuron,\n    };\n  }\n);\n\nexport const { addSenseItem, updateSenseItem, updateSenseList, reset } =\n  slice.actions;\n\nexport { getSenseList, getSenseChat, markAsRead };\n\n// selectors\nexport { selectUnreadCounts };\n\nexport default slice.reducer;\n","export const localStorageKeys = {\n  pocket: {\n    POCKET: 'pocket',\n    POCKET_ACCOUNT: 'pocketAccount',\n  },\n  MENU_SHOW: 'menuShow',\n};\n","export const enum Networks {\n  BOSTROM = 'bostrom',\n  SPACE_PUSSY = 'space-pussy',\n  ETH = 'eth',\n  OSMO = 'osmo',\n  TERRA = 'terra',\n  COSMOS = 'cosmoshub-4',\n}\n\nexport type NetworkConfig = {\n  CHAIN_ID: Networks;\n  DENOM_CYBER: string;\n  DENOM_LIQUID_TOKEN: string;\n  DENOM_CYBER_G: string;\n  CYBER_NODE_URL_API: string;\n  CYBER_WEBSOCKET_URL: string;\n  CYBER_NODE_URL_LCD: string;\n  CYBER_INDEX_HTTPS: string;\n  CYBER_INDEX_WEBSOCKET: string;\n  BECH32_PREFIX_ACC_ADDR_CYBER: string;\n  BECH32_PREFIX_ACC_ADDR_CYBERVALOPER: string;\n  MEMO_KEPLR: string;\n};\n\nexport type NetworksList = {\n  [key in Networks]: NetworkConfig;\n};\n","import { Networks } from '../types/networks';\n\nconst TIME_START = '2022-10-03T19:32:28Z';\nconst INFINITY = '';\nconst WP =\n  'https://ipfs.io/ipfs/QmQ1Vong13MDNxixDyUdjniqqEj8sjuNEBYMyhQU4gQgq3';\nconst AUCTION = {\n  ADDR_SMART_CONTRACT: '0x0b1f54be915e77d9bf14268f94f8a26afab11296',\n  ADDR_VESTING: '0xd84469ecd96825c956d7ae8b072209ca89ae37e2',\n  ADDR_EVANGELISM: '0xfc3849b9711f69ddb677facff0cd6755a981a1f0',\n  TOKEN_NAME: 'GOL',\n  ADDR_TOKEN: '0xF4ecdBa8ba4144Ff3a2d8792Cad9051431Aa4F64',\n  TOPICS_SEND:\n    '0x3b599f6217e39be59216b60e543ce0d4c7d534fe64dd9d962334924e7819894e',\n  TOPICS_CLAIM:\n    '0x3ed1528b0fdc7c5207c1bf935e34a667e13656b9ed165260c522be0bc544f303',\n  TOPICS_VESTING:\n    '0x552f182d4b9ab267a8580e2aa80cf374b7aabc8f528b7e9eea58919eea48e87d',\n  HTTP_PROVIDER_URL: 'https://rpc.ethereum.cybernode.ai/',\n  // 'https://mainnet.infura.io/v3/b80bdc43536c4f0c97b8c0afd2a7d75d',\n  ROUND_DURATION: 1000 * 60 * 60 * 23 + 1,\n  TOKEN_ALOCATION: 15 * 10 ** 3,\n};\n\nconst HUB_CONTRACTS = {\n  TOKENS: 'bostrom15phze6xnvfnpuvvgs2tw58xnnuf872wlz72sv0j2yauh6zwm7cmqqpmc42',\n  NETWORKS:\n    'bostrom1lpn69a74ftv04upfej8f9ay56pe2zyk48vzlk49kp3grysc7u56qq363nr',\n  CHANNELS:\n    'bostrom15tx5z779rdks07sg774ufn8q0a9x993c9uwmr6ycec78z6lfrmkqyjnfge',\n  PROTOCOLS:\n    'bostrom12yqsxh82qy3dz6alnmjhupyk85skgeqznzxv92q99hqtyu7vvdsqgwjgv',\n};\n\nconst ADD_ARAGON_FINANCE = '0xa0a55e68dc52b47f8a9d5d05329fab5bdabffb14';\n\nconst NETWORKSIDS = {\n  main: 1,\n  rinkeby: 4,\n  kovan: 42,\n  TestNet: 5777,\n};\n\nconst TAKEOFF = {\n  ATOMsALL: 300000,\n  CYBWON_A: 0.000740464,\n  CYBWON_B: -666.418,\n  CYBWON_C: 2.3328 * 10 ** 8,\n  CYBWON_D: 0.000343014,\n  GETSHARES_A: -1.856 * 10 ** -3,\n  GETSHARES_B: 2.355 * 10 ** -5,\n  GETSHARES_C: 6.66 * 10 ** -11,\n  GETSHARES_D: 7.332 * 10 ** -17,\n  DISCOUNT_TG: -0.00005,\n  DISCOUNT_TILT_ANGLE: 30,\n  DISCOUNT: 0.3,\n  SQRT_5: 2.23606797749979,\n  BLOCK_START: 2000000,\n  FINISH_PRICE: 1.485,\n  FINISH_AMOUNT: 15088.40963,\n  FINISH_ESTIMATION: 12141.224,\n};\n\nconst COSMOS = {\n  ADDR_FUNDING: 'cosmos1latzme6xf6s8tsrymuu6laf2ks2humqv2tkd9a',\n  TIME_START: 'April 27 2020 21:50:00 GMT +3',\n  TIME_END: 'November 31 2020 24:00:00 GMT +3',\n  CHAIN_ID: 'cosmoshub-4',\n  DEFAULT_GAS: 200000,\n  DEFAULT_GAS_PRICE: 0.01,\n  GAIA_NODE_URL_LSD: 'https://lcd.cosmoshub-4.cybernode.ai',\n  GAIA_WEBSOCKET_URL: 'wss://io.cybernode.ai/gaia_websocket',\n  DENOM_COSMOS: 'uatom',\n  DIVISOR_ATOM: 10 ** 6,\n  BECH32_PREFIX_ACC_ADDR_COSMOS: 'cosmos',\n};\n\nconst LOCALSTORAGE_CHAIN_ID = Networks.BOSTROM;\n\nlet CHAIN_PARAMS = {\n  CHAIN_ID: process.env.CHAIN_ID || Networks.BOSTROM,\n  DENOM_CYBER: 'boot',\n  DENOM_LIQUID_TOKEN: 'hydrogen',\n  DENOM_CYBER_G: `GBOOT`,\n  CYBER_NODE_URL_API:\n    process.env.CYBER_NODE_URL_API || 'https://rpc.bostrom.cybernode.ai',\n  CYBER_WEBSOCKET_URL:\n    process.env.CYBER_WEBSOCKET_URL ||\n    'wss://rpc.bostrom.cybernode.ai/websocket',\n  CYBER_NODE_URL_LCD:\n    process.env.CYBER_NODE_URL_LCD || 'https://lcd.bostrom.cybernode.ai',\n  CYBER_INDEX_HTTPS:\n    process.env.CYBER_INDEX_HTTPS ||\n    'https://index.bostrom.cybernode.ai/v1/graphql',\n  CYBER_INDEX_WEBSOCKET:\n    process.env.CYBER_INDEX_WEBSOCKET ||\n    'wss://index.bostrom.cybernode.ai/v1/graphql',\n  BECH32_PREFIX_ACC_ADDR_CYBER: 'bostrom',\n  BECH32_PREFIX_ACC_ADDR_CYBERVALOPER: 'bostromvaloper',\n  MEMO_KEPLR: '[bostrom] cyb.ai, using keplr',\n};\n\nif (LOCALSTORAGE_CHAIN_ID === 'space-pussy') {\n  CHAIN_PARAMS = {\n    CHAIN_ID: Networks.SPACE_PUSSY,\n    DENOM_CYBER: 'pussy',\n    DENOM_LIQUID_TOKEN: 'liquidpussy',\n    DENOM_CYBER_G: `GPUSSY`,\n    CYBER_NODE_URL_API: 'https://rpc.space-pussy.cybernode.ai/',\n    CYBER_WEBSOCKET_URL: 'wss://rpc.space-pussy.cybernode.ai/websocket',\n    CYBER_NODE_URL_LCD: 'https://lcd.space-pussy.cybernode.ai',\n    CYBER_INDEX_HTTPS: 'https://index.space-pussy.cybernode.ai/v1/graphql',\n    CYBER_INDEX_WEBSOCKET: 'wss://index.space-pussy.cybernode.ai/v1/graphql',\n\n    BECH32_PREFIX_ACC_ADDR_CYBER: 'pussy',\n    BECH32_PREFIX_ACC_ADDR_CYBERVALOPER: `pussyvaloper`,\n    MEMO_KEPLR: '[space-pussy] cyb.ai, using keplr',\n  };\n}\n\nconst CYBER = {\n  CYBER_CONGRESS_ADDRESS: 'bostrom1xszmhkfjs3s00z2nvtn7evqxw3dtus6yr8e4pw',\n  DIVISOR_CYBER_G: 10 ** 9,\n  HYDROGEN: 'H',\n\n  ...CHAIN_PARAMS,\n\n  // CHAIN_ID: 'dev',\n  // CYBER_NODE_URL_API: 'http://localhost:26657',\n  // CYBER_WEBSOCKET_URL: 'ws://localhost:26657/websocket',\n  // CYBER_NODE_URL_LCD: 'http://localhost:1317',\n\n  CYBER_GATEWAY:\n    process.env.CYBER_GATEWAY || 'https://gateway.ipfs.cybernode.ai',\n};\n\nconst DEFAULT_GAS_LIMITS = 200000;\n\nconst GAS_LIMITS = {\n  send: 200000,\n  cyberlink: 256000,\n  investmint: 160000,\n  createRoute: 128000,\n  editRoute: 128000,\n  editRouteAlias: 128000,\n  deleteRoute: 128000,\n};\n\nconst LEDGER = {\n  STAGE_INIT: 0,\n  STAGE_SELECTION: 1,\n  STAGE_LEDGER_INIT: 2,\n  STAGE_READY: 3,\n  STAGE_WAIT: 4,\n  STAGE_GENERATED: 5,\n  STAGE_SUBMITTED: 6,\n  STAGE_CONFIRMING: 7,\n  STAGE_CONFIRMED: 8,\n  STAGE_ERROR: 15,\n  LEDGER_VERSION_REQ: [1, 1, 1],\n  HDPATH: [44, 118, 0, 0, 0],\n  LEDGER_OK: 36864,\n  LEDGER_NOAPP: 28160,\n  MEMO: 'cyb.ai, using Ledger',\n};\n\nconst TAKEOFF_SUPPLY = 100000000000000;\nconst GENESIS_SUPPLY = 1000000000000000;\nconst TOTAL_GOL_GENESIS_SUPPLY = 50000000000000;\n\nconst DISTRIBUTION = {\n  takeoff: 100000000000000,\n  relevance: 20000000000000,\n  load: 10000000000000,\n  delegation: 5000000000000,\n  'full validator set': 5000000000000,\n  'euler 4 rewards': 5000000000000,\n  lifetime: 3000000000000,\n  'community pool': 2000000000000,\n};\n\nconst DISTRIBUTION_PRIZE = {\n  takeoff: 100000000000000,\n  relevance: 500000000000,\n  load: 500000000000,\n  delegation: 500000000000,\n  'full validator set': 250000000000,\n  'euler 4 rewards': 5000000000000,\n  lifetime: 500000000000,\n  'community pool': 2000000000000,\n};\n\nconst POCKET = {\n  STAGE_TWEET_ACTION_BAR: {\n    ADD_AVATAR: 'addAvatar',\n    FOLLOW: 'follow',\n    TWEET: 'tweet',\n  },\n};\n\nconst PROPOSAL_STATUS = {\n  /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status. */\n  PROPOSAL_STATUS_UNSPECIFIED: 0,\n  /**\n   * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\n   * period.\n   */\n  PROPOSAL_STATUS_DEPOSIT_PERIOD: 1,\n  /**\n   * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\n   * period.\n   */\n  PROPOSAL_STATUS_VOTING_PERIOD: 2,\n  /**\n   * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\n   * passed.\n   */\n  PROPOSAL_STATUS_PASSED: 3,\n  /**\n   * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\n   * been rejected.\n   */\n  PROPOSAL_STATUS_REJECTED: 4,\n  /**\n   * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\n   * failed.\n   */\n  PROPOSAL_STATUS_FAILED: 5,\n  UNRECOGNIZED: -1,\n};\n\nconst VOTE_OPTION = {\n  /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */\n  VOTE_OPTION_UNSPECIFIED: 0,\n  /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */\n  VOTE_OPTION_YES: 1,\n  /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */\n  VOTE_OPTION_ABSTAIN: 2,\n  /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */\n  VOTE_OPTION_NO: 3,\n  /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */\n  VOTE_OPTION_NO_WITH_VETO: 4,\n  UNRECOGNIZED: -1,\n};\n\nconst BOND_STATUS = {\n  BOND_STATUS_UNSPECIFIED: 0,\n  /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */\n  BOND_STATUS_UNBONDED: 1,\n  /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */\n  BOND_STATUS_UNBONDING: 2,\n  /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */\n  BOND_STATUS_BONDED: 3,\n};\n\nconst PATTERN = new RegExp(\n  `^0x[a-fA-F0-9]{40}$|^${CYBER.BECH32_PREFIX_ACC_ADDR_CYBER}valoper[a-zA-Z0-9]{39}$|^${CYBER.BECH32_PREFIX_ACC_ADDR_CYBER}[a-zA-Z0-9]{39}$|^cosmos[a-zA-Z0-9]{39}$`,\n  'g'\n);\nconst PATTERN_CYBER_CONTRACT = new RegExp(\n  `^${CYBER.BECH32_PREFIX_ACC_ADDR_CYBER}[a-zA-Z0-9]{59}$`,\n  'g'\n);\nconst PATTERN_CYBER_VALOPER = new RegExp(\n  `^${CYBER.BECH32_PREFIX_ACC_ADDR_CYBER}valoper[a-zA-Z0-9]{39}$`,\n  'g'\n);\nconst PATTERN_COSMOS = /^cosmos[a-zA-Z0-9]{39}$/g;\nconst PATTERN_OSMOS = /^osmo[a-zA-Z0-9]{39}$/g;\nconst PATTERN_TERRA = /^terra[a-zA-Z0-9]{39}$/g;\nconst PATTERN_ETH = /^0x[a-fA-F0-9]{40}$/g;\nconst PATTERN_TX = /[0-9a-fA-F]{64}$/g;\nconst PATTERN_BLOCK = /^[0-9]+$/g;\nconst PATTERN_HTTP = /^https:\\/\\/|^http:\\/\\//g;\nconst PATTERN_HTML = /<\\/?[\\w\\d]+>/gi;\n\nexport {\n  TAKEOFF,\n  COSMOS,\n  CYBER,\n  LEDGER,\n  AUCTION,\n  NETWORKSIDS,\n  DISTRIBUTION,\n  GENESIS_SUPPLY,\n  TOTAL_GOL_GENESIS_SUPPLY,\n  PATTERN,\n  PATTERN_CYBER_CONTRACT,\n  PATTERN_CYBER_VALOPER,\n  PATTERN_TX,\n  PATTERN_COSMOS,\n  PATTERN_ETH,\n  PATTERN_TERRA,\n  PATTERN_OSMOS,\n  PATTERN_BLOCK,\n  TIME_START,\n  TAKEOFF_SUPPLY,\n  WP,\n  PATTERN_HTTP,\n  POCKET,\n  INFINITY,\n  ADD_ARAGON_FINANCE,\n  DISTRIBUTION_PRIZE,\n  GAS_LIMITS,\n  DEFAULT_GAS_LIMITS,\n  PROPOSAL_STATUS,\n  VOTE_OPTION,\n  BOND_STATUS,\n  PATTERN_HTML,\n  HUB_CONTRACTS,\n};\n","import { Dispatch } from 'redux';\nimport { localStorageKeys } from 'src/constants/localStorageKeys';\n\nimport {\n  Account,\n  AccountValue,\n  Accounts,\n  DefaultAccount,\n} from 'src/types/defaultAccount';\nimport { PayloadAction, createSlice } from '@reduxjs/toolkit';\nimport { POCKET } from '../../utils/config';\nimport { RootState } from '../store';\n\ntype SliceState = {\n  actionBar: {\n    tweet: string;\n  };\n  defaultAccount: DefaultAccount;\n  accounts: null | Accounts;\n};\n\nconst initialState: SliceState = {\n  actionBar: {\n    tweet: POCKET.STAGE_TWEET_ACTION_BAR.TWEET, // stage for tweet ActionBar: 'addAvatar' 'follow' 'tweet'\n  },\n  defaultAccount: {\n    name: null,\n    account: null,\n  },\n  accounts: null,\n};\n\nconst checkAddress = (obj, network, address) =>\n  Object.keys(obj).some((k) => {\n    if (obj[k][network]) {\n      return obj[k][network].bech32 === address;\n    }\n  });\n\nfunction saveToLocalStorage(state: SliceState) {\n  const { defaultAccount, accounts } = state;\n\n  defaultAccount &&\n    localStorage.setItem(\n      localStorageKeys.pocket.POCKET,\n      JSON.stringify({\n        [defaultAccount.name]: defaultAccount.account,\n      })\n    );\n  accounts &&\n    localStorage.setItem(\n      localStorageKeys.pocket.POCKET_ACCOUNT,\n      JSON.stringify(accounts)\n    );\n}\n\nconst slice = createSlice({\n  name: 'pocket',\n  initialState,\n  reducers: {\n    setDefaultAccount: (\n      state,\n      {\n        payload: { name, account },\n      }: PayloadAction<{ name: string; account?: Account }>\n    ) => {\n      state.defaultAccount = {\n        name,\n        account: account || state.accounts?.[name] || null,\n      };\n\n      saveToLocalStorage(state);\n    },\n    setAccounts: (state, { payload }: PayloadAction<Accounts>) => {\n      state.accounts = payload;\n\n      saveToLocalStorage(state);\n    },\n    setStageTweetActionBar: (state, { payload }: PayloadAction<string>) => {\n      state.actionBar.tweet = payload;\n    },\n\n    // bullshit\n    deleteAddress: (state, { payload }: PayloadAction<string>) => {\n      if (state.accounts) {\n        Object.keys(state.accounts).forEach((accountKey) => {\n          Object.keys(state.accounts[accountKey]).forEach((networkKey) => {\n            if (state.accounts[accountKey][networkKey].bech32 === payload) {\n              delete state.accounts[accountKey][networkKey];\n\n              if (Object.keys(state.accounts[accountKey]).length === 0) {\n                delete state.accounts[accountKey];\n              }\n\n              if (state.defaultAccount?.account?.cyber?.bech32 === payload) {\n                const entries = Object.entries(state.accounts);\n\n                const entryCyber = entries.find(\n                  ([, value]) => value.cyber?.bech32\n                );\n\n                if (entryCyber) {\n                  state.defaultAccount = {\n                    name: entryCyber[0],\n                    account: entryCyber[1],\n                  };\n                } else {\n                  state.defaultAccount = {\n                    name: null,\n                    account: null,\n                  };\n                }\n              }\n\n              saveToLocalStorage(state);\n            }\n          });\n        });\n      }\n    },\n  },\n});\n\nexport const selectCurrentAddress = (store: RootState) =>\n  store.pocket.defaultAccount.account?.cyber?.bech32;\n\nexport const {\n  setDefaultAccount,\n  setAccounts,\n  setStageTweetActionBar,\n  deleteAddress,\n} = slice.actions;\n\nexport default slice.reducer;\n\n// refactor this\nexport const initPocket = () => (dispatch: Dispatch) => {\n  let defaultAccounts = null;\n  let defaultAccountsKeys = null;\n  let accountsTemp: Accounts | null = null;\n\n  const localStoragePocketAccount = localStorage.getItem(\n    localStorageKeys.pocket.POCKET_ACCOUNT\n  );\n  const localStoragePocket = localStorage.getItem(\n    localStorageKeys.pocket.POCKET\n  );\n  if (localStoragePocket !== null) {\n    const localStoragePocketData = JSON.parse(localStoragePocket);\n    const keyPocket = Object.keys(localStoragePocketData)[0];\n    const accountPocket = Object.values(localStoragePocketData)[0];\n    defaultAccounts = accountPocket;\n    defaultAccountsKeys = keyPocket;\n  }\n  if (localStoragePocketAccount !== null) {\n    const localStoragePocketAccountData = JSON.parse(localStoragePocketAccount);\n    if (localStoragePocket === null) {\n      const keys0 = Object.keys(localStoragePocketAccountData)[0];\n      localStorage.setItem(\n        localStorageKeys.pocket.POCKET,\n        JSON.stringify({ [keys0]: localStoragePocketAccountData[keys0] })\n      );\n      defaultAccounts = localStoragePocketAccountData[keys0];\n      defaultAccountsKeys = keys0;\n    } else if (defaultAccountsKeys !== null) {\n      accountsTemp = {\n        [defaultAccountsKeys]:\n          localStoragePocketAccountData[defaultAccountsKeys] || undefined,\n        ...localStoragePocketAccountData,\n      };\n    }\n  } else {\n    localStorage.removeItem(localStorageKeys.pocket.POCKET);\n    localStorage.removeItem(localStorageKeys.pocket.POCKET_ACCOUNT);\n  }\n\n  defaultAccountsKeys &&\n    defaultAccounts &&\n    dispatch(\n      setDefaultAccount({\n        name: defaultAccountsKeys,\n        account: defaultAccounts,\n      })\n    );\n\n  accountsTemp &&\n    Object.keys(accountsTemp).forEach((key) => {\n      if (!accountsTemp[key] || Object.keys(accountsTemp[key]).length === 0) {\n        delete accountsTemp[key];\n      }\n    });\n\n  accountsTemp && dispatch(setAccounts(accountsTemp));\n};\n\nconst defaultNameAccount = () => {\n  let key = 'Account 1';\n  let count = 1;\n\n  const localStorageCount = localStorage.getItem('count');\n\n  if (localStorageCount !== null) {\n    const dataCount = JSON.parse(localStorageCount);\n    count = parseFloat(dataCount);\n    key = `Account ${count}`;\n  }\n\n  localStorage.setItem('count', JSON.stringify(count + 1));\n\n  return key;\n};\n\nexport const addAddressPocket =\n  (accounts: AccountValue) => (dispatch: Dispatch) => {\n    const key = accounts.name || defaultNameAccount();\n\n    let dataPocketAccount = null;\n    let valueObj = {};\n    let pocketAccount: Accounts = {};\n\n    const localStorageStory = localStorage.getItem(\n      localStorageKeys.pocket.POCKET_ACCOUNT\n    );\n\n    if (localStorageStory !== null) {\n      dataPocketAccount = JSON.parse(localStorageStory);\n      valueObj = Object.values(dataPocketAccount);\n    }\n\n    const isAdded = !checkAddress(valueObj, 'cyber', accounts.bech32);\n\n    if (!isAdded) {\n      return;\n    }\n\n    const cyberAccounts: Account = {\n      cyber: accounts,\n    };\n\n    if (localStorageStory !== null) {\n      pocketAccount = { [key]: cyberAccounts, ...dataPocketAccount };\n    } else {\n      pocketAccount = { [key]: cyberAccounts };\n    }\n\n    if (Object.keys(pocketAccount).length > 0) {\n      dispatch(setAccounts(pocketAccount));\n      if (accounts.keys !== 'read-only') {\n        dispatch(setDefaultAccount({ name: key, account: cyberAccounts }));\n      }\n    }\n  };\n","import { updateSenseList } from 'src/features/sense/redux/sense.redux';\nimport { setDefaultAccount } from 'src/redux/features/pocket';\nimport { Account } from 'src/types/defaultAccount';\nimport { SenseListItem } from '../types/sense';\nimport {\n  BroadcastChannelMessage,\n  ServiceName,\n  ServiceStatus,\n  SyncEntryName,\n  SyncProgress,\n} from '../types/services';\nimport { CYB_BROADCAST_CHANNEL } from './consts';\n\nclass BroadcastChannelSender {\n  private channel: BroadcastChannel;\n\n  constructor() {\n    this.channel = new BroadcastChannel(CYB_BROADCAST_CHANNEL);\n  }\n\n  public postServiceStatus(\n    name: ServiceName,\n    status: ServiceStatus,\n    message?: string\n  ) {\n    this.channel.postMessage({\n      type: 'service_status',\n      value: { name, status, message },\n    });\n  }\n\n  public postSyncEntryProgress(entry: SyncEntryName, state: SyncProgress) {\n    // console.log('postSyncEntryProgress', entry, state);\n    this.channel.postMessage({ type: 'sync_entry', value: { entry, state } });\n  }\n\n  public postSenseUpdate(senseList: SenseListItem[]) {\n    // console.log('postSenseUpdate', senseList);\n    if (senseList.length > 0) {\n      this.channel.postMessage(updateSenseList(senseList));\n    }\n  }\n\n  public postSetDefaultAccount(name: string, account?: Account) {\n    this.channel.postMessage(\n      setDefaultAccount({\n        name,\n        account,\n      })\n    );\n  }\n\n  post(msg: BroadcastChannelMessage) {\n    this.channel.postMessage(msg);\n  }\n}\n\nexport default BroadcastChannelSender;\n","export const CYB_BROADCAST_CHANNEL = 'cyb-broadcast-channel';\n","import {\n  BehaviorSubject,\n  map,\n  timeout,\n  throwError,\n  of,\n  catchError,\n  EMPTY,\n  Observable,\n  mergeMap,\n  debounceTime,\n  merge,\n  tap,\n  interval,\n  filter,\n} from 'rxjs';\n\nimport * as R from 'ramda';\n\nimport { fetchIpfsContent } from 'src/services/ipfs/utils/utils-ipfs';\nimport { CybIpfsNode, IpfsContentSource } from 'src/services/ipfs/ipfs';\nimport { ParticleCid } from 'src/types/base';\n\nimport { promiseToObservable } from '../../utils/helpers';\n\nimport type {\n  QueueItem,\n  QueueItemResult,\n  QueueItemCallback,\n  QueueItemOptions,\n  QueueStats,\n  QueueSource,\n  IDeferredDbSaver,\n  QueueItemAsyncResult,\n} from './types';\n\nimport { QueueStrategy } from './QueueStrategy';\n\nimport { QueueItemTimeoutError } from './QueueItemTimeoutError';\nimport BroadcastChannelSender from '../backend/channels/BroadcastChannelSender';\n\nconst QUEUE_DEBOUNCE_MS = 33;\nconst CONNECTION_KEEPER_RETRY_MS = 5000;\n\nfunction getQueueItemTotalPriority(item: QueueItem): number {\n  return (item.priority || 0) + (item.viewPortPriority || 0);\n}\n\nconst debugCid = (cid: ParticleCid, prefix: string, ...args) => {\n  console.log(`>>> ${prefix}: ${cid}`, ...args);\n};\n\nconst strategies = {\n  external: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 60 * 1000, maxConcurrentExecutions: 50 },\n      gateway: { timeout: 21000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'node', 'gateway']\n  ),\n  embedded: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 60 * 1000, maxConcurrentExecutions: 50 },\n      gateway: { timeout: 21000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'gateway', 'node']\n  ),\n  helia: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 6 * 1000, maxConcurrentExecutions: 50 }, //TODO: set to 60\n      gateway: { timeout: 3 * 1000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'node', 'gateway']\n  ),\n};\n\ntype QueueMap = Map<ParticleCid, QueueItem>;\n\nclass QueueManager {\n  private queue$ = new BehaviorSubject<QueueMap>(new Map());\n\n  private node: CybIpfsNode | undefined = undefined;\n\n  private defferedDbSaver?: IDeferredDbSaver;\n\n  private strategy: QueueStrategy;\n\n  private queueDebounceMs: number;\n\n  private lastNodeCallTime: number = Date.now();\n\n  private channel = new BroadcastChannelSender();\n\n  private executing: Record<QueueSource, Set<ParticleCid>> = {\n    db: new Set(),\n    node: new Set(),\n    gateway: new Set(),\n  };\n\n  private switchStrategy(strategy: QueueStrategy): void {\n    this.strategy = strategy;\n  }\n\n  public async setNode(node: CybIpfsNode, customStrategy?: QueueStrategy) {\n    console.log(`switch node from ${this.node?.nodeType} to ${node.nodeType}`);\n    this.node = node;\n    this.switchStrategy(customStrategy || strategies[node.nodeType]);\n  }\n\n  private getItemBySourceAndPriority(queue: QueueMap) {\n    const pendingItems = [...queue.values()].filter(\n      (i) => i.status === 'pending'\n    );\n\n    const pendingBySource = R.groupBy((i) => i.source, pendingItems);\n\n    const itemsToExecute: QueueItem[] = [];\n    // eslint-disable-next-line no-loop-func, no-restricted-syntax\n    for (const [queueSource, items] of Object.entries(pendingBySource)) {\n      const settings = this.strategy.settings[queueSource as IpfsContentSource];\n\n      const executeCount =\n        settings.maxConcurrentExecutions -\n        this.executing[queueSource as IpfsContentSource].size;\n\n      const itemsByPriority = items\n        .sort(\n          (a, b) => getQueueItemTotalPriority(b) - getQueueItemTotalPriority(a)\n        )\n        .slice(0, executeCount);\n\n      // console.log('---itemsByPriority', itemsByPriority);\n\n      itemsToExecute.push(...itemsByPriority);\n    }\n\n    return itemsToExecute;\n  }\n\n  private postSummary() {\n    const summary = `(total: ${this.queue$.value.size} |  db - ${this.executing.db.size} node - ${this.executing.node.size} gateway - ${this.executing.gateway.size})`;\n\n    this.channel.postServiceStatus('ipfs', 'started', summary);\n  }\n\n  private fetchData$(item: QueueItem) {\n    const { cid, source, callbacks, controller } = item;\n    // const abortController = controller || new AbortController();\n    const settings = this.strategy.settings[source];\n    this.executing[source].add(cid);\n    this.postSummary();\n    const queueItem = this.queue$.value.get(cid);\n    // Mutate item without next\n    this.queue$.value.set(cid, {\n      ...queueItem,\n      status: 'executing',\n      executionTime: Date.now(),\n      controller: new AbortController(),\n    } as QueueItem);\n    // debugCid(cid, 'fetchData', cid, source);\n    callbacks.map((callback) => callback(cid, 'executing', source));\n\n    return promiseToObservable(async () => {\n      try {\n        const res = await fetchIpfsContent(cid, source, {\n          controller,\n          node: this.node,\n        }).then((content) => {\n          this.defferedDbSaver?.enqueueIpfsContent(content);\n\n          return content;\n        });\n        return res;\n      } catch (e) {\n        // console.log('---promtoo', e);\n        throw e;\n      }\n    }).pipe(\n      timeout({\n        each: settings.timeout,\n        with: () =>\n          throwError(() => {\n            controller?.abort('timeout');\n            return new QueueItemTimeoutError(settings.timeout);\n          }),\n      }),\n      map((result): QueueItemResult => {\n        return {\n          item,\n          status: result ? 'completed' : 'error',\n          source,\n          result,\n        };\n      }),\n      catchError((error): Observable<QueueItemResult> => {\n        // debugCid(cid, 'fetchData - fetchIpfsContent catchErr', error);\n        if (error instanceof QueueItemTimeoutError) {\n          return of({\n            item,\n            status: 'timeout',\n            source,\n          });\n        }\n\n        if (error?.name === 'AbortError') {\n          return of({ item, status: 'cancelled', source });\n        }\n        return of({ item, status: 'error', source });\n      })\n    );\n  }\n\n  /**\n   * Mutate queue item, and return new queue\n   * @param cid\n   * @param changes\n   * @returns\n   */\n  private mutateQueueItem(cid: string, changes: Partial<QueueItem>) {\n    const queue = this.queue$.value;\n    const item = queue.get(cid);\n    if (item) {\n      queue.set(cid, { ...item, ...changes });\n    }\n\n    return this.queue$.next(queue);\n  }\n\n  private removeAndNext(cid: string): void {\n    const queue = this.queue$.value;\n    queue.delete(cid);\n    this.queue$.next(queue);\n  }\n\n  // reset status and switch to next source\n  private switchSourceAndNext(item: QueueItem, nextSource: QueueSource): void {\n    item.callbacks.map((callback) => callback(item.cid, 'pending', nextSource));\n\n    this.mutateQueueItem(item.cid, { status: 'pending', source: nextSource });\n  }\n\n  private cancelDeprioritizedItems(queue: QueueMap): QueueMap {\n    (['node', 'gateway'] as IpfsContentSource[]).forEach((source) => {\n      Array.from(this.executing[source]).forEach((cid) => {\n        const item = queue.get(cid);\n        if (item && getQueueItemTotalPriority(item) < 0 && item.controller) {\n          // abort request and move to pending\n          item.controller.abort('cancelled');\n          item.callbacks.map((callback) =>\n            callback(item.cid, 'pending', item.source)\n          );\n\n          queue.set(cid, { ...item, status: 'pending' });\n          // console.log('-----cancel item', item, queue);\n\n          this.executing[source].delete(cid);\n        }\n      });\n    });\n\n    return queue;\n  }\n\n  private releaseExecution(cid: string) {\n    // eslint-disable-next-line no-restricted-syntax\n    Object.keys(this.executing).forEach((key) =>\n      this.executing[key as IpfsContentSource].delete(cid)\n    );\n  }\n\n  constructor(\n    ipfsInstance$: Observable<CybIpfsNode | undefined>,\n    {\n      strategy,\n      queueDebounceMs,\n      defferedDbSaver,\n    }: {\n      strategy?: QueueStrategy;\n      queueDebounceMs?: number;\n      defferedDbSaver?: IDeferredDbSaver;\n    }\n  ) {\n    ipfsInstance$.subscribe((node) => {\n      if (node) {\n        this.setNode(node);\n      }\n    });\n\n    this.strategy = strategy || strategies.embedded;\n    this.queueDebounceMs = queueDebounceMs || QUEUE_DEBOUNCE_MS;\n    this.defferedDbSaver = defferedDbSaver;\n\n    // Little hack to handle keep-alive connection to swarm cyber node\n    // Fix some lag with node peers(when it shown swarm node in peers but not  connected anymore)\n    interval(CONNECTION_KEEPER_RETRY_MS)\n      .pipe(filter(() => this.queue$.value.size > 0 && !!this.node))\n      .subscribe(() => this.node!.reconnectToSwarm(this.lastNodeCallTime));\n\n    this.queue$\n      .pipe(\n        // tap(() => console.log('----QUEUE')),\n        debounceTime(this.queueDebounceMs),\n        map((queue) => this.cancelDeprioritizedItems(queue)),\n        mergeMap((queue) => {\n          const workItems = this.getItemBySourceAndPriority(queue);\n          // console.log('---workItems', workItems);\n          if (workItems.length > 0) {\n            // wake up connnection to swarm cyber node\n            this.node?.reconnectToSwarm(this.lastNodeCallTime);\n\n            return merge(...workItems.map((item) => this.fetchData$(item)));\n          }\n          return EMPTY;\n        })\n      )\n      .subscribe(({ item, status, source, result }) => {\n        const { cid } = item;\n        const callbacks = this.queue$.value.get(cid)?.callbacks || [];\n        // fix to process dublicated items\n        // debugCid(cid, 'subscribe', cid, source, status, result, callbacks);\n\n        callbacks.map((callback) => callback(cid, status, source, result));\n\n        // HACK to use with GracePeriod for reconnection\n        if (source === 'node') {\n          this.lastNodeCallTime = Date.now();\n        }\n\n        this.executing[source].delete(cid);\n\n        // success execution -> next\n        if (status === 'completed' || status === 'cancelled') {\n          // debugCid(cid, '------done', item, status, source, result);\n          this.removeAndNext(cid);\n        } else {\n          // debugCid(cid, '------error', item, status, source, result);\n\n          // Retry -> (next sources) or -> next\n          const nextSource = this.strategy.getNextSource(source);\n\n          if (nextSource) {\n            this.switchSourceAndNext(item, nextSource);\n          } else {\n            this.removeAndNext(cid);\n            // notify thatn nothing found from all sources\n            callbacks.map((callback) =>\n              callback(cid, 'not_found', source, result)\n            );\n          }\n        }\n\n        this.postSummary();\n      });\n  }\n\n  public enqueue(\n    cid: string,\n    callback: QueueItemCallback,\n    options: QueueItemOptions = {}\n  ): void {\n    const queue = this.queue$.value;\n    const existingItem = queue.get(cid);\n    // debugCid(cid, '----/--enqueue ', cid, existingItem);\n\n    // In case if item already in queue,\n    // just attach one more callback to quieued item\n    if (existingItem) {\n      this.mutateQueueItem(cid, {\n        callbacks: [...existingItem.callbacks, callback],\n      });\n    } else {\n      const source = options.initialSource || this.strategy.order[0];\n      const item: QueueItem = {\n        cid,\n        callbacks: [callback],\n        source, // initial method to fetch\n        status: 'pending',\n        postProcessing: true, // by default rune-post-processing enabled\n        ...options,\n      };\n\n      callback(cid, 'pending', source);\n\n      queue.set(cid, item);\n      this.queue$.next(queue);\n    }\n  }\n\n  public enqueueAndWait(\n    cid: string,\n    options: QueueItemOptions = {}\n  ): Promise<QueueItemAsyncResult> {\n    return new Promise((resolve) => {\n      const callback = ((cid, status, source, result) => {\n        if (status === 'completed' || status === 'not_found') {\n          resolve({ status, source, result });\n        }\n      }) as QueueItemCallback;\n\n      this.enqueue(cid, callback, options);\n    });\n  }\n\n  public updateViewPortPriority(cid: string, viewPortPriority: number) {\n    this.mutateQueueItem(cid, { viewPortPriority });\n  }\n\n  public cancel(cid: string): void {\n    const queue = this.queue$.value;\n    const item = queue.get(cid);\n    // console.log('-----cancel item', item, item?.controller);\n    if (item) {\n      // If item has no abortController we can just remove it,\n      // otherwise abort&keep-to-finalize\n      if (!item.controller) {\n        this.removeAndNext(cid);\n      } else {\n        item.controller.abort('cancelled');\n      }\n    }\n  }\n\n  public cancelByParent(parent: string): void {\n    const queue = this.queue$.value;\n\n    queue.forEach((item, cid) => {\n      if (item.parent === parent) {\n        this.releaseExecution(cid);\n        item.controller?.abort('cancelled');\n        queue.delete(cid);\n      }\n    });\n\n    this.queue$.next(queue);\n  }\n\n  public clear(): void {\n    const queue = this.queue$.value;\n\n    queue.forEach((item, cid) => {\n      this.releaseExecution(cid);\n      item.controller?.abort('cancelled');\n      queue.delete(cid);\n    });\n\n    this.queue$.next(new Map());\n  }\n\n  public getQueueMap(): QueueMap {\n    return this.queue$.value;\n  }\n\n  public getQueueList(): QueueItem[] {\n    return Array.from(this.queue$.value.values());\n  }\n\n  public getStats(): QueueStats[] {\n    const fn = R.pipe(\n      R.countBy<QueueItem>(R.prop('status')),\n      R.toPairs,\n      R.map(R.zipObj(['status', 'count']))\n    );\n\n    return fn(this.getQueueList()) as QueueStats[];\n  }\n}\n\n// TODO: MOVE TO SEPARATE FILE AS GLOBAL VARIABLE\n// const queueManager = new QueueManager<IPFSContentMaybe>();\n\n// if (typeof window !== 'undefined') {\n//   window.qm = queueManager;\n// }\n\n// export { queueManager };\nexport default QueueManager;\n","import { Observable } from 'rxjs';\n\n/**\n * Promise will be rejected after timeout.\n *\n * @param promise\n * @param timeout ms\n * @param abortController trigger abort\n * @returns\n */\nasync function withTimeout<T>(\n  promise: Promise<T>,\n  timeout: number,\n  abortController?: AbortController\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      const timer = setTimeout(() => {\n        abortController?.abort('timeout');\n        clearTimeout(timer);\n        reject(new DOMException('timeout', 'AbortError'));\n      }, timeout);\n    }),\n  ]);\n}\n\n/**\n * Convert promise to observable\n * @param promiseFactory\n * @returns\n */\nexport function promiseToObservable<T>(promiseFactory: () => Promise<T>) {\n  return new Observable<T>((observer) => {\n    promiseFactory()\n      .then((response) => {\n        observer.next(response);\n        observer.complete();\n      })\n      .catch((error) => {\n        console.debug('----promiseToObservable error', error); //, error\n        observer.error(error);\n      });\n  });\n}\n\nexport function convertTimeToMilliseconds(timeValue: string | number): number {\n  if (typeof timeValue === 'number') {\n    return timeValue;\n  }\n  const numericValue = parseFloat(timeValue);\n\n  const unit = timeValue\n    .replace(numericValue.toString(), '')\n    .trim()\n    .toLowerCase();\n\n  switch (unit) {\n    case 'ms':\n    case '':\n      return numericValue;\n    case 's':\n      return numericValue * 1000;\n    case 'm':\n      return numericValue * 60 * 1000;\n    case 'h':\n      return numericValue * 60 * 60 * 1000;\n    case 'd':\n      return numericValue * 24 * 60 * 60 * 1000;\n    default:\n      throw new Error(`Invalid time unit: ${unit}`);\n  }\n}\n\nexport function debounce(func, timeout = 300) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      func.apply(this, args);\n    }, timeout);\n  };\n}\n","import { IPFSContentMaybe, IpfsContentSource } from '../ipfs/ipfs';\nimport { LinkDbEntity } from '../CozoDb/types/entities';\nimport { LinkDto } from '../CozoDb/types/dto';\n\n/* eslint-disable import/no-unused-modules */\nexport type QueueItemStatus =\n  | 'pending'\n  | 'executing'\n  | 'timeout'\n  | 'completed'\n  | 'cancelled'\n  | 'error'\n  | 'not_found';\n\nexport type QueueSourceSettings = {\n  timeout: number;\n  maxConcurrentExecutions: number;\n};\n\nexport type QueueSource = IpfsContentSource;\n\nexport type QueueSettings = Record<QueueSource, QueueSourceSettings>;\n\nexport interface IQueueStrategy {\n  settings: QueueSettings;\n  order: QueueSource[];\n  getNextSource(source: QueueSource): QueueSource | undefined;\n}\n\nexport type QueueStats = {\n  status: QueueItemStatus;\n  count: number;\n};\n\nexport enum QueuePriority {\n  ZERO = 0,\n  LOW = 0.1,\n  MEDIUM = 0.5,\n  HIGH = 0.9,\n  URGENT = 1,\n}\nexport type QueueItemOptions = {\n  parent?: string;\n  priority?: QueuePriority | number;\n  viewPortPriority?: number;\n  initialSource?: QueueSource;\n  postProcessing?: boolean;\n};\n\nexport type QueueItemCallback = (\n  cid: string,\n  status: QueueItemStatus,\n  source: QueueSource,\n  result?: IPFSContentMaybe\n) => void;\n\nexport type QueueItem = {\n  cid: string;\n  source: QueueSource;\n  status: QueueItemStatus;\n  callbacks: QueueItemCallback[];\n  controller?: AbortController;\n  executionTime?: number;\n} & Omit<QueueItemOptions, 'initialSource'>;\n\nexport type QueueItemResult = {\n  item: QueueItem;\n  status: QueueItemStatus;\n  source: QueueSource;\n  result?: IPFSContentMaybe;\n};\n\nexport type QueueItemAsyncResult = Omit<QueueItemResult, 'item'>;\n\nexport type QueueItemPostProcessor = (\n  content: IPFSContentMaybe\n) => Promise<IPFSContentMaybe>;\n\nexport interface IDeferredDbSaver {\n  // postProcess: (content: IPFSContentMaybe) => Promise<IPFSContentMaybe>;\n  enqueueIpfsContent: (content: IPFSContentMaybe) => void;\n  enqueueLinks: (links: LinkDto[]) => void;\n}\n\nexport type FetchParticleAsync = (\n  cid: string,\n  options?: QueueItemOptions\n) => Promise<QueueItemAsyncResult>;\n","import type { TransferHandler } from 'comlink';\nimport { IPFSContent } from 'src/services/ipfs/ipfs';\n\ntype IPFSContentTransferable = Omit<IPFSContent, 'result'> & {\n  port: MessagePort;\n};\n\nfunction createAsyncIterable(port: MessagePort): AsyncIterable<Uint8Array> {\n  return {\n    async *[Symbol.asyncIterator](): AsyncGenerator<\n      Uint8Array,\n      void,\n      undefined\n    > {\n      let done = false;\n      while (!done) {\n        // eslint-disable-next-line no-loop-func\n        const promise = new Promise<Uint8Array | null>((resolve) => {\n          // resolve = res;\n          port.onmessage = (event: MessageEvent) => {\n            if (event.data === null) {\n              done = true;\n              resolve(null);\n            } else {\n              resolve(event.data);\n            }\n          };\n        });\n        // eslint-disable-next-line no-await-in-loop\n        const value = await promise;\n        // eslint-disable-next-line no-await-in-loop\n        if (value !== null) {\n          yield value;\n        }\n      }\n    },\n  };\n}\n\nconst IPFSContentTransferHandler: TransferHandler<\n  IPFSContent | undefined,\n  IPFSContentTransferable | null\n> = {\n  canHandle: (obj: IPFSContent | undefined) =>\n    obj && obj.result && typeof obj.result[Symbol.asyncIterator] === 'function',\n  serialize(obj: IPFSContent) {\n    if (obj === undefined) {\n      return [null, []];\n    }\n    const { result, ...rest } = obj;\n    const { port1, port2 } = new MessageChannel();\n    if (result) {\n      (async () => {\n        // eslint-disable-next-line no-restricted-syntax\n        for await (const value of result) {\n          port1.postMessage(value);\n        }\n        port1.postMessage(null); // Send  \"end\" message\n\n        port1.close();\n      })();\n    }\n    return [{ ...rest, port: port2 }, [port2]];\n  },\n  deserialize(serializedObj: IPFSContentTransferable | null) {\n    if (!serializedObj) {\n      return undefined;\n    }\n    const { port, ...rest } = serializedObj;\n\n    return {\n      ...rest,\n      result: createAsyncIterable(port),\n    };\n  },\n};\n\nexport { IPFSContentTransferHandler };\n","import { wrap, Remote, expose, transferHandlers } from 'comlink';\nimport { IPFSContentTransferHandler } from './serializers';\n\ntype WorkerType = SharedWorker | Worker;\n\nconst isSharedWorkersSupported = typeof SharedWorker !== 'undefined';\n\nconst isSharedWorkerUsed = isSharedWorkersSupported && !process.env.IS_DEV;\n\n// apply serializers for custom types\nfunction installTransferHandlers() {\n  transferHandlers.set('IPFSContent', IPFSContentTransferHandler);\n}\n\nfunction safeStringify(obj: any): string {\n  try {\n    return JSON.stringify(obj);\n  } catch (error) {\n    return String(obj);\n  }\n}\n\n// Override console.log to send logs to main thread\nfunction overrideLogging(worker: Worker | MessagePort) {\n  const consoleLogMap = {\n    log: { original: console.log },\n    error: { original: console.error },\n    warn: { original: console.warn },\n  };\n  const replaceConsoleLog = (method: keyof typeof consoleLogMap) => {\n    const { original } = consoleLogMap[method];\n\n    consoleLogMap[method].original = console[method];\n\n    console[method] = (...args) => {\n      original.apply(console, args);\n      const serializableArgs = args.map((arg) => safeStringify(arg));\n\n      worker.postMessage({ type: 'console', method, args: serializableArgs });\n    };\n  };\n\n  Object.keys(consoleLogMap).forEach((method) =>\n    replaceConsoleLog(method as keyof typeof consoleLogMap)\n  );\n}\n\n// Install handlers for logging from worker\nfunction installLoggingHandler(worker: Worker | MessagePort, name: string) {\n  // Add event listener\n  worker.addEventListener('message', (event) => {\n    if (event.data.type === 'console') {\n      const { method, args } = event.data;\n\n      console[method](name, ...args);\n    }\n  });\n}\n\n// Create Shared Worker with fallback to usual Worker(in case of DEV too)\nexport function createWorkerApi<T>(\n  workerUrl: URL,\n  workerName: string\n): { worker: WorkerType; workerApiProxy: Remote<T> } {\n  installTransferHandlers();\n  //&& !process.env.IS_DEV\n  if (isSharedWorkerUsed) {\n    const worker = new SharedWorker(workerUrl, { name: workerName });\n    installLoggingHandler(worker.port, workerName);\n    return { worker, workerApiProxy: wrap<T>(worker.port) };\n  }\n\n  const worker = new Worker(workerUrl);\n  // installLoggingHandler(worker, workerName);\n  return { worker, workerApiProxy: wrap<T>(worker) };\n}\n\nexport function exposeWorkerApi<T>(worker: WorkerType, api: T) {\n  installTransferHandlers();\n  if (typeof worker.onconnect !== 'undefined') {\n    worker.onconnect = (e) => {\n      const port = e.ports[0];\n      overrideLogging(port);\n\n      expose(api, port);\n    };\n  } else {\n    // overrideLogging(worker);\n    expose(api);\n  }\n}\n","import { createCyblogChannel } from 'src/utils/logging/cyblog';\nimport {\n  ProgressTracking,\n  SyncEntryName,\n  SyncProgress,\n} from '../types/services';\nimport BroadcastChannelSender from './BroadcastChannelSender';\n\nexport const broadcastStatus = (\n  name: SyncEntryName,\n  channelApi: BroadcastChannelSender\n) => {\n  // const cyblogCh = createCyblogChannel({ thread: 'bckd', module: name });\n  return {\n    sendStatus: (\n      status: SyncProgress['status'],\n      message?: string,\n      progress?: ProgressTracking\n    ) => {\n      // cyblogCh.info(`>>>$ sync ${name} status: ${status} message: ${message}`);\n      channelApi.postSyncEntryProgress(name, {\n        status,\n        message,\n        progress,\n        done: ['active', 'error', 'listen'].some((s) => s === status),\n      });\n    },\n  };\n};\n","async function* arrayToAsyncIterable<T>(array: T[]): AsyncIterable<T> {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const item of array) {\n    yield item;\n  }\n}\n\nasync function asyncIterableBatchProcessor<T, K>(\n  items: AsyncIterable<T> | Iterable<T>,\n  batchProcess: (arg: T[]) => Promise<K>,\n  batchSize = 10\n): Promise<void> {\n  let batch = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of items) {\n    batch.push(item);\n    if (batch.length === batchSize) {\n      await batchProcess(batch);\n      batch = [];\n    }\n  }\n  // process the rest\n  if (batch.length > 0) {\n    await batchProcess(batch);\n  }\n}\n\nasync function asyncIterableToArray<T>(asyncIterable: AsyncIterable<T>) {\n  const resultArray = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of asyncIterable) {\n    resultArray.push(item);\n  }\n  return resultArray;\n}\n// Create a helper function to create AsyncIterable from a list and iterate one by one\nfunction createAsyncIterable<T>(data: T[]): AsyncIterable<T> {\n  let index = 0;\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next(): Promise<IteratorResult<T>> {\n          if (index < data.length) {\n            return Promise.resolve({ done: false, value: data[index++] });\n          }\n          return Promise.resolve({ done: true, value: undefined as any });\n        },\n      };\n    },\n  };\n}\n\nexport {\n  arrayToAsyncIterable,\n  asyncIterableBatchProcessor,\n  asyncIterableToArray,\n  createAsyncIterable,\n};\n","// export const CID_AVATAR = 'Qmf89bXkJH9jw4uaLkHmZkxQ51qGKfUPtAMxA8rTwBrmTs';\nexport const CID_TWEET = 'QmbdH2WBamyKLPE5zu4mJ9v49qvY8BFfoumoVPMR5V4Rvx';\nexport const CID_FOLLOW = 'QmPLSA5oPqYxgc8F7EwrM8WS9vKrr1zPoDniSRFh8HSrxx';\n\nexport const BECH32_PREFIX_ACC_ADDR_CYBER = 'bostrom';\n\nexport const PATTERN_CYBER = new RegExp(\n  `^${BECH32_PREFIX_ACC_ADDR_CYBER}[a-zA-Z0-9]{39}$`,\n  'g'\n);\nexport const PATTERN_IPFS_HASH = /^Qm[a-zA-Z0-9]{44}$/g;\n","import { CID_FOLLOW, CID_TWEET } from 'src/constants/app';\nimport { SyncEntryName } from 'src/services/backend/types/services';\n\nexport const MY_PARTICLES_SYNC_INTERVAL = 5 * 60 * 1000; // 60 sec\nexport const MY_FRIENDS_SYNC_INTERVAL = 5 * 60 * 1000; // 60 sec\nexport const IPFS_SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutes\n\nexport const MAX_DATABASE_PUT_SIZE = 500;\n\nexport const MAX_LINKS_RESOLVE_BATCH = 20;\n\nexport const DAY_IN_MS = 24 * 60 * 60 * 1000;\n\nexport const SENSE_FRIEND_PARTICLES = [CID_TWEET, CID_FOLLOW];\n\nexport const SYNC_ENTRIES_TO_TRACK_PROGRESS = [\n  'my-friends',\n  'particles',\n  'transactions',\n] as SyncEntryName[];\n","import {\n  BehaviorSubject,\n  Observable,\n  filter,\n  mergeMap,\n  tap,\n  map,\n  combineLatest,\n  share,\n  EMPTY,\n} from 'rxjs';\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { broadcastStatus } from 'src/services/backend/channels/broadcastStatus';\nimport { ParticleCid } from 'src/types/base';\nimport { SyncQueueStatus } from 'src/services/CozoDb/types/entities';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\n\nimport DbApi from '../../../dataSource/indexedDb/dbApiWrapper';\n\nimport { FetchIpfsFunc } from '../../types';\nimport { ServiceDeps } from '../types';\nimport { SyncQueueItem } from './types';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\n\nconst QUEUE_BATCH_SIZE = 100;\n\nclass ParticlesResolverQueue {\n  public isInitialized$: Observable<boolean>;\n\n  private db: DbApi | undefined;\n\n  private waitForParticleResolve: FetchIpfsFunc;\n\n  private statusApi = broadcastStatus('resolver', new BroadcastChannelSender());\n\n  private _syncQueue$ = new BehaviorSubject<Map<ParticleCid, SyncQueueItem>>(\n    new Map()\n  );\n\n  public get queue(): Map<ParticleCid, SyncQueueItem> {\n    return this._syncQueue$.getValue();\n  }\n\n  private _loop$: Observable<any> | undefined;\n\n  public get loop$(): Observable<any> | undefined {\n    return this._loop$;\n  }\n\n  constructor(deps: ServiceDeps) {\n    if (!deps.waitForParticleResolve) {\n      throw new Error('waitForParticleResolve is not defined');\n    }\n\n    this.waitForParticleResolve = deps.waitForParticleResolve;\n\n    deps.dbInstance$.subscribe(async (db) => {\n      this.db = db;\n      await this.loadSyncQueue();\n    });\n\n    this.isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.ipfsInstance$,\n    ]).pipe(\n      map(([dbInstance, ipfsInstance]) => !!ipfsInstance && !!dbInstance)\n    );\n  }\n\n  private async processSyncQueue(pendingItems: SyncQueueItem[]) {\n    // console.log('------processSyncQueue ', pendingItems);\n\n    const batchSize = pendingItems.length;\n\n    this.statusApi.sendStatus(\n      'in-progress',\n      `processing batch ${batchSize}/${batchSize} batch. ${this.queue.size} pending...`\n    );\n\n    let i = batchSize;\n    await Promise.all(\n      pendingItems.map(async (item) => {\n        const { id } = item;\n        // eslint-disable-next-line no-await-in-loop\n        return this.waitForParticleResolve(id, QueuePriority.MEDIUM).then(\n          async (result) => {\n            if (result.status === 'not_found') {\n              await this.db!.updateSyncQueue({\n                id,\n                status: SyncQueueStatus.error,\n              });\n            } else {\n              await this.db!.removeSyncQueue(id);\n            }\n\n            const queue = this._syncQueue$.value;\n            queue.delete(id);\n            i--;\n            this._syncQueue$.next(queue);\n\n            this.statusApi.sendStatus(\n              'in-progress',\n              `processing batch ${batchSize - i}/${batchSize} batch. ${\n                this.queue.size\n              } pending...`\n            );\n          }\n        );\n      })\n    );\n  }\n\n  start() {\n    const source$ = this.isInitialized$.pipe(\n      tap((q) => console.log(`sync queue isInitialized - ${q}`)),\n      filter((isInitialized) => isInitialized === true),\n      mergeMap(() => this._syncQueue$), // Merge the queue$ stream here.\n      // tap((q) => console.log(`sync queue - ${q.size}`)),\n      filter((q) => q.size > 0),\n      mergeMap((queue) => {\n        const list = [...queue.values()];\n\n        const executingCount = list.filter(\n          (i) => i.status === SyncQueueStatus.executing\n        ).length;\n\n        const batchSize = QUEUE_BATCH_SIZE - executingCount;\n\n        if (batchSize > 0) {\n          const pendingItems = list\n            .filter((i) => i.status === SyncQueueStatus.pending)\n            .sort((a, b) => {\n              return a.priority - b.priority;\n            })\n            .slice(0, batchSize);\n\n          if (pendingItems.length > 0) {\n            pendingItems.forEach((i) => {\n              queue.set(i.id, {\n                ...i,\n                status: SyncQueueStatus.executing,\n              });\n            });\n\n            this._syncQueue$.next(queue);\n\n            this.statusApi.sendStatus('in-progress', `starting...`);\n            return this.processSyncQueue(pendingItems);\n          }\n        }\n\n        return EMPTY;\n      })\n    );\n\n    this._loop$ = source$.pipe(share());\n\n    this._loop$.subscribe({\n      next: (result) => {\n        this.statusApi.sendStatus('active');\n      },\n      error: (err) => this.statusApi.sendStatus('error', err.toString()),\n    });\n\n    return this;\n  }\n\n  public async fetchDirect(cid: ParticleCid) {\n    return this.waitForParticleResolve(cid, QueuePriority.URGENT);\n  }\n\n  public async enqueueBatch(cids: ParticleCid[], priority: QueuePriority) {\n    return asyncIterableBatchProcessor(\n      cids,\n      (cids) =>\n        this.enqueue(\n          cids.map((cid) => ({\n            id: cid /* from is tweet */,\n            priority,\n          }))\n        ),\n      MAX_DATABASE_PUT_SIZE\n    );\n  }\n\n  public async enqueue(items: SyncQueueItem[]) {\n    if (items.length === 0) {\n      return;\n    }\n    await this.db!.putSyncQueue(items);\n    const queue = this._syncQueue$.value;\n\n    items.forEach((item) =>\n      queue.set(item.id, { ...item, status: SyncQueueStatus.pending })\n    );\n    this._syncQueue$.next(queue);\n  }\n\n  private async loadSyncQueue() {\n    const queue = await this.db!.getSyncQueue({\n      statuses: [SyncQueueStatus.pending],\n    }).then((items) => new Map(items.map((item) => [item.id, item])));\n\n    this._syncQueue$.next(new Map([...queue, ...this.queue]));\n  }\n}\n\nexport default ParticlesResolverQueue;\n","import dateFormat from 'dateformat';\n\nexport const numberToUtcDate = (timestamp: number) =>\n  dateFormat(new Date(timestamp), 'yyyy-mm-dd\"T\"HH:MM:ss.l', true);\n\nexport const dateToUtcNumber = (isoString: string) =>\n  Date.parse(isoString.endsWith('Z') ? isoString : `${isoString}Z`);\n\nexport const getNowUtcNumber = (): number => {\n  return Date.now(); //dateToUtcNumber(new Date().toISOString());\n};\n//\nfunction roundMilliseconds(dateTimeString: string) {\n  const date = new Date(dateTimeString);\n  const roundedMilliseconds = Math.round(date.getMilliseconds() / 1000) * 1000;\n  date.setMilliseconds(roundedMilliseconds);\n  return dateFormat(date, 'yyyy-mm-dd\"T\"HH:MM:ss.l');\n}\nfunction getCurrentTimezoneOffset() {\n  const now = new Date();\n  return -now.getTimezoneOffset() / 60;\n}\n\nfunction numberToDateWithTimezone(timestamp: number, timezoneOffset?: number) {\n  // Convert timestamp from milliseconds to a Date object\n  const date = new Date(timestamp);\n\n  const tzOffset = timezoneOffset || getCurrentTimezoneOffset();\n  console.log('---tzOffset', tzOffset);\n  // Adjust the date for the timezone offset\n  // The timezoneOffset is in hours for the target timezone relative to UTC\n  const localTime = date.getTime();\n  const localOffset = date.getTimezoneOffset() * 60000; // in milliseconds\n  const utc = localTime + localOffset;\n  const timezoneDate = new Date(utc + 3600000 * tzOffset);\n\n  // Format the date using dateFormat\n  return dateFormat(timezoneDate, 'yyyy-mm-dd HH:MM:ss');\n}\n\nfunction pluralizeUnit(quantity: number, unit: string): string {\n  return quantity === 1 ? unit : `${unit}s`;\n}\n\nconst minuteInMs = 60000; // 60 seconds * 1000 milliseconds\nconst hourInMs = 3600000; // 60 minutes * 60 seconds * 1000 milliseconds\nconst dayInMs = 86400000; // 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\n\nfunction convertTimestampToString(timestamp: number): string {\n  if (timestamp < minuteInMs) {\n    const seconds = Math.floor(timestamp / 1000);\n    return `${seconds} ${pluralizeUnit(seconds, 'second')}`;\n  }\n  if (timestamp < hourInMs) {\n    const minutes = Math.floor(timestamp / minuteInMs);\n    return `${minutes} ${pluralizeUnit(minutes, 'minute')}`;\n  }\n  if (timestamp < dayInMs) {\n    const hours = Math.floor(timestamp / hourInMs);\n    return `${hours} ${pluralizeUnit(hours, 'hour')}`;\n  }\n\n  const days = Math.floor(timestamp / dayInMs);\n  return `${days} ${pluralizeUnit(days, 'day')}`;\n}\n\nexport {\n  roundMilliseconds,\n  numberToDateWithTimezone,\n  convertTimestampToString,\n};\n","import { LsResult } from 'ipfs-core-types/src/pin';\nimport { dateToUtcNumber } from 'src/utils/date';\nimport { NeuronAddress, ParticleCid, TransactionHash } from 'src/types/base';\nimport { IPFSContent } from '../ipfs/ipfs';\nimport { LinkDbEntity, PinTypeMap } from './types/entities';\nimport { Transaction } from '../backend/services/indexer/types';\nimport { LinkDto, ParticleDto, PinDto, TransactionDto } from './types/dto';\nimport { CyberlinksByParticleResponse } from '../backend/services/dataSource/blockchain/indexer';\n\nexport const mapParticleToEntity = (particle: IPFSContent): ParticleDto => {\n  const { cid, result, meta, textPreview } = particle;\n  const { size, mime, type, blocks, sizeLocal } = meta;\n  // hack to fix string command\n  const text = textPreview?.replace(/\"/g, \"'\") || '';\n  return {\n    cid,\n    size: size || 0,\n    mime: mime || 'unknown',\n    type,\n    text,\n    size_local: sizeLocal || -1,\n    blocks: blocks || 0,\n  };\n};\n\n//TODO: REFACTOR\nexport const mapPinToEntity = (pin: LsResult): PinDto => ({\n  cid: pin.cid.toString(),\n  type: PinTypeMap[pin.type],\n});\n\nexport const mapIndexerTransactionToEntity = (\n  neuron: string,\n  tx: Transaction\n): TransactionDto => {\n  const {\n    transaction_hash,\n    index,\n    transaction: {\n      memo,\n      block: { timestamp, height },\n      success,\n    },\n    type,\n    value,\n  } = tx;\n  return {\n    hash: transaction_hash,\n    index,\n    type,\n    timestamp: dateToUtcNumber(timestamp),\n    // value: JSON.stringify(value),\n    memo,\n    value,\n    success,\n    neuron,\n    blockHeight: height,\n  };\n};\n\n// export const mapSyncStatusToEntity = (\n//   id: NeuronAddress | ParticleCid,\n//   entryType: EntryType,\n//   unreadCount: number,\n//   timestampUpdate: number,\n//   lastId: TransactionHash | ParticleCid = '',\n//   timestampRead: number = timestampUpdate,\n//   meta: Object = {}\n// ): SyncStatusDbEntity => {\n//   return {\n//     entry_type: entryType,\n//     id,\n//     timestamp_update: timestampUpdate,\n//     timestamp_read: timestampRead,\n//     unread_count: unreadCount,\n//     disabled: false,\n//     last_id: lastId,\n//     meta,\n//   };\n// };\n\nexport const mapLinkToEntity = (\n  from: ParticleCid,\n  to: ParticleCid,\n  neuron: NeuronAddress = '',\n  timestamp: number = 0\n): LinkDbEntity => ({\n  from,\n  to,\n  neuron,\n  timestamp,\n});\n\nexport const mapLinkFromIndexerToDto = ({\n  from,\n  to,\n  neuron,\n  timestamp,\n  transaction_hash,\n}: CyberlinksByParticleResponse['cyberlinks'][0]): LinkDto => ({\n  from,\n  to,\n  neuron,\n  timestamp: dateToUtcNumber(timestamp),\n  transactionHash: transaction_hash,\n});\n","export async function waitUntil(cond: () => boolean, timeoutDuration = 60000) {\n  if (cond()) {\n    return true;\n  }\n\n  const waitPromise = new Promise((resolve) => {\n    const interval = setInterval(() => {\n      if (cond()) {\n        clearInterval(interval);\n        resolve(true);\n      }\n    }, 10);\n  });\n\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error('waitUntil timed out!'));\n    }, timeoutDuration);\n  });\n\n  return Promise.race([waitPromise, timeoutPromise]);\n}\n\nexport function executeSequentially<T>(\n  promiseFunctions: (() => Promise<T>)[]\n): Promise<T[]> {\n  return promiseFunctions.reduce((promiseChain, currentFunction) => {\n    return promiseChain.then((chainResults) =>\n      currentFunction().then((currentResult) => [\n        ...chainResults,\n        currentResult,\n      ])\n    );\n  }, Promise.resolve([] as T[]));\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport function makeCancellable<T extends (...args: any[]) => Promise<any>>(\n  func: T,\n  signal: AbortSignal\n): (...funcArgs: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    // Promise that listens for the abort signal\n    const abortPromise = new Promise<ReturnType<T>>((_, reject) => {\n      const abortHandler = () => {\n        signal.removeEventListener('abort', abortHandler); // Clean up the event listener\n        reject(new DOMException('The operation was aborted.', 'AbortError'));\n      };\n      signal.addEventListener('abort', abortHandler, { once: true });\n    });\n\n    // Wrapping the original function in a promise\n    const taskPromise = new Promise<ReturnType<T>>(async (resolve, reject) => {\n      try {\n        const result = await func(...args);\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n\n    // Using Promise.race to handle cancellation\n    return Promise.race([taskPromise, abortPromise]);\n  };\n}\n\nexport function throwIfAborted<T extends (...args: any[]) => Promise<any>>(\n  func: T,\n  signal: AbortSignal\n): (...funcArgs: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    if (signal.aborted) {\n      throw new DOMException('The operation was aborted.', 'AbortError');\n    }\n    return func(...args);\n  };\n}\n","export const CYBER_NODE_URL_LCD =\n  process.env.CYBER_NODE_URL_LCD || 'https://lcd.bostrom.cybernode.ai';\nexport const CYBER_INDEX_HTTPS =\n  process.env.CYBER_INDEX_HTTPS ||\n  'https://index.bostrom.cybernode.ai/v1/graphql';\n\nexport const CYBER_INDEX_WSS =\n  process.env.CYBER_INDEX_WSS || 'wss://index.bostrom.cybernode.ai/v1/graphql';\n\nexport const CYBER_NODE_URL_WS =\n  process.env.CYBER_NODE_URL_WS || 'wss://rpc.bostrom.cybernode.ai/websocket';\n","import { Coin } from 'cosmjs-types/cosmos/base/v1beta1/coin';\nimport { CyberLinkSimple, NeuronAddress } from 'src/types/base';\n\ninterface GenericIndexerTransaction<T> {\n  value: T;\n  type: string;\n  transaction_hash: string;\n  index: number;\n  transaction: {\n    memo?: string;\n    success: boolean;\n    block: {\n      timestamp: string;\n    };\n  };\n}\nexport const MSG_SEND_TRANSACTION_TYPE = 'cosmos.bank.v1beta1.MsgSend';\n\nexport const MSG_MULTI_SEND_TRANSACTION_TYPE =\n  'cosmos.bank.v1beta1.MsgMultiSend';\n\nexport const CYBER_LINK_TRANSACTION_TYPE = 'cyber.graph.v1beta1.MsgCyberlink';\n\nconst DELEGATION_TRANSACTION_TYPE = 'cosmos.staking.v1beta1.MsgDelegate';\n\ninterface Input {\n  address: NeuronAddress;\n  coins: Coin[];\n}\n\ninterface Output {\n  address: NeuronAddress;\n  coins: Coin[];\n}\n\nexport interface MsgMultiSendValue {\n  inputs: Input[];\n  outputs: Output[];\n}\n\nexport interface MsgSendValue {\n  amount: Coin[];\n  from_address: NeuronAddress;\n  to_address: NeuronAddress;\n}\n\ninterface MsgDelegateValue {\n  amount: Coin;\n  delegator_address: NeuronAddress;\n  validator_address: NeuronAddress;\n}\n\nexport interface CyberLinkValue {\n  neuron: NeuronAddress;\n  links: CyberLinkSimple[];\n}\n\ninterface DelegateTransaction\n  extends GenericIndexerTransaction<MsgDelegateValue> {\n  type: typeof DELEGATION_TRANSACTION_TYPE;\n}\n\nexport interface CyberLinkTransaction\n  extends GenericIndexerTransaction<CyberLinkValue> {\n  type: typeof CYBER_LINK_TRANSACTION_TYPE;\n}\n\nexport interface MsgMultiSendTransaction\n  extends GenericIndexerTransaction<MsgMultiSendValue> {\n  type: typeof MSG_MULTI_SEND_TRANSACTION_TYPE;\n}\n\nexport interface MsgSendTransaction\n  extends GenericIndexerTransaction<MsgSendValue> {\n  type: typeof MSG_SEND_TRANSACTION_TYPE;\n}\n\nexport type Transaction =\n  // | DelegateTransaction\n  CyberLinkTransaction | MsgMultiSendTransaction | MsgSendTransaction;\n\nexport type GqlType = 'query' | 'subscription';\n","import { Tx } from 'cosmjs-types/cosmos/tx/v1beta1/tx';\nimport { MsgSend, MsgMultiSend } from 'cosmjs-types/cosmos/bank/v1beta1/tx';\n\nimport { fromBase64 } from '@cosmjs/encoding';\nimport {\n  MSG_MULTI_SEND_TRANSACTION_TYPE,\n  MSG_SEND_TRANSACTION_TYPE,\n} from 'src/services/backend/services/indexer/types';\nimport { NeuronAddress } from 'src/types/base';\nimport { TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { getNowUtcNumber } from 'src/utils/date';\n\n// eslint-disable-next-line import/no-unused-modules\nexport const extractTxData = (data: string) => {\n  const result = Tx.decode(fromBase64(data));\n  const memo = result.body?.memo;\n  const messages = result.body?.messages\n    .map((message) => {\n      const msgType = message.typeUrl.slice(1);\n      if (msgType === MSG_SEND_TRANSACTION_TYPE) {\n        return MsgSend.decode(message.value);\n      }\n\n      if (msgType === MSG_MULTI_SEND_TRANSACTION_TYPE) {\n        return MsgMultiSend.decode(message.value);\n      }\n      return undefined;\n    })\n    .filter((message) => message !== undefined);\n\n  return { memo, messages };\n};\n\n// eslint-disable-next-line import/no-unused-modules\nexport const mapWebsocketTxToTransactions = (\n  neuron: NeuronAddress,\n  result: any\n) => {\n  const { data, events } = result;\n\n  const hash = events['tx.hash'][0];\n  const transactionType = events['message.action'][0].slice(1);\n  const timestamp = getNowUtcNumber();\n  const blockHeight = events['tx.height'][0];\n\n  const { memo = '', messages } = extractTxData(data.value.TxResult.tx);\n\n  const transactions: TransactionDto[] = [];\n  messages!.forEach((message, index) => {\n    transactions.push({\n      hash,\n      index,\n      type: transactionType,\n      timestamp,\n      success: true,\n      value: message!,\n      memo,\n      neuron,\n      blockHeight,\n    });\n  });\n\n  return transactions;\n};\n","// eslint-disable-next-line import/prefer-default-export\nexport async function* fetchIterable<T, P>(\n  fetchFunction: (params: P & { offset: number }) => Promise<T[]>,\n  params: P\n): AsyncGenerator<T[], void, undefined> {\n  let offset = 0;\n  while (true) {\n    // eslint-disable-next-line no-await-in-loop\n    const items = await fetchFunction({ ...params, offset });\n\n    if (items.length === 0) {\n      break;\n    }\n\n    yield items;\n\n    offset += items.length;\n  }\n}\n","import { ApolloClient, DocumentNode, InMemoryCache } from '@apollo/client';\n\nimport {\n  GraphQLWsLink,\n  Observable as ApolloObservable,\n} from '@apollo/client/link/subscriptions';\nimport { GraphQLClient } from 'graphql-request';\nimport { createClient } from 'graphql-ws';\nimport { Observable } from 'rxjs';\nimport { CYBER_INDEX_HTTPS, CYBER_INDEX_WSS } from 'src/constants/config';\n\nconst cyberGraphQLWsLink = new GraphQLWsLink(\n  createClient({\n    url: CYBER_INDEX_WSS,\n    shouldRetry: (errOrCloseEvent: unknown) => true,\n    retryAttempts: 10,\n    retryWait: async (retries: number): Promise<void> => {\n      setTimeout(() => Promise.resolve(), Math.min(1000 * 2 ** retries, 10000));\n    },\n    // on: {\n    //   error: (err) => {\n    //     console.log('---ws errr', err);\n    //   },\n    //   message: (msg) => {\n    //     console.log('---ws message', msg);\n    //   },\n    //   // Handle connection opened event\n    //   opened: () => {\n    //     console.log('---ws opened');\n    //   },\n    //   // Handle connection closed event\n    //   closed: () => {\n    //     console.log('---ws closed');\n    //   },\n    // },\n  })\n);\n\nexport const createIndexerClient = (abortSignal: AbortSignal) =>\n  new GraphQLClient(CYBER_INDEX_HTTPS, {\n    signal: abortSignal,\n  });\n\n// eslint-disable-next-line import/no-unused-modules\nexport function createIndexerWebsocket<T>(\n  query: DocumentNode,\n  variables: object\n): Observable<T> {\n  const client = new ApolloClient({\n    link: cyberGraphQLWsLink,\n    cache: new InMemoryCache(),\n  });\n  const apolloObservable = client.subscribe({ query, variables });\n  return new Observable((subscriber) => {\n    const subscription = apolloObservable.subscribe({\n      next(result) {\n        subscriber.next(result.data as T);\n      },\n      error(err) {\n        subscriber.error(err);\n      },\n      complete() {\n        subscriber.complete();\n      },\n    });\n\n    // Cleanup subscription on unsubscribe\n    return () => subscription.unsubscribe();\n  });\n}\n","/* eslint-disable import/no-unused-modules */\nimport { request } from 'graphql-request';\n\nimport { gql } from '@apollo/client';\n\nimport { Cyberlink, ParticleCid, NeuronAddress } from 'src/types/base';\nimport { dateToUtcNumber, numberToUtcDate } from 'src/utils/date';\nimport { CYBER_INDEX_HTTPS } from 'src/constants/config';\n\nimport { CYBERLINKS_BATCH_LIMIT } from './consts';\nimport { fetchIterable } from './utils/fetch';\nimport { createIndexerClient } from '../../indexer/utils';\n\ntype CyberlinksCountResponse = {\n  cyberlinks_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n};\n\ntype CyberlinksSyncStatsResponse = {\n  cyberlinks_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n  first: {\n    timestamp: string;\n  }[];\n  last: {\n    timestamp: string;\n    to: ParticleCid;\n    from: ParticleCid;\n  }[];\n};\n\nexport type CyberlinksByParticleResponse = {\n  cyberlinks: (Omit<Cyberlink, 'timestamp'> & {\n    timestamp: string;\n    neuron: NeuronAddress;\n    transaction_hash: string;\n  })[];\n};\nconst cyberlinksByParticle = gql(`\nquery Cyberlinks($limit: Int, $offset: Int, $orderBy: [cyberlinks_order_by!], $where: cyberlinks_bool_exp) {\n  cyberlinks(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {\n    from: particle_from\n    to: particle_to\n    timestamp\n    neuron\n    transaction_hash\n  }\n}\n`);\n\nconst cyberlinksSyncStats = gql(`\n  query Cyberlinks($where: cyberlinks_bool_exp) {\n    cyberlinks_aggregate(where: $where) {\n      aggregate {\n        count\n      }\n    }\n    first: cyberlinks(limit: 1, order_by: { timestamp: asc }, where: $where) {\n      timestamp\n    }\n    last: cyberlinks(limit: 1, order_by: { timestamp: desc }, where: $where) {\n      timestamp,\n      to: particle_to,\n      from: particle_from\n    }\n  }\n`);\n\nconst cyberlinksCountByNeuron = gql(`\n  query MyQuery($address: String, $particles_from: [String!], $timestamp: timestamp) {\n    cyberlinks_aggregate(where: {\n        _and: [\n          { neuron: {_eq: $address}},\n          { particle_from: {_in: $particles_from}},\n          { timestamp: {_gt: $timestamp}}\n        ]\n      }) {\n      aggregate {\n        count\n      }\n    }\n  }\n  `);\n\nconst fetchCyberlinks = async ({\n  particleCid,\n  timestampFrom,\n  offset = 0,\n  abortSignal,\n}: {\n  particleCid: ParticleCid;\n  timestampFrom: number;\n  offset?: number;\n  abortSignal: AbortSignal;\n}) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksByParticleResponse>(cyberlinksByParticle, {\n    limit: CYBERLINKS_BATCH_LIMIT,\n    offset,\n    orderBy: [\n      {\n        timestamp: 'asc',\n      },\n    ],\n    where: {\n      _or: [\n        {\n          particle_to: {\n            _eq: particleCid,\n          },\n        },\n        {\n          particle_from: {\n            _eq: particleCid,\n          },\n        },\n      ],\n      timestamp: {\n        _gt: numberToUtcDate(timestampFrom),\n      },\n    },\n  });\n  return res.cyberlinks;\n};\n\nconst fetchCyberlinksCount = async (\n  address: NeuronAddress,\n  particlesFrom: ParticleCid[],\n  timestampFrom: number,\n  abortSignal?: AbortSignal\n) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksCountResponse>(cyberlinksCountByNeuron, {\n    address,\n    particles_from: particlesFrom,\n    timestamp: numberToUtcDate(timestampFrom),\n  });\n\n  return res?.cyberlinks_aggregate.aggregate.count;\n};\n\nconst fetchCyberlinksByNeroun = async ({\n  neuron,\n  particlesFrom,\n  timestampFrom,\n  batchSize,\n  offset = 0,\n  abortSignal,\n}: {\n  neuron: NeuronAddress;\n  particlesFrom: ParticleCid[];\n  timestampFrom: number;\n  batchSize: number;\n  offset?: number;\n  abortSignal?: AbortSignal;\n}) => {\n  const where = {\n    _and: [\n      {\n        timestamp: {\n          _gt: numberToUtcDate(timestampFrom),\n        },\n      },\n      {\n        neuron: {\n          _eq: neuron,\n        },\n      },\n      { particle_from: { _in: particlesFrom } },\n    ],\n  };\n\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksByParticleResponse>(cyberlinksByParticle, {\n    limit: batchSize,\n    offset,\n    orderBy: [\n      {\n        timestamp: 'asc',\n      },\n    ],\n    where,\n  });\n\n  return res.cyberlinks;\n};\n\nexport const fetchCyberlinksByNerounIterable = async (\n  neuron: NeuronAddress,\n  particlesFrom: ParticleCid[],\n  timestampFrom: number,\n  batchSize: number,\n  abortSignal?: AbortSignal\n) =>\n  fetchIterable(fetchCyberlinksByNeroun, {\n    neuron,\n    particlesFrom,\n    timestampFrom,\n    batchSize,\n    abortSignal,\n  });\n\nconst fetchCyberlinksIterable = (\n  particleCid: ParticleCid,\n  timestampFrom: number,\n  abortSignal: AbortSignal\n) =>\n  fetchIterable(fetchCyberlinks, { particleCid, timestampFrom, abortSignal });\n\nexport { fetchCyberlinksIterable, fetchCyberlinksCount };\n","const TRANSACTIONS_BATCH_LIMIT = 500;\nconst CYBERLINKS_BATCH_LIMIT = 200;\n\nexport { TRANSACTIONS_BATCH_LIMIT, CYBERLINKS_BATCH_LIMIT };\n","import { CyberLinkSimple, CyberlinkTxHash, ParticleCid } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { CID_TWEET } from 'src/constants/app';\nimport { LinkDto, TransactionDto } from 'src/services/CozoDb/types/dto';\n\nimport { fetchCyberlinksIterable } from '../../../dataSource/blockchain/indexer';\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { MAX_LINKS_RESOLVE_BATCH } from '../consts';\nimport {\n  CYBER_LINK_TRANSACTION_TYPE,\n  CyberLinkValue,\n} from '../../../indexer/types';\n\nconst getUniqueParticlesFromLinks = (links: CyberLinkSimple[]) =>\n  [\n    ...new Set([\n      ...links.map((link) => link.to),\n      ...links.map((link) => link.from),\n    ]),\n  ] as ParticleCid[];\n\n// eslint-disable-next-line import/no-unused-modules\nexport const fetchCyberlinksAndResolveParticles = async (\n  cid: ParticleCid,\n  timestampUpdate: number,\n  particlesResolver: ParticlesResolverQueue,\n  queuePriority: QueuePriority,\n  abortSignal: AbortSignal\n) => {\n  const cyberlinksIterable = fetchCyberlinksIterable(\n    cid,\n    timestampUpdate,\n    abortSignal\n  );\n  const links = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const batch of cyberlinksIterable) {\n    links.push(...batch);\n    const particles = getUniqueParticlesFromLinks(batch);\n    if (particles.length > 0) {\n      await asyncIterableBatchProcessor(\n        particles,\n        (cids: ParticleCid[]) =>\n          particlesResolver!.enqueueBatch(cids, queuePriority),\n        MAX_LINKS_RESOLVE_BATCH\n      );\n    }\n  }\n\n  return links;\n};\n\nexport function extractCybelinksFromTransaction(batch: TransactionDto[]) {\n  const cyberlinks = batch.filter(\n    (l) => l.type === CYBER_LINK_TRANSACTION_TYPE\n  );\n  const particlesFound = new Set<string>();\n  const links: LinkDto[] = [];\n  // Get links: only from TWEETS\n  const tweets: Record<ParticleCid, LinkDto> = cyberlinks.reduce<\n    Record<ParticleCid, LinkDto>\n  >((acc, { value, hash, timestamp }: TransactionDto) => {\n    (value as CyberLinkValue).links.forEach((link) => {\n      particlesFound.add(link.to);\n      particlesFound.add(link.from);\n      const txLink = {\n        ...link,\n        timestamp,\n        neuron: (value as CyberLinkValue).neuron,\n        transactionHash: hash,\n      };\n      links.push(txLink);\n\n      if (link.from === CID_TWEET) {\n        acc[txLink.to] = txLink;\n      }\n    });\n    return acc;\n  }, {});\n\n  return {\n    tweets,\n    particlesFound: [...particlesFound],\n    links,\n  };\n}\n","import { NeuronAddress } from 'src/types/base';\nimport { GqlType, Transaction } from './types';\n\nimport { gql } from '@apollo/client';\n\nimport { numberToUtcDate } from 'src/utils/date';\nimport {\n  MessagesByAddressVariables,\n  gqlMessagesByAddress,\n} from '../../indexer/transactions';\nimport {\n  TransactionsByAddressResponse,\n  fetchTransactions,\n} from './transactions';\nimport { createIndexerClient } from './utils';\nimport {\n  MessagesByAddressVariables,\n  gqlMessagesByAddress,\n} from './transactions';\nimport { camelToSnake } from 'src/utils/dto';\nimport { fetchIterable } from '../dataSource/blockchain/utils/fetch';\n\ntype OrderDirection = 'desc' | 'asc';\ntype Abortable = { abortSignal?: AbortSignal };\n\nexport type MessagesByAddressVariables = {\n  neuron: NeuronAddress;\n  timestampFrom: number;\n  offset?: number;\n  types: Transaction['type'][];\n  orderDirection: OrderDirection;\n  limit: number;\n} & Abortable;\n\nexport const mapMessagesByAddressVariables = ({\n  neuron,\n  timestampFrom,\n  offset = 0,\n  types = [],\n  orderDirection = 'desc',\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) => ({\n  address: `{${neuron}}`,\n  limit,\n  timestamp_from: numberToUtcDate(timestampFrom),\n  offset,\n  types: `{${types.map((t) => `\"${t}\"`).join(' ,')}}`,\n  order_direction: orderDirection,\n});\n\nexport const gqlMessagesByAddress = (type: GqlType) =>\n  gql(`\n${type} MyQuery($address: _text, $limit: bigint, $offset: bigint, $timestamp_from: timestamp, $types: _text, $order_direction: order_by) {\n  messages_by_address(\n    args: {addresses: $address, limit: $limit, offset: $offset, types: $types},\n    order_by: {transaction: {block: {timestamp: $order_direction}}},\n    where: {transaction: {block: {timestamp: {_gt: $timestamp_from}}}}\n    ) {\n    transaction_hash\n    index\n    value\n    transaction {\n      success\n      block {\n        timestamp,\n        height\n      }\n      memo\n    }\n    type\n  }\n}\n`);\n\nconst fetchTransactions = async ({\n  neuron,\n  timestampFrom,\n  offset = 0,\n  types = [],\n  orderDirection = 'desc',\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<TransactionsByAddressResponse>(\n    gqlMessagesByAddress('query'),\n    mapMessagesByAddressVariables({\n      neuron,\n      timestampFrom,\n      offset,\n      types,\n      orderDirection,\n      limit,\n      abortSignal,\n    })\n  );\n\n  return res?.messages_by_address;\n};\n\nexport type TransactionsByAddressResponse = {\n  messages_by_address: Transaction[];\n};\ntype MessagesCountResponse = {\n  messages_by_address_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n};\nconst transactionsCountByNeuron = gql(`\n  query MyQuery($address: _text, $timestamp: timestamp) {\n    messages_by_address_aggregate(\n      args: {addresses: $address, limit: \"100000000\", offset: \"0\", types: \"{}\"},\n      where: {transaction: {block: {timestamp: {_gt: $timestamp}}}}) {\n        aggregate {\n          count\n        }\n      }\n  }\n  `);\nexport const fetchTransactionMessagesCount = async (\n  address: NeuronAddress,\n  timestampFrom: number,\n  abortSignal: AbortSignal\n) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<MessagesCountResponse>(transactionsCountByNeuron, {\n    address: `{${address}}`,\n    timestamp: numberToUtcDate(timestampFrom),\n  });\n\n  return res?.messages_by_address_aggregate.aggregate.count;\n};\n\nexport const fetchTransactionsIterable = ({\n  neuron,\n  timestampFrom,\n  types,\n  orderDirection,\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) =>\n  fetchIterable(fetchTransactions, {\n    neuron,\n    timestampFrom,\n    types,\n    orderDirection,\n    limit,\n    abortSignal,\n  });\n","import { TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { SenseChat } from 'src/services/backend/types/sense';\nimport { NeuronAddress } from 'src/types/base';\nimport { Coin } from 'cosmjs-types/cosmos/base/v1beta1/coin';\n\nimport {\n  MSG_SEND_TRANSACTION_TYPE,\n  MSG_MULTI_SEND_TRANSACTION_TYPE,\n  MsgSendTransaction,\n} from '../../../indexer/types';\n\nexport const extractSenseChats = (\n  myAddress: NeuronAddress,\n  transactions: TransactionDto[]\n) => {\n  const sendTransactions =\n    transactions!.filter(\n      (t) =>\n        t.type === MSG_SEND_TRANSACTION_TYPE ||\n        t.type === MSG_MULTI_SEND_TRANSACTION_TYPE\n    ) || [];\n\n  if (sendTransactions.length === 0) {\n    return [];\n  }\n  const chats = new Map<NeuronAddress, SenseChat>();\n  transactions.forEach((t) => {\n    let userAddress = '';\n    if (t.type === MSG_MULTI_SEND_TRANSACTION_TYPE) {\n      const { inputs, outputs } = t.value;\n      const isSender = inputs.find((i) => i.address === myAddress);\n      const userMessages = isSender ? outputs : inputs;\n      userMessages.forEach((msg) =>\n        updateSenseChat(chats, msg.address, t, msg.coins, isSender)\n      );\n    } else if (t.type === MSG_SEND_TRANSACTION_TYPE) {\n      const { fromAddress, toAddress, amount } =\n        t.value as MsgSendTransaction['value'];\n      const isSender = fromAddress === myAddress;\n      userAddress = isSender ? toAddress : fromAddress;\n      updateSenseChat(chats, userAddress, t, amount, isSender);\n    }\n  });\n\n  return chats;\n};\n\nconst updateSenseChat = (\n  chats: Map<NeuronAddress, SenseChat>,\n  addr: string,\n  t: TransactionDto,\n  amount: Coin[],\n  isSender: boolean\n): Map<string, SenseChat> => {\n  const chat = chats.get(addr);\n  const transactions = chat?.transactions || [];\n\n  transactions.push(t);\n  chats.set(addr, {\n    userAddress: addr,\n    lastSendTimestamp: isSender ? t.timestamp : chat?.lastSendTimestamp || 0,\n    last: { amount, memo: t.memo, direction: isSender ? 'to' : 'from' },\n    transactions,\n  });\n  return chats;\n};\n","import { EntryType } from 'src/services/CozoDb/types/entities';\nimport DbApiWrapper from 'src/services/backend/services/dataSource/indexedDb/dbApiWrapper';\nimport { NeuronAddress } from 'src/types/base';\nimport {\n  SenseListItem,\n  SenseTransactionMeta,\n} from 'src/services/backend/types/sense';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport { extractSenseChats } from '../../utils/sense';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const syncMyChats = async (\n  db: DbApiWrapper,\n  myAddress: NeuronAddress,\n  timestampFrom: number,\n  signal: AbortSignal,\n  shouldUpdateTimestamp = true\n) => {\n  const syncItems = await db.findSyncStatus({\n    ownerId: myAddress,\n    entryType: EntryType.chat,\n  });\n\n  const syncItemsMap = new Map(syncItems?.map((i) => [i.id, i]));\n\n  const myTransactions = await db.getTransactions(myAddress, {\n    order: 'asc',\n    timestampFrom,\n  });\n\n  const myChats = extractSenseChats(myAddress, myTransactions!);\n\n  const results: SenseListItem[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const chat of myChats.values()) {\n    const syncItem = syncItemsMap.get(chat.userAddress);\n    const lastTransaction = chat.transactions.at(-1)!;\n\n    const { timestamp: transactionTimestamp, hash, index } = lastTransaction;\n    const syncItemHeader = {\n      entryType: EntryType.chat,\n      ownerId: myAddress,\n      meta: {\n        transactionHash: hash,\n        index,\n      } as SenseTransactionMeta,\n    };\n\n    // if no sync item(first message/initial)\n    if (!syncItem) {\n      const unreadCount = chat.transactions.filter(\n        (t) => t.timestamp > chat.lastSendTimestamp\n      ).length; // uread count on top of my last send message\n\n      const newItem = {\n        ...syncItemHeader,\n        id: chat.userAddress,\n        unreadCount,\n        // if 'fast' then no shift update poiter till 'slow' reupdate\n        timestampUpdate: shouldUpdateTimestamp ? transactionTimestamp : 0,\n        timestampRead: chat.lastSendTimestamp,\n        disabled: false,\n      };\n\n      // eslint-disable-next-line no-await-in-loop\n      await throwIfAborted(db.putSyncStatus.bind(db), signal)(newItem);\n\n      results.push({ ...newItem, meta: lastTransaction });\n    } else {\n      const {\n        id,\n        timestampRead,\n        timestampUpdate,\n        meta,\n        unreadCount: prevUnreadCount,\n      } = syncItem;\n\n      const lastTimestampRead = Math.max(\n        timestampRead!,\n        chat.lastSendTimestamp\n      );\n      const { timestampUpdateContent = 0, timestampUpdateChat = 0 } = meta;\n      const timestampUnreadFrom = Math.max(\n        chat.lastSendTimestamp,\n        timestampUpdateChat\n      );\n      const unreadCount =\n        prevUnreadCount +\n        chat.transactions.filter((t) => t.timestamp > timestampUnreadFrom) // + new messages count\n          .length;\n\n      if (timestampUpdate < transactionTimestamp) {\n        // if message source is 'fast' then no update till 'slow' reupdate\n        const newTimestampUpdateChat = shouldUpdateTimestamp\n          ? transactionTimestamp\n          : timestampUpdateChat;\n\n        const syncStatusChanges = {\n          ...syncItemHeader,\n          id: id!,\n          unreadCount,\n          timestampRead: lastTimestampRead,\n          // show max timestamp to use in sorting, in sense list\n          // real timestamp shold be resynced with 'slow' data source by timestampUpdateChat\n          timestampUpdate: Math.max(\n            transactionTimestamp,\n            timestampUpdateContent,\n            newTimestampUpdateChat\n          ),\n\n          meta: {\n            ...syncItemHeader.meta,\n            timestampUpdateChat: newTimestampUpdateChat,\n            timestampUpdateContent,\n          },\n        };\n\n        // eslint-disable-next-line no-await-in-loop\n        await throwIfAborted(\n          db.updateSyncStatus.bind(db),\n          signal\n        )(syncStatusChanges);\n\n        results.push({\n          ...syncItem,\n          ...syncStatusChanges,\n          meta: lastTransaction,\n        } as SenseListItem);\n      }\n    }\n  }\n  return results;\n};\n","import { ProgressTracking } from 'src/services/backend/types/services';\n\nconst ROLLING_WINDOW = 10;\n\ntype onProgressUpdateFunc = (progress: ProgressTracking) => void;\n\ntype RequestRecord = {\n  timestamp: number;\n  itemCount: number;\n};\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport class ProgressTracker {\n  private requestRecords: RequestRecord[] = [];\n\n  private totalRequests = 0;\n\n  private completedRequests = 0;\n\n  private estimatedTime = -1;\n\n  private batchSize = 1;\n\n  private onProgressUpdate?: onProgressUpdateFunc;\n\n  public get progress(): ProgressTracking {\n    return {\n      totalCount: this.totalRequests,\n      completeCount: this.completedRequests,\n      estimatedTime: this.estimatedTime,\n    };\n  }\n\n  constructor(onProgressUpdate?: onProgressUpdateFunc) {\n    this.onProgressUpdate = onProgressUpdate;\n  }\n\n  public start(totalRequests: number, batchSize = 1) {\n    this.totalRequests = totalRequests;\n    this.requestRecords = [];\n    this.completedRequests = 0;\n    this.estimatedTime = -1;\n    this.batchSize = batchSize;\n\n    return this.progress;\n  }\n\n  public add(extraRequests: number) {\n    this.totalRequests += extraRequests;\n\n    return this.progress;\n  }\n\n  public trackProgress(processedCount: number) {\n    this.addRequestRecord(processedCount);\n\n    if (this.requestRecords.length > ROLLING_WINDOW) {\n      this.requestRecords.shift();\n    }\n\n    if (this.requestRecords.length > 1) {\n      const averageTimePerItem = this.calculateAverageTimePerItem();\n      const remainingRequests = this.totalRequests - this.completedRequests;\n      const estimatedRemainingItems = remainingRequests * processedCount; // Assuming remaining requests will process the same number of items\n      const estimatedRemainingTime =\n        averageTimePerItem * estimatedRemainingItems;\n\n      this.completedRequests += processedCount;\n      this.estimatedTime = Math.round(estimatedRemainingTime); // Convert to seconds;\n      this.onProgressUpdate && this.onProgressUpdate(this.progress);\n    }\n\n    return this.progress;\n  }\n\n  private addRequestRecord(itemCount: number) {\n    this.requestRecords.push({ timestamp: Date.now(), itemCount });\n  }\n\n  private calculateAverageTimePerItem(): number {\n    let totalDiff = 0;\n    let totalItems = 0;\n\n    for (let i = 1; i < this.requestRecords.length; i++) {\n      const timeDiff =\n        this.requestRecords[i].timestamp - this.requestRecords[i - 1].timestamp;\n      const { itemCount } = this.requestRecords[i];\n\n      totalDiff += timeDiff * itemCount;\n      totalItems += itemCount;\n    }\n\n    return totalItems === 0 ? 0 : totalDiff / totalItems;\n  }\n}\n","import {\n  Observable,\n  filter,\n  distinctUntilChanged,\n  map,\n  switchMap,\n  take,\n  tap,\n} from 'rxjs';\n\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { broadcastStatus } from 'src/services/backend/channels/broadcastStatus';\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { CyblogChannel, createCyblogChannel } from 'src/utils/logging/cyblog';\n\nimport DbApiWrapper from '../../../dataSource/indexedDb/dbApiWrapper';\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ProgressTracker } from '../ProgressTracker/ProgressTracker';\nimport { ServiceDeps } from '../types';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSync {\n  protected name: string;\n\n  protected abortController: AbortController;\n\n  protected db: DbApiWrapper | undefined;\n\n  protected progressTracker = new ProgressTracker();\n\n  protected channelApi = new BroadcastChannelSender();\n\n  protected particlesResolver: ParticlesResolverQueue | undefined;\n\n  protected statusApi: ReturnType<typeof broadcastStatus>;\n\n  protected params: SyncServiceParams = {\n    myAddress: null,\n  };\n\n  protected readonly isInitialized$: Observable<boolean>;\n\n  protected cyblogCh: CyblogChannel;\n\n  constructor(\n    name: SyncEntryName,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue\n  ) {\n    this.name = name;\n\n    this.abortController = new AbortController();\n\n    this.statusApi = broadcastStatus(name, this.channelApi);\n    this.particlesResolver = particlesResolver;\n    this.cyblogCh = createCyblogChannel({ thread: 'bckd', module: name });\n    if (!deps.params$) {\n      throw new Error('params$ is not defined');\n    }\n\n    deps.dbInstance$.subscribe((db) => {\n      this.db = db;\n    });\n\n    this.particlesResolver = particlesResolver;\n\n    this.isInitialized$ = this.createIsInitializedObserver(deps);\n\n    this.isInitialized$.subscribe((isInitialized) => {\n      this.cyblogCh.info(\n        `>>> ${this.name} - ${isInitialized ? 'initialized' : 'inactive'}`\n      );\n      this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n    });\n\n    this.isInitialized$\n      .pipe(switchMap(() => deps.params$!))\n      .subscribe((params) => {\n        this.params = params;\n        this.cyblogCh.info(`>>> ${this.name} - params updated`, {\n          data: params,\n        });\n      });\n\n    // Restart observer\n    this.isInitialized$\n      .pipe(\n        filter((isInitialized) => !!isInitialized),\n        switchMap(() => this.createRestartObserver(deps.params$!))\n      )\n      .subscribe(() => {\n        this.restart();\n      });\n  }\n\n  protected initAbortController() {\n    this.abortController = new AbortController();\n  }\n\n  protected abstract createIsInitializedObserver(\n    deps: ServiceDeps\n  ): Observable<boolean>;\n\n  // eslint-disable-next-line class-methods-use-this\n  protected createRestartObserver(params$: Observable<SyncServiceParams>) {\n    return params$.pipe(\n      map((params) => params.myAddress),\n      distinctUntilChanged((addrBefore, addrAfter) => addrBefore === addrAfter),\n      map((v) => !!v),\n      filter((v) => !!v)\n    );\n  }\n\n  public abstract restart(): void;\n\n  public abstract start(): void;\n}\n\nexport default BaseSync;\n","/* eslint-disable import/prefer-default-export */\nimport {\n  distinctUntilChanged,\n  filter,\n  Observable,\n  share,\n  switchMap,\n  tap,\n} from 'rxjs';\n\nexport const switchWhenInitialized = (\n  isInitialized$: Observable<boolean>,\n  actionObservable$: Observable<any>,\n  onChange?: (isInitialized: boolean) => void\n) =>\n  isInitialized$.pipe(\n    distinctUntilChanged(),\n    tap((isInitialized) => onChange?.(isInitialized)),\n    filter((initialized) => initialized),\n    switchMap(() => actionObservable$),\n    share()\n  );\n","import { Observable, Subject, from, startWith, switchMap, tap } from 'rxjs';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ServiceDeps } from '../types';\nimport BaseSync from './BaseSync';\nimport { switchWhenInitialized } from '../utils/rxjs/withInitializer';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSyncClient extends BaseSync {\n  protected readonly source$: Observable<any>;\n\n  protected readonly reloadTrigger$ = new Subject<void>();\n\n  constructor(\n    name: SyncEntryName,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue\n  ) {\n    super(name, deps, particlesResolver);\n\n    const source$ = switchWhenInitialized(\n      this.isInitialized$!,\n      this.reloadTrigger$.pipe(\n        startWith(null),\n        tap(() => {\n          // initialize abort conteoller for restart strategy\n          this.initAbortController();\n        }),\n        switchMap(() =>\n          this.createInitObservable().pipe(\n            switchMap((timestampFrom: number) =>\n              this.createClientObservable(timestampFrom).pipe(\n                tap(() => this.statusApi.sendStatus('listen')),\n                switchMap((data) => from(this.onUpdate(data, this.params)))\n              )\n            )\n          )\n        )\n      ),\n      (isInitialized) => {\n        console.log(`>>> ${name} isInitialized`, isInitialized);\n        this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n      }\n    );\n\n    source$.subscribe({\n      next: () => {\n        this.statusApi.sendStatus('listen');\n      },\n      error: (err) => {\n        this.statusApi.sendStatus('error', err);\n      },\n    });\n    this.source$ = source$;\n  }\n\n  protected abstract createClientObservable(\n    timestampFrom: number\n  ): Observable<any>;\n\n  protected abstract createInitObservable(): Observable<number>;\n\n  public restart() {\n    this.abortController?.abort();\n    this.reloadTrigger$.next();\n    console.log(`>>> ${this.name} client restart`);\n  }\n\n  protected abstract onUpdate(\n    data: any,\n    params: SyncServiceParams\n  ): Promise<void>;\n\n  public start() {\n    this.source$.subscribe(() => {\n      // dummy subscriber to keep pipeline running - don't remove\n    });\n    return this;\n  }\n}\n\nexport default BaseSyncClient;\n","/* eslint-disable camelcase */\nimport {\n  map,\n  combineLatest,\n  Observable,\n  from,\n  defer,\n  distinctUntilChanged,\n  merge,\n  filter,\n} from 'rxjs';\nimport { isEmpty } from 'lodash';\n\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport { mapIndexerTransactionToEntity } from 'src/services/CozoDb/mapping';\nimport { numberToUtcDate } from 'src/utils/date';\nimport { NeuronAddress } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { SyncStatusDto, TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport {\n  createNodeWebsocketObservable,\n  getIncomingTransfersQuery,\n} from 'src/services/blockchain/websocket';\nimport { mapWebsocketTxToTransactions } from 'src/services/blockchain/utils/mapping';\n\nimport { ServiceDeps } from '../types';\nimport { extractCybelinksFromTransaction } from '../utils/links';\n\nimport {\n  fetchTransactionsIterable,\n  mapMessagesByAddressVariables,\n  fetchTransactionMessagesCount,\n  gqlMessagesByAddress,\n  TransactionsByAddressResponse,\n} from '../../../indexer/transactions';\nimport { syncMyChats } from './services/chat';\nimport { TRANSACTIONS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncClient from '../BaseSyncLoop/BaseSyncClient';\nimport { createIndexerWebsocket } from '../../../indexer/utils';\nimport { SyncServiceParams } from '../../types';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\n\ntype DataStreamResult = {\n  source: 'indexer' | 'node';\n  transactions: TransactionDto[];\n};\n\nclass SyncTransactionsLoop extends BaseSyncClient {\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.params$!.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      ),\n      this.particlesResolver!.isInitialized$,\n    ]).pipe(\n      map(\n        ([dbInstance, myAddress, syncQueueInitialized]) =>\n          !!dbInstance && !!syncQueueInitialized && !!myAddress\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected createClientObservable(\n    timestampFrom: number\n  ): Observable<DataStreamResult> {\n    const { myAddress } = this.params;\n    this.cyblogCh.info(\n      `>>> ${this.name} subscribe ${myAddress} from ${numberToUtcDate(\n        timestampFrom\n      )}`\n    );\n\n    const variables = mapMessagesByAddressVariables({\n      neuron: myAddress!,\n      timestampFrom,\n      types: [],\n      orderDirection: 'desc',\n      limit: 100,\n    });\n\n    const indexerObservable$ =\n      createIndexerWebsocket<TransactionsByAddressResponse>(\n        gqlMessagesByAddress('subscription'),\n        variables\n      ).pipe(\n        map((response: TransactionsByAddressResponse) => {\n          return {\n            source: 'indexer',\n            transactions: response.messages_by_address.map((i) =>\n              mapIndexerTransactionToEntity(myAddress!, i)\n            ),\n          };\n        })\n      );\n\n    const nodeObservample$ = createNodeWebsocketObservable(\n      myAddress!,\n      getIncomingTransfersQuery(myAddress!),\n      (message, ctx) => this.cyblogCh.info(message, { unit: 'node-ws', ...ctx })\n    ).pipe(\n      filter((data) => !isEmpty(data)),\n      map((data) => {\n        return {\n          source: 'node',\n          transactions: mapWebsocketTxToTransactions(myAddress!, data),\n        };\n      })\n    );\n\n    return merge(\n      indexerObservable$,\n      nodeObservample$\n    ) as Observable<DataStreamResult>;\n  }\n\n  protected createInitObservable() {\n    return defer(() => from(this.initSync()));\n    // return from(this.initSync());\n  }\n\n  public async initSync() {\n    const { myAddress } = this.params;\n    const { signal } = this.abortController;\n    const syncItem = await this.db!.getSyncStatus(myAddress!, myAddress!);\n\n    const lastTransactionTimestamp = await this.syncTransactions(\n      myAddress!,\n      myAddress!,\n      syncItem\n    );\n\n    this.statusApi.sendStatus('in-progress', `sync my chats`);\n    const syncStatusItems = await syncMyChats(\n      this.db!,\n      myAddress!,\n      syncItem.timestampUpdate,\n      signal\n    );\n\n    this.channelApi.postSenseUpdate(syncStatusItems);\n    this.statusApi.sendStatus('active');\n\n    return lastTransactionTimestamp;\n  }\n\n  protected async onUpdate(\n    { source, transactions }: DataStreamResult,\n    params: SyncServiceParams\n  ) {\n    const { myAddress } = params;\n    const { signal } = this.abortController;\n    if (transactions.length === 0) {\n      this.cyblogCh.info(`>>> ${this.name} ${myAddress} recived 0 updates `);\n      return;\n    }\n    const syncItem = await this.db!.getSyncStatus(myAddress!, myAddress!);\n\n    await this.processBatchTransactions(\n      myAddress!,\n      myAddress!,\n      transactions,\n      syncItem,\n      source\n    );\n\n    this.statusApi.sendStatus('in-progress', `sync my chats`);\n    const syncStatusItems = await syncMyChats(\n      this.db!,\n      myAddress!,\n      syncItem.timestampUpdate,\n      signal,\n      source !== 'node'\n    );\n\n    this.channelApi.postSenseUpdate(syncStatusItems);\n    this.statusApi.sendStatus('listen');\n  }\n\n  public async processBatchTransactions(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    transactions: TransactionDto[],\n    { timestampRead, unreadCount, timestampUpdate }: SyncStatusDto,\n    source: DataStreamResult['source']\n  ) {\n    const { signal } = this.abortController;\n\n    // node transaction is limited by incoming messages,\n    // to prevent missing of other msg types let's avoid to change ts\n    const shouldUpdateTimestamp = source !== 'node';\n\n    this.cyblogCh.info('--------syncTransactions batch ', {\n      data: [\n        myAddress,\n        address,\n        transactions.length,\n        transactions.at(0)?.timestamp,\n        transactions.at(-1)?.timestamp,\n        source,\n      ],\n    });\n\n    // save transaction\n    await throwIfAborted(this.db!.putTransactions, signal)(transactions);\n\n    // save links\n    this.syncLinks(transactions, signal);\n\n    const {\n      hash,\n      index,\n\n      timestamp,\n    } = transactions.at(-1)!;\n\n    const lastTimestampFrom = timestamp;\n\n    // Update transaction sync items\n    const newSyncItem = {\n      ownerId: myAddress,\n      entryType: EntryType.transactions,\n      id: address,\n      timestampUpdate: shouldUpdateTimestamp\n        ? lastTimestampFrom\n        : timestampUpdate!,\n      unreadCount: unreadCount! + transactions.length,\n      timestampRead: timestampRead || 0,\n      disabled: false,\n      meta: {\n        transactionHash: hash,\n        index,\n      },\n    };\n\n    await throwIfAborted(this.db!.putSyncStatus, signal)(newSyncItem);\n\n    return lastTimestampFrom;\n  }\n\n  public async syncTransactions(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    syncItem: SyncStatusDto\n  ) {\n    const { unreadCount, timestampUpdate } = syncItem;\n    const timestampFrom = timestampUpdate + 1; // ofsset + 1 to fix milliseconds precision bug\n\n    this.statusApi.sendStatus('estimating');\n\n    const totalMessageCount = await fetchTransactionMessagesCount(\n      address,\n      timestampFrom,\n      this.abortController!.signal\n    );\n\n    this.cyblogCh.info(\n      `>>> syncTransactions - start ${address},  count: ${totalMessageCount}, from: ${timestampFrom}`\n    );\n\n    if (totalMessageCount === 0) {\n      return timestampFrom;\n    }\n\n    this.statusApi.sendStatus(\n      'in-progress',\n      `sync ${address}...`,\n      this.progressTracker.start(\n        Math.ceil(totalMessageCount / TRANSACTIONS_BATCH_LIMIT)\n      )\n    );\n\n    const transactionsAsyncIterable = fetchTransactionsIterable({\n      neuron: address,\n      timestampFrom,\n      types: [], // SENSE_TRANSACTIONS,\n      orderDirection: 'asc',\n      limit: TRANSACTIONS_BATCH_LIMIT,\n      abortSignal: this.abortController?.signal,\n    });\n\n    let transactionCount = 0;\n    let lastTimestampFrom = timestampFrom;\n\n    // eslint-disable-next-line no-restricted-syntax\n    for await (const batch of transactionsAsyncIterable) {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `sync ${address}...`,\n        this.progressTracker.trackProgress(1)\n      );\n\n      transactionCount += batch.length;\n\n      const transactions = batch.map((i) =>\n        mapIndexerTransactionToEntity(address, i)\n      );\n\n      lastTimestampFrom = await this.processBatchTransactions(\n        myAddress,\n        address,\n        transactions,\n        {\n          ...syncItem,\n          unreadCount: unreadCount + transactionCount,\n        },\n        'indexer'\n      );\n    }\n\n    return lastTimestampFrom;\n  }\n\n  private async syncLinks(batch: TransactionDto[], signal: AbortSignal) {\n    const { tweets, particlesFound, links } =\n      extractCybelinksFromTransaction(batch);\n    if (links.length > 0) {\n      await asyncIterableBatchProcessor(\n        links,\n        (links) => throwIfAborted(this.db!.putCyberlinks, signal)(links),\n        MAX_DATABASE_PUT_SIZE\n      );\n    }\n\n    const tweetParticles = Object.keys(tweets);\n\n    const nonTweetParticles = particlesFound.filter(\n      (cid) => !tweetParticles.includes(cid)\n    );\n\n    // pre-resolve 'tweets' particles\n    await this.particlesResolver!.enqueueBatch(\n      tweetParticles,\n      QueuePriority.HIGH\n    );\n\n    // pre-resolve all the rest particles\n    if (nonTweetParticles.length > 0) {\n      await this.particlesResolver!.enqueueBatch(\n        nonTweetParticles,\n        QueuePriority.LOW\n      );\n    }\n  }\n}\n\nexport default SyncTransactionsLoop;\n","import { Observable } from 'rxjs';\nimport { CYBER_NODE_URL_WS } from 'src/constants/config';\nimport { NeuronAddress } from 'src/types/base';\nimport { LogFunc } from 'src/utils/logging/cyblog';\n\nexport const getIncomingTransfersQuery = (address: NeuronAddress) =>\n  `tm.event='Tx' AND transfer.recipient='${address}'`;\n\n// eslint-disable-next-line import/no-unused-modules\nexport function createNodeWebsocketObservable(\n  address: NeuronAddress,\n  query: string,\n  log: LogFunc\n) {\n  return new Observable((subscriber) => {\n    const ws = new WebSocket(CYBER_NODE_URL_WS);\n\n    ws.onopen = () => {\n      log(`node ws connected to ${CYBER_NODE_URL_WS} with ${query}`);\n      ws.send(\n        JSON.stringify({\n          jsonrpc: '2.0',\n          method: 'subscribe',\n          id: '0',\n          params: { query },\n        })\n      );\n    };\n\n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      log(`node ws ${address} onmessage`, message);\n      subscriber.next(message.result);\n    };\n\n    ws.onerror = (event) => {\n      log(`node ws ${address} error`, { error: event });\n      subscriber.error(event);\n    };\n\n    ws.onclose = () => {\n      log(`node ws ${address} closed`);\n      subscriber.complete();\n    };\n\n    return () => {\n      ws.close();\n    };\n  });\n}\n","import { EntityToDto, DtoToEntity } from 'src/types/dto';\n\nexport const snakeToCamel = (str: string) =>\n  str.replace(/([-_][a-z])/g, (group) =>\n    group.toUpperCase().replace('-', '').replace('_', '')\n  );\n\nexport const camelToSnake = (str: string) =>\n  str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n// Function to transform a DB entity to a DTO\n\n// eslint-disable-next-line import/no-unused-modules\nexport function entityToDto<T extends Record<string, any>>(\n  dbEntity: T\n): EntityToDto<T> {\n  if (!dbEntity || typeof dbEntity !== 'object') {\n    return dbEntity;\n  }\n  const dto: Record<string, any> = {}; // Specify the type for dto\n  Object.keys(dbEntity).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(dbEntity, key)) {\n      const camelCaseKey = snakeToCamel(key);\n      let value = dbEntity[key];\n      if (Array.isArray(dbEntity[key])) {\n        value = dbEntity[key].map((item) => entityToDto(item));\n      } else if (typeof dbEntity[key] === 'object') {\n        value = entityToDto(dbEntity[key]);\n      }\n      dto[camelCaseKey] = value;\n    }\n  });\n  return dto as EntityToDto<T>;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport function dtoToEntity<T extends Record<string, any>>(\n  dto: T\n): DtoToEntity<T> {\n  // in case of recursive calls\n  if (!dto || typeof dto !== 'object') {\n    return dto;\n  }\n  const dbEntity: any = {};\n\n  Object.keys(dto).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(dto, key)) {\n      const snakeCaseKey = camelToSnake(key);\n      let value = dto[key];\n      if (Array.isArray(dto[key])) {\n        value = dto[key].map((item) => dtoToEntity(item));\n      } else if (typeof dto[key] === 'object') {\n        value = dtoToEntity(dto[key]);\n      }\n      dbEntity[snakeCaseKey] = value;\n    }\n  });\n  return dbEntity as DtoToEntity<T>; // Replace T with the appropriate DB Entity type if known\n}\n\nexport function dtoListToEntity<T extends Record<string, any>>(\n  array: T[]\n): DtoToEntity<T>[] {\n  return array.map((dto) => dtoToEntity(dto));\n}\n\nexport function entityListToDto<T extends Record<string, any>>(\n  array: T[]\n): EntityToDto<T>[] {\n  return array.map((dto) => entityToDto(dto));\n}\n\nexport function removeUndefinedFields(entity: Record<string, any>) {\n  Object.keys(entity).forEach((key) => {\n    if (entity[key] === undefined) {\n      delete entity[key];\n    }\n  });\n  return entity;\n}\n","import { NeuronAddress } from 'src/types/base';\nimport { LinkDto, SyncStatusDto } from 'src/services/CozoDb/types/dto';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\n\nimport { findLastIndex } from 'lodash';\nimport { entityToDto } from 'src/utils/dto';\n\nimport { SenseItemLinkMeta } from '../../types/sense';\nimport { SyncEntryName } from '../../types/services';\n\n// export function extractLinkData(\n//   cid: ParticleCid,\n//   links: CyberlinksByParticleResponse['cyberlinks']\n// ) {\n//   return {\n//     lastLink: links[0],\n//     count: links.length,\n//     lastTimestamp: dateToUtcNumber(links[0].timestamp),\n//     firstTimestamp: dateToUtcNumber(links[links.length - 1].timestamp),\n//   };\n// }\n\nexport function getLastReadInfo(\n  links: LinkDto[],\n  ownerId: NeuronAddress,\n  prevTimestampRead = 0,\n  prevUnreadCount = 0\n) {\n  const lastUnreadLinks = links.filter(\n    (link) => link.timestamp > prevTimestampRead\n  );\n  const lastMyLinkIndex = findLastIndex(\n    lastUnreadLinks,\n    (link) => link.neuron === ownerId\n  );\n\n  const unreadCount =\n    lastMyLinkIndex < 0\n      ? prevUnreadCount + lastUnreadLinks.length\n      : lastUnreadLinks.length - lastMyLinkIndex - 1;\n\n  const timestampRead =\n    lastMyLinkIndex < 0 ? prevTimestampRead : links[lastMyLinkIndex].timestamp;\n\n  return {\n    timestampRead,\n    unreadCount,\n  };\n}\n\nexport function changeParticleSyncStatus(\n  syncStatus: Partial<SyncStatusDto>,\n  links: LinkDto[],\n  ownerId: NeuronAddress,\n  shouldUpdateTimestamp = true\n) {\n  const { timestampRead, unreadCount } = getLastReadInfo(\n    links,\n    ownerId,\n    syncStatus.timestampRead,\n    syncStatus.unreadCount\n  );\n\n  const lastLink = entityToDto(links[links.length - 1]);\n  const timestampUpdate = lastLink.timestamp;\n  return {\n    ...syncStatus,\n    ownerId,\n    entryType: EntryType.particle,\n    disabled: false,\n    unreadCount,\n    meta: {\n      ...lastLink,\n      timestamp: timestampUpdate,\n    } as SenseItemLinkMeta,\n    timestampRead,\n    timestampUpdate: shouldUpdateTimestamp\n      ? timestampUpdate\n      : syncStatus.timestampUpdate,\n  } as SyncStatusDto;\n}\n\nconst mapSyncEntryReadable: Record<SyncEntryName, string> = {\n  'my-friends': \"friend's logs\",\n  particles: 'log cyberlinks',\n  resolver: 'particles',\n  transactions: 'transactions',\n  pin: 'ipfs pins',\n};\n\nexport const syncEntryNameToReadable = (name: SyncEntryName) =>\n  mapSyncEntryReadable[name] || name;\n","export const isAbortException = (e: Error) =>\n  e instanceof DOMException && e.name === 'AbortError';\n","import { Observable, defer, filter, from, tap } from 'rxjs';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { isAbortException } from 'src/utils/exceptions/helpers';\nimport { clone } from 'ramda';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ServiceDeps } from '../types';\nimport { createLoopObservable } from '../utils/rxjs/loop';\nimport BaseSync from './BaseSync';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSyncLoop extends BaseSync {\n  private restartLoop: (() => void) | undefined;\n\n  public readonly loop$: Observable<boolean>;\n\n  constructor(\n    name: SyncEntryName,\n    intervalMs: number,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue,\n    {\n      warmupMs,\n    }: {\n      warmupMs: number;\n    } = { warmupMs: 0 }\n  ) {\n    super(name, deps, particlesResolver);\n\n    const { loop$, restartLoop } = createLoopObservable(\n      this.isInitialized$,\n      // defer(() => from(this.sync())),\n      defer(() => from(this.doSync())),\n      {\n        intervalMs,\n        warmupMs,\n        // onStartInterval: () => this.initAbortController(),\n        onError: (error) => {\n          this.cyblogCh.info(`>>> ${name} error`, error.toString());\n          this.statusApi.sendStatus('error', error.toString());\n        },\n        onChange: (isInitialized) => {\n          this.cyblogCh.info(`>>> ${name} initialized: ${isInitialized}`);\n          this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n        },\n      }\n    );\n\n    this.loop$ = loop$;\n    this.restartLoop = restartLoop;\n  }\n\n  public restart() {\n    this.abortController?.abort();\n    this.restartLoop?.();\n    this.cyblogCh.info(`>>> ${this.name} loop restart`);\n  }\n\n  public start() {\n    this.loop$.subscribe(() => this.statusApi.sendStatus('active'));\n    return this;\n  }\n\n  private async doSync() {\n    const params = clone(this.params);\n    this.initAbortController();\n    try {\n      await this.sync(params);\n    } catch (e) {\n      const isAborted = isAbortException(e);\n      this.cyblogCh.info(\n        `>>> ${this.name} ${params.myAddress} sync error [abrt:${isAborted}]:`,\n        {\n          error: e,\n        }\n      );\n\n      if (!isAborted) {\n        throw e;\n      }\n    }\n  }\n\n  protected abstract sync(params: SyncServiceParams): Promise<void>;\n}\n\nexport default BaseSyncLoop;\n","/* eslint-disable import/prefer-default-export */\nimport {\n  Observable,\n  switchMap,\n  interval,\n  startWith,\n  tap,\n  retry,\n  delay,\n  exhaustMap,\n  Subject,\n} from 'rxjs';\nimport { switchWhenInitialized } from './withInitializer';\n\ntype LoopObservableOptions = {\n  warmupMs?: number;\n  retryDelayMs?: number;\n  onStartInterval?: () => void;\n  onError?: (error: any) => void;\n  onChange?: (isInitialized: boolean) => void;\n  intervalMs?: number;\n};\n\nexport const createLoopObservable = (\n  isInitialized$: Observable<boolean>,\n  actionObservable$: Observable<any>,\n  options: LoopObservableOptions = {}\n) => {\n  const {\n    intervalMs,\n    warmupMs = 0,\n    onStartInterval,\n    onError,\n    retryDelayMs = 0,\n    onChange,\n  } = options;\n\n  const restartTrigger$ = new Subject<void>();\n\n  const intervalOrRestart$ = restartTrigger$.pipe(\n    startWith(null),\n    switchMap(() => interval(intervalMs).pipe(startWith(0), delay(warmupMs)))\n  );\n\n  const source$ = switchWhenInitialized(\n    isInitialized$,\n    intervalOrRestart$.pipe(\n      tap(() => onStartInterval && onStartInterval()),\n      exhaustMap(() =>\n        actionObservable$.pipe(\n          retry({\n            delay: (error) => {\n              console.log('retry', error);\n              onError && onError(error);\n              return interval(retryDelayMs);\n            },\n          })\n        )\n      )\n    ),\n    (isInitialized) => onChange?.(isInitialized)\n  );\n\n  return {\n    loop$: source$,\n    restartLoop: () => {\n      // console.log('>>> createLoopObservable restart');\n      // Trigger a restart by emitting a new value\n      restartTrigger$.next();\n    },\n  };\n};\n","import { map, combineLatest, distinctUntilChanged } from 'rxjs';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport { SyncStatusDto } from 'src/services/CozoDb/types/dto';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { NeuronAddress } from 'src/types/base';\n\nimport { mapLinkFromIndexerToDto } from 'src/services/CozoDb/mapping';\nimport { CID_TWEET } from 'src/constants/app';\nimport { dateToUtcNumber } from 'src/utils/date';\nimport { SenseListItem } from 'src/services/backend/types/sense';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport { entityToDto } from 'src/utils/dto';\n\nimport { ServiceDeps } from '../types';\nimport { fetchCyberlinksAndResolveParticles } from '../utils/links';\n\nimport { changeParticleSyncStatus } from '../../utils';\nimport {\n  fetchCyberlinksByNerounIterable,\n  fetchCyberlinksCount,\n} from '../../../dataSource/blockchain/indexer';\nimport { CYBERLINKS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncLoop from '../BaseSyncLoop/BaseSyncLoop';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\nimport { SyncServiceParams } from '../../types';\n\nclass SyncParticlesLoop extends BaseSyncLoop {\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.ipfsInstance$,\n      deps.params$!.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      ),\n      this.particlesResolver!.isInitialized$,\n    ]).pipe(\n      map(\n        ([dbInstance, ipfsInstance, myAddress, particleResolverInitialized]) =>\n          !!ipfsInstance &&\n          !!dbInstance &&\n          !!particleResolverInitialized &&\n          !!myAddress\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  protected async sync(params: SyncServiceParams): Promise<void> {\n    const { myAddress } = params;\n    const { signal } = this.abortController;\n    this.statusApi.sendStatus('estimating');\n\n    const syncItemParticles = await this.db!.findSyncStatus({\n      ownerId: myAddress!,\n      entryType: EntryType.particle,\n    });\n\n    const timestampUpdate = syncItemParticles.at(0)?.timestampUpdate || 0;\n\n    // Get count of new links after last update\n    const newLinkCount = await fetchCyberlinksCount(\n      myAddress!,\n      [CID_TWEET],\n      timestampUpdate,\n      signal\n    );\n\n    this.cyblogCh.info(\n      `>>> syncMyParticles ${myAddress} count ${newLinkCount}`\n    );\n    this.progressTracker.start(newLinkCount + syncItemParticles.length);\n    this.statusApi.sendStatus(\n      'in-progress',\n      'preparing...',\n      this.progressTracker.progress\n    );\n\n    if (newLinkCount > 0) {\n      // fetch and save new particles\n      const newSyncItemParticles = await this.fetchNewTweets(\n        myAddress!,\n        timestampUpdate,\n        signal\n      );\n\n      // add to fetch-sync linked particles\n      syncItemParticles.push(...newSyncItemParticles);\n    }\n    await this.syncParticles(myAddress!, syncItemParticles, signal);\n  }\n\n  private async fetchNewTweets(\n    myAddress: NeuronAddress,\n    timestampUpdate: number,\n    signal: AbortSignal\n  ) {\n    const tweetsAsyncIterable = await fetchCyberlinksByNerounIterable(\n      myAddress,\n      [CID_TWEET],\n      timestampUpdate,\n      CYBERLINKS_BATCH_LIMIT,\n      this.abortController?.signal\n    );\n\n    const newTweets: SyncStatusDto[] = [];\n    const existingParticles = await this.db!.findSyncStatus({\n      ownerId: myAddress,\n      entryType: EntryType.particle,\n    });\n    const existingParticlesMap = new Map(\n      existingParticles.map((i) => [i.id, i])\n    );\n    // eslint-disable-next-line no-await-in-loop, no-restricted-syntax\n    for await (const tweetsBatch of tweetsAsyncIterable) {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `fetching new tweets...`,\n        this.progressTracker.trackProgress(1)\n      );\n      const syncStatusEntities = tweetsBatch.map(entityToDto).map((item) => {\n        const { timestamp, to } = item;\n        const timestampUpdate = dateToUtcNumber(timestamp);\n\n        // In case my tweet already linked from other neuron, resync from beginning\n        const timestampSyncFrom = existingParticlesMap.get(to)\n          ? dateToUtcNumber(timestamp)\n          : 0;\n\n        // Initial state\n        return {\n          ownerId: myAddress,\n          id: to,\n          entryType: EntryType.particle,\n          timestampUpdate: timestampSyncFrom,\n          timestampRead: timestampUpdate,\n          unreadCount: 0,\n          disabled: false,\n          meta: { ...item, timestamp: timestampUpdate },\n        } as SyncStatusDto;\n      });\n\n      if (syncStatusEntities.length > 0) {\n        await throwIfAborted(\n          this.db!.putSyncStatus,\n          signal\n        )(syncStatusEntities);\n        newTweets.push(...syncStatusEntities);\n      }\n    }\n\n    return newTweets;\n  }\n\n  private async syncParticles(\n    myAddress: NeuronAddress,\n    syncItems: SyncStatusDto[],\n    signal: AbortSignal\n  ) {\n    const updatedSyncItems: SyncStatusDto[] = [];\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const syncItem of syncItems) {\n      const { id, timestampUpdate } = syncItem;\n\n      this.statusApi.sendStatus(\n        'in-progress',\n        `fetching tweet updates...`,\n        this.progressTracker.trackProgress(1)\n      );\n      // eslint-disable-next-line no-await-in-loop\n      const linksIndexer = await fetchCyberlinksAndResolveParticles(\n        id,\n        timestampUpdate,\n        this.particlesResolver!,\n        QueuePriority.MEDIUM,\n        this.abortController?.signal\n      );\n\n      if (linksIndexer.length > 0) {\n        const links = linksIndexer.map(mapLinkFromIndexerToDto);\n\n        // save links\n        // eslint-disable-next-line no-await-in-loop\n        await asyncIterableBatchProcessor(\n          links,\n          (links) => throwIfAborted(this.db!.putCyberlinks, signal)(links),\n          MAX_DATABASE_PUT_SIZE\n        );\n\n        const newItem = changeParticleSyncStatus(syncItem, links, myAddress);\n\n        updatedSyncItems.push(newItem);\n      }\n    }\n\n    if (updatedSyncItems.length > 0) {\n      await throwIfAborted(this.db!.putSyncStatus, signal)(updatedSyncItems);\n    }\n    this.channelApi.postSenseUpdate(updatedSyncItems as SenseListItem[]);\n  }\n}\n\nexport default SyncParticlesLoop;\n","/* eslint-disable camelcase */\nimport {\n  map,\n  combineLatest,\n  distinctUntilChanged,\n  BehaviorSubject,\n} from 'rxjs';\n\nimport { EntryType } from 'src/services/CozoDb/types/entities';\n\nimport { NeuronAddress } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { isAbortException } from 'src/utils/exceptions/helpers';\n\nimport { mapLinkFromIndexerToDto } from 'src/services/CozoDb/mapping';\nimport { throwIfAborted } from 'src/utils/async/promise';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { SenseItemLinkMeta } from 'src/services/backend/types/sense';\nimport { entityToDto } from 'src/utils/dto';\nimport { ServiceDeps } from '../types';\n\nimport { fetchCyberlinksByNerounIterable } from '../../../dataSource/blockchain/indexer';\nimport { CYBERLINKS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncLoop from '../BaseSyncLoop/BaseSyncLoop';\nimport { SyncServiceParams } from '../../types';\nimport { getLastReadInfo } from '../../utils';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { SENSE_FRIEND_PARTICLES } from '../consts';\n\nclass SyncMyFriendsLoop extends BaseSyncLoop {\n  protected followings: NeuronAddress[] = [];\n\n  constructor(\n    name: SyncEntryName,\n    intervalMs: number,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue,\n    { warmupMs }: { warmupMs: number } = { warmupMs: 0 }\n  ) {\n    if (!deps.followings$) {\n      throw new Error('followings$ is required');\n    }\n\n    super(name, intervalMs, deps, particlesResolver, {\n      warmupMs,\n    });\n  }\n\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const followingsInitialized$ = new BehaviorSubject<boolean>(false);\n    deps.params$\n      ?.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      )\n      .subscribe(() => {\n        followingsInitialized$.next(false);\n      });\n\n    deps.followings$!.subscribe((followings) => {\n      this.followings = followings;\n      followingsInitialized$.next(true);\n\n      this.restart();\n    });\n\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.params$!,\n      this.particlesResolver!.isInitialized$,\n      followingsInitialized$!,\n    ]).pipe(\n      map(\n        ([dbInstance, params, syncQueueInitialized, followingsInitialized]) =>\n          !!dbInstance &&\n          !!params.myAddress &&\n          !!syncQueueInitialized &&\n          followingsInitialized\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  protected async sync(params: SyncServiceParams) {\n    const { signal } = this.abortController;\n\n    this.statusApi.sendStatus('in-progress', 'preparing...');\n    const { myAddress } = params;\n\n    const { followings } = this;\n\n    this.statusApi.sendStatus('estimating');\n\n    this.cyblogCh.info(\n      `>>> syncMyFriends ${myAddress} count ${followings.length}`,\n      {\n        unit: 'friends-sync',\n        data: followings,\n      }\n    );\n\n    this.progressTracker.start(followings.length);\n    this.statusApi.sendStatus(\n      'in-progress',\n      `sync...`,\n      this.progressTracker.progress\n    );\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const addr of followings) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.syncLinks(myAddress!, addr, signal);\n    }\n  }\n\n  public async syncLinks(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    signal: AbortSignal\n  ) {\n    let syncUpdates = [];\n    try {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `starting sync ${address}...`,\n        this.progressTracker.progress\n      );\n      const { timestampRead, unreadCount, meta } = await this.db!.getSyncStatus(\n        myAddress,\n        address\n      );\n\n      const { timestampUpdateChat = 0, timestampUpdateContent = 0 } =\n        meta || {};\n\n      const timestampFrom = timestampUpdateContent + 1; // ofsset + 1 to fix milliseconds precision bug\n\n      const linksAsyncIterable = await fetchCyberlinksByNerounIterable(\n        address,\n        SENSE_FRIEND_PARTICLES,\n        timestampFrom,\n        CYBERLINKS_BATCH_LIMIT,\n        signal\n      );\n\n      // eslint-disable-next-line no-restricted-syntax\n      for await (const linksBatch of linksAsyncIterable) {\n        this.statusApi.sendStatus(\n          'in-progress',\n          `sync ${address}...`,\n          this.progressTracker.trackProgress(1)\n        );\n\n        const links = linksBatch.map(mapLinkFromIndexerToDto);\n\n        const { timestampRead: newTimestampRead, unreadCount: newUnreadCount } =\n          getLastReadInfo(links, myAddress, timestampRead, unreadCount);\n\n        // const unreadItemsCount = unreadCount + links.length;\n\n        if (links.length > 0) {\n          const lastLink = entityToDto(links.at(-1)!);\n          const newTimestampUpdateContent = lastLink!.timestamp;\n\n          await throwIfAborted(this.db!.putCyberlinks, signal)(links);\n\n          const particles = links.map((t) => t.to);\n          await this.particlesResolver!.enqueueBatch(\n            particles,\n            QueuePriority.HIGH\n          );\n\n          const newSyncItem = {\n            ownerId: myAddress,\n            entryType: EntryType.chat,\n            id: address,\n            timestampUpdate: Math.max(\n              newTimestampUpdateContent,\n              timestampUpdateChat\n            ),\n            unreadCount: newUnreadCount,\n            timestampRead: newTimestampRead,\n            disabled: false,\n            meta: {\n              ...lastLink!,\n              timestampUpdateContent: newTimestampUpdateContent,\n              timestampUpdateChat,\n            } as SenseItemLinkMeta,\n          };\n          // Update transaction\n          await throwIfAborted(this.db!.putSyncStatus, signal)(newSyncItem);\n\n          syncUpdates.push(newSyncItem);\n        }\n      }\n    } catch (err) {\n      this.cyblogCh.error(`>>> SyncMyFriends ${address} error`, {\n        error: err,\n      });\n      if (!isAbortException(err)) {\n        this.statusApi.sendStatus('error', err.toString());\n      } else {\n        syncUpdates = [];\n        throw err;\n      }\n    } finally {\n      // console.log('-----syncUpdates with redux', syncUpdates);\n      this.channelApi.postSenseUpdate(syncUpdates);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  // protected createRestartObserver(\n  //   params$: Observable<SyncServiceParams>\n  // ): Observable<boolean> {\n  //   return super\n  //     .createRestartObserver(params$)\n  //     .pipe(switchMap((addressChanged) => this.isInitialized$));\n  // }\n}\n\nexport default SyncMyFriendsLoop;\n","import Unixfs from 'ipfs-unixfs';\nimport { DAGNode, util as DAGUtil } from 'ipld-dag-pb';\nimport { isString } from 'lodash';\nimport { IpfsApi } from 'src/services/backend/workers/background/worker';\nimport { ParticleCid } from 'src/types/base';\nimport { PATTERN_IPFS_HASH } from 'src/constants/app';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const getIpfsHash = (string: string): Promise<ParticleCid> =>\n  new Promise((resolve, reject) => {\n    const unixFsFile = new Unixfs('file', Buffer.from(string));\n\n    const buffer = unixFsFile.marshal();\n    DAGNode.create(buffer, (err, dagNode) => {\n      if (err) {\n        reject(new Error('Cannot create ipfs DAGNode'));\n      }\n\n      DAGUtil.cid(dagNode, (error, cid) => {\n        resolve(cid.toBaseEncodedString());\n      });\n    });\n  });\nexport const addIfpsMessageOrCid = async (\n  message: string | ParticleCid | File,\n  { ipfsApi }: { ipfsApi: IpfsApi | null }\n) => {\n  if (!ipfsApi) {\n    throw Error('IpfsApi is not initialized');\n  }\n\n  return (\n    isString(message) && message.match(PATTERN_IPFS_HASH)\n      ? message\n      : ((await ipfsApi!.addContent(message)) as string)\n  ) as ParticleCid;\n};\n","import { NeuronAddress, ParticleCid } from 'src/types/base';\nimport { getIpfsHash } from 'src/utils/ipfs/helpers';\nimport { PATTERN_CYBER } from 'src/constants/app';\nimport { Subject, Observable } from 'rxjs';\n\nimport DbApiWrapper from '../backend/services/dataSource/indexedDb/dbApiWrapper';\nimport { getFollowsAsCid, getFollowers } from '../backend/services/lcd/lcd';\nimport { FetchParticleAsync, QueuePriority } from '../QueueManager/types';\nimport { CommunityDto } from '../CozoDb/types/dto';\nimport { FetchIpfsFunc } from '../backend/services/sync/types';\nimport { createCyblogChannel } from 'src/utils/logging/cyblog';\n\nexport type SyncCommunityResult = {\n  action: 'reset' | 'add' | 'complete';\n  items: CommunityDto[];\n};\n\nconst cyblogCh = createCyblogChannel({\n  thread: 'bckd',\n  unit: 'fetchStoredSyncCommunity',\n});\n\n// eslint-disable-next-line import/prefer-default-export, import/no-unused-modules\nexport const fetchStoredSyncCommunity$ = (\n  dbApi: DbApiWrapper,\n  address: NeuronAddress,\n  fetchParticleAsync?: FetchIpfsFunc,\n  signal?: AbortSignal\n): Observable<SyncCommunityResult> => {\n  return new Observable<SyncCommunityResult>((subscriber) => {\n    subscriber.next({ action: 'reset', items: [] });\n\n    (async () => {\n      const storedCommunity = await dbApi.getCommunity(address);\n\n      subscriber.next({ action: 'add', items: storedCommunity });\n\n      const communityUpdatesMap = new Map<ParticleCid, CommunityDto>(\n        storedCommunity.map((c) => [c.particle, c])\n      );\n\n      const getExistingOrDefault = (cid: ParticleCid): Partial<CommunityDto> =>\n        communityUpdatesMap.get(cid) || {\n          ownerId: address,\n          name: '',\n          following: false,\n          follower: false,\n        };\n\n      const followsCids = await getFollowsAsCid(address, signal);\n      const followers = await getFollowers(address, signal);\n\n      const newFollowerCids = followsCids.filter(\n        (cid) => !storedCommunity.some((i) => i.particle === cid && i.following)\n      );\n\n      const newFollowingNeurons = followers.filter(\n        (addr) => !storedCommunity.some((i) => i.neuron === addr && i.follower)\n      );\n\n      cyblogCh.info(\n        `>>>$ sync community ${address} processing, stored ${storedCommunity.length} new followers: ${newFollowerCids.length} new following: ${newFollowingNeurons.length}`\n      );\n\n      const followersCommunity = await Promise.all(\n        newFollowingNeurons.map(async (neuron) => {\n          const cid = await getIpfsHash(neuron);\n\n          const communityItem = {\n            ...getExistingOrDefault(cid),\n            particle: cid,\n            neuron,\n            follower: true,\n          } as CommunityDto;\n\n          await dbApi.putCommunity(communityItem);\n          communityUpdatesMap.set(cid, communityItem);\n          return communityItem;\n        })\n      );\n\n      subscriber.next({ action: 'add', items: followersCommunity });\n\n      await Promise.all(\n        newFollowerCids.map(async (cid: ParticleCid) => {\n          const neuron = (await fetchParticleAsync!(cid, QueuePriority.URGENT))\n            ?.result?.textPreview;\n          if (neuron && neuron.match(PATTERN_CYBER)) {\n            const communityItem = {\n              ...getExistingOrDefault(cid),\n              neuron,\n              particle: cid,\n              following: true,\n            } as CommunityDto;\n\n            await dbApi.putCommunity(communityItem);\n            communityUpdatesMap.set(cid, communityItem);\n            subscriber.next({ action: 'add', items: [communityItem] });\n          }\n        })\n      );\n\n      cyblogCh.info(`>>>$ sync community ${address}, done`);\n      // const communityUpdates = [...communityUpdatesMap.values()];\n\n      // if (communityUpdates.length > 0) {\n      //   subscriber.next(communityUpdates);\n      // }\n      subscriber.next({ action: 'complete', items: [] });\n\n      subscriber.complete();\n    })().catch((err) => {\n      cyblogCh.error(`>>>$ sync community ${address}, error`, { error: err });\n      subscriber.error(err);\n    });\n  });\n};\n\n// eslint-disable-next-line import/no-unused-modules\nexport const fetchCommunity = async (\n  address: NeuronAddress,\n  fetchParticleAsync?: FetchParticleAsync,\n  onResolve?: (community: CommunityDto[]) => void,\n  signal?: AbortSignal\n) => {\n  const communityUpdatesMap = new Map<ParticleCid, CommunityDto>();\n\n  const getExistingOrDefault = (cid: ParticleCid): Partial<CommunityDto> =>\n    communityUpdatesMap.get(cid) || {\n      ownerId: address,\n      name: '',\n      following: false,\n      follower: false,\n    };\n\n  const followsCids = await getFollowsAsCid(address, signal);\n  const followers = await getFollowers(address, signal);\n\n  console.log(`>>> sync community ${address} processing without store`);\n\n  const followsPromise = Promise.all(\n    followsCids.map(async (cid) => {\n      const neuron = (await fetchParticleAsync!(cid))?.result?.textPreview;\n      if (neuron && neuron.match(PATTERN_CYBER)) {\n        const communityItem = {\n          ...getExistingOrDefault(cid),\n          neuron,\n          particle: cid,\n          following: true,\n        } as CommunityDto;\n        communityUpdatesMap.set(cid, communityItem);\n        onResolve && !signal?.aborted && onResolve([communityItem]);\n      }\n    })\n  );\n\n  const followersPromise = Promise.all(\n    followers.map(async (neuron) => {\n      const cid = await getIpfsHash(neuron);\n\n      const communityItem = {\n        ...getExistingOrDefault(cid),\n        particle: cid,\n        neuron,\n        follower: true,\n      } as CommunityDto;\n\n      communityUpdatesMap.set(cid, communityItem);\n      onResolve && !signal?.aborted && onResolve([communityItem]);\n    })\n  );\n\n  await Promise.all([followersPromise, followsPromise]);\n};\n","import axios from 'axios';\nimport { CYBER_NODE_URL_LCD } from 'src/constants/config';\nimport { NeuronAddress, ParticleCid } from 'src/types/base';\nimport { CID_FOLLOW } from 'src/constants/app';\nimport { getIpfsHash } from 'src/utils/ipfs/helpers';\n\nexport const getFollowsAsCid = async (\n  address: NeuronAddress,\n  signal?: AbortSignal\n): Promise<ParticleCid[]> => {\n  const response = await axios({\n    method: 'get',\n    url: `${CYBER_NODE_URL_LCD}/txs?cyberlink.neuron=${address}&cyberlink.particleFrom=${CID_FOLLOW}&limit=1000000000`,\n    signal,\n  });\n\n  if (!response.data.txs) {\n    return [];\n  }\n  return response.data.txs.map(\n    (item) => item.tx.value.msg[0].value.links[0].to\n  );\n};\n\nexport const getFollowers = async (\n  address: NeuronAddress,\n  signal?: AbortSignal\n): Promise<NeuronAddress[]> => {\n  const addressHash = await getIpfsHash(address);\n\n  const response = await axios({\n    method: 'get',\n    url: `${CYBER_NODE_URL_LCD}/txs?cyberlink.particleFrom=${CID_FOLLOW}&cyberlink.particleTo=${addressHash}&limit=1000000000`,\n    signal,\n  });\n  // console.log(\n  //   '-----getFollowers',\n  //   `${CYBER_NODE_URL_LCD}/txs?cyberlink.particleFrom=${CID_FOLLOW}&cyberlink.particleTo=${addressHash}&limit=1000000000`,\n  //   response.data\n  // );\n  if (!response.data.txs) {\n    return [];\n  }\n  return response.data.txs.map((item) => item.tx.value.msg[0].value.neuron);\n};\n\nexport async function getTransaction(txHash: string) {\n  // https://lcd.bostrom.cybernode.ai/cosmos/tx/v1beta1/txs/67FD87EBCC1633B779C154C1CAFD48DE71350074A04F742DAD418F69F1D05BB0\n  const response = axios.get(\n    `${CYBER_NODE_URL_LCD}/cosmos/tx/v1beta1/txs/${txHash}`\n  );\n  return response;\n}\n","/* eslint-disable no-restricted-syntax */\nimport { Observable, combineLatest } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport BroadcastChannelSender from '../../channels/BroadcastChannelSender';\n\nimport ParticlesResolverQueue from './services/ParticlesResolverQueue/ParticlesResolverQueue';\n\n// import SyncIpfsLoop from './services/SyncIpfsLoop/SyncIpfsLoop';\nimport SyncTransactionsLoop from './services/SyncTransactionsLoop/SyncTransactionsLoop';\nimport SyncParticlesLoop from './services/SyncParticlesLoop/SyncParticlesLoop';\n\nimport { ServiceDeps } from './services/types';\nimport {\n  MY_FRIENDS_SYNC_INTERVAL,\n  MY_PARTICLES_SYNC_INTERVAL,\n} from './services/consts';\nimport SyncMyFriendsLoop from './services/SyncMyFriendsLoop/SyncMyFriendsLoop';\nimport { SyncEntryName } from '../../types/services';\nimport BaseSyncLoop from './services/BaseSyncLoop/BaseSyncLoop';\nimport createCommunitySync$ from './services/CommunitySync/CommunitySync';\nimport { createCyblogChannel } from 'src/utils/logging/cyblog';\n\nconst cyblogCh = createCyblogChannel({ thread: 'bckd' });\n\n// eslint-disable-next-line import/prefer-default-export\nexport class SyncService {\n  private isInitialized$: Observable<boolean>;\n\n  private channelApi = new BroadcastChannelSender();\n\n  private loops: Partial<Record<SyncEntryName, BaseSyncLoop>> = {};\n\n  constructor(deps: ServiceDeps) {\n    const { dbInstance$, ipfsInstance$ } = deps;\n    this.isInitialized$ = combineLatest([dbInstance$, ipfsInstance$]).pipe(\n      map(([dbInstance, ipfsInstance]) => !!dbInstance && !!ipfsInstance)\n    );\n    // subscribe when started\n    this.isInitialized$.subscribe({\n      next: (result) => {\n        return result && this.channelApi.postServiceStatus('sync', 'started');\n      },\n      error: (err) => this.channelApi.postServiceStatus('sync', 'error', err),\n    });\n\n    const particlesResolver = new ParticlesResolverQueue(deps).start();\n\n    const communitySync$ = createCommunitySync$(deps);\n    communitySync$.subscribe((community) => {\n      cyblogCh.info('--> community fetched', {\n        unit: 'community',\n        data: community,\n      });\n    });\n\n    const followings$ = communitySync$.pipe(\n      map((c) => c.filter((i) => i.following)),\n      map((c) => c.map((i) => i.neuron))\n    );\n\n    // new SyncIpfsLoop(deps, particlesResolver).start();\n\n    new SyncTransactionsLoop('transactions', deps, particlesResolver).start();\n\n    new SyncParticlesLoop(\n      'particles',\n      MY_PARTICLES_SYNC_INTERVAL,\n      deps,\n      particlesResolver\n    ).start();\n\n    new SyncMyFriendsLoop(\n      'my-friends',\n      MY_FRIENDS_SYNC_INTERVAL,\n      { ...deps, followings$ },\n      particlesResolver\n      // { warmupMs: 1000 }\n    ).start();\n  }\n\n  public restart(name: SyncEntryName) {\n    this.loops[name]?.restart();\n  }\n}\n","import {\n  Observable,\n  combineLatest,\n  defer,\n  distinctUntilChanged,\n  filter,\n  map,\n  switchMap,\n} from 'rxjs';\n\nimport {\n  SyncCommunityResult,\n  fetchStoredSyncCommunity$,\n} from 'src/services/community/community';\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { CommunityDto } from 'src/services/CozoDb/types/dto';\nimport { ServiceDeps } from '../types';\n\n// eslint-disable-next-line import/no-unused-modules\nexport default function createCommunitySync$(\n  deps: ServiceDeps\n): Observable<CommunityDto[]> {\n  const { dbInstance$, ipfsInstance$, params$ } = deps;\n  const channel = new BroadcastChannelSender();\n\n  return combineLatest([\n    dbInstance$,\n    params$!.pipe(\n      map((params) => params.myAddress),\n      distinctUntilChanged()\n    ),\n    ipfsInstance$,\n  ]).pipe(\n    filter(\n      ([dbInstance, myAddress, ipfsInstance]) =>\n        !!dbInstance && !!ipfsInstance && !!myAddress\n    ),\n    switchMap(([dbApi, myAddress, ipfsInstance]) => {\n      const { waitForParticleResolve } = deps;\n      let community: CommunityDto[] = []; // Fix: Add type declaration for community array\n      return new Observable<CommunityDto[]>((observer) => {\n        observer.next([]);\n\n        fetchStoredSyncCommunity$(\n          dbApi!,\n          myAddress!,\n          waitForParticleResolve!\n        ).subscribe(({ action, items }: SyncCommunityResult) => {\n          channel.post({ type: 'load_community', value: { action, items } });\n\n          if (action === 'reset') {\n            community = [];\n          } else if (['add', 'complete'].some((s) => s === action)) {\n            community.push(...items);\n          }\n\n          if (action === 'complete') {\n            observer.next(community);\n            observer.complete();\n          }\n        });\n      });\n    })\n  );\n}\n","import {\n  BehaviorSubject,\n  defer,\n  Observable,\n  filter,\n  from,\n  mergeMap,\n  tap,\n} from 'rxjs';\nimport { IDeferredDbSaver } from 'src/services/QueueManager/types';\nimport { IPFSContent, IPFSContentMaybe } from 'src/services/ipfs/ipfs';\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { ParticleCid } from 'src/types/base';\nimport { mapParticleToEntity } from 'src/services/CozoDb/mapping';\nimport DbApi from '../dataSource/indexedDb/dbApiWrapper';\nimport { LinkDto } from 'src/services/CozoDb/types/dto';\n\ntype QueueItem = {\n  content?: IPFSContent;\n  links?: LinkDto[];\n};\n\ntype QueueMap = Map<ParticleCid | typeof uuidv4, QueueItem>;\n\nclass DeferredDbSaver implements IDeferredDbSaver {\n  private queue$ = new BehaviorSubject<QueueMap>(new Map());\n\n  private dbApi: DbApi | undefined;\n\n  public get queue(): QueueMap {\n    return this.queue$.getValue();\n  }\n\n  constructor(dbInstance$: Observable<DbApi | undefined>) {\n    dbInstance$.subscribe((db) => {\n      this.dbApi = db;\n    });\n\n    dbInstance$\n      .pipe(\n        filter((dbInstance) => !!dbInstance),\n        tap(() => cyblog.info('DeferredDbSaver - initialized')),\n        mergeMap(() => this.queue$), // Merge the queue$ stream here.\n        filter((queue) => queue.size > 0),\n        mergeMap((queue) => defer(() => from(this.processQueue(queue))))\n      )\n      .subscribe({\n        // next: () => console.log('Queue processed'),\n        error: (err) => console.error('Error processing IPFS queue', err),\n      });\n  }\n\n  public enqueueIpfsContent(content: IPFSContentMaybe) {\n    if (!content) {\n      return;\n    }\n    const { cid } = content;\n\n    this.queue$.next(new Map(this.queue$.value).set(cid, { content }));\n  }\n\n  public enqueueLinks(links: LinkDto[]) {\n    if (!links || !links.length) {\n      return;\n    }\n    const id = uuidv4();\n    this.queue$.next(new Map(this.queue$.value).set(id, { links }));\n  }\n\n  private async processQueue(queue: QueueMap) {\n    // const processingQueue = new Map(this.queue$.value); // Snapshot of the current queue\n    this.queue$.next(new Map());\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [cid, item] of queue) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.processQueueItem(item);\n      // console.log(' deffered DB done ', cid, item);\n\n      queue.delete(cid);\n    }\n    // this.queue$.next(queue);\n  }\n\n  private async processQueueItem(queueItem: QueueItem) {\n    const { content, links } = queueItem;\n    // console.log(`PostProcessing queue item: ${cid}`, item);\n    if (content) {\n      // eslint-disable-next-line no-await-in-loop\n      const entity = mapParticleToEntity(content);\n      await this.dbApi!.putParticles(entity);\n    }\n\n    if (links && links.length > 0) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.dbApi!.putCyberlinks(links);\n    }\n  }\n}\n\nexport default DeferredDbSaver;\n","import { ProxyMarked, Remote, proxy } from 'comlink';\n\nimport { initIpfsNode } from 'src/services/ipfs/node/factory';\n\nimport {\n  CybIpfsNode,\n  IpfsContentType,\n  IpfsOptsType,\n} from 'src/services/ipfs/ipfs';\n\nimport QueueManager from 'src/services/QueueManager/QueueManager';\n\n// import { CozoDbWorkerApi } from 'src/services/backend/workers/db/worker';\n\nimport {\n  QueueItemCallback,\n  QueueItemOptions,\n  QueuePriority,\n} from 'src/services/QueueManager/types';\nimport { ParticleCid } from 'src/types/base';\nimport { LinkDto } from 'src/services/CozoDb/types/dto';\nimport { BehaviorSubject, Subject } from 'rxjs';\n\nimport { exposeWorkerApi } from '../factoryMethods';\n\nimport { SyncService } from '../../services/sync/sync';\nimport { SyncServiceParams } from '../../services/sync/types';\n\nimport DbApi from '../../services/dataSource/indexedDb/dbApiWrapper';\n\nimport BroadcastChannelSender from '../../channels/BroadcastChannelSender';\nimport DeferredDbSaver from '../../services/DeferredDbSaver/DeferredDbSaver';\nimport { SyncEntryName } from '../../types/services';\n\nconst createBackgroundWorkerApi = () => {\n  const dbInstance$ = new Subject<DbApi | undefined>();\n\n  const ipfsInstance$ = new BehaviorSubject<CybIpfsNode | undefined>(undefined);\n\n  const params$ = new BehaviorSubject<SyncServiceParams>({\n    myAddress: null,\n  });\n\n  let ipfsNode: CybIpfsNode | undefined;\n  const defferedDbSaver = new DeferredDbSaver(dbInstance$);\n\n  const ipfsQueue = new QueueManager(ipfsInstance$, {\n    defferedDbSaver,\n  });\n  const broadcastApi = new BroadcastChannelSender();\n\n  // service to sync updates about cyberlinks, transactions, swarm etc.\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const syncService = new SyncService({\n    waitForParticleResolve: async (\n      cid: ParticleCid,\n      priority: QueuePriority = QueuePriority.MEDIUM\n    ) => ipfsQueue.enqueueAndWait(cid, { postProcessing: true, priority }),\n    dbInstance$,\n    ipfsInstance$,\n    params$,\n  });\n\n  const init = async (dbApiProxy: DbApi & ProxyMarked) => {\n    dbInstance$.next(dbApiProxy);\n  };\n\n  const stopIpfs = async () => {\n    if (ipfsNode) {\n      await ipfsNode.stop();\n    }\n    ipfsInstance$.next(undefined);\n    broadcastApi.postServiceStatus('ipfs', 'inactive');\n  };\n\n  const startIpfs = async (ipfsOpts: IpfsOptsType) => {\n    try {\n      if (ipfsNode) {\n        console.log('Ipfs node already started!');\n        await ipfsNode.stop();\n      }\n      broadcastApi.postServiceStatus('ipfs', 'starting');\n      ipfsNode = await initIpfsNode(ipfsOpts);\n\n      ipfsInstance$.next(ipfsNode);\n\n      setTimeout(() => broadcastApi.postServiceStatus('ipfs', 'started'), 0);\n      return true;\n    } catch (err) {\n      console.log('----ipfs node init error ', err);\n      const msg = err instanceof Error ? err.message : (err as string);\n      broadcastApi.postServiceStatus('ipfs', 'error', msg);\n      throw Error(msg);\n    }\n  };\n\n  const defferedDbApi = {\n    importCyberlinks: (links: LinkDto[]) => {\n      defferedDbSaver.enqueueLinks(links);\n    },\n  };\n\n  const ipfsApi = {\n    start: startIpfs,\n    stop: stopIpfs,\n    getIpfsNode: async () => ipfsNode && proxy(ipfsNode),\n    config: async () => ipfsNode?.config,\n    info: async () => ipfsNode?.info(),\n    fetchWithDetails: async (cid: string, parseAs?: IpfsContentType) =>\n      ipfsNode?.fetchWithDetails(cid, parseAs),\n    enqueue: async (\n      cid: string,\n      callback: QueueItemCallback,\n      options: QueueItemOptions\n    ) => ipfsQueue!.enqueue(cid, callback, options),\n    enqueueAndWait: async (cid: string, options?: QueueItemOptions) =>\n      ipfsQueue!.enqueueAndWait(cid, options),\n    dequeue: async (cid: string) => ipfsQueue.cancel(cid),\n    dequeueByParent: async (parent: string) => ipfsQueue.cancelByParent(parent),\n    clearQueue: async () => ipfsQueue.clear(),\n    addContent: async (content: string | File) => ipfsNode?.addContent(content),\n  };\n\n  return {\n    init,\n    isInitialized: () => !!ipfsInstance$.value,\n    // syncDrive,\n    ipfsApi: proxy(ipfsApi),\n    defferedDbApi: proxy(defferedDbApi),\n    ipfsQueue: proxy(ipfsQueue),\n    restartSync: (name: SyncEntryName) => syncService.restart(name),\n    setParams: (params: Partial<SyncServiceParams>) =>\n      params$.next({ ...params$.value, ...params }),\n  };\n};\n\nconst backgroundWorker = createBackgroundWorkerApi();\nexport type IpfsApi = Remote<typeof backgroundWorker.ipfsApi>;\nexport type BackgroundWorker = typeof backgroundWorker;\n\n// Expose the API to the main thread as shared/regular worker\nexposeWorkerApi(self, backgroundWorker);\n","export const CYBLOG_LOG_SHOW = 'cyblog_show';\n\nexport const CYBLOG_BROADCAST_CHANNEL_NAME = 'CYBLOG_BROADCST_CHANNEL';\n\nexport const CYBLOG_CONSOLE_PARAMS_DEFAULT = {\n  thread: 'all',\n  unit: 'all',\n  module: 'all',\n};\n","import _, { isEmpty } from 'lodash';\nimport { ConsoleLogParams, LogContext, LogItem, LogLevel } from './types';\nimport { CYBLOG_BROADCAST_CHANNEL_NAME } from './constants';\n\nconst logList: LogItem[] = [];\n\nfunction createCybLog<T>(defaultContext: Partial<LogContext<T>> = {}) {\n  function appendLog(logItem: LogItem, truncate = true) {\n    logList.push(logItem);\n\n    while (truncate && logList.length > 1000) {\n      logList.shift(); // Remove the first element to keep the list size <= 1000\n    }\n  }\n  let consoleLogParams = {} as ConsoleLogParams;\n\n  const channel = new BroadcastChannel(CYBLOG_BROADCAST_CHANNEL_NAME);\n\n  channel.onmessage = (event) => {\n    if (event.data.type === 'params') {\n      consoleLogParams = { ...consoleLogParams, ...event.data.value };\n    }\n  };\n\n  const getConsoleLogParams = () => consoleLogParams;\n\n  function consoleLog<T>(\n    level: LogLevel,\n    message: T,\n    context: Partial<LogContext<T>>\n  ) {\n    const ctx = _.omit(context, [\n      'formatter',\n      'thread',\n      'module',\n      'unit',\n      'data',\n    ]);\n    const { thread = '', module = '', unit = '', data = '' } = context;\n    const ctxItem = isEmpty(ctx) ? '' : ctx;\n\n    if (Array.isArray(message)) {\n      console[level](...message, ctxItem);\n      return;\n    }\n\n    if (context?.formatter) {\n      console[level](context?.formatter(message), ctxItem);\n      return;\n    }\n\n    console[level](`[${thread}:${module}:${unit}] ${message}`, data, ctxItem);\n  }\n\n  // eslint-disable-next-line import/no-unused-modules\n  function log<T>(\n    level: LogLevel,\n    message: string | T,\n    context: LogContext<any> = defaultContext\n  ) {\n    try {\n      const formattedMessage = context?.formatter\n        ? context?.formatter(message)\n        : message;\n\n      const logEntry = {\n        timestamp: new Date(),\n        level,\n        message: formattedMessage,\n        stacktrace: context?.stacktrace,\n        context: _.omit(context, ['formatter', 'stacktrace']),\n      };\n\n      appendLog(logEntry);\n      // !!localStorage.getItem(LOCAL_STORAGE_USE_CONSOLE_LOG_KEY) &&\n      const showConsoleLog = Object.keys(consoleLogParams).reduce(\n        (acc: boolean, key: string) => {\n          const params = consoleLogParams[key];\n          const contextItem = context[key];\n          if (params && contextItem) {\n            return (\n              acc ||\n              params === 'all' ||\n              params.length === 0 ||\n              params.some((p) => p === contextItem)\n            );\n          }\n          return acc;\n        },\n        false\n      );\n\n      if (showConsoleLog) {\n        consoleLog(level, message, context);\n      }\n    } catch (error) {\n      console.log('cyblog error', error);\n    }\n  }\n\n  function info<T>(message: T, context?: LogContext<string | T>) {\n    return log('info', message, context);\n  }\n\n  function error<T>(message: T, context?: LogContext<string | T>) {\n    return log('error', message, context);\n  }\n\n  function warn<T>(message: T, context?: LogContext<string | T>) {\n    return log('warn', message, context);\n  }\n\n  function trace<T>(message: T, context?: LogContext<string | T>) {\n    return log('warn', message, context);\n  }\n\n  function normalizeLog() {\n    return logList.map((logItem) => {\n      const { context, ...rest } = logItem;\n      const {\n        unit = '',\n        module = '',\n        thread = '',\n        data = '',\n        error = '',\n        stacktrace = '',\n      } = context || {};\n      return {\n        ...rest,\n        unit,\n        module,\n        thread,\n        data, //: JSON.stringify(data),\n        error,\n        stacktrace,\n      };\n    });\n  }\n\n  return {\n    log,\n    info,\n    error,\n    warn,\n    trace,\n    logList,\n    getLogs: () => normalizeLog(),\n    clear: () => logList.splice(0, logList.length),\n    getConsoleLogParams,\n  };\n}\n\nexport const createCyblogChannel = (\n  defaultContext: Partial<LogContext<T>> = {}\n) => {\n  const channel = new BroadcastChannel(CYBLOG_BROADCAST_CHANNEL_NAME);\n\n  function postLogToChannel<T>(\n    level: LogLevel,\n    message: T,\n    context?: LogContext<string | T>\n  ) {\n    const ctx = { ...defaultContext, ...context };\n    if (context?.error) {\n      ctx.error = JSON.stringify(context.error);\n    }\n    channel.postMessage({\n      type: 'log',\n      value: { level, message, context: ctx },\n    });\n  }\n\n  function info<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('info', message, context);\n  }\n\n  function error<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('error', message, context);\n  }\n\n  function warn<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('warn', message, context);\n  }\n\n  function trace<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('warn', message, context);\n  }\n\n  return { info, error, warn, trace };\n};\n\nconst cyblog = createCybLog({ thread: 'main' });\n\nexport type LogFunc = (message: T, context?: LogContext<string | T>) => void;\n\nexport type CyblogChannel = ReturnType<typeof createCyblogChannel>;\n\nexport default cyblog;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [598,393,698,724], function() { return __webpack_require__(17228); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdO = {};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"393\":\"d8cfa458\",\"598\":\"150c1fc2\",\"698\":\"4fa3266d\",\"724\":\"0892e360\",\"827\":\"89ce62da\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t280: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkcyb\"] = self[\"webpackChunkcyb\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","stringToCid","s","stringToIpfsPath","CYBER_NODE_SWARM_PEER_ID","CYBERNODE_SWARM_ADDR_WSS","CYBERNODE_SWARM_ADDR_TCP","CYBER_GATEWAY_URL","nodeType","_config","_isStarted","config","this","isStarted","response","node","get","gatewayUrl","address","nodeAddress","port","async","options","initConfig","window","toCid","console","log","swarm","localAddrs","map","a","toString","cid","files","stat","withLocal","size","then","result","type","sizeLocal","local","blocks","cat","content","add","pin","peers","c","peer","addr","bootstrap","connect","ls","repoSize","stats","repo","responseId","id","agentVersion","addOptionsV0","cidVersion","rawLeaves","blockstore","open","datastore","libp2p","bootstrapList","transports","rtcConfiguration","iceServers","urls","credential","username","discoverRelays","connectionEncryption","streamMuxers","connectionGater","denyDialMultiaddr","peerDiscovery","list","services","identify","libp2pFactory","fs","addEventListener","evt","peerId","detail","conn","getConnections","transportsByAddr","Object","fromEntries","remoteAddr","protoCodes","v","name","debug","getMultiaddrs","fileSize","localFileSize","dagSize","mtime","optionsV0","File","fileName","arrayBuffer","data","Uint8Array","addFile","path","TextEncoder","encode","addBytes","cid_","pins","isPinned","remotePeer","stop","start","dial","iterable","item","metadata","toV0","mapToLsResult","host","relay","enabled","hop","preload","API","HTTPHeaders","Addresses","Gateway","Swarm","Delegates","Discovery","MDNS","Enabled","Interval","webRTCStar","Bootstrap","Pubsub","ConnMgr","HighWater","LowWater","DisableNatPortMap","Routing","Type","filter","filters","nat","EXPERIMENTAL","ipnsPubsub","Number","getMimeFromUint8Array","raw","fileType","mime","PATTERN_HTTP","createImgData","rawData","basic","parseArrayLikeToDetails","onProgress","meta","link","gateway","initialType","includes","detectContentType","indexOf","bytesDownloaded","byteLength","chunks","ReadableStream","reader","getReader","readStream","done","value","push","read","Symbol","asyncIterator","chunk","error","getResponseResult","Buffer","from","dataBase64","length","match","string","newString","trim","slice","test","isHtml","text","shortenString","blob","Blob","URL","createObjectURL","e","createTextPreview","array","previewLength","db","version","stores","following","ipfsContentAddtToInddexdDB","dbValue","cluster","file","dataFile","status","loadIPFSContentFromDb","textPreview","source","emptyMeta","fetchIPFSContentMeta","signal","fetchIPFSContentFromNode","controller","controllerLegacy","AbortController","timer","setTimeout","abort","startTime","Date","now","statsDoneTime","statsTime","allowedSize","clearTimeout","availableDownload","firstChunk","offset","fullyDownloaded","stream","catTime","pinTime","fetchIPFSContentFromGateway","isExternalNode","contentUrl","fetch","method","body","flushResults","Promise","resolve","flush","firstChunkStream","fullStream","tee","firstReader","restReader","asyncIterable","toAsyncIterableWithMime","getIPFSContent","callBackFuncStatus","dataRsponseDb","addContenToIpfs","contentToUint8Array","nodeClassMap","helia","embedded","external","initIpfsNode","ipfsNodeType","restOptions","EnhancedClass","Base","parseAs","details","super","getPeers","find","swarmPeerId","lastConnectedTimestamp","isConnectedToSwarm","connectPeer","swarmPeerAddress","catch","err","message","withCybFeatures","instance","init","url","urlOpts","reconnectToSwarm","QueueStrategy","constructor","settings","order","getNextSource","index","QueueItemTimeoutError","Error","timeoutMs","setPrototypeOf","prototype","isParticle","Boolean","EntryType","SyncQueueStatus","initialState","isLoading","chats","summary","unreadCount","total","particles","neurons","formatApiData","entryType","chat","to","particle","formatted","timestamp","toISOString","transactionHash","hash","transaction_hash","memo","senseChatId","transactions","ownerId","fromAddress","inputs","assign","neuron","fromLog","getSenseList","senseApi","getList","getSenseChat","getLinks","getFriendItems","markAsRead","newChatStructure","checkIfMessageExists","newMessage","some","msg","reducers","updateSenseList","reducer","state","action","payload","forEach","concat","caseReducers","orderSenseList","prepare","addSenseItem","newList","unshift","updateSenseItem","chatId","txHash","isSuccess","sorted","keys","reduce","acc","lastMsg","sort","b","parse","i","reset","extraReducers","builder","addCase","pending","fulfilled","rejected","arg","sense","unreadCountParticle","unreadCountNeuron","values","actions","POCKET","POCKET_ACCOUNT","Networks","LOCALSTORAGE_CHAIN_ID","BOSTROM","CHAIN_PARAMS","CHAIN_ID","DENOM_CYBER","DENOM_LIQUID_TOKEN","DENOM_CYBER_G","CYBER_NODE_URL_API","CYBER_WEBSOCKET_URL","process","env","CYBER_NODE_URL_LCD","CYBER_INDEX_HTTPS","CYBER_INDEX_WEBSOCKET","BECH32_PREFIX_ACC_ADDR_CYBER","BECH32_PREFIX_ACC_ADDR_CYBERVALOPER","MEMO_KEPLR","SPACE_PUSSY","CYBER","CYBER_CONGRESS_ADDRESS","DIVISOR_CYBER_G","HYDROGEN","CYBER_GATEWAY","RegExp","actionBar","tweet","defaultAccount","account","accounts","saveToLocalStorage","localStorage","setItem","JSON","stringify","setDefaultAccount","setAccounts","setStageTweetActionBar","deleteAddress","accountKey","networkKey","bech32","cyber","entryCyber","entries","channel","BroadcastChannel","postServiceStatus","postMessage","postSyncEntryProgress","entry","postSenseUpdate","senseList","postSetDefaultAccount","post","getQueueItemTotalPriority","priority","viewPortPriority","strategies","timeout","maxConcurrentExecutions","ipfsInstance$","strategy","queueDebounceMs","defferedDbSaver","queue$","BehaviorSubject","Map","lastNodeCallTime","executing","Set","subscribe","setNode","interval","pipe","debounceTime","queue","cancelDeprioritizedItems","mergeMap","workItems","getItemBySourceAndPriority","merge","fetchData$","E","callbacks","callback","delete","removeAndNext","nextSource","switchSourceAndNext","postSummary","switchStrategy","customStrategy","pendingItems","pendingBySource","itemsToExecute","queueSource","items","executeCount","itemsByPriority","queueItem","set","executionTime","promiseFactory","res","fetchIpfsContent","enqueueIpfsContent","Observable","observer","complete","each","with","throwError","catchError","of","mutateQueueItem","changes","Array","releaseExecution","key","enqueue","existingItem","initialSource","postProcessing","enqueueAndWait","updateViewPortPriority","cancel","cancelByParent","parent","clear","getQueueMap","getQueueList","getStats","fn","QueuePriority","createAsyncIterable","promise","onmessage","event","IPFSContentTransferHandler","canHandle","obj","serialize","rest","port1","port2","MessageChannel","close","deserialize","serializedObj","SharedWorker","IS_DEV","installTransferHandlers","overrideLogging","worker","consoleLogMap","original","warn","replaceConsoleLog","args","apply","serializableArgs","String","safeStringify","broadcastStatus","channelApi","sendStatus","progress","asyncIterableBatchProcessor","batchProcess","batchSize","batch","CID_TWEET","CID_FOLLOW","SENSE_FRIEND_PARTICLES","deps","statusApi","_syncQueue$","waitForParticleResolve","dbInstance$","loadSyncQueue","isInitialized$","combineLatest","dbInstance","ipfsInstance","getValue","loop$","_loop$","all","MEDIUM","updateSyncQueue","removeSyncQueue","source$","tap","q","isInitialized","processSyncQueue","share","URGENT","cids","putSyncQueue","getSyncQueue","statuses","numberToUtcDate","dateToUtcNumber","isoString","endsWith","mapIndexerTransactionToEntity","tx","transaction","block","height","success","blockHeight","mapLinkFromIndexerToDto","throwIfAborted","func","aborted","DOMException","CYBER_INDEX_WSS","CYBER_NODE_URL_WS","MSG_SEND_TRANSACTION_TYPE","MSG_MULTI_SEND_TRANSACTION_TYPE","mapWebsocketTxToTransactions","events","transactionType","messages","Tx","msgType","typeUrl","MsgSend","MsgMultiSend","extractTxData","TxResult","fetchIterable","fetchFunction","params","cyberGraphQLWsLink","shouldRetry","errOrCloseEvent","retryAttempts","retryWait","retries","Math","min","createIndexerClient","abortSignal","cyberlinksByParticle","cyberlinksCountByNeuron","fetchCyberlinks","particleCid","timestampFrom","request","limit","orderBy","where","_or","particle_to","_eq","particle_from","_gt","cyberlinks","fetchCyberlinksByNeroun","particlesFrom","_and","_in","fetchCyberlinksByNerounIterable","getUniqueParticlesFromLinks","links","fetchCyberlinksAndResolveParticles","timestampUpdate","particlesResolver","queuePriority","cyberlinksIterable","fetchCyberlinksIterable","enqueueBatch","mapMessagesByAddressVariables","types","orderDirection","timestamp_from","t","join","order_direction","gqlMessagesByAddress","fetchTransactions","messages_by_address","transactionsCountByNeuron","updateSenseChat","amount","isSender","userAddress","lastSendTimestamp","last","direction","syncMyChats","myAddress","shouldUpdateTimestamp","syncItems","findSyncStatus","syncItemsMap","myChats","outputs","coins","toAddress","extractSenseChats","getTransactions","results","syncItem","lastTransaction","at","transactionTimestamp","syncItemHeader","timestampRead","prevUnreadCount","lastTimestampRead","max","timestampUpdateContent","timestampUpdateChat","timestampUnreadFrom","newTimestampUpdateChat","syncStatusChanges","updateSyncStatus","bind","newItem","disabled","putSyncStatus","ProgressTracker","onProgressUpdate","requestRecords","totalRequests","completedRequests","estimatedTime","totalCount","completeCount","extraRequests","trackProgress","processedCount","addRequestRecord","shift","estimatedRemainingTime","calculateAverageTimePerItem","round","itemCount","totalDiff","totalItems","timeDiff","progressTracker","abortController","cyblogCh","thread","module","params$","createIsInitializedObserver","info","switchMap","createRestartObserver","restart","initAbortController","distinctUntilChanged","addrBefore","addrAfter","switchWhenInitialized","actionObservable$","onChange","initialized","reloadTrigger$","Subject","startWith","createInitObservable","createClientObservable","onUpdate","syncQueueInitialized","variables","indexerObservable$","query","apolloObservable","ApolloClient","cache","subscriber","subscription","unsubscribe","createIndexerWebsocket","nodeObservample$","ws","WebSocket","onopen","send","jsonrpc","onerror","onclose","createNodeWebsocketObservable","ctx","unit","isEmpty","defer","initSync","getSyncStatus","lastTransactionTimestamp","syncTransactions","syncStatusItems","processBatchTransactions","putTransactions","syncLinks","lastTimestampFrom","newSyncItem","totalMessageCount","messages_by_address_aggregate","aggregate","count","fetchTransactionMessagesCount","ceil","transactionsAsyncIterable","fetchTransactionsIterable","transactionCount","tweets","particlesFound","l","txLink","extractCybelinksFromTransaction","putCyberlinks","tweetParticles","nonTweetParticles","HIGH","LOW","snakeToCamel","str","replace","group","toUpperCase","entityToDto","dbEntity","dto","hasOwnProperty","call","camelCaseKey","isArray","getLastReadInfo","prevTimestampRead","lastUnreadLinks","lastMyLinkIndex","findLastIndex","changeParticleSyncStatus","syncStatus","lastLink","isAbortException","intervalMs","warmupMs","restartLoop","onStartInterval","onError","retryDelayMs","restartTrigger$","intervalOrRestart$","delay","exhaustMap","retry","createLoopObservable","doSync","sync","isAborted","particleResolverInitialized","syncItemParticles","newLinkCount","particles_from","cyberlinks_aggregate","fetchCyberlinksCount","newSyncItemParticles","fetchNewTweets","syncParticles","tweetsAsyncIterable","newTweets","existingParticles","existingParticlesMap","tweetsBatch","syncStatusEntities","timestampSyncFrom","updatedSyncItems","linksIndexer","followings$","followings","followingsInitialized$","followingsInitialized","syncUpdates","linksAsyncIterable","linksBatch","newTimestampRead","newUnreadCount","newTimestampUpdateContent","reject","buffer","marshal","DAGNode","dagNode","toBaseEncodedString","fetchStoredSyncCommunity$","dbApi","fetchParticleAsync","storedCommunity","getCommunity","communityUpdatesMap","getExistingOrDefault","follower","followsCids","txs","followers","addressHash","newFollowerCids","newFollowingNeurons","followersCommunity","communityItem","putCommunity","SyncService","loops","communitySync$","community","createCommunitySync$","processQueue","enqueueLinks","processQueueItem","entity","size_local","mapParticleToEntity","putParticles","backgroundWorker","ipfsNode","ipfsQueue","broadcastApi","syncService","defferedDbApi","importCyberlinks","ipfsApi","ipfsOpts","getIpfsNode","fetchWithDetails","dequeue","dequeueByParent","clearQueue","addContent","dbApiProxy","restartSync","setParams","createBackgroundWorkerApi","api","self","onconnect","ports","CYBLOG_BROADCAST_CHANNEL_NAME","logList","createCyblogChannel","defaultContext","postLogToChannel","level","context","trace","cyblog","consoleLogParams","formattedMessage","formatter","logItem","truncate","appendLog","stacktrace","contextItem","p","ctxItem","consoleLog","getLogs","splice","getConsoleLogParams","createCybLog","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","loaded","__webpack_modules__","m","x","__webpack_exports__","O","amdO","chunkIds","notFulfilled","Infinity","j","every","r","n","getter","__esModule","d","getPrototypeOf","__proto__","mode","ns","create","def","current","getOwnPropertyNames","definition","o","defineProperty","enumerable","f","chunkId","promises","u","miniCssF","g","globalThis","Function","prop","toStringTag","nmd","paths","children","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","pop"],"sourceRoot":""}