{"version":3,"file":"73.3e3d6f2f.chunk.js","mappings":"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","sources":["webpack://cyb/webpack/runtime/chunk loaded","webpack://cyb/webpack/runtime/create fake namespace object","webpack://cyb/webpack/runtime/startup chunk dependencies","webpack://cyb/./src/services/ipfs/utils/cid.ts","webpack://cyb/./src/services/ipfs/config.ts","webpack://cyb/./src/services/ipfs/node/impl/kubo.ts","webpack://cyb/./src/services/ipfs/node/impl/helia.ts","webpack://cyb/./src/services/ipfs/node/impl/configs/jsIpfsConfig.ts","webpack://cyb/./src/services/ipfs/node/impl/js-ipfs.ts","webpack://cyb/./src/services/ipfs/utils/stream.ts","webpack://cyb/./src/services/ipfs/utils/content.ts","webpack://cyb/./src/db.js","webpack://cyb/./src/services/ipfs/utils/ipfsCacheDb.ts","webpack://cyb/./src/services/ipfs/utils/cluster.ts","webpack://cyb/./src/services/ipfs/utils/utils-ipfs.ts","webpack://cyb/./src/services/ipfs/node/factory.ts","webpack://cyb/./src/services/ipfs/node/mixins/withCybFeatures.ts","webpack://cyb/./src/services/QueueManager/QueueStrategy.ts","webpack://cyb/./src/services/QueueManager/QueueItemTimeoutError.ts","webpack://cyb/./src/features/particle/utils.tsx","webpack://cyb/./src/services/CozoDb/types/entities.ts","webpack://cyb/./src/features/sense/redux/sense.redux.ts","webpack://cyb/./src/services/backend/channels/BroadcastChannelSender.ts","webpack://cyb/./src/services/backend/channels/consts.ts","webpack://cyb/./src/services/QueueManager/QueueManager.ts","webpack://cyb/./src/utils/helpers.ts","webpack://cyb/./src/services/QueueManager/types.ts","webpack://cyb/./src/services/backend/workers/serializers.ts","webpack://cyb/./src/services/backend/workers/factoryMethods.ts","webpack://cyb/./src/services/backend/channels/broadcastStatus.ts","webpack://cyb/./src/utils/async/iterable.ts","webpack://cyb/./src/constants/app.ts","webpack://cyb/./src/services/backend/services/sync/services/consts.ts","webpack://cyb/./src/services/backend/services/sync/services/ParticlesResolverQueue/ParticlesResolverQueue.ts","webpack://cyb/./src/utils/date.ts","webpack://cyb/./src/services/CozoDb/mapping.ts","webpack://cyb/./src/utils/async/promise.ts","webpack://cyb/./src/constants/config.ts","webpack://cyb/./src/services/backend/services/indexer/types.ts","webpack://cyb/./src/services/blockchain/utils/mapping.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/utils/fetch.ts","webpack://cyb/./src/services/backend/services/indexer/utils.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/indexer.ts","webpack://cyb/./src/services/backend/services/dataSource/blockchain/consts.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/links.ts","webpack://cyb/./src/services/backend/services/indexer/transactions.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/sense.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncTransactionsLoop/services/chat.ts","webpack://cyb/./src/services/backend/services/sync/services/ProgressTracker/ProgressTracker.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSync.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/rxjs/withInitializer.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSyncClient.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncTransactionsLoop/SyncTransactionsLoop.ts","webpack://cyb/./src/services/blockchain/websocket.ts","webpack://cyb/./src/utils/dto.ts","webpack://cyb/./src/services/backend/services/sync/utils.ts","webpack://cyb/./src/utils/exceptions/helpers.ts","webpack://cyb/./src/services/backend/services/sync/services/BaseSyncLoop/BaseSyncLoop.ts","webpack://cyb/./src/services/backend/services/sync/services/utils/rxjs/loop.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncParticlesLoop/SyncParticlesLoop.ts","webpack://cyb/./src/services/backend/services/sync/services/SyncMyFriendsLoop/SyncMyFriendsLoop.ts","webpack://cyb/./src/utils/ipfs/helpers.ts","webpack://cyb/./src/services/community/community.ts","webpack://cyb/./src/services/backend/services/lcd/lcd.ts","webpack://cyb/./src/services/backend/services/sync/sync.ts","webpack://cyb/./src/services/backend/services/sync/services/CommunitySync/CommunitySync.ts","webpack://cyb/./src/services/backend/services/DeferredDbSaver/DeferredDbSaver.ts","webpack://cyb/./src/services/backend/workers/background/worker.ts","webpack://cyb/./src/utils/logging/constants.ts","webpack://cyb/./src/utils/logging/cyblog.ts","webpack://cyb/webpack/bootstrap","webpack://cyb/webpack/runtime/amd options","webpack://cyb/webpack/runtime/compat get default export","webpack://cyb/webpack/runtime/define property getters","webpack://cyb/webpack/runtime/ensure chunk","webpack://cyb/webpack/runtime/get javascript chunk filename","webpack://cyb/webpack/runtime/get mini-css chunk filename","webpack://cyb/webpack/runtime/global","webpack://cyb/webpack/runtime/hasOwnProperty shorthand","webpack://cyb/webpack/runtime/make namespace object","webpack://cyb/webpack/runtime/node module decorator","webpack://cyb/webpack/runtime/publicPath","webpack://cyb/webpack/runtime/importScripts chunk loading","webpack://cyb/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });\n\t}\n\tdef['default'] = function() { return value; };\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([912,393,698,724].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","import { CID } from 'multiformats/cid';\n\nexport const stringToCid = (s: string) => CID.parse(s);\nexport const stringToIpfsPath = (s: string) => `/ipfs/${s}`;\n","import { IPFSNodes, IpfsOptsType } from './ipfs.d';\n\nexport const CYBER_NODE_SWARM_PEER_ID =\n  'QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB';\n\nexport const CYBERNODE_SWARM_ADDR_WSS = `/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/${CYBER_NODE_SWARM_PEER_ID}`;\nexport const CYBERNODE_SWARM_ADDR_TCP = `/ip4/88.99.105.146/tcp/4001/p2p/${CYBER_NODE_SWARM_PEER_ID}`;\n\nexport const IPFS_CLUSTER_URL = 'https://io.cybernode.ai';\n\nexport const CYBER_GATEWAY_URL = 'https://gateway.ipfs.cybernode.ai';\n\nexport const FILE_SIZE_DOWNLOAD = 20 * 10 ** 6;\n\nexport const getIpfsOpts = () => {\n  let ipfsOpts: IpfsOptsType = {\n    ipfsNodeType: IPFSNodes.HELIA,\n    urlOpts: '/ip4/127.0.0.1/tcp/5001', // default url\n    userGateway: 'http://127.0.0.1:8080',\n  };\n\n  // get type ipfs\n  const lsTypeIpfs = localStorage.getItem('ipfsState');\n  if (lsTypeIpfs !== null) {\n    const lsTypeIpfsData = JSON.parse(lsTypeIpfs);\n    ipfsOpts = { ...ipfsOpts, ...lsTypeIpfsData };\n  }\n\n  localStorage.setItem('ipfsState', JSON.stringify(ipfsOpts));\n\n  return ipfsOpts as IpfsOptsType;\n};\n","import { IPFSHTTPClient, create as createKuboClient } from 'kubo-rpc-client';\nimport { multiaddr } from '@multiformats/multiaddr';\n\nimport { stringToCid, stringToIpfsPath } from '../../utils/cid';\nimport {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  InitOptions,\n  IpfsFileStats,\n  IpfsNode,\n  IpfsNodePrperties,\n} from '../../ipfs';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nclass KuboNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'external';\n\n  private node?: IPFSHTTPClient;\n\n  private _config: IpfsNodePrperties = {};\n\n  get config() {\n    return this._config;\n  }\n\n  private _isStarted: boolean = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private async initConfig() {\n    const response = await this.node!.config.get('Addresses.Gateway');\n    if (!response) {\n      return { gatewayUrl: CYBER_GATEWAY_URL };\n    }\n    const address = multiaddr(response as string).nodeAddress();\n\n    return { gatewayUrl: `http://${address.address}:${address.port}` };\n  }\n\n  async init(options?: InitOptions) {\n    this.node = createKuboClient(options);\n    this._config = await this.initConfig();\n\n    if (typeof window !== 'undefined') {\n      window.node = this.node;\n      window.toCid = stringToCid;\n    }\n    console.log(\n      'IPFS - Kubo addrs',\n      (await this.node.swarm.localAddrs()).map((a) => a.toString())\n    );\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.node!.files.stat(stringToIpfsPath(cid), {\n      ...options,\n      withLocal: true,\n      size: true,\n    }).then((result) => {\n      const { type, size, sizeLocal, local, blocks } = result;\n      return {\n        type,\n        size: size || -1,\n        sizeLocal: sizeLocal || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.node!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    return (await this.node!.add(content, options)).cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    return (await this.node!.pin.add(stringToCid(cid), options)).toString();\n  }\n\n  async getPeers() {\n    return (await this.node!.swarm.peers()).map((c) => c.peer.toString());\n  }\n\n  async stop() {}\n  async start() {}\n\n  async connectPeer(address: string) {\n    const addr = multiaddr(address);\n    await this.node!.bootstrap.add(addr);\n\n    await this.node!.swarm.connect(addr);\n    return true;\n  }\n\n  ls() {\n    return this.node!.pin.ls();\n  }\n\n  async info() {\n    const { repoSize } = await this.node!.stats.repo();\n\n    const responseId = await this.node!.id();\n    const { agentVersion, id } = responseId;\n    return { id: id.toString(), agentVersion, repoSize };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default KuboNode;\n","import { Helia, Pin, createHelia } from 'helia';\nimport { IDBBlockstore } from 'blockstore-idb';\nimport { IDBDatastore } from 'datastore-idb';\nimport { Libp2p, createLibp2p } from 'libp2p';\nimport { noise } from '@chainsafe/libp2p-noise';\nimport { yamux } from '@chainsafe/libp2p-yamux';\n// import { mplex } from '@libp2p/mplex';\n\nimport { circuitRelayTransport } from 'libp2p/circuit-relay';\nimport { UnixFS, unixfs, AddOptions } from '@helia/unixfs';\nimport { bootstrap } from '@libp2p/bootstrap';\nimport { webRTC, webRTCDirect } from '@libp2p/webrtc';\nimport { webSockets } from '@libp2p/websockets';\nimport { webTransport } from '@libp2p/webtransport';\nimport { identifyService } from 'libp2p/identify';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport { LsResult } from 'ipfs-core-types/src/pin';\n\nimport {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  IpfsFileStats,\n  IpfsNode,\n} from '../../ipfs';\n// import { all } from '@libp2p/websockets/filters';\nimport { stringToCid } from '../../utils/cid';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nasync function* mapToLsResult(\n  iterable: AsyncIterable<Pin>\n): AsyncIterable<LsResult> {\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of iterable) {\n    const { cid, metadata } = item;\n    yield { cid: cid.toV0(), metadata, type: 'recursive' };\n  }\n}\n\nconst libp2pFactory = async (\n  datastore: IDBDatastore,\n  bootstrapList: string[] = []\n) => {\n  const libp2p = await createLibp2p({\n    datastore,\n    // addresses: {\n    //   listen: [\n    //     '/ip4/127.0.0.1/tcp/0',\n    //     '/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    //   ],\n    // },\n    transports: [\n      webSockets(),\n      webTransport(),\n      webRTC({\n        rtcConfiguration: {\n          iceServers: [\n            {\n              urls: [\n                'stun:stun.l.google.com:19302',\n                'stun:global.stun.twilio.com:3478',\n                'STUN:freestun.net:3479',\n                'STUN:stun.bernardoprovenzano.net:3478',\n                'STUN:stun.aa.net.uk:3478',\n              ],\n            },\n            {\n              credential: 'free',\n              username: 'free',\n              urls: ['TURN:freestun.net:3479', 'TURNS:freestun.net:5350'],\n            },\n          ],\n        },\n      }),\n      webRTCDirect(),\n      circuitRelayTransport({\n        discoverRelays: 1,\n      }),\n    ],\n    connectionEncryption: [noise()],\n    streamMuxers: [yamux()],\n    connectionGater: {\n      denyDialMultiaddr: () => {\n        return false;\n        // by default we refuse to dial local addresses from the browser since they\n        // are usually sent by remote peers broadcasting undialable multiaddrs but\n        // here we are explicitly connecting to a local node so do not deny dialing\n        // any discovered address\n      },\n    },\n    peerDiscovery: [\n      bootstrap({\n        list: bootstrapList,\n      }),\n    ],\n    services: {\n      identify: identifyService(),\n    },\n  });\n  return libp2p;\n};\n\nconst addOptionsV0: Partial<AddOptions> = {\n  cidVersion: 0,\n  rawLeaves: false,\n};\n\nclass HeliaNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'helia';\n\n  get config() {\n    return { gatewayUrl: CYBER_GATEWAY_URL };\n  }\n\n  private _isStarted = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private node?: Helia;\n\n  private fs?: UnixFS;\n\n  async init() {\n    const blockstore = new IDBBlockstore('helia-bs');\n    await blockstore.open();\n\n    const datastore = new IDBDatastore('helia-ds');\n    await datastore.open();\n\n    const bootstrapList = [\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n      '/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n      '/dns4/swarm.io.cybernode.ai/tcp/443/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    ];\n    const libp2p = await libp2pFactory(datastore, bootstrapList);\n\n    this.node = await createHelia({ blockstore, datastore, libp2p });\n\n    this.fs = unixfs(this.node);\n\n    if (typeof window !== 'undefined') {\n      window.libp2p = libp2p;\n      window.node = this.node;\n      window.fs = this.fs;\n      window.toCid = stringToCid;\n    }\n\n    // DEBUG\n    libp2p.addEventListener('peer:connect', (evt) => {\n      const peerId = evt.detail.toString();\n      const conn = libp2p.getConnections(peerId) || [];\n      const transportsByAddr = Object.fromEntries(\n        conn.map((c) => [\n          c.remoteAddr.toString(),\n          c.remoteAddr.protoCodes().map((v) => protocols(v)?.name),\n        ])\n      );\n      console.debug(`Connected to ${peerId}`, transportsByAddr);\n\n      // console.log(\n      //   '---------ppppp',\n      //   peerId,\n      //   conn,\n      //   conn?.remoteAddr.protoCodes().map((v) => protocols(v)?.name)\n      // ); //.includes(WEBRTC_CODE)\n      // if (conn && conn.stat) {\n      //   const transport = conn.stat.transport; // This might vary based on libp2p version\n      //   console.log(`Connected to ${peerId} using transport ${transport}`);\n      // } else {\n      //   console.log(`Connected to ${peerId}`);\n      // }\n    });\n    libp2p.addEventListener('peer:disconnect', (evt) => {\n      console.debug(`Disconnected from ${evt.detail.toString()}`);\n    });\n    console.log(\n      'IPFS - Helia addrs',\n      libp2p.getMultiaddrs().map((a) => a.toString())\n    );\n    // const webrtcConn = await libp2p.dial(\n    //   multiaddr(\n    //     '/ip4/127.0.0.1/udp/4001/quic-v1/webtransport/certhash/uEiDHumbyZRFV1Av7qH9-2l5HGgU2a2UqM6eloqO0vYz5pQ/certhash/uEiDD_TuVgih5_ua31Z4MVbNq7WSw095UAQmZqdUFMDTVRA/p2p/12D3KooWEYGfgK4dEY3spfuDKVq6Jpiyj4KxP1r6HS5RFp5WHebz'\n    //   )\n    // );\n    // console.log('----webrtcConn', webrtcConn);\n\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.fs!.stat(stringToCid(cid), options).then((result) => {\n      const { type, fileSize, localFileSize, blocks, dagSize, mtime } = result;\n      return {\n        type,\n        size: fileSize || -1,\n        sizeLocal: localFileSize || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.fs!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    // Options to keep CID in V0 format 'Qm....';\n    const optionsV0 = {\n      ...options,\n      ...addOptionsV0,\n    } as Partial<AddOptions>;\n\n    let cid;\n\n    if (content instanceof File) {\n      const fileName = content.name;\n      const arrayBuffer = await content.arrayBuffer();\n      const data = new Uint8Array(arrayBuffer);\n      cid = await this.fs!.addFile(\n        { path: fileName, content: data },\n        optionsV0\n      );\n    } else {\n      const data = new TextEncoder().encode(content);\n      cid = await this.fs!.addBytes(data, optionsV0);\n    }\n    console.log('----added to helia', cid.toString());\n    this.pin(cid.toString(), options);\n    return cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    const cid_ = stringToCid(cid);\n    const isPinned = await this.node?.pins.isPinned(cid_, options);\n    if (!isPinned) {\n      const pinResult = (\n        await this.node?.pins.add(cid_, options)\n      )?.cid.toString();\n      // console.log('------pin', pinResult);\n    }\n    // console.log('------pinned', cid, isPinned);\n    return undefined;\n  }\n\n  async getPeers() {\n    return this.node!.libp2p!.getConnections().map((c) =>\n      c.remotePeer.toString()\n    );\n  }\n\n  async stop() {\n    await this.node?.stop();\n  }\n\n  async start() {\n    await this.node?.start();\n  }\n\n  async connectPeer(address: string) {\n    const conn = await this.node!.libp2p!.dial(multiaddr(address));\n    return true;\n  }\n\n  ls() {\n    const result = mapToLsResult(this.node!.pins.ls());\n    return result;\n  }\n\n  async info() {\n    const id = this.node!.libp2p.peerId.toString();\n    const agentVersion = this.node!.libp2p!.services!.identify!.host!\n      .agentVersion as string;\n    return { id, agentVersion, repoSize: -1 };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default HeliaNode;\n","// eslint-disable-next-line import/no-unresolved\nimport { webSockets } from '@libp2p/websockets';\nimport * as filters from '@libp2p/websockets/filters';\nimport { Options } from 'ipfs-core/dist/src/types';\n\nconst configIpfs = (): Options => ({\n  start: true,\n  repo: 'ipfs-repo-cyber-v2',\n  relay: {\n    enabled: false,\n    hop: {\n      enabled: false,\n    },\n  },\n  preload: {\n    enabled: false,\n  },\n  config: {\n    API: {\n      HTTPHeaders: {\n        'Access-Control-Allow-Methods': ['PUT', 'POST'],\n        'Access-Control-Allow-Origin': [\n          'http://localhost:3000',\n          'http://127.0.0.1:5001',\n          'http://127.0.0.1:8888',\n          'http://localhost:8888',\n        ],\n      },\n    },\n    Addresses: {\n      Gateway: '/ip4/127.0.0.1/tcp/8080',\n      Swarm: [\n        // '/dns4/ws-star.discovery.cybernode.ai/tcp/443/wss/p2p-webrtc-star',\n        // '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',\n        // '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star',\n      ],\n      Delegates: [\n        // '/dns4/node0.delegate.ipfs.io/tcp/443/https',\n        // '/dns4/node1.delegate.ipfs.io/tcp/443/https',\n        // '/dns4/node2.delegate.ipfs.io/tcp/443/https',\n      ],\n    },\n    Discovery: {\n      MDNS: {\n        Enabled: true,\n        Interval: 10,\n      },\n      webRTCStar: {\n        Enabled: false,\n      },\n    },\n    Bootstrap: [\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n      // '/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n      // '/dns4/ws-star.discovery.cybernode.ai/tcp/4430/wss/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB',\n    ],\n    Pubsub: {\n      Enabled: false,\n    },\n    Swarm: {\n      ConnMgr: {\n        HighWater: 300,\n        LowWater: 50,\n      },\n      DisableNatPortMap: false,\n    },\n    Routing: {\n      Type: 'dhtclient',\n    },\n  },\n  libp2p: {\n    transports: [\n      // This is added for local demo!\n      // In a production environment the default filter should be used\n      // where only DNS + WSS addresses will be dialed by websockets in the browser.\n      webSockets({\n        filter: filters.dnsWss,\n      }),\n    ],\n    nat: {\n      enabled: false,\n    },\n  },\n  EXPERIMENTAL: {\n    ipnsPubsub: false,\n  },\n});\n\nexport default configIpfs;\n","import {\n  AbortOptions,\n  CatOptions,\n  IpfsNodeType,\n  IpfsFileStats,\n  IpfsNode,\n  IpfsNodePrperties,\n} from '../../ipfs';\nimport { create as createJsIpfsClient, IPFS } from 'ipfs-core';\nimport { stringToCid, stringToIpfsPath } from '../../utils/cid';\nimport { multiaddr } from '@multiformats/multiaddr';\n\nimport configIpfs from './configs/jsIpfsConfig';\nimport { CYBER_GATEWAY_URL } from '../../config';\n\nclass JsIpfsNode implements IpfsNode {\n  readonly nodeType: IpfsNodeType = 'embedded';\n\n  get config() {\n    return { gatewayUrl: CYBER_GATEWAY_URL };\n  }\n\n  private _isStarted: boolean = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  private node?: IPFS;\n\n  async init() {\n    this.node = await createJsIpfsClient(configIpfs());\n    if (typeof window !== 'undefined') {\n      window.node = this.node;\n      window.toCid = stringToCid;\n    }\n\n    this._isStarted = true;\n  }\n\n  async stat(cid: string, options: AbortOptions = {}): Promise<IpfsFileStats> {\n    return this.node!.files.stat(stringToIpfsPath(cid), {\n      ...options,\n      withLocal: true,\n      size: true,\n    }).then((result) => {\n      const { type, size, sizeLocal, local, blocks } = result;\n      return {\n        type,\n        size: size || -1,\n        sizeLocal: sizeLocal || -1,\n        blocks,\n      };\n    });\n  }\n\n  cat(cid: string, options: CatOptions = {}) {\n    return this.node!.cat(stringToCid(cid), options);\n  }\n\n  async add(content: File | string, options: AbortOptions = {}) {\n    return (await this.node!.add(content, options)).cid.toString();\n  }\n\n  async pin(cid: string, options: AbortOptions = {}) {\n    return (await this.node!.pin.add(stringToCid(cid), options)).toString();\n  }\n\n  async getPeers() {\n    return (await this.node!.swarm.peers()).map((c) => c.peer.toString());\n  }\n\n  async stop() {}\n  async start() {}\n\n  async connectPeer(address: string) {\n    const addr = multiaddr(address);\n    await this.node!.bootstrap.add(addr);\n\n    await this.node!.swarm.connect(addr);\n    return true;\n  }\n\n  ls() {\n    return this.node!.pin.ls();\n  }\n\n  async info() {\n    const response = await this.node!.stats.repo();\n    const repoSize = Number(response.repoSize);\n\n    const responseId = await this.node!.id();\n    const { agentVersion, id } = responseId;\n    return { id: id.toString(), agentVersion, repoSize };\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport default JsIpfsNode;\n","/* eslint-disable valid-jsdoc */\n/* eslint-disable import/no-unused-modules */\nimport { fileTypeFromBuffer } from 'file-type';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { Uint8ArrayLike } from '../ipfs';\n\ntype ResultWithMime = {\n  result: Uint8ArrayLike;\n  mime: string | undefined;\n  firstChunk: Uint8Array | undefined;\n};\n\ntype StreamDoneCallback = (\n  chunks: Array<Uint8Array>,\n  mime: string | undefined\n) => Promise<void> | void;\n\n// interface AsyncIterableWithReturn<T> extends AsyncIterable<T> {\n//   return?: (value?: unknown) => Promise<IteratorResult<T>>;\n// }\n\nexport const getMimeFromUint8Array = async (\n  raw: Uint8Array | undefined\n): Promise<string | undefined> => {\n  if (!raw) {\n    return 'unknown';\n  }\n  // TODO: try to pass only first N-bytes\n  const fileType = await fileTypeFromBuffer(raw);\n\n  return fileType?.mime || 'text/plain';\n};\n\nexport async function toAsyncIterableWithMime(\n  stream: ReadableStream<Uint8Array>,\n  flush?: StreamDoneCallback\n): Promise<ResultWithMime> {\n  const [firstChunkStream, fullStream] = stream.tee();\n  const chunks: Array<Uint8Array> = []; // accumulate all the data to pim/save\n\n  // Read the first chunk from the stream\n  const firstReader = firstChunkStream.getReader();\n  const { value } = await firstReader.read();\n  const mime = value ? await getMimeFromUint8Array(value) : undefined;\n\n  const restReader = fullStream.getReader();\n\n  const asyncIterable: AsyncIterable<Uint8Array> = {\n    async *[Symbol.asyncIterator]() {\n      while (true) {\n        const { done, value } = await restReader.read();\n        if (done) {\n          flush && flush(chunks, mime);\n          return; // Exit the loop when done\n        }\n        flush && chunks.push(value);\n        yield value; // Yield the value to the consumer\n      }\n    },\n  };\n\n  return { mime, result: asyncIterable, firstChunk: value };\n}\n\nexport async function toReadableStreamWithMime(\n  stream: ReadableStream<Uint8Array>,\n  flush?: StreamDoneCallback\n): Promise<ResultWithMime> {\n  const [firstChunkStream, fullStream] = stream.tee();\n  const chunks: Array<Uint8Array> = []; // accumulate all the data to pim/save\n\n  // Read the first chunk from the stream\n  const firstReader = firstChunkStream.getReader();\n  const { value } = await firstReader.read();\n  const mime = value ? await getMimeFromUint8Array(value) : undefined;\n\n  const modifiedStream = new ReadableStream<Uint8Array>({\n    async pull(controller) {\n      const restReader = fullStream.getReader();\n      const { done, value } = await restReader.read();\n      if (done) {\n        controller.close();\n        flush && flush(chunks, mime);\n      } else {\n        controller.enqueue(value);\n        flush && chunks.push(value);\n      }\n      restReader.releaseLock();\n    },\n    cancel() {\n      firstChunkStream.cancel();\n      fullStream.cancel();\n    },\n  });\n\n  return { mime, result: modifiedStream, firstChunk: value };\n}\n\nexport type onProgressCallback = (progress: number) => void;\n\nexport const getResponseResult = async (\n  response: Uint8ArrayLike,\n  onProgress?: onProgressCallback\n) => {\n  let bytesDownloaded = 0;\n  try {\n    if (response instanceof Uint8Array) {\n      onProgress && onProgress(response.byteLength);\n      return response;\n    }\n    const chunks: Array<Uint8Array> = [];\n\n    if (response instanceof ReadableStream) {\n      const reader = response.getReader();\n\n      const readStream = async ({\n        done,\n        value,\n      }: ReadableStreamReadResult<Uint8Array>): Promise<Uint8Array> => {\n        if (done) {\n          return uint8ArrayConcat(chunks);\n        }\n\n        chunks.push(value!);\n        bytesDownloaded += value!.byteLength;\n        onProgress && onProgress(bytesDownloaded);\n        return reader.read().then(readStream);\n      };\n\n      const readArray: Uint8Array = await reader.read().then(readStream);\n\n      return readArray;\n    }\n\n    const reader = response[Symbol.asyncIterator]();\n\n    // if (cid === 'QmRqms6Utkk6L4mtyLQXY2spcQ8Pk7fBBTNjvxa9jTNrXp') {\n    //   debugger;\n    // }\n    // eslint-disable-next-line no-restricted-syntax\n    for await (const chunk of reader) {\n      if (chunk instanceof Uint8Array) {\n        chunks.push(chunk);\n        bytesDownloaded += chunk.byteLength;\n        onProgress && onProgress(bytesDownloaded);\n      }\n    }\n    const result = uint8ArrayConcat(chunks);\n    return result;\n  } catch (error) {\n    console.error(\n      `Error reading stream/iterable.\\r\\n Probably Hot reload error!`,\n      error\n    );\n\n    return undefined;\n  }\n};\n","import { toString as uint8ArrayToAsciiString } from 'uint8arrays/to-string';\nimport isSvg from 'is-svg';\nimport { IPFSContentDetails, IPFSContentMaybe, IpfsContentType } from '../ipfs';\nimport { getResponseResult, onProgressCallback } from './stream';\n\n// TODO: fix to get working inside web worker, REFACTOR\n// import { PATTERN_HTTP, PATTERN_IPFS_HASH } from '../config';\nconst PATTERN_IPFS_HASH = /^Qm[a-zA-Z0-9]{44}$/g;\nconst PATTERN_HTTP = /^https:\\/\\/|^http:\\/\\//g;\n\nfunction createObjectURL(rawData: Uint8Array, type: string) {\n  const blob = new Blob([rawData], { type });\n  return URL.createObjectURL(blob);\n}\n\nfunction createImgData(rawData: Uint8Array, type: string) {\n  const imgBase64 = uint8ArrayToAsciiString(rawData, 'base64');\n  const file = `data:${type};base64,${imgBase64}`;\n  return file;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport const detectContentType = (\n  mime: string | undefined\n): IpfsContentType => {\n  if (mime) {\n    if (mime.includes('video')) {\n      return 'video';\n    }\n\n    if (mime.includes('audio')) {\n      return 'audio';\n    }\n  }\n  return 'other';\n};\n\nconst basic = /\\s?<!doctype html>|(<html\\b[^>]*>|<body\\b[^>]*>|<x-[^>]+>)+/i;\n\nfunction isHtml(string) {\n  const newString = string.trim().slice(0, 1000);\n  return basic.test(newString);\n}\n\nfunction shortenString(string: string, length = 300) {\n  return string.length > length ? `${string.slice(0, length)}...` : string;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport const chunksToBlob = (\n  chunks: Array<Uint8Array>,\n  mime: string | undefined\n) => new Blob(chunks, mime ? { type: mime } : {});\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport const parseArrayLikeToDetails = async (\n  content: IPFSContentMaybe,\n  // rawDataResponse: Uint8ArrayLike | undefined,\n  // mime: string | undefined,\n  cid: string,\n  onProgress?: onProgressCallback\n): Promise<IPFSContentDetails> => {\n  try {\n    // console.log('------parseArrayLikeToDetails', cid, content);\n    const mime = content?.meta?.mime;\n    const response: IPFSContentDetails = {\n      link: `/ipfs/${cid}`,\n      gateway: false,\n      cid,\n    };\n    const initialType = detectContentType(mime);\n    if (['video', 'audio'].indexOf(initialType) > -1) {\n      return { ...response, type: initialType, gateway: true };\n    }\n\n    const rawData = content?.result\n      ? await getResponseResult(content.result, onProgress)\n      : undefined;\n\n    // console.log(rawData);\n\n    if (!mime) {\n      response.text = `Can't detect MIME for ${cid.toString()}`;\n      response.gateway = true; // ???\n    } else if (\n      mime.indexOf('text/plain') !== -1 ||\n      mime.indexOf('application/xml') !== -1\n    ) {\n      if (isSvg(Buffer.from(rawData))) {\n        response.type = 'image';\n        response.content = createImgData(rawData, 'image/svg+xml'); // file\n      } else {\n        const dataBase64 = uint8ArrayToAsciiString(rawData);\n        // TODO: search can bel longer for 42???!\n        // also cover ipns links\n        response.link =\n          dataBase64.length > 42 ? `/ipfs/${cid}` : `/search/${dataBase64}`;\n\n        if (dataBase64.match(PATTERN_IPFS_HASH)) {\n          response.gateway = true;\n          response.type = 'other';\n          response.content = dataBase64;\n          response.link = `/ipfs/${cid}`;\n        } else if (dataBase64.match(PATTERN_HTTP)) {\n          response.type = 'link';\n          response.gateway = false;\n          response.content = dataBase64;\n          response.link = `/ipfs/${cid}`;\n        } else if (isHtml(dataBase64)) {\n          response.type = 'other';\n          response.gateway = true;\n          response.content = cid.toString();\n        } else {\n          response.type = 'text';\n          response.content = dataBase64;\n          response.text = shortenString(dataBase64);\n        }\n      }\n    } else if (mime.indexOf('image') !== -1) {\n      response.content = createImgData(rawData, mime); // file\n      response.type = 'image';\n      response.gateway = false;\n    } else if (mime.indexOf('application/pdf') !== -1) {\n      response.type = 'pdf';\n      response.content = createObjectURL(rawData, mime); // file\n      response.gateway = true; // ???\n    }\n\n    return response;\n  } catch (e) {\n    console.log('----parseRawIpfsData', e, cid);\n    return undefined;\n  }\n};\n\nexport const contentToUint8Array = async (\n  content: File | string\n): Promise<Uint8Array> => {\n  return new Uint8Array(\n    typeof content === 'string'\n      ? Buffer.from(content)\n      : await content.arrayBuffer()\n  );\n};\n\nexport const createTextPreview = (\n  array: Uint8Array | undefined,\n  mime?: string,\n  previewLength = 150\n) => {\n  return array && mime && mime === 'text/plain'\n    ? uint8ArrayToAsciiString(array).slice(0, previewLength)\n    : undefined;\n};\n","import Dexie from 'dexie';\n\nconst db = new Dexie('cyber-page-cash');\ndb.version(3).stores({\n  cid: 'cid',\n  following: 'cid',\n});\n\nexport default db;\n","import db from 'src/db';\n\nconst ipfsCacheDb = () => {\n  const add = async (cid: string, raw: Uint8Array): Promise<void> => {\n    const dbValue = await db.table('cid').get({ cid });\n\n    if (!dbValue) {\n      const ipfsContentAddtToInddexdDB = {\n        cid,\n        data: raw,\n      };\n      db.table('cid').add(ipfsContentAddtToInddexdDB);\n    }\n  };\n\n  const get = async (cid: string): Promise<Uint8Array | undefined> => {\n    // TODO: use cursor\n    const dbValue = await db.table('cid').get({ cid });\n\n    // backward compatibility\n    return dbValue?.data || dbValue?.content;\n  };\n\n  return { add, get };\n};\n\nexport default ipfsCacheDb();\n","import {\n  AddResponse,\n  PinResponse,\n} from '@nftstorage/ipfs-cluster/dist/src/interface';\n\nimport { Cluster } from '@nftstorage/ipfs-cluster';\nimport { IPFS_CLUSTER_URL } from '../config';\n\nconst cyberCluster = () => {\n  const cluster = new Cluster(IPFS_CLUSTER_URL);\n\n  const add = async (\n    file: File | string\n  ): Promise<AddResponse | PinResponse | undefined> => {\n    const dataFile =\n      typeof file === 'string' ? new File([file], 'file.txt') : file;\n    return cluster.add(dataFile, { cidVersion: 0, rawLeaves: false });\n  };\n\n  const status = async (cid: string) => cluster.status(cid);\n  return { add, status };\n};\n\nexport default cyberCluster();\n","/* eslint-disable import/no-unused-modules */\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\n\nimport { Option } from 'src/types';\nimport {\n  // getIpfsUserGatewanAndNodeType,\n  IPFSContentMaybe,\n  IPFSContentMeta,\n  CallBackFuncStatus,\n  IpfsContentSource,\n  IpfsNode,\n} from '../ipfs';\n\nimport { getMimeFromUint8Array, toAsyncIterableWithMime } from './stream';\n\nimport ipfsCacheDb from './ipfsCacheDb';\nimport cyberCluster from './cluster';\n\nimport { contentToUint8Array, createTextPreview } from './content';\n\nimport {\n  // CYBERNODE_SWARM_ADDR_WSS,\n  // CYBERNODE_SWARM_ADDR_TCP,\n  // CYBER_NODE_SWARM_PEER_ID,\n  CYBER_GATEWAY_URL,\n  FILE_SIZE_DOWNLOAD,\n} from '../config';\n\n// import { convertTimeToMilliseconds } from '../helpers';\n// import { CYBER } from '../config';\n\n// TODO: fix to get working inside web worker, REFACTOR\n\n// Get IPFS node from local storage\n// TODO: refactor\n// const getIpfsUserGatewanAndNode = (): getIpfsUserGatewanAndNodeType => {\n//   const LS_IPFS_STATE = localStorage.getItem('ipfsState');\n\n//   if (LS_IPFS_STATE !== null) {\n//     const lsTypeIpfsData = JSON.parse(LS_IPFS_STATE);\n//     if (lsTypeIpfsData?.userGateway) {\n//       const { userGateway, ipfsNodeType } = lsTypeIpfsData;\n//       return { userGateway, ipfsNodeType };\n//     }\n//   }\n\n//   return { ipfsNodeType: undefined, userGateway: undefined };\n// };\n\n// Get data by CID from local storage\nconst loadIPFSContentFromDb = async (\n  cid: string\n): Promise<IPFSContentMaybe> => {\n  // TODO: enable, disabled for tests\n\n  // TODO: use cursor\n  const data = await ipfsCacheDb.get(cid);\n  if (data && data.length) {\n    // TODO: use cursor\n    const mime = await getMimeFromUint8Array(data);\n    const textPreview = createTextPreview(data, mime);\n\n    const meta: IPFSContentMeta = {\n      type: 'file', // `TODO: ipfs refactor dir support ?\n      size: data.length,\n      sizeLocal: data.length,\n      mime,\n    };\n    return { result: data, cid, meta, source: 'db', textPreview };\n  }\n\n  return undefined;\n};\n\nconst emptyMeta: IPFSContentMeta = {\n  type: 'file',\n  size: undefined,\n  local: undefined,\n  sizeLocal: undefined,\n};\n\nconst fetchIPFSContentMeta = async (\n  cid: string,\n  node?: IpfsNode,\n  signal?: AbortSignal\n): Promise<IPFSContentMeta> => {\n  if (node) {\n    const meta = await node.stat(cid, { signal });\n    return meta;\n  }\n  return emptyMeta;\n};\n\nconst fetchIPFSContentFromNode = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController\n): Promise<IPFSContentMaybe> => {\n  const controllerLegacy = controller || new AbortController();\n  const { signal } = controllerLegacy;\n  let timer: NodeJS.Timeout | undefined;\n\n  if (!node) {\n    console.log('--------fetchIPFSContentFromNode NO NODE INTIALIZED--------');\n    return undefined;\n  }\n\n  if (!controller) {\n    timer = setTimeout(() => {\n      controllerLegacy.abort();\n    }, 1000 * 60 * 1);\n  } // 1 min\n\n  // TODO: cover ipns case\n  try {\n    // const stat = await node.files.stat(path, { signal });\n    const startTime = Date.now();\n    const meta = await fetchIPFSContentMeta(cid, node, signal);\n    const statsDoneTime = Date.now();\n    meta.statsTime = statsDoneTime - startTime;\n    const allowedSize = meta.size ? meta.size < FILE_SIZE_DOWNLOAD : false;\n    timer && clearTimeout(timer);\n\n    switch (meta.type) {\n      case 'directory': {\n        // TODO: return directory structure\n        return { cid, availableDownload: true, source: 'node', meta };\n      }\n      default: {\n        // Get sample of content\n        const { value: firstChunk, done } = await node\n          .cat(cid, { signal, length: 2048, offset: 0 })\n          [Symbol.asyncIterator]()\n          .next();\n\n        const mime = await getMimeFromUint8Array(firstChunk);\n        const fullyDownloaded =\n          meta.size && meta.size > -1 && firstChunk.length >= meta.size;\n\n        const textPreview = createTextPreview(firstChunk, mime);\n\n        if (fullyDownloaded) {\n          await ipfsCacheDb.add(cid, uint8ArrayConcat(firstChunk));\n        }\n\n        // If all content fits in first chunk return byte-array instead iterable\n        const stream = fullyDownloaded\n          ? firstChunk\n          : allowedSize\n          ? node.cat(cid, { signal })\n          : undefined;\n\n        meta.catTime = Date.now() - statsDoneTime;\n\n        // TODO: add to db flag that content is pinned TO local node\n        // if already pinned skip pin\n        if (!meta.local && allowedSize) {\n          node.pin(cid);\n\n          meta.pinTime = Date.now() - meta.catTime;\n        } else {\n          meta.pinTime = -1;\n        }\n\n        return {\n          result: stream,\n          textPreview,\n          cid,\n          meta: { ...meta, mime },\n          source: 'node',\n        };\n        // }\n      }\n    }\n  } catch (error) {\n    console.debug('error fetchIPFSContentFromNode', error);\n    return { cid, availableDownload: true, source: 'node', meta: emptyMeta };\n  }\n};\n\nconst fetchIPFSContentFromGateway = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController\n): Promise<IPFSContentMaybe> => {\n  // TODO: Should we use Cyber Gateway?\n  // const { userGateway } = getIpfsUserGatewanAndNode();\n\n  // fetch META only from external node(toooo slow), TODO: fetch meta from cybernode\n  const isExternalNode = node?.nodeType === 'external';\n  const meta = isExternalNode\n    ? await fetchIPFSContentMeta(cid, node, controller?.signal)\n    : emptyMeta;\n\n  const contentUrl = `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n  const response = await fetch(contentUrl, {\n    method: 'GET',\n    signal: controller?.signal,\n  });\n\n  if (response && response.body) {\n    // fetch doesn't provide any headers in our case :(\n\n    // const contentLength = parseInt(\n    //   response.headers['content-length'] || '-1',\n    //   10\n    // );\n    // const contentType = response.headers['content-type'];\n\n    // Extract meta if ipfs prob/node not started yet\n    // if (!meta.mime) {\n    //   meta = { ...meta, mime: contentType };\n    // }\n\n    // TODO: fix\n    const flushResults = (chunks: Uint8Array[]) =>\n      !isExternalNode\n        ? ipfsCacheDb.add(cid, uint8ArrayConcat(chunks))\n        : Promise.resolve();\n\n    const { mime, result, firstChunk } = await toAsyncIterableWithMime(\n      response.body,\n      flushResults\n    );\n\n    const textPreview = createTextPreview(firstChunk, mime);\n    return {\n      cid,\n      textPreview,\n      meta: { ...meta, mime },\n      result,\n      source: 'gateway',\n      contentUrl,\n    };\n  }\n\n  return undefined;\n};\n\ntype fetchContentOptions = {\n  controller?: AbortController;\n  node?: IpfsNode;\n};\n\nasync function fetchIpfsContent(\n  cid: string,\n  source: IpfsContentSource,\n  options: fetchContentOptions\n): Promise<IPFSContentMaybe> {\n  const { node, controller } = options;\n\n  try {\n    switch (source) {\n      case 'db':\n        return loadIPFSContentFromDb(cid);\n      case 'node':\n        return fetchIPFSContentFromNode(cid, node, controller);\n      case 'gateway':\n        return fetchIPFSContentFromGateway(cid, node, controller);\n      default:\n        return undefined;\n    }\n  } catch (e) {\n    console.log('----fetchIpfsContent error', e);\n    return undefined;\n  }\n}\n\nconst getIPFSContent = async (\n  cid: string,\n  node?: IpfsNode,\n  controller?: AbortController,\n  callBackFuncStatus?: CallBackFuncStatus\n): Promise<IPFSContentMaybe> => {\n  const dataRsponseDb = await loadIPFSContentFromDb(cid);\n  if (dataRsponseDb !== undefined) {\n    return dataRsponseDb;\n  }\n\n  if (node) {\n    callBackFuncStatus && callBackFuncStatus('trying to get with a node');\n    // console.log('----Fetch from node', cid);\n    const ipfsContent = await fetchIPFSContentFromNode(cid, node, controller);\n\n    return ipfsContent;\n  }\n\n  callBackFuncStatus && callBackFuncStatus('trying to get with a gatway');\n  // console.log('----Fetch from gateway', cid);\n  const respnseGateway = await fetchIPFSContentFromGateway(\n    cid,\n    node,\n    controller\n  );\n\n  return respnseGateway;\n};\n\nconst catIPFSContentFromNode = (\n  cid: string,\n  node?: IpfsNode,\n  offset?: number,\n  controller?: AbortController\n): AsyncIterable<Uint8Array> | undefined => {\n  if (!node) {\n    console.log(\n      '--------fetchIPFSContentFromNode NO NODE INTIALIZED TODO: cover case--------'\n    );\n    return undefined;\n  }\n\n  // TODO: cover ipns case\n\n  return node.cat(cid, { offset, signal: controller?.signal });\n};\n\n// const nodeContentFindProvs = async (\n//   node: AppIPFS,\n//   cid: string,\n//   offset: number,\n//   controller?: AbortController\n// ): AsyncIterable<number> | undefined => {\n//   if (!node) {\n//     console.log(\n//       '--------fetchIPFSContentFromNode NO NODE INTIALIZED TODO: cover case--------'\n//     );\n//     return undefined;\n//   }\n\n//   // TODO: cover ipns case\n//   const path = `/ipfs/${cid}`;\n\n//   const providers = node.dht.findProvs(path, {\n//     signal: controller?.signal,\n//   });\n\n//   let count = 0;\n//   for await (const provider of providers) {\n//     //  console.log(provider.id.toString())\n//     //  id: PeerId\n//     // multiaddrs: Multiaddr[]\n//     // protocols: string[]\n//     count++;\n//   }\n\n//   return count;\n// };\n\nconst addContenToIpfs = async (\n  node: IpfsNode,\n  content: File | string\n): Promise<Option<string>> => {\n  let cid;\n  if (node) {\n    cid = await node.add(content);\n  }\n  // TODO: TMP solution make cluster call non-awaitable\n  cyberCluster.add(content);\n  // const pinResponse = await cyberCluster.add(content);\n  // cid = cid || pinResponse?.cid;\n\n  cid && (await ipfsCacheDb.add(cid, await contentToUint8Array(content)));\n  return cid;\n};\n\n// '/dns4/swarm.io.cybernode.ai/tcp/4001/p2p/QmUgmRxoLtGERot7Y6G7UyF6fwvnusQZfGR15PuE6pY3aB';\n\n// const connectToSwarm = async (node, address) => {\n//   const multiaddrSwarm = multiaddr(address);\n//   // console.log(`Connecting to swarm ${address}`, node);\n//   if (node.nodeType === 'helia') {\n//     // node.libp2p.bootstrap.add(multiaddrSwarm);\n//     node.libp2p.dial(multiaddrSwarm);\n//     return;\n//   }\n\n//   await node.bootstrap.add(multiaddrSwarm);\n\n//   node?.swarm\n//     .connect(multiaddrSwarm)\n//     .then((resp) => {\n//       console.log(`Welcome to swarm ${address} 🐝🐝🐝`);\n//       // node.swarm.peers().then((peers) => console.log('---peeers', peers));\n//     })\n//     .catch((err) => {\n//       console.log(\n//         'Error object properties:',\n//         Object.getOwnPropertyNames(err),\n//         err.stack,\n//         err.errors,\n//         err.message\n//       );\n//       console.log(`Can't connect to swarm ${address}: ${err.message}`);\n//     });\n// };\n\n// const connectToCyberSwarm = async (node: AppIPFS) => {\n//   const cyberNodeAddr =\n//     node.nodeType === 'embedded'\n//       ? CYBERNODE_SWARM_ADDR_WSS\n//       : CYBERNODE_SWARM_ADDR_TCP;\n//   await connectToSwarm(node, cyberNodeAddr);\n// };\n\n// const reconnectToCyberSwarm = async (node?: IpfsNode, lastCallTime: 0) => {\n//   if (!node) {\n//     return;\n//   }\n//   const isHelia = node.nodeType === 'helia';\n//   const cyberNodeAddr =\n//     node.nodeType !== 'external'\n//       ? CYBERNODE_SWARM_ADDR_WSS\n//       : CYBERNODE_SWARM_ADDR_TCP;\n\n//   const isSwarmConnected = isHelia\n//     ? node!.libp2p\n//         .getConnections()\n//         .find((c) => c.remotePeer.toString() === CYBER_NODE_SWARM_PEER_ID)\n//     : (await node!.swarm.peers()).find(\n//         (p) => p.peer.toString() === CYBER_NODE_SWARM_PEER_ID\n//       );\n\n//   // console.log('autoDialTime', await getNodeAutoDialInterval(node));\n//   // console.log('lastCallTime', lastCallTime, Date.now() - lastCallTime);\n\n//   // console.log('---isConnected', true, peers.length);\n\n//   if (!isSwarmConnected) {\n//     // TODO: refactor using timeout for node\n//     const needToReconnect =\n//       Date.now() - lastCallTime < (node.connMgrGracePeriod || 20);\n//     if (needToReconnect) {\n//       await connectToSwarm(node, cyberNodeAddr);\n//     }\n//   }\n// };\n\n// const DEFAULT_AUTO_DIAL_INTERVAL = 10000;\n// const GET_CONFIG_TIMEOUT = 3000;\n// TODO: REFACTOR\n// const getNodeAutoDialInterval = async (node: IpfsNode) => {\n//   try {\n//     const autoDialTime = convertTimeToMilliseconds(\n//       ((await node.config.get('Swarm.ConnMgr.GracePeriod', {\n//         timeout: GET_CONFIG_TIMEOUT,\n//       })) as string) || DEFAULT_AUTO_DIAL_INTERVAL\n//     );\n\n//     return autoDialTime;\n//   } catch {\n//     return DEFAULT_AUTO_DIAL_INTERVAL;\n//   }\n// };\n\n// const getIpfsGatewayUrl = async (node: IpfsNode, cid: string) => {\n//   if (node.nodeType !== 'external') {\n//     return `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n//   }\n\n//   const response = await node.config.get('Addresses.Gateway');\n//   const address = multiaddr(response).nodeAddress();\n\n//   try {\n//     return `http://${address.address}:${address.port}/ipfs/${cid}`;\n//   } catch (error) {\n//     return `${CYBER_GATEWAY_URL}/ipfs/${cid}`;\n//   }\n// };\n\nexport {\n  getIPFSContent,\n  catIPFSContentFromNode,\n  fetchIpfsContent,\n  addContenToIpfs,\n  // reconnectToCyberSwarm,\n  // getIpfsGatewayUrl,\n  // getNodeAutoDialInterval,\n};\n","// import { getNodeAutoDialInterval } from './utils-ipfs';\nimport { IpfsNodeType, IpfsNode, CybIpfsNode, IpfsOptsType } from '../ipfs';\nimport KuboNode from './impl/kubo';\nimport HeliaNode from './impl/helia';\nimport JsIpfsNode from './impl/js-ipfs';\n// import EnhancedIpfsNode from './node/enhancedNode';\nimport {\n  CYBERNODE_SWARM_ADDR_TCP,\n  CYBERNODE_SWARM_ADDR_WSS,\n  CYBER_NODE_SWARM_PEER_ID,\n} from '../config';\nimport { withCybFeatures } from './mixins/withCybFeatures';\n\nconst nodeClassMap: Record<IpfsNodeType, new () => IpfsNode> = {\n  helia: HeliaNode,\n  embedded: JsIpfsNode,\n  external: KuboNode,\n};\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport async function initIpfsNode(\n  options: IpfsOptsType\n): Promise<CybIpfsNode> {\n  const { ipfsNodeType, ...restOptions } = options;\n\n  const swarmPeerId = CYBER_NODE_SWARM_PEER_ID;\n\n  const swarmPeerAddress =\n    ipfsNodeType === 'external'\n      ? CYBERNODE_SWARM_ADDR_TCP\n      : CYBERNODE_SWARM_ADDR_WSS;\n\n  const EnhancedClass = withCybFeatures(nodeClassMap[ipfsNodeType], {\n    swarmPeerId,\n    swarmPeerAddress,\n  });\n\n  const instance = new EnhancedClass();\n\n  await instance.init({ url: restOptions.urlOpts });\n  // TODO: REFACT\n  //   instance.connMgrGracePeriod = await getNodeAutoDialInterval(instance);\n  // window.ipfs = instance;\n\n  console.log('----init', ipfsNodeType);\n\n  await instance.reconnectToSwarm();\n  return instance;\n}\n","import { IpfsNode, CybIpfsNode, IpfsContentType } from '../../ipfs';\nimport { parseArrayLikeToDetails } from '../../utils/content';\nimport { addContenToIpfs, getIPFSContent } from '../../utils/utils-ipfs';\n\ntype WithCybFeaturesOptions = {\n  swarmPeerId: string;\n  swarmPeerAddress: string;\n};\n\nfunction withCybFeatures<TBase extends new (...args: any[]) => IpfsNode>(\n  Base: TBase,\n  options: WithCybFeaturesOptions\n) {\n  return class CybIpfsNodeMixin extends Base implements CybIpfsNode {\n    async fetchWithDetails(cid: string, parseAs?: IpfsContentType) {\n      const response = await getIPFSContent(cid, this);\n      const details = await parseArrayLikeToDetails(response, cid);\n\n      return !parseAs\n        ? details\n        : details?.type === parseAs\n        ? details\n        : undefined;\n    }\n\n    async addContent(content: File | string) {\n      return addContenToIpfs(this, content);\n    }\n\n    async isConnectedToSwarm() {\n      return !!(await super.getPeers()).find(\n        (peerId) => peerId === options.swarmPeerId\n      );\n    }\n\n    async reconnectToSwarm(lastConnectedTimestamp?: number) {\n      if (!(await this.isConnectedToSwarm())) {\n        // TODO: refactor using timeout for node config\n\n        //   const needToReconnect =\n        //     Date.now() - lastConnectedTimestamp <\n        //     DEFAULT_CONNECTION_LIFETIME_SECONDS;\n        super\n          .connectPeer(options.swarmPeerAddress)\n          .then(() => {\n            console.log(`🐝 connected to swarm - ${options.swarmPeerAddress}`);\n            return true;\n          })\n          .catch((err) => {\n            console.log(\n              `Can't connect to swarm ${options.swarmPeerAddress}: ${err.message}`\n            );\n            return false;\n          });\n      }\n    }\n  };\n}\n\nexport { withCybFeatures };\n","import { IQueueStrategy, QueueSettings, QueueSource } from './types';\n\nexport class QueueStrategy implements IQueueStrategy {\n  settings: QueueSettings;\n\n  order: QueueSource[];\n\n  constructor(settings: QueueSettings, order: QueueSource[]) {\n    this.settings = settings;\n    this.order = order;\n  }\n\n  getNextSource(source: QueueSource): QueueSource | undefined {\n    const index = this.order.indexOf(source);\n    return index < this.order.length ? this.order[index + 1] : undefined;\n  }\n}\n","export class QueueItemTimeoutError extends Error {\n  constructor(timeoutMs: number) {\n    super(`Timeout after ${timeoutMs}`);\n    Object.setPrototypeOf(this, QueueItemTimeoutError.prototype);\n  }\n}\n","export function isParticle(value: string) {\n  // copied from src/utils/config.ts , to prevent crash in worker, need refactor\n  // import { PATTERN_IPFS_HASH } from 'src/utils/config';\n  return Boolean(value.match(/^Qm[a-zA-Z0-9]{44}$/g));\n}\n","import { PinType } from 'ipfs-core-types/src/pin';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { Transaction } from 'src/services/backend/services/indexer/types';\nimport {\n  SenseChatExtension,\n  SenseLinkMeta,\n  SenseListItemtMeta,\n  SenseTransactionMeta,\n} from 'src/services/backend/types/sense';\nimport { IpfsContentType } from 'src/services/ipfs/ipfs';\nimport { NeuronAddress, ParticleCid, TransactionHash } from 'src/types/base';\nimport { DtoToEntity } from 'src/types/dto';\n\ntype PinEntryType = Exclude<PinType, 'all'>;\n// example of db optimization for classifiers\n\nexport const PinTypeMap: Record<PinEntryType, number> = {\n  indirect: -1,\n  direct: 0,\n  recursive: 1,\n};\n\nexport enum EntryType {\n  transactions = 1,\n  particle = 2,\n  chat = 3,\n}\n\n// Transaction if formed by frontend\n// Should be replaced after sync\n\nexport type PinDbEntity = {\n  cid: string;\n  type: keyof typeof PinTypeMap;\n};\n\nexport type TransactionDbEntity = {\n  hash: string;\n  index: number;\n  type: string;\n  timestamp: number;\n  block_height: number;\n  value: Transaction['value'];\n  success: boolean;\n  memo: string;\n  neuron: NeuronAddress;\n};\n\ntype SyncItemMeta = DtoToEntity<\n  (SenseLinkMeta | SenseTransactionMeta) & SenseChatExtension\n>;\n\nexport type SyncStatusDbEntity = {\n  entry_type: EntryType;\n  id: NeuronAddress | ParticleCid;\n  owner_id: NeuronAddress;\n  timestamp_update: number;\n  timestamp_read: number;\n  disabled: boolean;\n  unread_count: number;\n  meta: SyncItemMeta;\n};\n\nexport type ParticleDbEntity = {\n  id: ParticleCid;\n  size: number;\n  size_local: number;\n  blocks: number;\n  mime: string;\n  type: IpfsContentType;\n  text: string;\n};\n\nexport type LinkDbEntity = {\n  from: ParticleCid;\n  to: ParticleCid;\n  neuron: NeuronAddress;\n  timestamp: number;\n  transaction_hash: string;\n};\n\nexport type ConfigDbEntity = {\n  key: string;\n  group_key: string;\n  value: NonNullable<unknown>;\n};\n\nexport enum SyncQueueStatus {\n  pending = 0,\n  executing = 1,\n  done = 2,\n  error = -1,\n}\n\nexport type SyncQueueDbEntity = {\n  id: string;\n  status: SyncQueueStatus;\n  priority: QueuePriority | number;\n};\n\nexport type CommunityDbEntity = {\n  ownerId: NeuronAddress;\n  particle: ParticleCid;\n  neuron: NeuronAddress;\n  name: string;\n  following: boolean;\n  follower: boolean;\n};\n\nexport type DbEntity =\n  | TransactionDbEntity\n  | ParticleDbEntity\n  | SyncStatusDbEntity\n  | ConfigDbEntity\n  | SyncQueueDbEntity;\n","import {\n  createAsyncThunk,\n  createSelector,\n  createSlice,\n  PayloadAction,\n} from '@reduxjs/toolkit';\nimport { SenseApi } from 'src/contexts/backend/services/senseApi';\nimport {\n  SenseItemLinkMeta,\n  SenseListItem,\n  SenseListItemTransactionMeta,\n  SenseUnread,\n} from 'src/services/backend/types/sense';\nimport { isParticle } from '../../particle/utils';\nimport { SenseItemId } from '../types/sense';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport {\n  MsgMultiSendValue,\n  MsgSendValue,\n} from 'src/services/backend/services/indexer/types';\nimport { RootState } from 'src/redux/store';\n\n// similar to blockchain/tx/message type\nexport type SenseItem = {\n  id: SenseItemId;\n  transactionHash: string;\n\n  // add normal type\n  type: string;\n\n  meta: SenseListItem['meta'];\n  timestamp: string;\n  memo: string | undefined;\n  from: string;\n\n  // for optimistic update\n  status?: 'pending' | 'error';\n  fromLog?: boolean;\n};\n\ntype Chat = {\n  id: SenseItemId;\n  isLoading: boolean;\n  error: string | undefined;\n  data: SenseItem[];\n  unreadCount: number;\n};\n\ntype SliceState = {\n  list: {\n    isLoading: boolean;\n    data: string[];\n    error: string | undefined;\n  };\n  chats: {\n    [key in SenseItemId]?: Chat;\n  };\n  summary: {\n    unreadCount: {\n      total: number;\n      particles: number;\n      neurons: number;\n    };\n  };\n};\n\nconst initialState: SliceState = {\n  list: {\n    isLoading: false,\n    data: [],\n    error: undefined,\n  },\n  chats: {},\n  summary: {\n    unreadCount: {\n      total: 0,\n      particles: 0,\n      neurons: 0,\n    },\n  },\n};\n\nfunction formatApiData(item: SenseListItem): SenseItem {\n  if (item.entryType === EntryType.chat && item.meta.to) {\n    item.entryType = EntryType.particle;\n  }\n\n  const { meta } = item;\n\n  const formatted: SenseItem = {\n    timestamp: new Date(meta.timestamp).toISOString(),\n\n    // lol\n    transactionHash:\n      item.transactionHash ||\n      item.hash ||\n      item.meta.transaction_hash ||\n      item.meta.hash ||\n      item.meta.transactionHash,\n\n    memo: item.memo || meta.memo,\n\n    senseChatId: item.id,\n    // not good\n    unreadCount: item.unreadCount || 0,\n  };\n\n  switch (item.entryType) {\n    case EntryType.chat:\n    case EntryType.transactions: {\n      const meta = item.meta as SenseListItemTransactionMeta;\n      const { type } = meta;\n\n      let from = item.ownerId;\n\n      if (type === 'cosmos.bank.v1beta1.MsgSend') {\n        const value = meta.value as MsgSendValue;\n        from = value.fromAddress;\n      } else if (type === 'cosmos.bank.v1beta1.MsgMultiSend') {\n        const value = meta.value as MsgMultiSendValue;\n\n        from = value.inputs[0].address;\n      }\n\n      Object.assign(formatted, {\n        type,\n        from,\n        meta: item.meta.value,\n      });\n\n      break;\n    }\n\n    case EntryType.particle: {\n      const meta = item.meta as SenseItemLinkMeta;\n\n      Object.assign(formatted, {\n        type: 'cyber.graph.v1beta1.MsgCyberlink',\n        from: meta.neuron,\n        meta: meta,\n        fromLog: true,\n      });\n\n      break;\n    }\n\n    default:\n      // sholdn't be\n      debugger;\n      return {};\n  }\n\n  return formatted;\n}\n\nconst getSenseList = createAsyncThunk(\n  'sense/getSenseList',\n  async (senseApi: SenseApi) => {\n    const data = await senseApi!.getList();\n    return data.map(formatApiData);\n  }\n);\n\nconst getSenseChat = createAsyncThunk(\n  'sense/getSenseChat',\n  async ({ id, senseApi }: { id: SenseItemId; senseApi: SenseApi }) => {\n    const particle = isParticle(id);\n\n    if (particle) {\n      const links = await senseApi!.getLinks(id);\n      const formattedLinks = links.map((item) => {\n        if (item.timestamp === 0) {\n          // FIXME:\n          return;\n        }\n        return formatApiData({\n          ...item,\n          id,\n          entryType: EntryType.particle,\n          meta: item,\n        });\n      });\n\n      return formattedLinks.filter(Boolean);\n    }\n\n    const data = await senseApi!.getFriendItems(id);\n    const formattedData = data.map((item) => {\n      const entryType = item.to ? EntryType.particle : EntryType.chat;\n      return formatApiData({\n        ...item,\n        entryType,\n        id,\n        meta: item,\n      });\n    });\n\n    return formattedData;\n  }\n);\n\nconst markAsRead = createAsyncThunk(\n  'sense/markAsRead',\n  async ({ id, senseApi }: { id: SenseItemId; senseApi: SenseApi }) => {\n    return senseApi!.markAsRead(id);\n  }\n);\n\nconst newChatStructure: Chat = {\n  id: '',\n  isLoading: false,\n  data: [],\n  error: undefined,\n  unreadCount: 0,\n};\n\nfunction checkIfMessageExists(chat: Chat, newMessage: SenseItem) {\n  const lastMessages = chat.data.slice(-5);\n\n  const isMessageExists = lastMessages.some((msg) => {\n    return msg.transactionHash === newMessage.transactionHash;\n  });\n\n  return isMessageExists;\n}\n\nconst slice = createSlice({\n  name: 'sense',\n  initialState,\n  reducers: {\n    // backend may push this action\n    updateSenseList: {\n      reducer: (state, action: PayloadAction<SenseItem[]>) => {\n        const data = action.payload;\n\n        data.forEach((message) => {\n          const { senseChatId: id } = message;\n\n          if (!state.chats[id]) {\n            state.chats[id] = { ...newChatStructure };\n          }\n\n          const chat = state.chats[id]!;\n\n          Object.assign(chat, {\n            id,\n            // fix ts\n            unreadCount: message.unreadCount || 0,\n          });\n\n          if (!checkIfMessageExists(chat, message)) {\n            chat.data = chat.data.concat(message);\n          }\n        });\n\n        slice.caseReducers.orderSenseList(state);\n      },\n      prepare: (data: SenseListItem[]) => {\n        return {\n          payload: data.map(formatApiData),\n        };\n      },\n    },\n    // optimistic update\n    addSenseItem(\n      state,\n      action: PayloadAction<{ id: SenseItemId; item: SenseItem }>\n    ) {\n      const { id, item } = action.payload;\n      const chat = state.chats[id]!;\n\n      chat.data.push({\n        ...item,\n        meta: item.meta,\n        status: 'pending',\n      });\n\n      const newList = state.list.data.filter((item) => item !== id);\n      newList.unshift(id);\n      state.list.data = newList;\n    },\n    // optimistic confirm/error\n    updateSenseItem(\n      state,\n      action: PayloadAction<{\n        chatId: SenseItemId;\n        txHash: string;\n        isSuccess: boolean;\n      }>\n    ) {\n      const { chatId, txHash, isSuccess } = action.payload;\n      const chat = state.chats[chatId]!;\n\n      const item = chat.data.find((item) => item.transactionHash === txHash);\n\n      if (item) {\n        if (isSuccess) {\n          delete item.status;\n        } else {\n          item.status = 'error';\n        }\n      }\n    },\n    orderSenseList(state) {\n      const chatsLastMessage = Object.keys(state.chats).reduce<\n        {\n          id: string;\n          lastMsg: SenseItem;\n        }[]\n      >((acc, id) => {\n        const chat = state.chats[id]!;\n\n        // may be loading this moment, no data\n        if (!chat.data.length) {\n          return acc;\n        }\n\n        const lastMsg = chat.data[chat.data.length - 1];\n        acc.push({ id, lastMsg });\n\n        return acc;\n      }, []);\n\n      const sorted = chatsLastMessage.sort((a, b) => {\n        return (\n          Date.parse(b.lastMsg.timestamp) - Date.parse(a.lastMsg.timestamp)\n        );\n      });\n\n      state.list.data = sorted.map((i) => i.id);\n    },\n    reset() {\n      return initialState;\n    },\n  },\n\n  extraReducers: (builder) => {\n    builder.addCase(getSenseList.pending, (state) => {\n      state.list.isLoading = true;\n    });\n\n    builder.addCase(getSenseList.fulfilled, (state, action) => {\n      state.list.isLoading = false;\n\n      const newList: SliceState['list']['data'] = [];\n\n      action.payload.forEach((message) => {\n        const { senseChatId: id } = message;\n\n        if (!state.chats[id]) {\n          state.chats[id] = { ...newChatStructure };\n        }\n\n        const chat = state.chats[id]!;\n\n        Object.assign(chat, {\n          id,\n          // fix\n          unreadCount: message.unreadCount || 0,\n        });\n\n        if (!checkIfMessageExists(chat, message)) {\n          chat.data = chat.data.concat(message);\n        }\n\n        newList.push(id);\n      });\n\n      state.list.data = newList;\n    });\n    builder.addCase(getSenseList.rejected, (state, action) => {\n      console.error(action);\n\n      state.list.isLoading = false;\n      state.list.error = action.error.message;\n    });\n\n    builder.addCase(getSenseChat.pending, (state, action) => {\n      const { id } = action.meta.arg;\n\n      if (!state.chats[id]) {\n        state.chats[id] = { ...newChatStructure };\n      }\n\n      // don't understand why ts warning\n      state.chats[id].isLoading = true;\n    });\n\n    builder.addCase(getSenseChat.fulfilled, (state, action) => {\n      const { id } = action.meta.arg;\n      const chat = state.chats[id]!;\n      chat.isLoading = false;\n\n      chat.id = id;\n\n      chat.data = action.payload;\n    });\n    builder.addCase(getSenseChat.rejected, (state, action) => {\n      console.error(action);\n\n      const chat = state.chats[action.meta.arg.id]!;\n      chat.isLoading = false;\n      chat.error = action.error.message;\n    });\n\n    // maybe add .pending, .rejected\n    // can be optimistic\n    builder.addCase(markAsRead.fulfilled, (state, action) => {\n      const { id } = action.meta.arg;\n      const chat = state.chats[id]!;\n\n      const particle = isParticle(id);\n\n      const { unreadCount } = chat;\n\n      state.summary.unreadCount.total -= unreadCount;\n      if (particle) {\n        state.summary.unreadCount.particles -= unreadCount;\n      } else {\n        state.summary.unreadCount.neurons -= unreadCount;\n      }\n\n      chat.unreadCount = 0;\n    });\n  },\n});\n\nconst selectUnreadCounts = createSelector(\n  (state: RootState) => state.sense.chats,\n  (chats) => {\n    let unreadCountParticle = 0;\n    let unreadCountNeuron = 0;\n\n    Object.values(chats).forEach(({ id, unreadCount }) => {\n      const particle = isParticle(id);\n\n      if (particle) {\n        unreadCountParticle += unreadCount;\n      } else {\n        unreadCountNeuron += unreadCount;\n      }\n    });\n\n    const total = unreadCountParticle + unreadCountNeuron;\n\n    return {\n      total,\n      particles: unreadCountParticle,\n      neurons: unreadCountNeuron,\n    };\n  }\n);\n\nexport const { addSenseItem, updateSenseItem, updateSenseList, reset } =\n  slice.actions;\n\nexport { getSenseList, getSenseChat, markAsRead };\n\n// selectors\nexport { selectUnreadCounts };\n\nexport default slice.reducer;\n","import { updateSenseList } from 'src/features/sense/redux/sense.redux';\nimport { SenseListItem } from '../types/sense';\nimport {\n  BroadcastChannelMessage,\n  ServiceName,\n  ServiceStatus,\n  SyncEntryName,\n  SyncProgress,\n} from '../types/services';\nimport { CYB_BROADCAST_CHANNEL } from './consts';\n\nclass BroadcastChannelSender {\n  private channel: BroadcastChannel;\n\n  constructor() {\n    this.channel = new BroadcastChannel(CYB_BROADCAST_CHANNEL);\n  }\n\n  public postServiceStatus(\n    name: ServiceName,\n    status: ServiceStatus,\n    message?: string\n  ) {\n    this.channel.postMessage({\n      type: 'service_status',\n      value: { name, status, message },\n    });\n  }\n\n  public postSyncEntryProgress(entry: SyncEntryName, state: SyncProgress) {\n    // console.log('postSyncEntryProgress', entry, state);\n    this.channel.postMessage({ type: 'sync_entry', value: { entry, state } });\n  }\n\n  public postSenseUpdate(senseList: SenseListItem[]) {\n    // console.log('postSenseUpdate', senseList);\n    if (senseList.length > 0) {\n      this.channel.postMessage(updateSenseList(senseList));\n    }\n  }\n\n  post(msg: BroadcastChannelMessage) {\n    this.channel.postMessage(msg);\n  }\n}\n\nexport default BroadcastChannelSender;\n","export const CYB_BROADCAST_CHANNEL = 'cyb-broadcast-channel';\n","import {\n  BehaviorSubject,\n  map,\n  timeout,\n  throwError,\n  of,\n  catchError,\n  EMPTY,\n  Observable,\n  mergeMap,\n  debounceTime,\n  merge,\n  tap,\n  interval,\n  filter,\n} from 'rxjs';\n\nimport * as R from 'ramda';\n\nimport { fetchIpfsContent } from 'src/services/ipfs/utils/utils-ipfs';\nimport { CybIpfsNode, IpfsContentSource } from 'src/services/ipfs/ipfs';\nimport { ParticleCid } from 'src/types/base';\n\nimport { promiseToObservable } from '../../utils/helpers';\n\nimport type {\n  QueueItem,\n  QueueItemResult,\n  QueueItemCallback,\n  QueueItemOptions,\n  QueueStats,\n  QueueSource,\n  IDeferredDbSaver,\n  QueueItemAsyncResult,\n} from './types';\n\nimport { QueueStrategy } from './QueueStrategy';\n\nimport { QueueItemTimeoutError } from './QueueItemTimeoutError';\nimport BroadcastChannelSender from '../backend/channels/BroadcastChannelSender';\n\nconst QUEUE_DEBOUNCE_MS = 33;\nconst CONNECTION_KEEPER_RETRY_MS = 5000;\n\nfunction getQueueItemTotalPriority(item: QueueItem): number {\n  return (item.priority || 0) + (item.viewPortPriority || 0);\n}\n\nconst debugCid = (cid: ParticleCid, prefix: string, ...args) => {\n  console.log(`>>> ${prefix}: ${cid}`, ...args);\n};\n\nconst strategies = {\n  external: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 60 * 1000, maxConcurrentExecutions: 50 },\n      gateway: { timeout: 21000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'node', 'gateway']\n  ),\n  embedded: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 60 * 1000, maxConcurrentExecutions: 50 },\n      gateway: { timeout: 21000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'gateway', 'node']\n  ),\n  helia: new QueueStrategy(\n    {\n      db: { timeout: 5000, maxConcurrentExecutions: 999 },\n      node: { timeout: 6 * 1000, maxConcurrentExecutions: 50 }, //TODO: set to 60\n      gateway: { timeout: 3 * 1000, maxConcurrentExecutions: 11 },\n    },\n    ['db', 'node', 'gateway']\n  ),\n};\n\ntype QueueMap = Map<ParticleCid, QueueItem>;\n\nclass QueueManager {\n  private queue$ = new BehaviorSubject<QueueMap>(new Map());\n\n  private node: CybIpfsNode | undefined = undefined;\n\n  private defferedDbSaver?: IDeferredDbSaver;\n\n  private strategy: QueueStrategy;\n\n  private queueDebounceMs: number;\n\n  private lastNodeCallTime: number = Date.now();\n\n  private channel = new BroadcastChannelSender();\n\n  private executing: Record<QueueSource, Set<ParticleCid>> = {\n    db: new Set(),\n    node: new Set(),\n    gateway: new Set(),\n  };\n\n  private switchStrategy(strategy: QueueStrategy): void {\n    this.strategy = strategy;\n  }\n\n  public async setNode(node: CybIpfsNode, customStrategy?: QueueStrategy) {\n    console.log(`switch node from ${this.node?.nodeType} to ${node.nodeType}`);\n    this.node = node;\n    this.switchStrategy(customStrategy || strategies[node.nodeType]);\n  }\n\n  private getItemBySourceAndPriority(queue: QueueMap) {\n    const pendingItems = [...queue.values()].filter(\n      (i) => i.status === 'pending'\n    );\n\n    const pendingBySource = R.groupBy((i) => i.source, pendingItems);\n\n    const itemsToExecute: QueueItem[] = [];\n    // eslint-disable-next-line no-loop-func, no-restricted-syntax\n    for (const [queueSource, items] of Object.entries(pendingBySource)) {\n      const settings = this.strategy.settings[queueSource as IpfsContentSource];\n\n      const executeCount =\n        settings.maxConcurrentExecutions -\n        this.executing[queueSource as IpfsContentSource].size;\n\n      const itemsByPriority = items\n        .sort(\n          (a, b) => getQueueItemTotalPriority(b) - getQueueItemTotalPriority(a)\n        )\n        .slice(0, executeCount);\n\n      // console.log('---itemsByPriority', itemsByPriority);\n\n      itemsToExecute.push(...itemsByPriority);\n    }\n\n    return itemsToExecute;\n  }\n\n  private postSummary() {\n    const summary = `(total: ${this.queue$.value.size} |  db - ${this.executing.db.size} node - ${this.executing.node.size} gateway - ${this.executing.gateway.size})`;\n\n    this.channel.postServiceStatus('ipfs', 'started', summary);\n  }\n\n  private fetchData$(item: QueueItem) {\n    const { cid, source, callbacks, controller } = item;\n    // const abortController = controller || new AbortController();\n    const settings = this.strategy.settings[source];\n    this.executing[source].add(cid);\n    this.postSummary();\n    const queueItem = this.queue$.value.get(cid);\n    // Mutate item without next\n    this.queue$.value.set(cid, {\n      ...queueItem,\n      status: 'executing',\n      executionTime: Date.now(),\n      controller: new AbortController(),\n    } as QueueItem);\n    // debugCid(cid, 'fetchData', cid, source);\n    callbacks.map((callback) => callback(cid, 'executing', source));\n\n    return promiseToObservable(async () => {\n      try {\n        const res = await fetchIpfsContent(cid, source, {\n          controller,\n          node: this.node,\n        }).then((content) => {\n          this.defferedDbSaver?.enqueueIpfsContent(content);\n\n          return content;\n        });\n        return res;\n      } catch (e) {\n        // console.log('---promtoo', e);\n        throw e;\n      }\n    }).pipe(\n      timeout({\n        each: settings.timeout,\n        with: () =>\n          throwError(() => {\n            controller?.abort('timeout');\n            return new QueueItemTimeoutError(settings.timeout);\n          }),\n      }),\n      map((result): QueueItemResult => {\n        return {\n          item,\n          status: result ? 'completed' : 'error',\n          source,\n          result,\n        };\n      }),\n      catchError((error): Observable<QueueItemResult> => {\n        // debugCid(cid, 'fetchData - fetchIpfsContent catchErr', error);\n        if (error instanceof QueueItemTimeoutError) {\n          return of({\n            item,\n            status: 'timeout',\n            source,\n          });\n        }\n\n        if (error?.name === 'AbortError') {\n          return of({ item, status: 'cancelled', source });\n        }\n        return of({ item, status: 'error', source });\n      })\n    );\n  }\n\n  /**\n   * Mutate queue item, and return new queue\n   * @param cid\n   * @param changes\n   * @returns\n   */\n  private mutateQueueItem(cid: string, changes: Partial<QueueItem>) {\n    const queue = this.queue$.value;\n    const item = queue.get(cid);\n    if (item) {\n      queue.set(cid, { ...item, ...changes });\n    }\n\n    return this.queue$.next(queue);\n  }\n\n  private removeAndNext(cid: string): void {\n    const queue = this.queue$.value;\n    queue.delete(cid);\n    this.queue$.next(queue);\n  }\n\n  // reset status and switch to next source\n  private switchSourceAndNext(item: QueueItem, nextSource: QueueSource): void {\n    item.callbacks.map((callback) => callback(item.cid, 'pending', nextSource));\n\n    this.mutateQueueItem(item.cid, { status: 'pending', source: nextSource });\n  }\n\n  private cancelDeprioritizedItems(queue: QueueMap): QueueMap {\n    (['node', 'gateway'] as IpfsContentSource[]).forEach((source) => {\n      Array.from(this.executing[source]).forEach((cid) => {\n        const item = queue.get(cid);\n        if (item && getQueueItemTotalPriority(item) < 0 && item.controller) {\n          // abort request and move to pending\n          item.controller.abort('cancelled');\n          item.callbacks.map((callback) =>\n            callback(item.cid, 'pending', item.source)\n          );\n\n          queue.set(cid, { ...item, status: 'pending' });\n          // console.log('-----cancel item', item, queue);\n\n          this.executing[source].delete(cid);\n        }\n      });\n    });\n\n    return queue;\n  }\n\n  private releaseExecution(cid: string) {\n    // eslint-disable-next-line no-restricted-syntax\n    Object.keys(this.executing).forEach((key) =>\n      this.executing[key as IpfsContentSource].delete(cid)\n    );\n  }\n\n  constructor(\n    ipfsInstance$: Observable<CybIpfsNode | undefined>,\n    {\n      strategy,\n      queueDebounceMs,\n      defferedDbSaver,\n    }: {\n      strategy?: QueueStrategy;\n      queueDebounceMs?: number;\n      defferedDbSaver?: IDeferredDbSaver;\n    }\n  ) {\n    ipfsInstance$.subscribe((node) => {\n      if (node) {\n        this.setNode(node);\n      }\n    });\n\n    this.strategy = strategy || strategies.embedded;\n    this.queueDebounceMs = queueDebounceMs || QUEUE_DEBOUNCE_MS;\n    this.defferedDbSaver = defferedDbSaver;\n\n    // Little hack to handle keep-alive connection to swarm cyber node\n    // Fix some lag with node peers(when it shown swarm node in peers but not  connected anymore)\n    interval(CONNECTION_KEEPER_RETRY_MS)\n      .pipe(filter(() => this.queue$.value.size > 0 && !!this.node))\n      .subscribe(() => this.node!.reconnectToSwarm(this.lastNodeCallTime));\n\n    this.queue$\n      .pipe(\n        // tap(() => console.log('----QUEUE')),\n        debounceTime(this.queueDebounceMs),\n        map((queue) => this.cancelDeprioritizedItems(queue)),\n        mergeMap((queue) => {\n          const workItems = this.getItemBySourceAndPriority(queue);\n          // console.log('---workItems', workItems);\n          if (workItems.length > 0) {\n            // wake up connnection to swarm cyber node\n            this.node?.reconnectToSwarm(this.lastNodeCallTime);\n\n            return merge(...workItems.map((item) => this.fetchData$(item)));\n          }\n          return EMPTY;\n        })\n      )\n      .subscribe(({ item, status, source, result }) => {\n        const { cid } = item;\n        const callbacks = this.queue$.value.get(cid)?.callbacks || [];\n        // fix to process dublicated items\n        // debugCid(cid, 'subscribe', cid, source, status, result, callbacks);\n\n        callbacks.map((callback) => callback(cid, status, source, result));\n\n        // HACK to use with GracePeriod for reconnection\n        if (source === 'node') {\n          this.lastNodeCallTime = Date.now();\n        }\n\n        this.executing[source].delete(cid);\n\n        // success execution -> next\n        if (status === 'completed' || status === 'cancelled') {\n          // debugCid(cid, '------done', item, status, source, result);\n          this.removeAndNext(cid);\n        } else {\n          // debugCid(cid, '------error', item, status, source, result);\n\n          // Retry -> (next sources) or -> next\n          const nextSource = this.strategy.getNextSource(source);\n\n          if (nextSource) {\n            this.switchSourceAndNext(item, nextSource);\n          } else {\n            this.removeAndNext(cid);\n            // notify thatn nothing found from all sources\n            callbacks.map((callback) =>\n              callback(cid, 'not_found', source, result)\n            );\n          }\n        }\n\n        this.postSummary();\n      });\n  }\n\n  public enqueue(\n    cid: string,\n    callback: QueueItemCallback,\n    options: QueueItemOptions = {}\n  ): void {\n    const queue = this.queue$.value;\n    const existingItem = queue.get(cid);\n    // debugCid(cid, '----/--enqueue ', cid, existingItem);\n\n    // In case if item already in queue,\n    // just attach one more callback to quieued item\n    if (existingItem) {\n      this.mutateQueueItem(cid, {\n        callbacks: [...existingItem.callbacks, callback],\n      });\n    } else {\n      const source = options.initialSource || this.strategy.order[0];\n      const item: QueueItem = {\n        cid,\n        callbacks: [callback],\n        source, // initial method to fetch\n        status: 'pending',\n        postProcessing: true, // by default rune-post-processing enabled\n        ...options,\n      };\n\n      callback(cid, 'pending', source);\n\n      queue.set(cid, item);\n      this.queue$.next(queue);\n    }\n  }\n\n  public enqueueAndWait(\n    cid: string,\n    options: QueueItemOptions = {}\n  ): Promise<QueueItemAsyncResult> {\n    return new Promise((resolve) => {\n      const callback = ((cid, status, source, result) => {\n        if (status === 'completed' || status === 'not_found') {\n          resolve({ status, source, result });\n        }\n      }) as QueueItemCallback;\n\n      this.enqueue(cid, callback, options);\n    });\n  }\n\n  public updateViewPortPriority(cid: string, viewPortPriority: number) {\n    this.mutateQueueItem(cid, { viewPortPriority });\n  }\n\n  public cancel(cid: string): void {\n    const queue = this.queue$.value;\n    const item = queue.get(cid);\n    // console.log('-----cancel item', item, item?.controller);\n    if (item) {\n      // If item has no abortController we can just remove it,\n      // otherwise abort&keep-to-finalize\n      if (!item.controller) {\n        this.removeAndNext(cid);\n      } else {\n        item.controller.abort('cancelled');\n      }\n    }\n  }\n\n  public cancelByParent(parent: string): void {\n    const queue = this.queue$.value;\n\n    queue.forEach((item, cid) => {\n      if (item.parent === parent) {\n        this.releaseExecution(cid);\n        item.controller?.abort('cancelled');\n        queue.delete(cid);\n      }\n    });\n\n    this.queue$.next(queue);\n  }\n\n  public clear(): void {\n    const queue = this.queue$.value;\n\n    queue.forEach((item, cid) => {\n      this.releaseExecution(cid);\n      item.controller?.abort('cancelled');\n      queue.delete(cid);\n    });\n\n    this.queue$.next(new Map());\n  }\n\n  public getQueueMap(): QueueMap {\n    return this.queue$.value;\n  }\n\n  public getQueueList(): QueueItem[] {\n    return Array.from(this.queue$.value.values());\n  }\n\n  public getStats(): QueueStats[] {\n    const fn = R.pipe(\n      R.countBy<QueueItem>(R.prop('status')),\n      R.toPairs,\n      R.map(R.zipObj(['status', 'count']))\n    );\n\n    return fn(this.getQueueList()) as QueueStats[];\n  }\n}\n\n// TODO: MOVE TO SEPARATE FILE AS GLOBAL VARIABLE\n// const queueManager = new QueueManager<IPFSContentMaybe>();\n\n// if (typeof window !== 'undefined') {\n//   window.qm = queueManager;\n// }\n\n// export { queueManager };\nexport default QueueManager;\n","import { Observable } from 'rxjs';\n\n/**\n * Promise will be rejected after timeout.\n *\n * @param promise\n * @param timeout ms\n * @param abortController trigger abort\n * @returns\n */\nasync function withTimeout<T>(\n  promise: Promise<T>,\n  timeout: number,\n  abortController?: AbortController\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      const timer = setTimeout(() => {\n        abortController?.abort('timeout');\n        clearTimeout(timer);\n        reject(new DOMException('timeout', 'AbortError'));\n      }, timeout);\n    }),\n  ]);\n}\n\n/**\n * Convert promise to observable\n * @param promiseFactory\n * @returns\n */\nexport function promiseToObservable<T>(promiseFactory: () => Promise<T>) {\n  return new Observable<T>((observer) => {\n    promiseFactory()\n      .then((response) => {\n        observer.next(response);\n        observer.complete();\n      })\n      .catch((error) => {\n        console.debug('----promiseToObservable error', error); //, error\n        observer.error(error);\n      });\n  });\n}\n\nexport function convertTimeToMilliseconds(timeValue: string | number): number {\n  if (typeof timeValue === 'number') {\n    return timeValue;\n  }\n  const numericValue = parseFloat(timeValue);\n\n  const unit = timeValue\n    .replace(numericValue.toString(), '')\n    .trim()\n    .toLowerCase();\n\n  switch (unit) {\n    case 'ms':\n    case '':\n      return numericValue;\n    case 's':\n      return numericValue * 1000;\n    case 'm':\n      return numericValue * 60 * 1000;\n    case 'h':\n      return numericValue * 60 * 60 * 1000;\n    case 'd':\n      return numericValue * 24 * 60 * 60 * 1000;\n    default:\n      throw new Error(`Invalid time unit: ${unit}`);\n  }\n}\n\nexport function debounce(func, timeout = 300) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      func.apply(this, args);\n    }, timeout);\n  };\n}\n","import { IPFSContentMaybe, IpfsContentSource } from '../ipfs/ipfs';\nimport { LinkDbEntity } from '../CozoDb/types/entities';\nimport { LinkDto } from '../CozoDb/types/dto';\n\n/* eslint-disable import/no-unused-modules */\nexport type QueueItemStatus =\n  | 'pending'\n  | 'executing'\n  | 'timeout'\n  | 'completed'\n  | 'cancelled'\n  | 'error'\n  | 'not_found';\n\nexport type QueueSourceSettings = {\n  timeout: number;\n  maxConcurrentExecutions: number;\n};\n\nexport type QueueSource = IpfsContentSource;\n\nexport type QueueSettings = Record<QueueSource, QueueSourceSettings>;\n\nexport interface IQueueStrategy {\n  settings: QueueSettings;\n  order: QueueSource[];\n  getNextSource(source: QueueSource): QueueSource | undefined;\n}\n\nexport type QueueStats = {\n  status: QueueItemStatus;\n  count: number;\n};\n\nexport enum QueuePriority {\n  ZERO = 0,\n  LOW = 0.1,\n  MEDIUM = 0.5,\n  HIGH = 0.9,\n  URGENT = 1,\n}\nexport type QueueItemOptions = {\n  parent?: string;\n  priority?: QueuePriority | number;\n  viewPortPriority?: number;\n  initialSource?: QueueSource;\n  postProcessing?: boolean;\n};\n\nexport type QueueItemCallback = (\n  cid: string,\n  status: QueueItemStatus,\n  source: QueueSource,\n  result?: IPFSContentMaybe\n) => void;\n\nexport type QueueItem = {\n  cid: string;\n  source: QueueSource;\n  status: QueueItemStatus;\n  callbacks: QueueItemCallback[];\n  controller?: AbortController;\n  executionTime?: number;\n} & Omit<QueueItemOptions, 'initialSource'>;\n\nexport type QueueItemResult = {\n  item: QueueItem;\n  status: QueueItemStatus;\n  source: QueueSource;\n  result?: IPFSContentMaybe;\n};\n\nexport type QueueItemAsyncResult = Omit<QueueItemResult, 'item'>;\n\nexport type QueueItemPostProcessor = (\n  content: IPFSContentMaybe\n) => Promise<IPFSContentMaybe>;\n\nexport interface IDeferredDbSaver {\n  // postProcess: (content: IPFSContentMaybe) => Promise<IPFSContentMaybe>;\n  enqueueIpfsContent: (content: IPFSContentMaybe) => void;\n  enqueueLinks: (links: LinkDto[]) => void;\n}\n\nexport type FetchParticleAsync = (\n  cid: string,\n  options?: QueueItemOptions\n) => Promise<QueueItemAsyncResult>;\n","import type { TransferHandler } from 'comlink';\nimport { IPFSContent } from 'src/services/ipfs/ipfs';\n\ntype IPFSContentTransferable = Omit<IPFSContent, 'result'> & {\n  port: MessagePort;\n};\n\nfunction createAsyncIterable(port: MessagePort): AsyncIterable<Uint8Array> {\n  return {\n    async *[Symbol.asyncIterator](): AsyncGenerator<\n      Uint8Array,\n      void,\n      undefined\n    > {\n      let done = false;\n      while (!done) {\n        // eslint-disable-next-line no-loop-func\n        const promise = new Promise<Uint8Array | null>((resolve) => {\n          // resolve = res;\n          port.onmessage = (event: MessageEvent) => {\n            if (event.data === null) {\n              done = true;\n              resolve(null);\n            } else {\n              resolve(event.data);\n            }\n          };\n        });\n        // eslint-disable-next-line no-await-in-loop\n        const value = await promise;\n        // eslint-disable-next-line no-await-in-loop\n        if (value !== null) {\n          yield value;\n        }\n      }\n    },\n  };\n}\n\nconst IPFSContentTransferHandler: TransferHandler<\n  IPFSContent | undefined,\n  IPFSContentTransferable | null\n> = {\n  canHandle: (obj: IPFSContent | undefined) =>\n    obj && obj.result && typeof obj.result[Symbol.asyncIterator] === 'function',\n  serialize(obj: IPFSContent) {\n    if (obj === undefined) {\n      return [null, []];\n    }\n    const { result, ...rest } = obj;\n    const { port1, port2 } = new MessageChannel();\n    if (result) {\n      (async () => {\n        // eslint-disable-next-line no-restricted-syntax\n        for await (const value of result) {\n          port1.postMessage(value);\n        }\n        port1.postMessage(null); // Send  \"end\" message\n\n        port1.close();\n      })();\n    }\n    return [{ ...rest, port: port2 }, [port2]];\n  },\n  deserialize(serializedObj: IPFSContentTransferable | null) {\n    if (!serializedObj) {\n      return undefined;\n    }\n    const { port, ...rest } = serializedObj;\n\n    return {\n      ...rest,\n      result: createAsyncIterable(port),\n    };\n  },\n};\n\nexport { IPFSContentTransferHandler };\n","import { wrap, Remote, expose, transferHandlers } from 'comlink';\nimport { IPFSContentTransferHandler } from './serializers';\n\ntype WorkerType = SharedWorker | Worker;\n\nconst isSharedWorkersSupported = typeof SharedWorker !== 'undefined';\n\nconst isSharedWorkerUsed = isSharedWorkersSupported && !process.env.IS_DEV;\n\n// apply serializers for custom types\nfunction installTransferHandlers() {\n  transferHandlers.set('IPFSContent', IPFSContentTransferHandler);\n}\n\nfunction safeStringify(obj: any): string {\n  try {\n    return JSON.stringify(obj);\n  } catch (error) {\n    return String(obj);\n  }\n}\n\n// Override console.log to send logs to main thread\nfunction overrideLogging(worker: Worker | MessagePort) {\n  const consoleLogMap = {\n    log: { original: console.log },\n    error: { original: console.error },\n    warn: { original: console.warn },\n  };\n  const replaceConsoleLog = (method: keyof typeof consoleLogMap) => {\n    const { original } = consoleLogMap[method];\n\n    consoleLogMap[method].original = console[method];\n\n    console[method] = (...args) => {\n      original.apply(console, args);\n      const serializableArgs = args.map((arg) => safeStringify(arg));\n\n      worker.postMessage({ type: 'console', method, args: serializableArgs });\n    };\n  };\n\n  Object.keys(consoleLogMap).forEach((method) =>\n    replaceConsoleLog(method as keyof typeof consoleLogMap)\n  );\n}\n\n// Install handlers for logging from worker\nfunction installLoggingHandler(worker: Worker | MessagePort, name: string) {\n  // Add event listener\n  worker.addEventListener('message', (event) => {\n    if (event.data.type === 'console') {\n      const { method, args } = event.data;\n\n      console[method](name, ...args);\n    }\n  });\n}\n\n// Create Shared Worker with fallback to usual Worker(in case of DEV too)\nexport function createWorkerApi<T>(\n  workerUrl: URL,\n  workerName: string\n): { worker: WorkerType; workerApiProxy: Remote<T> } {\n  installTransferHandlers();\n  //&& !process.env.IS_DEV\n  if (isSharedWorkerUsed) {\n    const worker = new SharedWorker(workerUrl, { name: workerName });\n    installLoggingHandler(worker.port, workerName);\n    return { worker, workerApiProxy: wrap<T>(worker.port) };\n  }\n\n  const worker = new Worker(workerUrl);\n  // installLoggingHandler(worker, workerName);\n  return { worker, workerApiProxy: wrap<T>(worker) };\n}\n\nexport function exposeWorkerApi<T>(worker: WorkerType, api: T) {\n  installTransferHandlers();\n  if (typeof worker.onconnect !== 'undefined') {\n    worker.onconnect = (e) => {\n      const port = e.ports[0];\n      overrideLogging(port);\n\n      expose(api, port);\n    };\n  } else {\n    // overrideLogging(worker);\n    expose(api);\n  }\n}\n","import { createCyblogChannel } from 'src/utils/logging/cyblog';\nimport {\n  ProgressTracking,\n  SyncEntryName,\n  SyncProgress,\n} from '../types/services';\nimport BroadcastChannelSender from './BroadcastChannelSender';\n\nexport const broadcastStatus = (\n  name: SyncEntryName,\n  channelApi: BroadcastChannelSender\n) => {\n  // const cyblogCh = createCyblogChannel({ thread: 'bckd', module: name });\n  return {\n    sendStatus: (\n      status: SyncProgress['status'],\n      message?: string,\n      progress?: ProgressTracking\n    ) => {\n      // cyblogCh.info(`>>>$ sync ${name} status: ${status} message: ${message}`);\n      channelApi.postSyncEntryProgress(name, {\n        status,\n        message,\n        progress,\n        done: ['active', 'error', 'listen'].some((s) => s === status),\n      });\n    },\n  };\n};\n","async function* arrayToAsyncIterable<T>(array: T[]): AsyncIterable<T> {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const item of array) {\n    yield item;\n  }\n}\n\nasync function asyncIterableBatchProcessor<T, K>(\n  items: AsyncIterable<T> | Iterable<T>,\n  batchProcess: (arg: T[]) => Promise<K>,\n  batchSize = 10\n): Promise<void> {\n  let batch = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of items) {\n    batch.push(item);\n    if (batch.length === batchSize) {\n      await batchProcess(batch);\n      batch = [];\n    }\n  }\n  // process the rest\n  if (batch.length > 0) {\n    await batchProcess(batch);\n  }\n}\n\nasync function asyncIterableToArray<T>(asyncIterable: AsyncIterable<T>) {\n  const resultArray = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const item of asyncIterable) {\n    resultArray.push(item);\n  }\n  return resultArray;\n}\n// Create a helper function to create AsyncIterable from a list and iterate one by one\nfunction createAsyncIterable<T>(data: T[]): AsyncIterable<T> {\n  let index = 0;\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next(): Promise<IteratorResult<T>> {\n          if (index < data.length) {\n            return Promise.resolve({ done: false, value: data[index++] });\n          }\n          return Promise.resolve({ done: true, value: undefined as any });\n        },\n      };\n    },\n  };\n}\n\nexport {\n  arrayToAsyncIterable,\n  asyncIterableBatchProcessor,\n  asyncIterableToArray,\n  createAsyncIterable,\n};\n","// export const CID_AVATAR = 'Qmf89bXkJH9jw4uaLkHmZkxQ51qGKfUPtAMxA8rTwBrmTs';\nexport const CID_TWEET = 'QmbdH2WBamyKLPE5zu4mJ9v49qvY8BFfoumoVPMR5V4Rvx';\nexport const CID_FOLLOW = 'QmPLSA5oPqYxgc8F7EwrM8WS9vKrr1zPoDniSRFh8HSrxx';\n\nexport const BECH32_PREFIX_ACC_ADDR_CYBER = 'bostrom';\n\nexport const PATTERN_CYBER = new RegExp(\n  `^${BECH32_PREFIX_ACC_ADDR_CYBER}[a-zA-Z0-9]{39}$`,\n  'g'\n);\n","import { CID_FOLLOW, CID_TWEET } from 'src/constants/app';\nimport { SyncEntryName } from 'src/services/backend/types/services';\n\nexport const MY_PARTICLES_SYNC_INTERVAL = 5 * 60 * 1000; // 60 sec\nexport const MY_FRIENDS_SYNC_INTERVAL = 5 * 60 * 1000; // 60 sec\nexport const IPFS_SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutes\n\nexport const MAX_DATABASE_PUT_SIZE = 500;\n\nexport const MAX_LINKS_RESOLVE_BATCH = 20;\n\nexport const DAY_IN_MS = 24 * 60 * 60 * 1000;\n\nexport const SENSE_FRIEND_PARTICLES = [CID_TWEET, CID_FOLLOW];\n\nexport const SYNC_ENTRIES_TO_TRACK_PROGRESS = [\n  'my-friends',\n  'particles',\n  'transactions',\n] as SyncEntryName[];\n","import {\n  BehaviorSubject,\n  Observable,\n  filter,\n  mergeMap,\n  tap,\n  map,\n  combineLatest,\n  share,\n  EMPTY,\n} from 'rxjs';\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { broadcastStatus } from 'src/services/backend/channels/broadcastStatus';\nimport { ParticleCid } from 'src/types/base';\nimport { SyncQueueStatus } from 'src/services/CozoDb/types/entities';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\n\nimport DbApi from '../../../dataSource/indexedDb/dbApiWrapper';\n\nimport { FetchIpfsFunc } from '../../types';\nimport { ServiceDeps } from '../types';\nimport { SyncQueueItem } from './types';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\n\nconst QUEUE_BATCH_SIZE = 100;\n\nclass ParticlesResolverQueue {\n  public isInitialized$: Observable<boolean>;\n\n  private db: DbApi | undefined;\n\n  private waitForParticleResolve: FetchIpfsFunc;\n\n  private statusApi = broadcastStatus('resolver', new BroadcastChannelSender());\n\n  private _syncQueue$ = new BehaviorSubject<Map<ParticleCid, SyncQueueItem>>(\n    new Map()\n  );\n\n  public get queue(): Map<ParticleCid, SyncQueueItem> {\n    return this._syncQueue$.getValue();\n  }\n\n  private _loop$: Observable<any> | undefined;\n\n  public get loop$(): Observable<any> | undefined {\n    return this._loop$;\n  }\n\n  constructor(deps: ServiceDeps) {\n    if (!deps.waitForParticleResolve) {\n      throw new Error('waitForParticleResolve is not defined');\n    }\n\n    this.waitForParticleResolve = deps.waitForParticleResolve;\n\n    deps.dbInstance$.subscribe(async (db) => {\n      this.db = db;\n      await this.loadSyncQueue();\n    });\n\n    this.isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.ipfsInstance$,\n    ]).pipe(\n      map(([dbInstance, ipfsInstance]) => !!ipfsInstance && !!dbInstance)\n    );\n  }\n\n  private async processSyncQueue(pendingItems: SyncQueueItem[]) {\n    // console.log('------processSyncQueue ', pendingItems);\n\n    const batchSize = pendingItems.length;\n\n    this.statusApi.sendStatus(\n      'in-progress',\n      `processing batch ${batchSize}/${batchSize} batch. ${this.queue.size} pending...`\n    );\n\n    let i = batchSize;\n    await Promise.all(\n      pendingItems.map(async (item) => {\n        const { id } = item;\n        // eslint-disable-next-line no-await-in-loop\n        return this.waitForParticleResolve(id, QueuePriority.MEDIUM).then(\n          async (result) => {\n            if (result.status === 'not_found') {\n              await this.db!.updateSyncQueue({\n                id,\n                status: SyncQueueStatus.error,\n              });\n            } else {\n              await this.db!.removeSyncQueue(id);\n            }\n\n            const queue = this._syncQueue$.value;\n            queue.delete(id);\n            i--;\n            this._syncQueue$.next(queue);\n\n            this.statusApi.sendStatus(\n              'in-progress',\n              `processing batch ${batchSize - i}/${batchSize} batch. ${\n                this.queue.size\n              } pending...`\n            );\n          }\n        );\n      })\n    );\n  }\n\n  start() {\n    const source$ = this.isInitialized$.pipe(\n      tap((q) => console.log(`sync queue isInitialized - ${q}`)),\n      filter((isInitialized) => isInitialized === true),\n      mergeMap(() => this._syncQueue$), // Merge the queue$ stream here.\n      // tap((q) => console.log(`sync queue - ${q.size}`)),\n      filter((q) => q.size > 0),\n      mergeMap((queue) => {\n        const list = [...queue.values()];\n\n        const executingCount = list.filter(\n          (i) => i.status === SyncQueueStatus.executing\n        ).length;\n\n        const batchSize = QUEUE_BATCH_SIZE - executingCount;\n\n        if (batchSize > 0) {\n          const pendingItems = list\n            .filter((i) => i.status === SyncQueueStatus.pending)\n            .sort((a, b) => {\n              return a.priority - b.priority;\n            })\n            .slice(0, batchSize);\n\n          if (pendingItems.length > 0) {\n            pendingItems.forEach((i) => {\n              queue.set(i.id, {\n                ...i,\n                status: SyncQueueStatus.executing,\n              });\n            });\n\n            this._syncQueue$.next(queue);\n\n            this.statusApi.sendStatus('in-progress', `starting...`);\n            return this.processSyncQueue(pendingItems);\n          }\n        }\n\n        return EMPTY;\n      })\n    );\n\n    this._loop$ = source$.pipe(share());\n\n    this._loop$.subscribe({\n      next: (result) => {\n        this.statusApi.sendStatus('active');\n      },\n      error: (err) => this.statusApi.sendStatus('error', err.toString()),\n    });\n\n    return this;\n  }\n\n  public async fetchDirect(cid: ParticleCid) {\n    return this.waitForParticleResolve(cid, QueuePriority.URGENT);\n  }\n\n  public async enqueueBatch(cids: ParticleCid[], priority: QueuePriority) {\n    return asyncIterableBatchProcessor(\n      cids,\n      (cids) =>\n        this.enqueue(\n          cids.map((cid) => ({\n            id: cid /* from is tweet */,\n            priority,\n          }))\n        ),\n      MAX_DATABASE_PUT_SIZE\n    );\n  }\n\n  public async enqueue(items: SyncQueueItem[]) {\n    if (items.length === 0) {\n      return;\n    }\n    await this.db!.putSyncQueue(items);\n    const queue = this._syncQueue$.value;\n\n    items.forEach((item) =>\n      queue.set(item.id, { ...item, status: SyncQueueStatus.pending })\n    );\n    this._syncQueue$.next(queue);\n  }\n\n  private async loadSyncQueue() {\n    const queue = await this.db!.getSyncQueue({\n      statuses: [SyncQueueStatus.pending],\n    }).then((items) => new Map(items.map((item) => [item.id, item])));\n\n    this._syncQueue$.next(new Map([...queue, ...this.queue]));\n  }\n}\n\nexport default ParticlesResolverQueue;\n","import dateFormat from 'dateformat';\n\nexport const numberToUtcDate = (timestamp: number) =>\n  dateFormat(new Date(timestamp), 'yyyy-mm-dd\"T\"HH:MM:ss.l', true);\n\nexport const dateToUtcNumber = (isoString: string) =>\n  Date.parse(isoString.endsWith('Z') ? isoString : `${isoString}Z`);\n\nexport const getNowUtcNumber = (): number => {\n  return dateToUtcNumber(new Date().toISOString());\n};\n//\nfunction roundMilliseconds(dateTimeString: string) {\n  const date = new Date(dateTimeString);\n  const roundedMilliseconds = Math.round(date.getMilliseconds() / 1000) * 1000;\n  date.setMilliseconds(roundedMilliseconds);\n  return dateFormat(date, 'yyyy-mm-dd\"T\"HH:MM:ss.l');\n}\nfunction getCurrentTimezoneOffset() {\n  const now = new Date();\n  return -now.getTimezoneOffset() / 60;\n}\n\nfunction numberToDateWithTimezone(timestamp: number, timezoneOffset?: number) {\n  // Convert timestamp from milliseconds to a Date object\n  const date = new Date(timestamp);\n\n  const tzOffset = timezoneOffset || getCurrentTimezoneOffset();\n  console.log('---tzOffset', tzOffset);\n  // Adjust the date for the timezone offset\n  // The timezoneOffset is in hours for the target timezone relative to UTC\n  const localTime = date.getTime();\n  const localOffset = date.getTimezoneOffset() * 60000; // in milliseconds\n  const utc = localTime + localOffset;\n  const timezoneDate = new Date(utc + 3600000 * tzOffset);\n\n  // Format the date using dateFormat\n  return dateFormat(timezoneDate, 'yyyy-mm-dd HH:MM:ss');\n}\n\nfunction pluralizeUnit(quantity: number, unit: string): string {\n  return quantity === 1 ? unit : `${unit}s`;\n}\n\nconst minuteInMs = 60000; // 60 seconds * 1000 milliseconds\nconst hourInMs = 3600000; // 60 minutes * 60 seconds * 1000 milliseconds\nconst dayInMs = 86400000; // 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\n\nfunction convertTimestampToString(timestamp: number): string {\n  if (timestamp < minuteInMs) {\n    const seconds = Math.floor(timestamp / 1000);\n    return `${seconds} ${pluralizeUnit(seconds, 'second')}`;\n  }\n  if (timestamp < hourInMs) {\n    const minutes = Math.floor(timestamp / minuteInMs);\n    return `${minutes} ${pluralizeUnit(minutes, 'minute')}`;\n  }\n  if (timestamp < dayInMs) {\n    const hours = Math.floor(timestamp / hourInMs);\n    return `${hours} ${pluralizeUnit(hours, 'hour')}`;\n  }\n\n  const days = Math.floor(timestamp / dayInMs);\n  return `${days} ${pluralizeUnit(days, 'day')}`;\n}\n\nexport {\n  roundMilliseconds,\n  numberToDateWithTimezone,\n  convertTimestampToString,\n};\n","import { LsResult } from 'ipfs-core-types/src/pin';\nimport { dateToUtcNumber } from 'src/utils/date';\nimport { NeuronAddress, ParticleCid, TransactionHash } from 'src/types/base';\nimport { IPFSContent } from '../ipfs/ipfs';\nimport { LinkDbEntity, PinTypeMap } from './types/entities';\nimport { Transaction } from '../backend/services/indexer/types';\nimport { LinkDto, ParticleDto, PinDto, TransactionDto } from './types/dto';\nimport { CyberlinksByParticleResponse } from '../backend/services/dataSource/blockchain/indexer';\n\nexport const mapParticleToEntity = (particle: IPFSContent): ParticleDto => {\n  const { cid, result, meta, textPreview } = particle;\n  const { size, mime, type, blocks, sizeLocal } = meta;\n  // hack to fix string command\n  const text = textPreview?.replace(/\"/g, \"'\") || '';\n  return {\n    cid,\n    size: size || 0,\n    mime: mime || 'unknown',\n    type,\n    text,\n    size_local: sizeLocal || -1,\n    blocks: blocks || 0,\n  };\n};\n\n//TODO: REFACTOR\nexport const mapPinToEntity = (pin: LsResult): PinDto => ({\n  cid: pin.cid.toString(),\n  type: PinTypeMap[pin.type],\n});\n\nexport const mapIndexerTransactionToEntity = (\n  neuron: string,\n  tx: Transaction\n): TransactionDto => {\n  const {\n    transaction_hash,\n    index,\n    transaction: {\n      memo,\n      block: { timestamp, height },\n      success,\n    },\n    type,\n    value,\n  } = tx;\n  return {\n    hash: transaction_hash,\n    index,\n    type,\n    timestamp: dateToUtcNumber(timestamp),\n    // value: JSON.stringify(value),\n    memo,\n    value,\n    success,\n    neuron,\n    blockHeight: height,\n  };\n};\n\n// export const mapSyncStatusToEntity = (\n//   id: NeuronAddress | ParticleCid,\n//   entryType: EntryType,\n//   unreadCount: number,\n//   timestampUpdate: number,\n//   lastId: TransactionHash | ParticleCid = '',\n//   timestampRead: number = timestampUpdate,\n//   meta: Object = {}\n// ): SyncStatusDbEntity => {\n//   return {\n//     entry_type: entryType,\n//     id,\n//     timestamp_update: timestampUpdate,\n//     timestamp_read: timestampRead,\n//     unread_count: unreadCount,\n//     disabled: false,\n//     last_id: lastId,\n//     meta,\n//   };\n// };\n\nexport const mapLinkToEntity = (\n  from: ParticleCid,\n  to: ParticleCid,\n  neuron: NeuronAddress = '',\n  timestamp: number = 0\n): LinkDbEntity => ({\n  from,\n  to,\n  neuron,\n  timestamp,\n});\n\nexport const mapLinkFromIndexerToDbEntity = ({\n  from,\n  to,\n  neuron,\n  timestamp,\n  transaction_hash,\n}: CyberlinksByParticleResponse['cyberlinks'][0]): LinkDbEntity => ({\n  from,\n  to,\n  neuron,\n  timestamp: dateToUtcNumber(timestamp),\n  transaction_hash,\n});\n","export async function waitUntil(cond: () => boolean, timeoutDuration = 60000) {\n  if (cond()) {\n    return true;\n  }\n\n  const waitPromise = new Promise((resolve) => {\n    const interval = setInterval(() => {\n      if (cond()) {\n        clearInterval(interval);\n        resolve(true);\n      }\n    }, 10);\n  });\n\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error('waitUntil timed out!'));\n    }, timeoutDuration);\n  });\n\n  return Promise.race([waitPromise, timeoutPromise]);\n}\n\nexport function executeSequentially<T>(\n  promiseFunctions: (() => Promise<T>)[]\n): Promise<T[]> {\n  return promiseFunctions.reduce((promiseChain, currentFunction) => {\n    return promiseChain.then((chainResults) =>\n      currentFunction().then((currentResult) => [\n        ...chainResults,\n        currentResult,\n      ])\n    );\n  }, Promise.resolve([] as T[]));\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport function makeCancellable<T extends (...args: any[]) => Promise<any>>(\n  func: T,\n  signal: AbortSignal\n): (...funcArgs: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    // Promise that listens for the abort signal\n    const abortPromise = new Promise<ReturnType<T>>((_, reject) => {\n      const abortHandler = () => {\n        signal.removeEventListener('abort', abortHandler); // Clean up the event listener\n        reject(new DOMException('The operation was aborted.', 'AbortError'));\n      };\n      signal.addEventListener('abort', abortHandler, { once: true });\n    });\n\n    // Wrapping the original function in a promise\n    const taskPromise = new Promise<ReturnType<T>>(async (resolve, reject) => {\n      try {\n        const result = await func(...args);\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n\n    // Using Promise.race to handle cancellation\n    return Promise.race([taskPromise, abortPromise]);\n  };\n}\n\nexport function throwIfAborted<T extends (...args: any[]) => Promise<any>>(\n  func: T,\n  signal: AbortSignal\n): (...funcArgs: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    if (signal.aborted) {\n      throw new DOMException('The operation was aborted.', 'AbortError');\n    }\n    return func(...args);\n  };\n}\n","export const CYBER_NODE_URL_LCD =\n  process.env.CYBER_NODE_URL_LCD || 'https://lcd.bostrom.cybernode.ai';\nexport const CYBER_INDEX_HTTPS =\n  process.env.CYBER_INDEX_HTTPS ||\n  'https://index.bostrom.cybernode.ai/v1/graphql';\n\nexport const CYBER_INDEX_WSS =\n  process.env.CYBER_INDEX_WSS || 'wss://index.bostrom.cybernode.ai/v1/graphql';\n\nexport const CYBER_NODE_URL_WS =\n  process.env.CYBER_NODE_URL_WS || 'wss://rpc.bostrom.cybernode.ai/websocket';\n","import { Coin } from 'cosmjs-types/cosmos/base/v1beta1/coin';\nimport { CyberLinkSimple, NeuronAddress } from 'src/types/base';\n\ninterface GenericIndexerTransaction<T> {\n  value: T;\n  type: string;\n  transaction_hash: string;\n  index: number;\n  transaction: {\n    memo?: string;\n    success: boolean;\n    block: {\n      timestamp: string;\n    };\n  };\n}\nexport const MSG_SEND_TRANSACTION_TYPE = 'cosmos.bank.v1beta1.MsgSend';\n\nexport const MSG_MULTI_SEND_TRANSACTION_TYPE =\n  'cosmos.bank.v1beta1.MsgMultiSend';\n\nexport const CYBER_LINK_TRANSACTION_TYPE = 'cyber.graph.v1beta1.MsgCyberlink';\n\nconst DELEGATION_TRANSACTION_TYPE = 'cosmos.staking.v1beta1.MsgDelegate';\n\ninterface Input {\n  address: NeuronAddress;\n  coins: Coin[];\n}\n\ninterface Output {\n  address: NeuronAddress;\n  coins: Coin[];\n}\n\nexport interface MsgMultiSendValue {\n  inputs: Input[];\n  outputs: Output[];\n}\n\nexport interface MsgSendValue {\n  amount: Coin[];\n  from_address: NeuronAddress;\n  to_address: NeuronAddress;\n}\n\ninterface MsgDelegateValue {\n  amount: Coin;\n  delegator_address: NeuronAddress;\n  validator_address: NeuronAddress;\n}\n\nexport interface CyberLinkValue {\n  neuron: NeuronAddress;\n  links: CyberLinkSimple[];\n}\n\ninterface DelegateTransaction\n  extends GenericIndexerTransaction<MsgDelegateValue> {\n  type: typeof DELEGATION_TRANSACTION_TYPE;\n}\n\nexport interface CyberLinkTransaction\n  extends GenericIndexerTransaction<CyberLinkValue> {\n  type: typeof CYBER_LINK_TRANSACTION_TYPE;\n}\n\nexport interface MsgMultiSendTransaction\n  extends GenericIndexerTransaction<MsgMultiSendValue> {\n  type: typeof MSG_MULTI_SEND_TRANSACTION_TYPE;\n}\n\nexport interface MsgSendTransaction\n  extends GenericIndexerTransaction<MsgSendValue> {\n  type: typeof MSG_SEND_TRANSACTION_TYPE;\n}\n\nexport type Transaction =\n  // | DelegateTransaction\n  CyberLinkTransaction | MsgMultiSendTransaction | MsgSendTransaction;\n\nexport type GqlType = 'query' | 'subscription';\n","import { Tx } from 'cosmjs-types/cosmos/tx/v1beta1/tx';\nimport { MsgSend, MsgMultiSend } from 'cosmjs-types/cosmos/bank/v1beta1/tx';\n\nimport { fromBase64 } from '@cosmjs/encoding';\nimport {\n  MSG_MULTI_SEND_TRANSACTION_TYPE,\n  MSG_SEND_TRANSACTION_TYPE,\n} from 'src/services/backend/services/indexer/types';\nimport { NeuronAddress } from 'src/types/base';\nimport { TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { getNowUtcNumber } from 'src/utils/date';\n\n// eslint-disable-next-line import/no-unused-modules\nexport const extractTxData = (data: string) => {\n  const result = Tx.decode(fromBase64(data));\n  const memo = result.body?.memo;\n  const messages = result.body?.messages\n    .map((message) => {\n      const msgType = message.typeUrl.slice(1);\n      if (msgType === MSG_SEND_TRANSACTION_TYPE) {\n        return MsgSend.decode(message.value);\n      }\n\n      if (msgType === MSG_MULTI_SEND_TRANSACTION_TYPE) {\n        return MsgMultiSend.decode(message.value);\n      }\n      return undefined;\n    })\n    .filter((message) => message !== undefined);\n\n  return { memo, messages };\n};\n\n// eslint-disable-next-line import/no-unused-modules\nexport const mapWebsocketTxToTransactions = (\n  neuron: NeuronAddress,\n  result: any\n) => {\n  const { data, events } = result;\n\n  const hash = events['tx.hash'][0];\n  const transactionType = events['message.action'][0].slice(1);\n  const timestamp = getNowUtcNumber();\n  const blockHeight = events['tx.height'][0];\n\n  const { memo = '', messages } = extractTxData(data.value.TxResult.tx);\n\n  const transactions: TransactionDto[] = [];\n  messages!.forEach((message, index) => {\n    transactions.push({\n      hash,\n      index,\n      type: transactionType,\n      timestamp,\n      success: true,\n      value: message!,\n      memo,\n      neuron,\n      blockHeight,\n    });\n  });\n\n  return transactions;\n};\n","// eslint-disable-next-line import/prefer-default-export\nexport async function* fetchIterable<T, P>(\n  fetchFunction: (params: P & { offset: number }) => Promise<T[]>,\n  params: P\n): AsyncGenerator<T[], void, undefined> {\n  let offset = 0;\n  while (true) {\n    // eslint-disable-next-line no-await-in-loop\n    const items = await fetchFunction({ ...params, offset });\n\n    if (items.length === 0) {\n      break;\n    }\n\n    yield items;\n\n    offset += items.length;\n  }\n}\n","import { ApolloClient, DocumentNode, InMemoryCache } from '@apollo/client';\n\nimport {\n  GraphQLWsLink,\n  Observable as ApolloObservable,\n} from '@apollo/client/link/subscriptions';\nimport { GraphQLClient } from 'graphql-request';\nimport { createClient } from 'graphql-ws';\nimport { Observable } from 'rxjs';\nimport { CYBER_INDEX_HTTPS, CYBER_INDEX_WSS } from 'src/constants/config';\n\nconst cyberGraphQLWsLink = new GraphQLWsLink(\n  createClient({\n    url: CYBER_INDEX_WSS,\n    shouldRetry: (errOrCloseEvent: unknown) => true,\n    retryAttempts: 10,\n    retryWait: async (retries: number): Promise<void> => {\n      setTimeout(() => Promise.resolve(), Math.min(1000 * 2 ** retries, 10000));\n    },\n    // on: {\n    //   error: (err) => {\n    //     console.log('---ws errr', err);\n    //   },\n    //   message: (msg) => {\n    //     console.log('---ws message', msg);\n    //   },\n    //   // Handle connection opened event\n    //   opened: () => {\n    //     console.log('---ws opened');\n    //   },\n    //   // Handle connection closed event\n    //   closed: () => {\n    //     console.log('---ws closed');\n    //   },\n    // },\n  })\n);\n\nexport const createIndexerClient = (abortSignal: AbortSignal) =>\n  new GraphQLClient(CYBER_INDEX_HTTPS, {\n    signal: abortSignal,\n  });\n\n// eslint-disable-next-line import/no-unused-modules\nexport function createIndexerWebsocket<T>(\n  query: DocumentNode,\n  variables: object\n): Observable<T> {\n  const client = new ApolloClient({\n    link: cyberGraphQLWsLink,\n    cache: new InMemoryCache(),\n  });\n  const apolloObservable = client.subscribe({ query, variables });\n  return new Observable((subscriber) => {\n    const subscription = apolloObservable.subscribe({\n      next(result) {\n        subscriber.next(result.data as T);\n      },\n      error(err) {\n        subscriber.error(err);\n      },\n      complete() {\n        subscriber.complete();\n      },\n    });\n\n    // Cleanup subscription on unsubscribe\n    return () => subscription.unsubscribe();\n  });\n}\n","/* eslint-disable import/no-unused-modules */\nimport { request } from 'graphql-request';\n\nimport { gql } from '@apollo/client';\n\nimport { Cyberlink, ParticleCid, NeuronAddress } from 'src/types/base';\nimport { dateToUtcNumber, numberToUtcDate } from 'src/utils/date';\nimport { CYBER_INDEX_HTTPS } from 'src/constants/config';\n\nimport { CYBERLINKS_BATCH_LIMIT } from './consts';\nimport { fetchIterable } from './utils/fetch';\nimport { createIndexerClient } from '../../indexer/utils';\n\ntype CyberlinksCountResponse = {\n  cyberlinks_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n};\n\ntype CyberlinksSyncStatsResponse = {\n  cyberlinks_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n  first: {\n    timestamp: string;\n  }[];\n  last: {\n    timestamp: string;\n    to: ParticleCid;\n    from: ParticleCid;\n  }[];\n};\n\nexport type CyberlinksByParticleResponse = {\n  cyberlinks: (Omit<Cyberlink, 'timestamp'> & {\n    timestamp: string;\n    neuron: NeuronAddress;\n    transaction_hash: string;\n  })[];\n};\nconst cyberlinksByParticle = gql(`\nquery Cyberlinks($limit: Int, $offset: Int, $orderBy: [cyberlinks_order_by!], $where: cyberlinks_bool_exp) {\n  cyberlinks(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {\n    from: particle_from\n    to: particle_to\n    timestamp\n    neuron\n    transaction_hash\n  }\n}\n`);\n\nconst cyberlinksSyncStats = gql(`\n  query Cyberlinks($where: cyberlinks_bool_exp) {\n    cyberlinks_aggregate(where: $where) {\n      aggregate {\n        count\n      }\n    }\n    first: cyberlinks(limit: 1, order_by: { timestamp: asc }, where: $where) {\n      timestamp\n    }\n    last: cyberlinks(limit: 1, order_by: { timestamp: desc }, where: $where) {\n      timestamp,\n      to: particle_to,\n      from: particle_from\n    }\n  }\n`);\n\nconst cyberlinksCountByNeuron = gql(`\n  query MyQuery($address: String, $particles_from: [String!], $timestamp: timestamp) {\n    cyberlinks_aggregate(where: {\n        _and: [\n          { neuron: {_eq: $address}},\n          { particle_from: {_in: $particles_from}},\n          { timestamp: {_gt: $timestamp}}\n        ]\n      }) {\n      aggregate {\n        count\n      }\n    }\n  }\n  `);\n\nconst fetchCyberlinks = async ({\n  particleCid,\n  timestampFrom,\n  offset = 0,\n  abortSignal,\n}: {\n  particleCid: ParticleCid;\n  timestampFrom: number;\n  offset?: number;\n  abortSignal?: AbortSignal;\n}) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksByParticleResponse>(cyberlinksByParticle, {\n    limit: CYBERLINKS_BATCH_LIMIT,\n    offset,\n    orderBy: [\n      {\n        timestamp: 'desc',\n      },\n    ],\n    where: {\n      _or: [\n        {\n          particle_to: {\n            _eq: particleCid,\n          },\n        },\n        {\n          particle_from: {\n            _eq: particleCid,\n          },\n        },\n      ],\n      timestamp: {\n        _gt: numberToUtcDate(timestampFrom),\n      },\n    },\n  });\n  return res.cyberlinks;\n};\n\nconst fetchCyberlinksCount = async (\n  address: NeuronAddress,\n  particlesFrom: ParticleCid[],\n  timestampFrom: number,\n  abortSignal?: AbortSignal\n) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksCountResponse>(cyberlinksCountByNeuron, {\n    address,\n    particles_from: particlesFrom,\n    timestamp: numberToUtcDate(timestampFrom),\n  });\n\n  return res?.cyberlinks_aggregate.aggregate.count;\n};\n\nconst fetchCyberlinksByNeroun = async ({\n  neuron,\n  particlesFrom,\n  timestampFrom,\n  batchSize,\n  offset = 0,\n  abortSignal,\n}: {\n  neuron: NeuronAddress;\n  particlesFrom: ParticleCid[];\n  timestampFrom: number;\n  batchSize: number;\n  offset?: number;\n  abortSignal?: AbortSignal;\n}) => {\n  const where = {\n    _and: [\n      {\n        timestamp: {\n          _gt: numberToUtcDate(timestampFrom),\n        },\n      },\n      {\n        neuron: {\n          _eq: neuron,\n        },\n      },\n      { particle_from: { _in: particlesFrom } },\n    ],\n  };\n\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<CyberlinksByParticleResponse>(cyberlinksByParticle, {\n    limit: batchSize,\n    offset,\n    orderBy: [\n      {\n        timestamp: 'asc',\n      },\n    ],\n    where,\n  });\n\n  return res.cyberlinks;\n};\n\nexport const fetchCyberlinksByNerounIterable = async (\n  neuron: NeuronAddress,\n  particlesFrom: ParticleCid[],\n  timestampFrom: number,\n  batchSize: number,\n  abortSignal?: AbortSignal\n) =>\n  fetchIterable(fetchCyberlinksByNeroun, {\n    neuron,\n    particlesFrom,\n    timestampFrom,\n    batchSize,\n    abortSignal,\n  });\n\nconst fetchCyberlinksIterable = (\n  particleCid: ParticleCid,\n  timestampFrom: number,\n  abortSignal?: AbortSignal\n) =>\n  fetchIterable(fetchCyberlinks, { particleCid, timestampFrom, abortSignal });\n\nconst fetchCyberlinkSyncStats = async (\n  particleCid: ParticleCid,\n  timestampFrom: number\n) => {\n  const res = await request<CyberlinksSyncStatsResponse>(\n    CYBER_INDEX_HTTPS,\n    cyberlinksSyncStats,\n    {\n      where: {\n        _or: [\n          {\n            particle_to: {\n              _eq: particleCid,\n            },\n          },\n          {\n            particle_from: {\n              _eq: particleCid,\n            },\n          },\n        ],\n        timestamp: {\n          _gt: numberToUtcDate(timestampFrom),\n        },\n      },\n    }\n  );\n\n  const {\n    first,\n    last,\n    cyberlinks_aggregate: {\n      aggregate: { count },\n    },\n  } = res;\n  const lastCyberlink = last[0];\n  if (!lastCyberlink) {\n    return undefined;\n  }\n\n  const isFrom = lastCyberlink?.from === particleCid;\n  const lastLinkedParticle =\n    lastCyberlink &&\n    (lastCyberlink.from === particleCid\n      ? lastCyberlink.to\n      : lastCyberlink.from);\n\n  return {\n    firstTimestamp: first.length > 0 ? dateToUtcNumber(first[0].timestamp) : 0,\n    lastTimestamp: lastCyberlink ? dateToUtcNumber(lastCyberlink.timestamp) : 0,\n    lastLinkedParticle,\n    isFrom,\n    count,\n  };\n};\n\nexport { fetchCyberlinksIterable, fetchCyberlinksCount };\n","const TRANSACTIONS_BATCH_LIMIT = 500;\nconst CYBERLINKS_BATCH_LIMIT = 200;\n\nexport { TRANSACTIONS_BATCH_LIMIT, CYBERLINKS_BATCH_LIMIT };\n","import { CyberLinkSimple, CyberlinkTxHash, ParticleCid } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { CID_TWEET } from 'src/constants/app';\nimport { TransactionDto } from 'src/services/CozoDb/types/dto';\n\nimport { fetchCyberlinksIterable } from '../../../dataSource/blockchain/indexer';\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { MAX_LINKS_RESOLVE_BATCH } from '../consts';\nimport {\n  CYBER_LINK_TRANSACTION_TYPE,\n  CyberLinkValue,\n} from '../../../indexer/types';\n\nconst getUniqueParticlesFromLinks = (links: CyberLinkSimple[]) =>\n  [\n    ...new Set([\n      ...links.map((link) => link.to),\n      ...links.map((link) => link.from),\n    ]),\n  ] as ParticleCid[];\n\n// eslint-disable-next-line import/no-unused-modules\nexport const fetchCyberlinksAndResolveParticles = async (\n  cid: ParticleCid,\n  timestampUpdate: number,\n  particlesResolver: ParticlesResolverQueue,\n  queuePriority: QueuePriority,\n  abortSignal?: AbortSignal\n) => {\n  const cyberlinksIterable = fetchCyberlinksIterable(\n    cid,\n    timestampUpdate,\n    abortSignal\n  );\n  const links = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for await (const batch of cyberlinksIterable) {\n    links.push(...batch);\n    const particles = getUniqueParticlesFromLinks(batch);\n    if (particles.length > 0) {\n      await asyncIterableBatchProcessor(\n        particles,\n        (cids: ParticleCid[]) =>\n          particlesResolver!.enqueueBatch(cids, queuePriority),\n        MAX_LINKS_RESOLVE_BATCH\n      );\n    }\n  }\n\n  return links;\n};\n\nexport function extractCybelinksFromTransaction(batch: TransactionDto[]) {\n  const cyberlinks = batch.filter(\n    (l) => l.type === CYBER_LINK_TRANSACTION_TYPE\n  );\n  const particlesFound = new Set<string>();\n  const links: CyberlinkTxHash[] = [];\n  // Get links: only from TWEETS\n  const tweets: Record<ParticleCid, CyberlinkTxHash> = cyberlinks.reduce<\n    Record<ParticleCid, CyberlinkTxHash>\n  >((acc, { value, hash, timestamp }: TransactionDto) => {\n    (value as CyberLinkValue).links.forEach((link) => {\n      particlesFound.add(link.to);\n      particlesFound.add(link.from);\n      const txLink = {\n        ...link,\n        timestamp,\n        neuron: (value as CyberLinkValue).neuron,\n        transaction_hash: hash,\n      };\n      links.push(txLink);\n\n      if (link.from === CID_TWEET) {\n        acc[txLink.to] = txLink;\n      }\n    });\n    return acc;\n  }, {});\n\n  return {\n    tweets,\n    particlesFound: [...particlesFound],\n    links,\n  };\n}\n","import { NeuronAddress } from 'src/types/base';\nimport { GqlType, Transaction } from './types';\n\nimport { gql } from '@apollo/client';\n\nimport { numberToUtcDate } from 'src/utils/date';\nimport {\n  MessagesByAddressVariables,\n  gqlMessagesByAddress,\n} from '../../indexer/transactions';\nimport {\n  TransactionsByAddressResponse,\n  fetchTransactions,\n} from './transactions';\nimport { createIndexerClient } from './utils';\nimport {\n  MessagesByAddressVariables,\n  gqlMessagesByAddress,\n} from './transactions';\nimport { camelToSnake } from 'src/utils/dto';\nimport { fetchIterable } from '../dataSource/blockchain/utils/fetch';\n\ntype OrderDirection = 'desc' | 'asc';\ntype Abortable = { abortSignal?: AbortSignal };\n\nexport type MessagesByAddressVariables = {\n  neuron: NeuronAddress;\n  timestampFrom: number;\n  offset?: number;\n  types: Transaction['type'][];\n  orderDirection: OrderDirection;\n  limit: number;\n} & Abortable;\n\nexport const mapMessagesByAddressVariables = ({\n  neuron,\n  timestampFrom,\n  offset = 0,\n  types = [],\n  orderDirection = 'desc',\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) => ({\n  address: `{${neuron}}`,\n  limit,\n  timestamp_from: numberToUtcDate(timestampFrom),\n  offset,\n  types: `{${types.map((t) => `\"${t}\"`).join(' ,')}}`,\n  order_direction: orderDirection,\n});\n\nexport const gqlMessagesByAddress = (type: GqlType) =>\n  gql(`\n${type} MyQuery($address: _text, $limit: bigint, $offset: bigint, $timestamp_from: timestamp, $types: _text, $order_direction: order_by) {\n  messages_by_address(\n    args: {addresses: $address, limit: $limit, offset: $offset, types: $types},\n    order_by: {transaction: {block: {timestamp: $order_direction}}},\n    where: {transaction: {block: {timestamp: {_gt: $timestamp_from}}}}\n    ) {\n    transaction_hash\n    index\n    value\n    transaction {\n      success\n      block {\n        timestamp,\n        height\n      }\n      memo\n    }\n    type\n  }\n}\n`);\n\nconst fetchTransactions = async ({\n  neuron,\n  timestampFrom,\n  offset = 0,\n  types = [],\n  orderDirection = 'desc',\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<TransactionsByAddressResponse>(\n    gqlMessagesByAddress('query'),\n    mapMessagesByAddressVariables({\n      neuron,\n      timestampFrom,\n      offset,\n      types,\n      orderDirection,\n      limit,\n      abortSignal,\n    })\n  );\n\n  return res?.messages_by_address;\n};\n\nexport type TransactionsByAddressResponse = {\n  messages_by_address: Transaction[];\n};\ntype MessagesCountResponse = {\n  messages_by_address_aggregate: {\n    aggregate: {\n      count: number;\n    };\n  };\n};\nconst transactionsCountByNeuron = gql(`\n  query MyQuery($address: _text, $timestamp: timestamp) {\n    messages_by_address_aggregate(\n      args: {addresses: $address, limit: \"100000000\", offset: \"0\", types: \"{}\"},\n      where: {transaction: {block: {timestamp: {_gt: $timestamp}}}}) {\n        aggregate {\n          count\n        }\n      }\n  }\n  `);\nexport const fetchTransactionMessagesCount = async (\n  address: NeuronAddress,\n  timestampFrom: number,\n  abortSignal: AbortSignal\n) => {\n  const res = await createIndexerClient(\n    abortSignal\n  ).request<MessagesCountResponse>(transactionsCountByNeuron, {\n    address: `{${address}}`,\n    timestamp: numberToUtcDate(timestampFrom),\n  });\n\n  return res?.messages_by_address_aggregate.aggregate.count;\n};\n\nexport const fetchTransactionsIterable = ({\n  neuron,\n  timestampFrom,\n  types,\n  orderDirection,\n  limit,\n  abortSignal,\n}: MessagesByAddressVariables) =>\n  fetchIterable(fetchTransactions, {\n    neuron,\n    timestampFrom,\n    types,\n    orderDirection,\n    limit,\n    abortSignal,\n  });\n","import { TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { SenseChat } from 'src/services/backend/types/sense';\nimport { NeuronAddress } from 'src/types/base';\nimport { Coin } from 'cosmjs-types/cosmos/base/v1beta1/coin';\n\nimport {\n  MSG_SEND_TRANSACTION_TYPE,\n  MSG_MULTI_SEND_TRANSACTION_TYPE,\n  MsgSendTransaction,\n} from '../../../indexer/types';\n\nexport const extractSenseChats = (\n  myAddress: NeuronAddress,\n  transactions: TransactionDto[]\n) => {\n  const sendTransactions =\n    transactions!.filter(\n      (t) =>\n        t.type === MSG_SEND_TRANSACTION_TYPE ||\n        t.type === MSG_MULTI_SEND_TRANSACTION_TYPE\n    ) || [];\n\n  if (sendTransactions.length === 0) {\n    return [];\n  }\n  const chats = new Map<NeuronAddress, SenseChat>();\n  transactions.forEach((t) => {\n    let userAddress = '';\n    if (t.type === MSG_MULTI_SEND_TRANSACTION_TYPE) {\n      const { inputs, outputs } = t.value;\n      const isSender = inputs.find((i) => i.address === myAddress);\n      const userMessages = isSender ? outputs : inputs;\n      userMessages.forEach((msg) =>\n        updateSenseChat(chats, msg.address, t, msg.coins, isSender)\n      );\n    } else if (t.type === MSG_SEND_TRANSACTION_TYPE) {\n      const { fromAddress, toAddress, amount } =\n        t.value as MsgSendTransaction['value'];\n      const isSender = fromAddress === myAddress;\n      userAddress = isSender ? toAddress : fromAddress;\n      updateSenseChat(chats, userAddress, t, amount, isSender);\n    }\n  });\n\n  return chats;\n};\n\nconst updateSenseChat = (\n  chats: Map<NeuronAddress, SenseChat>,\n  addr: string,\n  t: TransactionDto,\n  amount: Coin[],\n  isSender: boolean\n): Map<string, SenseChat> => {\n  const chat = chats.get(addr);\n  const transactions = chat?.transactions || [];\n\n  transactions.push(t);\n  chats.set(addr, {\n    userAddress: addr,\n    lastSendTimestamp: isSender ? t.timestamp : chat?.lastSendTimestamp || 0,\n    last: { amount, memo: t.memo, direction: isSender ? 'to' : 'from' },\n    transactions,\n  });\n  return chats;\n};\n","import { EntryType } from 'src/services/CozoDb/types/entities';\nimport DbApiWrapper from 'src/services/backend/services/dataSource/indexedDb/dbApiWrapper';\nimport { NeuronAddress } from 'src/types/base';\nimport {\n  SenseListItem,\n  SenseTransactionMeta,\n} from 'src/services/backend/types/sense';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport { extractSenseChats } from '../../utils/sense';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const syncMyChats = async (\n  db: DbApiWrapper,\n  myAddress: NeuronAddress,\n  timestampFrom: number,\n  signal: AbortSignal,\n  shouldUpdateTimestamp = true\n) => {\n  const syncItems = await db.findSyncStatus({\n    ownerId: myAddress,\n    entryType: EntryType.chat,\n  });\n\n  const syncItemsMap = new Map(syncItems?.map((i) => [i.id, i]));\n\n  const myTransactions = await db.getTransactions(myAddress, {\n    order: 'asc',\n    timestampFrom,\n  });\n\n  const myChats = extractSenseChats(myAddress, myTransactions!);\n\n  const results: SenseListItem[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const chat of myChats.values()) {\n    const syncItem = syncItemsMap.get(chat.userAddress);\n    const lastTransaction = chat.transactions.at(-1)!;\n\n    const { timestamp: transactionTimestamp, hash, index } = lastTransaction;\n    const syncItemHeader = {\n      entryType: EntryType.chat,\n      ownerId: myAddress,\n      meta: {\n        transactionHash: hash,\n        index,\n      } as SenseTransactionMeta,\n    };\n    // if (\n    //   chat.userAddress === 'bostrom13hepw93y8mjcew7mfra5z7ju7k6585348dnux4' ||\n    //   chat.userAddress === 'bostrom1a4krl6m7jg7ckczk94hh0wdlcezvpgwcwkrpcg'\n    // ) {\n    //   debugger;\n    // }\n    // if no sync item(first message/initial)\n    if (!syncItem) {\n      const unreadCount = chat.transactions.filter(\n        (t) => t.timestamp > chat.lastSendTimestamp\n      ).length; // uread count on top of my last send message\n\n      const newItem = {\n        ...syncItemHeader,\n        id: chat.userAddress,\n        unreadCount,\n        // if 'fast' then no shift update poiter till 'slow' reupdate\n        timestampUpdate: shouldUpdateTimestamp ? transactionTimestamp : 0,\n        timestampRead: chat.lastSendTimestamp,\n        disabled: false,\n      };\n\n      // eslint-disable-next-line no-await-in-loop\n      await throwIfAborted(db.putSyncStatus, signal)(newItem);\n\n      results.push({ ...newItem, meta: lastTransaction });\n    } else {\n      const {\n        id,\n        timestampRead,\n        timestampUpdate,\n        meta,\n        unreadCount: prevUnreadCount,\n      } = syncItem;\n\n      const lastTimestampRead = Math.max(\n        timestampRead!,\n        chat.lastSendTimestamp\n      );\n      const { timestampUpdateContent = 0, timestampUpdateChat = 0 } = meta;\n      const timestampUnreadFrom = Math.max(\n        chat.lastSendTimestamp,\n        timestampUpdateChat\n      );\n      const unreadCount =\n        prevUnreadCount +\n        chat.transactions.filter((t) => t.timestamp > timestampUnreadFrom) // + new messages count\n          .length;\n\n      if (timestampUpdate < transactionTimestamp) {\n        // if message source is 'fast' then no update till 'slow' reupdate\n        const newTimestampUpdateChat = shouldUpdateTimestamp\n          ? transactionTimestamp\n          : timestampUpdateChat;\n\n        const syncStatusChanges = {\n          ...syncItemHeader,\n          id: id!,\n          unreadCount,\n          timestampRead: lastTimestampRead,\n          // show max timestamp to use in sorting, in sense list\n          // real timestamp shold be resynced with 'slow' data source by timestampUpdateChat\n          timestampUpdate: Math.max(\n            transactionTimestamp,\n            timestampUpdateContent,\n            newTimestampUpdateChat\n          ),\n\n          meta: {\n            ...syncItemHeader.meta,\n            timestampUpdateChat: newTimestampUpdateChat,\n            timestampUpdateContent,\n          },\n        };\n\n        // eslint-disable-next-line no-await-in-loop\n        await throwIfAborted(db.updateSyncStatus, signal)(syncStatusChanges);\n\n        results.push({\n          ...syncItem,\n          ...syncStatusChanges,\n          meta: lastTransaction,\n        } as SenseListItem);\n      }\n    }\n  }\n  return results;\n};\n","import { ProgressTracking } from 'src/services/backend/types/services';\n\nconst ROLLING_WINDOW = 10;\n\ntype onProgressUpdateFunc = (progress: ProgressTracking) => void;\n\ntype RequestRecord = {\n  timestamp: number;\n  itemCount: number;\n};\n\n// eslint-disable-next-line import/no-unused-modules, import/prefer-default-export\nexport class ProgressTracker {\n  private requestRecords: RequestRecord[] = [];\n\n  private totalRequests = 0;\n\n  private completedRequests = 0;\n\n  private estimatedTime = -1;\n\n  private batchSize = 1;\n\n  private onProgressUpdate?: onProgressUpdateFunc;\n\n  public get progress(): ProgressTracking {\n    return {\n      totalCount: this.totalRequests,\n      completeCount: this.completedRequests,\n      estimatedTime: this.estimatedTime,\n    };\n  }\n\n  constructor(onProgressUpdate?: onProgressUpdateFunc) {\n    this.onProgressUpdate = onProgressUpdate;\n  }\n\n  public start(totalRequests: number, batchSize = 1) {\n    this.totalRequests = totalRequests;\n    this.requestRecords = [];\n    this.completedRequests = 0;\n    this.estimatedTime = -1;\n    this.batchSize = batchSize;\n\n    return this.progress;\n  }\n\n  public add(extraRequests: number) {\n    this.totalRequests += extraRequests;\n\n    return this.progress;\n  }\n\n  public trackProgress(processedCount: number) {\n    this.addRequestRecord(processedCount);\n\n    if (this.requestRecords.length > ROLLING_WINDOW) {\n      this.requestRecords.shift();\n    }\n\n    if (this.requestRecords.length > 1) {\n      const averageTimePerItem = this.calculateAverageTimePerItem();\n      const remainingRequests = this.totalRequests - this.completedRequests;\n      const estimatedRemainingItems = remainingRequests * processedCount; // Assuming remaining requests will process the same number of items\n      const estimatedRemainingTime =\n        averageTimePerItem * estimatedRemainingItems;\n\n      this.completedRequests += processedCount;\n      this.estimatedTime = Math.round(estimatedRemainingTime); // Convert to seconds;\n      this.onProgressUpdate && this.onProgressUpdate(this.progress);\n    }\n\n    return this.progress;\n  }\n\n  private addRequestRecord(itemCount: number) {\n    this.requestRecords.push({ timestamp: Date.now(), itemCount });\n  }\n\n  private calculateAverageTimePerItem(): number {\n    let totalDiff = 0;\n    let totalItems = 0;\n\n    for (let i = 1; i < this.requestRecords.length; i++) {\n      const timeDiff =\n        this.requestRecords[i].timestamp - this.requestRecords[i - 1].timestamp;\n      const { itemCount } = this.requestRecords[i];\n\n      totalDiff += timeDiff * itemCount;\n      totalItems += itemCount;\n    }\n\n    return totalItems === 0 ? 0 : totalDiff / totalItems;\n  }\n}\n","import {\n  Observable,\n  filter,\n  distinctUntilChanged,\n  map,\n  switchMap,\n  take,\n  tap,\n} from 'rxjs';\n\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { broadcastStatus } from 'src/services/backend/channels/broadcastStatus';\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { CyblogChannel, createCyblogChannel } from 'src/utils/logging/cyblog';\n\nimport DbApiWrapper from '../../../dataSource/indexedDb/dbApiWrapper';\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ProgressTracker } from '../ProgressTracker/ProgressTracker';\nimport { ServiceDeps } from '../types';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSync {\n  protected name: string;\n\n  protected abortController: AbortController;\n\n  protected db: DbApiWrapper | undefined;\n\n  protected progressTracker = new ProgressTracker();\n\n  protected channelApi = new BroadcastChannelSender();\n\n  protected particlesResolver: ParticlesResolverQueue | undefined;\n\n  protected statusApi: ReturnType<typeof broadcastStatus>;\n\n  protected params: SyncServiceParams = {\n    myAddress: null,\n  };\n\n  protected readonly isInitialized$: Observable<boolean>;\n\n  protected cyblogCh: CyblogChannel;\n\n  constructor(\n    name: SyncEntryName,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue\n  ) {\n    this.name = name;\n\n    this.abortController = new AbortController();\n\n    this.statusApi = broadcastStatus(name, this.channelApi);\n    this.particlesResolver = particlesResolver;\n    this.cyblogCh = createCyblogChannel({ thread: 'bckd', module: name });\n    if (!deps.params$) {\n      throw new Error('params$ is not defined');\n    }\n\n    deps.dbInstance$.subscribe((db) => {\n      this.db = db;\n    });\n\n    this.particlesResolver = particlesResolver;\n\n    this.isInitialized$ = this.createIsInitializedObserver(deps);\n\n    this.isInitialized$.subscribe((isInitialized) => {\n      this.cyblogCh.info(\n        `>>> ${this.name} - ${isInitialized ? 'initialized' : 'inactive'}`\n      );\n      this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n    });\n\n    this.isInitialized$\n      .pipe(switchMap(() => deps.params$!))\n      .subscribe((params) => {\n        this.params = params;\n        this.cyblogCh.info(`>>> ${this.name} - params updated`, {\n          data: params,\n        });\n      });\n\n    // Restart observer\n    this.isInitialized$\n      .pipe(\n        filter((isInitialized) => !!isInitialized),\n        switchMap(() => this.createRestartObserver(deps.params$!))\n      )\n      .subscribe(() => {\n        this.restart();\n      });\n  }\n\n  protected initAbortController() {\n    this.abortController = new AbortController();\n  }\n\n  protected abstract createIsInitializedObserver(\n    deps: ServiceDeps\n  ): Observable<boolean>;\n\n  // eslint-disable-next-line class-methods-use-this\n  protected createRestartObserver(params$: Observable<SyncServiceParams>) {\n    return params$.pipe(\n      map((params) => params.myAddress),\n      distinctUntilChanged((addrBefore, addrAfter) => addrBefore === addrAfter),\n      map((v) => !!v),\n      filter((v) => !!v)\n    );\n  }\n\n  public abstract restart(): void;\n\n  public abstract start(): void;\n}\n\nexport default BaseSync;\n","/* eslint-disable import/prefer-default-export */\nimport {\n  distinctUntilChanged,\n  filter,\n  Observable,\n  share,\n  switchMap,\n  tap,\n} from 'rxjs';\n\nexport const switchWhenInitialized = (\n  isInitialized$: Observable<boolean>,\n  actionObservable$: Observable<any>,\n  onChange?: (isInitialized: boolean) => void\n) =>\n  isInitialized$.pipe(\n    distinctUntilChanged(),\n    tap((isInitialized) => onChange?.(isInitialized)),\n    filter((initialized) => initialized),\n    switchMap(() => actionObservable$),\n    share()\n  );\n","import { Observable, Subject, from, startWith, switchMap, tap } from 'rxjs';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ServiceDeps } from '../types';\nimport BaseSync from './BaseSync';\nimport { switchWhenInitialized } from '../utils/rxjs/withInitializer';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSyncClient extends BaseSync {\n  protected readonly source$: Observable<any>;\n\n  protected readonly reloadTrigger$ = new Subject<void>();\n\n  constructor(\n    name: SyncEntryName,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue\n  ) {\n    super(name, deps, particlesResolver);\n\n    const source$ = switchWhenInitialized(\n      this.isInitialized$!,\n      this.reloadTrigger$.pipe(\n        startWith(null),\n        tap(() => {\n          // initialize abort conteoller for restart strategy\n          this.initAbortController();\n        }),\n        switchMap(() =>\n          this.createInitObservable().pipe(\n            switchMap((timestampFrom: number) =>\n              this.createClientObservable(timestampFrom).pipe(\n                tap(() => this.statusApi.sendStatus('listen')),\n                switchMap((data) => from(this.onUpdate(data, this.params)))\n              )\n            )\n          )\n        )\n      ),\n      (isInitialized) => {\n        console.log(`>>> ${name} isInitialized`, isInitialized);\n        this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n      }\n    );\n\n    source$.subscribe({\n      next: () => {\n        this.statusApi.sendStatus('listen');\n      },\n      error: (err) => {\n        this.statusApi.sendStatus('error', err);\n      },\n    });\n    this.source$ = source$;\n  }\n\n  protected abstract createClientObservable(\n    timestampFrom: number\n  ): Observable<any>;\n\n  protected abstract createInitObservable(): Observable<number>;\n\n  public restart() {\n    this.abortController?.abort();\n    this.reloadTrigger$.next();\n    console.log(`>>> ${this.name} client restart`);\n  }\n\n  protected abstract onUpdate(\n    data: any,\n    params: SyncServiceParams\n  ): Promise<void>;\n\n  public start() {\n    this.source$.subscribe(() => {\n      // dummy subscriber to keep pipeline running - don't remove\n    });\n    return this;\n  }\n}\n\nexport default BaseSyncClient;\n","/* eslint-disable camelcase */\nimport {\n  map,\n  combineLatest,\n  Observable,\n  from,\n  defer,\n  distinctUntilChanged,\n  merge,\n  filter,\n} from 'rxjs';\nimport { isEmpty } from 'lodash';\n\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport { mapIndexerTransactionToEntity } from 'src/services/CozoDb/mapping';\nimport { numberToUtcDate } from 'src/utils/date';\nimport { NeuronAddress } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { SyncStatusDto, TransactionDto } from 'src/services/CozoDb/types/dto';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport {\n  createNodeWebsocketObservable,\n  getIncomingTransfersQuery,\n} from 'src/services/blockchain/websocket';\nimport { mapWebsocketTxToTransactions } from 'src/services/blockchain/utils/mapping';\n\nimport { ServiceDeps } from '../types';\nimport { extractCybelinksFromTransaction } from '../utils/links';\n\nimport {\n  fetchTransactionsIterable,\n  mapMessagesByAddressVariables,\n  fetchTransactionMessagesCount,\n  gqlMessagesByAddress,\n  TransactionsByAddressResponse,\n} from '../../../indexer/transactions';\nimport { syncMyChats } from './services/chat';\nimport { TRANSACTIONS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncClient from '../BaseSyncLoop/BaseSyncClient';\nimport { createIndexerWebsocket } from '../../../indexer/utils';\nimport { SyncServiceParams } from '../../types';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\n\ntype DataStreamResult = {\n  source: 'indexer' | 'node';\n  transactions: TransactionDto[];\n};\n\nclass SyncTransactionsLoop extends BaseSyncClient {\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.params$!.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      ),\n      this.particlesResolver!.isInitialized$,\n    ]).pipe(\n      map(\n        ([dbInstance, myAddress, syncQueueInitialized]) =>\n          !!dbInstance && !!syncQueueInitialized && !!myAddress\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected createClientObservable(\n    timestampFrom: number\n  ): Observable<DataStreamResult> {\n    const { myAddress } = this.params;\n    this.cyblogCh.info(\n      `>>> ${this.name} subscribe ${myAddress} from ${numberToUtcDate(\n        timestampFrom\n      )}`\n    );\n\n    const variables = mapMessagesByAddressVariables({\n      neuron: myAddress!,\n      timestampFrom,\n      types: [],\n      orderDirection: 'desc',\n      limit: 100,\n    });\n\n    const indexerObservable$ =\n      createIndexerWebsocket<TransactionsByAddressResponse>(\n        gqlMessagesByAddress('subscription'),\n        variables\n      ).pipe(\n        map((response: TransactionsByAddressResponse) => {\n          return {\n            source: 'indexer',\n            transactions: response.messages_by_address.map((i) =>\n              mapIndexerTransactionToEntity(myAddress!, i)\n            ),\n          };\n        })\n      );\n\n    const nodeObservample$ = createNodeWebsocketObservable(\n      myAddress!,\n      getIncomingTransfersQuery(myAddress!),\n      (message, ctx) => this.cyblogCh.info(message, { unit: 'node-ws', ...ctx })\n    ).pipe(\n      filter((data) => !isEmpty(data)),\n      map((data) => {\n        return {\n          source: 'node',\n          transactions: mapWebsocketTxToTransactions(myAddress!, data),\n        };\n      })\n    );\n\n    return merge(\n      indexerObservable$,\n      nodeObservample$\n    ) as Observable<DataStreamResult>;\n  }\n\n  protected createInitObservable() {\n    return defer(() => from(this.initSync()));\n    // return from(this.initSync());\n  }\n\n  public async initSync() {\n    const { myAddress } = this.params;\n    const { signal } = this.abortController;\n    const syncItem = await this.db!.getSyncStatus(myAddress!, myAddress!);\n\n    const lastTransactionTimestamp = await this.syncTransactions(\n      myAddress!,\n      myAddress!,\n      syncItem\n    );\n\n    this.statusApi.sendStatus('in-progress', `sync my chats`);\n    const syncStatusItems = await syncMyChats(\n      this.db!,\n      myAddress!,\n      syncItem.timestampUpdate,\n      signal\n    );\n\n    this.channelApi.postSenseUpdate(syncStatusItems);\n    this.statusApi.sendStatus('active');\n\n    return lastTransactionTimestamp;\n  }\n\n  protected async onUpdate(\n    { source, transactions }: DataStreamResult,\n    params: SyncServiceParams\n  ) {\n    const { myAddress } = params;\n    const { signal } = this.abortController;\n    if (transactions.length === 0) {\n      this.cyblogCh.info(`>>> ${this.name} ${myAddress} recived 0 updates `);\n      return;\n    }\n    const syncItem = await this.db!.getSyncStatus(myAddress!, myAddress!);\n\n    await this.processBatchTransactions(\n      myAddress!,\n      myAddress!,\n      transactions,\n      syncItem,\n      source\n    );\n\n    this.statusApi.sendStatus('in-progress', `sync my chats`);\n    const syncStatusItems = await syncMyChats(\n      this.db!,\n      myAddress!,\n      syncItem.timestampUpdate,\n      signal,\n      source !== 'node'\n    );\n\n    this.channelApi.postSenseUpdate(syncStatusItems);\n    this.statusApi.sendStatus('listen');\n  }\n\n  public async processBatchTransactions(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    transactions: TransactionDto[],\n    { timestampRead, unreadCount, timestampUpdate }: SyncStatusDto,\n    source: DataStreamResult['source']\n  ) {\n    const { signal } = this.abortController;\n\n    // node transaction is limited by incoming messages,\n    // to prevent missing of other msg types let's avoid to change ts\n    const shouldUpdateTimestamp = source !== 'node';\n\n    this.cyblogCh.info('--------syncTransactions batch ', {\n      data: [\n        myAddress,\n        address,\n        transactions.length,\n        transactions.at(0)?.timestamp,\n        transactions.at(-1)?.timestamp,\n        source,\n      ],\n    });\n\n    // save transaction\n    await throwIfAborted(this.db!.putTransactions, signal)(transactions);\n\n    // save links\n    this.syncLinks(transactions, signal);\n\n    const {\n      hash,\n      index,\n\n      timestamp,\n    } = transactions.at(-1)!;\n\n    const lastTimestampFrom = timestamp;\n\n    // Update transaction sync items\n    const newSyncItem = {\n      ownerId: myAddress,\n      entryType: EntryType.transactions,\n      id: address,\n      timestampUpdate: shouldUpdateTimestamp\n        ? lastTimestampFrom\n        : timestampUpdate!,\n      unreadCount: unreadCount! + transactions.length,\n      timestampRead: timestampRead || 0,\n      disabled: false,\n      meta: {\n        transactionHash: hash,\n        index,\n      },\n    };\n\n    await throwIfAborted(this.db!.putSyncStatus, signal)(newSyncItem);\n\n    return lastTimestampFrom;\n  }\n\n  public async syncTransactions(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    syncItem: SyncStatusDto\n  ) {\n    const { unreadCount, timestampUpdate } = syncItem;\n    const timestampFrom = timestampUpdate + 1; // ofsset + 1 to fix milliseconds precision bug\n\n    this.statusApi.sendStatus('estimating');\n\n    const totalMessageCount = await fetchTransactionMessagesCount(\n      address,\n      timestampFrom,\n      this.abortController!.signal\n    );\n\n    this.cyblogCh.info(\n      `>>> syncTransactions - start ${address},  count: ${totalMessageCount}, from: ${timestampFrom}`\n    );\n\n    if (totalMessageCount === 0) {\n      return timestampFrom;\n    }\n\n    this.statusApi.sendStatus(\n      'in-progress',\n      `sync ${address}...`,\n      this.progressTracker.start(\n        Math.ceil(totalMessageCount / TRANSACTIONS_BATCH_LIMIT)\n      )\n    );\n\n    const transactionsAsyncIterable = fetchTransactionsIterable({\n      neuron: address,\n      timestampFrom,\n      types: [], // SENSE_TRANSACTIONS,\n      orderDirection: 'asc',\n      limit: TRANSACTIONS_BATCH_LIMIT,\n      abortSignal: this.abortController?.signal,\n    });\n\n    let transactionCount = 0;\n    let lastTimestampFrom = timestampFrom;\n\n    // eslint-disable-next-line no-restricted-syntax\n    for await (const batch of transactionsAsyncIterable) {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `sync ${address}...`,\n        this.progressTracker.trackProgress(1)\n      );\n\n      transactionCount += batch.length;\n\n      const transactions = batch.map((i) =>\n        mapIndexerTransactionToEntity(address, i)\n      );\n\n      lastTimestampFrom = await this.processBatchTransactions(\n        myAddress,\n        address,\n        transactions,\n        {\n          ...syncItem,\n          unreadCount: unreadCount + transactionCount,\n        },\n        'indexer'\n      );\n    }\n\n    return lastTimestampFrom;\n  }\n\n  private async syncLinks(batch: TransactionDto[], signal: AbortSignal) {\n    const { tweets, particlesFound, links } =\n      extractCybelinksFromTransaction(batch);\n    if (links.length > 0) {\n      await asyncIterableBatchProcessor(\n        links,\n        (links) => throwIfAborted(this.db!.putCyberlinks, signal)(links),\n        MAX_DATABASE_PUT_SIZE\n      );\n    }\n\n    const tweetParticles = Object.keys(tweets);\n\n    const nonTweetParticles = particlesFound.filter(\n      (cid) => !tweetParticles.includes(cid)\n    );\n\n    // pre-resolve 'tweets' particles\n    await this.particlesResolver!.enqueueBatch(\n      tweetParticles,\n      QueuePriority.HIGH\n    );\n\n    // pre-resolve all the rest particles\n    if (nonTweetParticles.length > 0) {\n      await this.particlesResolver!.enqueueBatch(\n        nonTweetParticles,\n        QueuePriority.LOW\n      );\n    }\n  }\n}\n\nexport default SyncTransactionsLoop;\n","import { Observable } from 'rxjs';\nimport { CYBER_NODE_URL_WS } from 'src/constants/config';\nimport { NeuronAddress } from 'src/types/base';\nimport { LogFunc } from 'src/utils/logging/cyblog';\n\nexport const getIncomingTransfersQuery = (address: NeuronAddress) =>\n  `tm.event='Tx' AND transfer.recipient='${address}'`;\n\n// eslint-disable-next-line import/no-unused-modules\nexport function createNodeWebsocketObservable(\n  address: NeuronAddress,\n  query: string,\n  log: LogFunc\n) {\n  return new Observable((subscriber) => {\n    const ws = new WebSocket(CYBER_NODE_URL_WS);\n\n    ws.onopen = () => {\n      log(`node ws connected to ${CYBER_NODE_URL_WS} with ${query}`);\n      ws.send(\n        JSON.stringify({\n          jsonrpc: '2.0',\n          method: 'subscribe',\n          id: '0',\n          params: { query },\n        })\n      );\n    };\n\n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      log(`node ws ${address} onmessage`, message);\n      subscriber.next(message.result);\n    };\n\n    ws.onerror = (event) => {\n      log(`node ws ${address} error`, { error: event });\n      subscriber.error(event);\n    };\n\n    ws.onclose = () => {\n      log(`node ws ${address} closed`);\n      subscriber.complete();\n    };\n\n    return () => {\n      ws.close();\n    };\n  });\n}\n","import { EntityToDto, DtoToEntity } from 'src/types/dto';\n\nexport const snakeToCamel = (str: string) =>\n  str.replace(/([-_][a-z])/g, (group) =>\n    group.toUpperCase().replace('-', '').replace('_', '')\n  );\n\nexport const camelToSnake = (str: string) =>\n  str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n// Function to transform a DB entity to a DTO\n\n// eslint-disable-next-line import/no-unused-modules\nexport function entityToDto<T extends Record<string, any>>(\n  dbEntity: T\n): EntityToDto<T> {\n  if (!dbEntity || typeof dbEntity !== 'object') {\n    return dbEntity;\n  }\n  const dto: Record<string, any> = {}; // Specify the type for dto\n  Object.keys(dbEntity).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(dbEntity, key)) {\n      const camelCaseKey = snakeToCamel(key);\n      let value = dbEntity[key];\n      if (Array.isArray(dbEntity[key])) {\n        value = dbEntity[key].map((item) => entityToDto(item));\n      } else if (typeof dbEntity[key] === 'object') {\n        value = entityToDto(dbEntity[key]);\n      }\n      dto[camelCaseKey] = value;\n    }\n  });\n  return dto as EntityToDto<T>;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport function dtoToEntity<T extends Record<string, any>>(\n  dto: T\n): DtoToEntity<T> {\n  // in case of recursive calls\n  if (!dto || typeof dto !== 'object') {\n    return dto;\n  }\n  const dbEntity: any = {};\n\n  Object.keys(dto).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(dto, key)) {\n      const snakeCaseKey = camelToSnake(key);\n      let value = dto[key];\n      if (Array.isArray(dto[key])) {\n        value = dto[key].map((item) => dtoToEntity(item));\n      } else if (typeof dto[key] === 'object') {\n        value = dtoToEntity(dto[key]);\n      }\n      dbEntity[snakeCaseKey] = value;\n    }\n  });\n  return dbEntity as DtoToEntity<T>; // Replace T with the appropriate DB Entity type if known\n}\n\nexport function dtoListToEntity<T extends Record<string, any>>(\n  array: T[]\n): DtoToEntity<T>[] {\n  return array.map((dto) => dtoToEntity(dto));\n}\n\nexport function entityListToDto<T extends Record<string, any>>(\n  array: T[]\n): EntityToDto<T>[] {\n  return array.map((dto) => entityToDto(dto));\n}\n\nexport function removeUndefinedFields(entity: Record<string, any>) {\n  Object.keys(entity).forEach((key) => {\n    if (entity[key] === undefined) {\n      delete entity[key];\n    }\n  });\n  return entity;\n}\n","import { dateToUtcNumber } from 'src/utils/date';\n\nimport { NeuronAddress, ParticleCid } from 'src/types/base';\nimport { SyncStatusDto } from 'src/services/CozoDb/types/dto';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\n\nimport { CyberlinksByParticleResponse } from '../dataSource/blockchain/indexer';\nimport { findLastIndex } from 'lodash';\nimport { SenseItemLinkMeta } from '../../types/sense';\nimport { entityToDto } from 'src/utils/dto';\nimport { SyncEntryName } from '../../types/services';\n\nexport function extractLinkData(\n  cid: ParticleCid,\n  links: CyberlinksByParticleResponse['cyberlinks']\n) {\n  return {\n    lastLink: links[0],\n    count: links.length,\n    lastTimestamp: dateToUtcNumber(links[0].timestamp),\n    firstTimestamp: dateToUtcNumber(links[links.length - 1].timestamp),\n  };\n}\n\nexport function getLastReadInfo(\n  links: CyberlinksByParticleResponse['cyberlinks'],\n  ownerId: NeuronAddress,\n  prevTimestampRead = 0,\n  prevUnreadCount = 0\n) {\n  const lastMyLinkIndex = findLastIndex(\n    links,\n    (link) =>\n      link.neuron === ownerId &&\n      dateToUtcNumber(link.timestamp) > prevTimestampRead\n  );\n\n  const unreadCount =\n    lastMyLinkIndex < 0\n      ? prevUnreadCount || 0\n      : links.length - lastMyLinkIndex - 1;\n\n  const timestampRead =\n    lastMyLinkIndex < 0\n      ? prevTimestampRead\n      : dateToUtcNumber(links[lastMyLinkIndex].timestamp);\n\n  return {\n    timestampRead,\n    unreadCount,\n  };\n}\n\nexport function changeSyncStatus(\n  statusEntity: Partial<SyncStatusDto>,\n  links: CyberlinksByParticleResponse['cyberlinks'],\n  ownerId: NeuronAddress\n) {\n  const timestampUpdate = dateToUtcNumber(links[0].timestamp);\n  const { timestampRead, unreadCount } = getLastReadInfo(\n    links,\n    ownerId,\n    statusEntity.timestampRead,\n    statusEntity.unreadCount\n  );\n\n  const lastLink = entityToDto(links[0]);\n\n  return {\n    ...statusEntity,\n    ownerId,\n    entryType: EntryType.particle,\n    disabled: false,\n    unreadCount,\n    meta: {\n      ...lastLink,\n      timestamp: timestampUpdate,\n    } as SenseItemLinkMeta,\n    timestampRead,\n    timestampUpdate,\n  } as SyncStatusDto;\n}\n\nconst mapSyncEntryReadable: Record<SyncEntryName, string> = {\n  'my-friends': \"friend's logs\",\n  particles: 'log cyberlinks',\n  resolver: 'particles',\n  transactions: 'transactions',\n};\nexport const syncEntryNameToReadable = (name: SyncEntryName) =>\n  mapSyncEntryReadable[name] || name;\n","export const isAbortException = (e: Error) =>\n  e instanceof DOMException && e.name === 'AbortError';\n","import { Observable, defer, filter, from, tap } from 'rxjs';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { isAbortException } from 'src/utils/exceptions/helpers';\nimport { clone } from 'ramda';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { ServiceDeps } from '../types';\nimport { createLoopObservable } from '../utils/rxjs/loop';\nimport BaseSync from './BaseSync';\nimport { SyncServiceParams } from '../../types';\n\nabstract class BaseSyncLoop extends BaseSync {\n  private restartLoop: (() => void) | undefined;\n\n  public readonly loop$: Observable<boolean>;\n\n  constructor(\n    name: SyncEntryName,\n    intervalMs: number,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue,\n    {\n      warmupMs,\n    }: {\n      warmupMs: number;\n    } = { warmupMs: 0 }\n  ) {\n    super(name, deps, particlesResolver);\n\n    const { loop$, restartLoop } = createLoopObservable(\n      this.isInitialized$,\n      // defer(() => from(this.sync())),\n      defer(() => from(this.doSync())),\n      {\n        intervalMs,\n        warmupMs,\n        // onStartInterval: () => this.initAbortController(),\n        onError: (error) => {\n          this.cyblogCh.info(`>>> ${name} error`, error.toString());\n          this.statusApi.sendStatus('error', error.toString());\n        },\n        onChange: (isInitialized) => {\n          this.cyblogCh.info(`>>> ${name} initialized: ${isInitialized}`);\n          this.statusApi.sendStatus(isInitialized ? 'initialized' : 'inactive');\n        },\n      }\n    );\n\n    this.loop$ = loop$;\n    this.restartLoop = restartLoop;\n  }\n\n  public restart() {\n    this.abortController?.abort();\n    this.restartLoop?.();\n    this.cyblogCh.info(`>>> ${this.name} loop restart`);\n  }\n\n  public start() {\n    this.loop$.subscribe(() => this.statusApi.sendStatus('active'));\n    return this;\n  }\n\n  private async doSync() {\n    const params = clone(this.params);\n    this.initAbortController();\n    try {\n      await this.sync(params);\n    } catch (e) {\n      const isAborted = isAbortException(e);\n      this.cyblogCh.info(\n        `>>> ${this.name} ${params.myAddress} sync error [abrt:${isAborted}]:`,\n        {\n          error: e,\n        }\n      );\n\n      if (!isAborted) {\n        throw e;\n      }\n    }\n  }\n\n  protected abstract sync(params: SyncServiceParams): Promise<void>;\n}\n\nexport default BaseSyncLoop;\n","/* eslint-disable import/prefer-default-export */\nimport {\n  Observable,\n  switchMap,\n  interval,\n  startWith,\n  tap,\n  retry,\n  delay,\n  exhaustMap,\n  Subject,\n} from 'rxjs';\nimport { switchWhenInitialized } from './withInitializer';\n\ntype LoopObservableOptions = {\n  warmupMs?: number;\n  retryDelayMs?: number;\n  onStartInterval?: () => void;\n  onError?: (error: any) => void;\n  onChange?: (isInitialized: boolean) => void;\n  intervalMs?: number;\n};\n\nexport const createLoopObservable = (\n  isInitialized$: Observable<boolean>,\n  actionObservable$: Observable<any>,\n  options: LoopObservableOptions = {}\n) => {\n  const {\n    intervalMs,\n    warmupMs = 0,\n    onStartInterval,\n    onError,\n    retryDelayMs = 0,\n    onChange,\n  } = options;\n\n  const restartTrigger$ = new Subject<void>();\n\n  const intervalOrRestart$ = restartTrigger$.pipe(\n    startWith(null),\n    switchMap(() => interval(intervalMs).pipe(startWith(0), delay(warmupMs)))\n  );\n\n  const source$ = switchWhenInitialized(\n    isInitialized$,\n    intervalOrRestart$.pipe(\n      tap(() => onStartInterval && onStartInterval()),\n      exhaustMap(() =>\n        actionObservable$.pipe(\n          retry({\n            delay: (error) => {\n              console.log('retry', error);\n              onError && onError(error);\n              return interval(retryDelayMs);\n            },\n          })\n        )\n      )\n    ),\n    (isInitialized) => onChange?.(isInitialized)\n  );\n\n  return {\n    loop$: source$,\n    restartLoop: () => {\n      // console.log('>>> createLoopObservable restart');\n      // Trigger a restart by emitting a new value\n      restartTrigger$.next();\n    },\n  };\n};\n","import { map, combineLatest, distinctUntilChanged } from 'rxjs';\nimport { EntryType } from 'src/services/CozoDb/types/entities';\nimport { SyncStatusDto } from 'src/services/CozoDb/types/dto';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { NeuronAddress } from 'src/types/base';\n\nimport { mapLinkFromIndexerToDbEntity } from 'src/services/CozoDb/mapping';\nimport { CID_TWEET } from 'src/constants/app';\nimport { dateToUtcNumber } from 'src/utils/date';\nimport { SenseListItem } from 'src/services/backend/types/sense';\nimport { asyncIterableBatchProcessor } from 'src/utils/async/iterable';\nimport { throwIfAborted } from 'src/utils/async/promise';\nimport { entityToDto } from 'src/utils/dto';\n\nimport { ServiceDeps } from '../types';\nimport { fetchCyberlinksAndResolveParticles } from '../utils/links';\n\nimport { changeSyncStatus } from '../../utils';\nimport {\n  fetchCyberlinksByNerounIterable,\n  fetchCyberlinksCount,\n} from '../../../dataSource/blockchain/indexer';\nimport { CYBERLINKS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncLoop from '../BaseSyncLoop/BaseSyncLoop';\nimport { MAX_DATABASE_PUT_SIZE } from '../consts';\nimport { SyncServiceParams } from '../../types';\n\nclass SyncParticlesLoop extends BaseSyncLoop {\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.ipfsInstance$,\n      deps.params$!.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      ),\n      this.particlesResolver!.isInitialized$,\n    ]).pipe(\n      map(\n        ([dbInstance, ipfsInstance, myAddress, particleResolverInitialized]) =>\n          !!ipfsInstance &&\n          !!dbInstance &&\n          !!particleResolverInitialized &&\n          !!myAddress\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  protected async sync(params: SyncServiceParams): Promise<void> {\n    const { myAddress } = params;\n    const { signal } = this.abortController;\n    this.statusApi.sendStatus('estimating');\n\n    const syncItemParticles = await this.db!.findSyncStatus({\n      ownerId: myAddress!,\n      entryType: EntryType.particle,\n    });\n\n    const timestampUpdate = syncItemParticles.at(0)?.timestampUpdate || 0;\n\n    // Get count of new links after last update\n    const newLinkCount = await fetchCyberlinksCount(\n      myAddress!,\n      [CID_TWEET],\n      timestampUpdate,\n      signal\n    );\n\n    this.cyblogCh.info(\n      `>>> syncMyParticles ${myAddress} count ${newLinkCount}`\n    );\n    this.progressTracker.start(newLinkCount + syncItemParticles.length);\n    this.statusApi.sendStatus(\n      'in-progress',\n      'preparing...',\n      this.progressTracker.progress\n    );\n\n    if (newLinkCount > 0) {\n      // fetch and save new particles\n      const newSyncItemParticles = await this.fetchNewTweets(\n        myAddress!,\n        timestampUpdate,\n        signal\n      );\n\n      // add to fetch-sync linked particles\n      syncItemParticles.push(...newSyncItemParticles);\n    }\n    await this.syncParticles(myAddress!, syncItemParticles, signal);\n  }\n\n  private async fetchNewTweets(\n    myAddress: NeuronAddress,\n    timestampUpdate: number,\n    signal: AbortSignal\n  ) {\n    const tweetsAsyncIterable = await fetchCyberlinksByNerounIterable(\n      myAddress,\n      [CID_TWEET],\n      timestampUpdate,\n      CYBERLINKS_BATCH_LIMIT,\n      this.abortController?.signal\n    );\n\n    const newTweets: SyncStatusDto[] = [];\n    // eslint-disable-next-line no-await-in-loop, no-restricted-syntax\n    for await (const tweetsBatch of tweetsAsyncIterable) {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `fetching new tweets...`,\n        this.progressTracker.trackProgress(1)\n      );\n      const syncStatusEntities = tweetsBatch.map(entityToDto).map((item) => {\n        const { timestamp, to } = item;\n        const timestampUpdate = dateToUtcNumber(timestamp);\n\n        // Initial state\n        return {\n          ownerId: myAddress,\n          id: to,\n          entryType: EntryType.particle,\n          timestampUpdate,\n          timestampRead: timestampUpdate,\n          unreadCount: 0,\n          disabled: false,\n          meta: { ...item, timestamp: timestampUpdate },\n        } as SyncStatusDto;\n      });\n\n      if (syncStatusEntities.length > 0) {\n        await throwIfAborted(\n          this.db!.putSyncStatus,\n          signal\n        )(syncStatusEntities);\n        newTweets.push(...syncStatusEntities);\n      }\n    }\n\n    return newTweets;\n  }\n\n  private async syncParticles(\n    myAddress: NeuronAddress,\n    syncItems: SyncStatusDto[],\n    signal: AbortSignal\n  ) {\n    const updatedSyncItems: SyncStatusDto[] = [];\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const syncItem of syncItems) {\n      const { id, timestampUpdate } = syncItem;\n\n      this.statusApi.sendStatus(\n        'in-progress',\n        `fetching tweet updates...`,\n        this.progressTracker.trackProgress(1)\n      );\n\n      // eslint-disable-next-line no-await-in-loop\n      const links = await fetchCyberlinksAndResolveParticles(\n        id,\n        timestampUpdate,\n        this.particlesResolver!,\n        QueuePriority.MEDIUM,\n        this.abortController?.signal\n      );\n\n      if (links.length > 0) {\n        // save links\n        // eslint-disable-next-line no-await-in-loop\n        await asyncIterableBatchProcessor(\n          links,\n          (links) =>\n            throwIfAborted(\n              this.db!.putCyberlinks,\n              signal\n            )(links.map(mapLinkFromIndexerToDbEntity)),\n          MAX_DATABASE_PUT_SIZE\n        );\n\n        const newItem = changeSyncStatus(syncItem, links, myAddress);\n\n        updatedSyncItems.push(newItem);\n      }\n    }\n\n    if (updatedSyncItems.length > 0) {\n      await throwIfAborted(this.db!.putSyncStatus, signal)(updatedSyncItems);\n    }\n    this.channelApi.postSenseUpdate(updatedSyncItems as SenseListItem[]);\n  }\n}\n\nexport default SyncParticlesLoop;\n","/* eslint-disable camelcase */\nimport {\n  map,\n  combineLatest,\n  distinctUntilChanged,\n  BehaviorSubject,\n} from 'rxjs';\n\nimport { EntryType } from 'src/services/CozoDb/types/entities';\n\nimport { NeuronAddress } from 'src/types/base';\nimport { QueuePriority } from 'src/services/QueueManager/types';\nimport { isAbortException } from 'src/utils/exceptions/helpers';\n\nimport { mapLinkFromIndexerToDbEntity } from 'src/services/CozoDb/mapping';\nimport { throwIfAborted } from 'src/utils/async/promise';\n\nimport { SyncEntryName } from 'src/services/backend/types/services';\nimport { SenseItemLinkMeta } from 'src/services/backend/types/sense';\nimport { entityToDto } from 'src/utils/dto';\nimport { ServiceDeps } from '../types';\n\nimport { fetchCyberlinksByNerounIterable } from '../../../dataSource/blockchain/indexer';\nimport { CYBERLINKS_BATCH_LIMIT } from '../../../dataSource/blockchain/consts';\nimport BaseSyncLoop from '../BaseSyncLoop/BaseSyncLoop';\nimport { SyncServiceParams } from '../../types';\nimport { getLastReadInfo } from '../../utils';\n\nimport ParticlesResolverQueue from '../ParticlesResolverQueue/ParticlesResolverQueue';\nimport { SENSE_FRIEND_PARTICLES } from '../consts';\n\nclass SyncMyFriendsLoop extends BaseSyncLoop {\n  protected followings: NeuronAddress[] = [];\n\n  constructor(\n    name: SyncEntryName,\n    intervalMs: number,\n    deps: ServiceDeps,\n    particlesResolver: ParticlesResolverQueue,\n    { warmupMs }: { warmupMs: number } = { warmupMs: 0 }\n  ) {\n    if (!deps.followings$) {\n      throw new Error('followings$ is required');\n    }\n\n    super(name, intervalMs, deps, particlesResolver, {\n      warmupMs,\n    });\n  }\n\n  protected createIsInitializedObserver(deps: ServiceDeps) {\n    const followingsInitialized$ = new BehaviorSubject<boolean>(false);\n    deps.params$\n      ?.pipe(\n        map((params) => params.myAddress),\n        distinctUntilChanged()\n      )\n      .subscribe(() => {\n        followingsInitialized$.next(false);\n      });\n\n    deps.followings$!.subscribe((followings) => {\n      this.followings = followings;\n      followingsInitialized$.next(true);\n\n      this.restart();\n    });\n\n    const isInitialized$ = combineLatest([\n      deps.dbInstance$,\n      deps.params$!,\n      this.particlesResolver!.isInitialized$,\n      followingsInitialized$!,\n    ]).pipe(\n      map(\n        ([dbInstance, params, syncQueueInitialized, followingsInitialized]) =>\n          !!dbInstance &&\n          !!params.myAddress &&\n          !!syncQueueInitialized &&\n          followingsInitialized\n      )\n    );\n\n    return isInitialized$;\n  }\n\n  protected async sync(params: SyncServiceParams) {\n    const { signal } = this.abortController;\n\n    this.statusApi.sendStatus('in-progress', 'preparing...');\n    const { myAddress } = params;\n\n    const { followings } = this;\n\n    this.statusApi.sendStatus('estimating');\n\n    this.cyblogCh.info(\n      `>>> syncMyFriends ${myAddress} count ${followings.length}`,\n      {\n        unit: 'friends-sync',\n        data: followings,\n      }\n    );\n\n    this.progressTracker.start(followings.length);\n    this.statusApi.sendStatus(\n      'in-progress',\n      `sync...`,\n      this.progressTracker.progress\n    );\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const addr of followings) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.syncLinks(myAddress!, addr, signal);\n    }\n  }\n\n  public async syncLinks(\n    myAddress: NeuronAddress,\n    address: NeuronAddress,\n    signal: AbortSignal\n  ) {\n    let syncUpdates = [];\n    try {\n      this.statusApi.sendStatus(\n        'in-progress',\n        `starting sync ${address}...`,\n        this.progressTracker.progress\n      );\n      const { timestampRead, unreadCount, meta } = await this.db!.getSyncStatus(\n        myAddress,\n        address\n      );\n\n      const { timestampUpdateChat = 0, timestampUpdateContent = 0 } =\n        meta || {};\n\n      const timestampFrom = timestampUpdateContent + 1; // ofsset + 1 to fix milliseconds precision bug\n\n      const linksAsyncIterable = await fetchCyberlinksByNerounIterable(\n        address,\n        SENSE_FRIEND_PARTICLES,\n        timestampFrom,\n        CYBERLINKS_BATCH_LIMIT,\n        signal\n      );\n\n      // eslint-disable-next-line no-restricted-syntax\n      for await (const linksBatch of linksAsyncIterable) {\n        this.statusApi.sendStatus(\n          'in-progress',\n          `sync ${address}...`,\n          this.progressTracker.trackProgress(1)\n        );\n\n        const links = linksBatch.map(mapLinkFromIndexerToDbEntity);\n\n        const { timestampRead: newTimestampRead, unreadCount: newUnreadCount } =\n          getLastReadInfo(linksBatch, myAddress, timestampRead, unreadCount);\n\n        // const unreadItemsCount = unreadCount + links.length;\n\n        if (links.length > 0) {\n          const lastLink = entityToDto(links.at(-1)!);\n          const newTimestampUpdateContent = lastLink!.timestamp;\n\n          await throwIfAborted(this.db!.putCyberlinks, signal)(links);\n\n          const particles = links.map((t) => t.to);\n          await this.particlesResolver!.enqueueBatch(\n            particles,\n            QueuePriority.HIGH\n          );\n\n          const newSyncItem = {\n            ownerId: myAddress,\n            entryType: EntryType.chat,\n            id: address,\n            timestampUpdate: Math.max(\n              newTimestampUpdateContent,\n              timestampUpdateChat\n            ),\n            unreadCount: newUnreadCount,\n            timestampRead: newTimestampRead,\n            disabled: false,\n            meta: {\n              ...lastLink!,\n              timestampUpdateContent: newTimestampUpdateContent,\n              timestampUpdateChat,\n            } as SenseItemLinkMeta,\n          };\n          // Update transaction\n          await throwIfAborted(this.db!.putSyncStatus, signal)(newSyncItem);\n\n          syncUpdates.push(newSyncItem);\n        }\n      }\n    } catch (err) {\n      this.cyblogCh.error(`>>> SyncMyFriends ${address} error`, {\n        error: err,\n      });\n      if (!isAbortException(err)) {\n        this.statusApi.sendStatus('error', err.toString());\n      } else {\n        syncUpdates = [];\n        throw err;\n      }\n    } finally {\n      // console.log('-----syncUpdates with redux', syncUpdates);\n      this.channelApi.postSenseUpdate(syncUpdates);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  // protected createRestartObserver(\n  //   params$: Observable<SyncServiceParams>\n  // ): Observable<boolean> {\n  //   return super\n  //     .createRestartObserver(params$)\n  //     .pipe(switchMap((addressChanged) => this.isInitialized$));\n  // }\n}\n\nexport default SyncMyFriendsLoop;\n","import Unixfs from 'ipfs-unixfs';\nimport { DAGNode, util as DAGUtil } from 'ipld-dag-pb';\nimport { ParticleCid } from 'src/types/base';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const getIpfsHash = (string: string): Promise<ParticleCid> =>\n  new Promise((resolve, reject) => {\n    const unixFsFile = new Unixfs('file', Buffer.from(string));\n\n    const buffer = unixFsFile.marshal();\n    DAGNode.create(buffer, (err, dagNode) => {\n      if (err) {\n        reject(new Error('Cannot create ipfs DAGNode'));\n      }\n\n      DAGUtil.cid(dagNode, (error, cid) => {\n        resolve(cid.toBaseEncodedString());\n      });\n    });\n  });\n","import { NeuronAddress, ParticleCid } from 'src/types/base';\nimport { getIpfsHash } from 'src/utils/ipfs/helpers';\nimport { PATTERN_CYBER } from 'src/constants/app';\nimport { Subject, Observable } from 'rxjs';\n\nimport DbApiWrapper from '../backend/services/dataSource/indexedDb/dbApiWrapper';\nimport { getFollowsAsCid, getFollowers } from '../backend/services/lcd/lcd';\nimport { FetchParticleAsync, QueuePriority } from '../QueueManager/types';\nimport { CommunityDto } from '../CozoDb/types/dto';\nimport { FetchIpfsFunc } from '../backend/services/sync/types';\nimport { createCyblogChannel } from 'src/utils/logging/cyblog';\n\nexport type SyncCommunityResult = {\n  action: 'reset' | 'add' | 'complete';\n  items: CommunityDto[];\n};\n\nconst cyblogCh = createCyblogChannel({\n  thread: 'bckd',\n  unit: 'fetchStoredSyncCommunity',\n});\n\n// eslint-disable-next-line import/prefer-default-export, import/no-unused-modules\nexport const fetchStoredSyncCommunity$ = (\n  dbApi: DbApiWrapper,\n  address: NeuronAddress,\n  fetchParticleAsync?: FetchIpfsFunc,\n  signal?: AbortSignal\n): Observable<SyncCommunityResult> => {\n  return new Observable<SyncCommunityResult>((subscriber) => {\n    subscriber.next({ action: 'reset', items: [] });\n\n    (async () => {\n      const storedCommunity = await dbApi.getCommunity(address);\n\n      subscriber.next({ action: 'add', items: storedCommunity });\n\n      const communityUpdatesMap = new Map<ParticleCid, CommunityDto>(\n        storedCommunity.map((c) => [c.particle, c])\n      );\n\n      const getExistingOrDefault = (cid: ParticleCid): Partial<CommunityDto> =>\n        communityUpdatesMap.get(cid) || {\n          ownerId: address,\n          name: '',\n          following: false,\n          follower: false,\n        };\n\n      const followsCids = await getFollowsAsCid(address, signal);\n      const followers = await getFollowers(address, signal);\n\n      const newFollowerCids = followsCids.filter(\n        (cid) => !storedCommunity.some((i) => i.particle === cid && i.following)\n      );\n\n      const newFollowingNeurons = followers.filter(\n        (addr) => !storedCommunity.some((i) => i.neuron === addr && i.follower)\n      );\n\n      cyblogCh.info(\n        `>>>$ sync community ${address} processing, stored ${storedCommunity.length} new followers: ${newFollowerCids.length} new following: ${newFollowingNeurons.length}`\n      );\n\n      const followersCommunity = await Promise.all(\n        newFollowingNeurons.map(async (neuron) => {\n          const cid = await getIpfsHash(neuron);\n\n          const communityItem = {\n            ...getExistingOrDefault(cid),\n            particle: cid,\n            neuron,\n            follower: true,\n          } as CommunityDto;\n\n          await dbApi.putCommunity(communityItem);\n          communityUpdatesMap.set(cid, communityItem);\n          return communityItem;\n        })\n      );\n\n      subscriber.next({ action: 'add', items: followersCommunity });\n\n      await Promise.all(\n        newFollowerCids.map(async (cid: ParticleCid) => {\n          const neuron = (await fetchParticleAsync!(cid, QueuePriority.URGENT))\n            ?.result?.textPreview;\n          if (neuron && neuron.match(PATTERN_CYBER)) {\n            const communityItem = {\n              ...getExistingOrDefault(cid),\n              neuron,\n              particle: cid,\n              following: true,\n            } as CommunityDto;\n\n            await dbApi.putCommunity(communityItem);\n            communityUpdatesMap.set(cid, communityItem);\n            subscriber.next({ action: 'add', items: [communityItem] });\n          }\n        })\n      );\n\n      cyblogCh.info(`>>>$ sync community ${address}, done`);\n      // const communityUpdates = [...communityUpdatesMap.values()];\n\n      // if (communityUpdates.length > 0) {\n      //   subscriber.next(communityUpdates);\n      // }\n      subscriber.next({ action: 'complete', items: [] });\n\n      subscriber.complete();\n    })().catch((err) => {\n      cyblogCh.error(`>>>$ sync community ${address}, error`, { error: err });\n      subscriber.error(err);\n    });\n  });\n};\n\n// eslint-disable-next-line import/no-unused-modules\nexport const fetchCommunity = async (\n  address: NeuronAddress,\n  fetchParticleAsync?: FetchParticleAsync,\n  onResolve?: (community: CommunityDto[]) => void,\n  signal?: AbortSignal\n) => {\n  const communityUpdatesMap = new Map<ParticleCid, CommunityDto>();\n\n  const getExistingOrDefault = (cid: ParticleCid): Partial<CommunityDto> =>\n    communityUpdatesMap.get(cid) || {\n      ownerId: address,\n      name: '',\n      following: false,\n      follower: false,\n    };\n\n  const followsCids = await getFollowsAsCid(address, signal);\n  const followers = await getFollowers(address, signal);\n\n  console.log(`>>> sync community ${address} processing without store`);\n\n  const followsPromise = Promise.all(\n    followsCids.map(async (cid) => {\n      const neuron = (await fetchParticleAsync!(cid))?.result?.textPreview;\n      if (neuron && neuron.match(PATTERN_CYBER)) {\n        const communityItem = {\n          ...getExistingOrDefault(cid),\n          neuron,\n          particle: cid,\n          following: true,\n        } as CommunityDto;\n        communityUpdatesMap.set(cid, communityItem);\n        onResolve && !signal?.aborted && onResolve([communityItem]);\n      }\n    })\n  );\n\n  const followersPromise = Promise.all(\n    followers.map(async (neuron) => {\n      const cid = await getIpfsHash(neuron);\n\n      const communityItem = {\n        ...getExistingOrDefault(cid),\n        particle: cid,\n        neuron,\n        follower: true,\n      } as CommunityDto;\n\n      communityUpdatesMap.set(cid, communityItem);\n      onResolve && !signal?.aborted && onResolve([communityItem]);\n    })\n  );\n\n  await Promise.all([followersPromise, followsPromise]);\n};\n","import axios from 'axios';\nimport { CYBER_NODE_URL_LCD } from 'src/constants/config';\nimport { NeuronAddress, ParticleCid } from 'src/types/base';\nimport { CID_FOLLOW } from 'src/constants/app';\nimport { getIpfsHash } from 'src/utils/ipfs/helpers';\n\nexport const getFollowsAsCid = async (\n  address: NeuronAddress,\n  signal?: AbortSignal\n): Promise<ParticleCid[]> => {\n  const response = await axios({\n    method: 'get',\n    url: `${CYBER_NODE_URL_LCD}/txs?cyberlink.neuron=${address}&cyberlink.particleFrom=${CID_FOLLOW}&limit=1000000000`,\n    signal,\n  });\n\n  if (!response.data.txs) {\n    return [];\n  }\n  return response.data.txs.map(\n    (item) => item.tx.value.msg[0].value.links[0].to\n  );\n};\n\nexport const getFollowers = async (\n  address: NeuronAddress,\n  signal?: AbortSignal\n): Promise<NeuronAddress[]> => {\n  const addressHash = await getIpfsHash(address);\n\n  const response = await axios({\n    method: 'get',\n    url: `${CYBER_NODE_URL_LCD}/txs?cyberlink.particleFrom=${CID_FOLLOW}&cyberlink.particleTo=${addressHash}&limit=1000000000`,\n    signal,\n  });\n  // console.log(\n  //   '-----getFollowers',\n  //   `${CYBER_NODE_URL_LCD}/txs?cyberlink.particleFrom=${CID_FOLLOW}&cyberlink.particleTo=${addressHash}&limit=1000000000`,\n  //   response.data\n  // );\n  if (!response.data.txs) {\n    return [];\n  }\n  return response.data.txs.map((item) => item.tx.value.msg[0].value.neuron);\n};\n\nexport async function getTransaction(txHash: string) {\n  // https://lcd.bostrom.cybernode.ai/cosmos/tx/v1beta1/txs/67FD87EBCC1633B779C154C1CAFD48DE71350074A04F742DAD418F69F1D05BB0\n  const response = axios.get(\n    `${CYBER_NODE_URL_LCD}/cosmos/tx/v1beta1/txs/${txHash}`\n  );\n  return response;\n}\n","/* eslint-disable no-restricted-syntax */\nimport { Observable, combineLatest } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport BroadcastChannelSender from '../../channels/BroadcastChannelSender';\n\nimport ParticlesResolverQueue from './services/ParticlesResolverQueue/ParticlesResolverQueue';\n\n// import SyncIpfsLoop from './services/SyncIpfsLoop/SyncIpfsLoop';\nimport SyncTransactionsLoop from './services/SyncTransactionsLoop/SyncTransactionsLoop';\nimport SyncParticlesLoop from './services/SyncParticlesLoop/SyncParticlesLoop';\n\nimport { ServiceDeps } from './services/types';\nimport {\n  MY_FRIENDS_SYNC_INTERVAL,\n  MY_PARTICLES_SYNC_INTERVAL,\n} from './services/consts';\nimport SyncMyFriendsLoop from './services/SyncMyFriendsLoop/SyncMyFriendsLoop';\nimport { SyncEntryName } from '../../types/services';\nimport BaseSyncLoop from './services/BaseSyncLoop/BaseSyncLoop';\nimport createCommunitySync$ from './services/CommunitySync/CommunitySync';\nimport { createCyblogChannel } from 'src/utils/logging/cyblog';\n\nconst cyblogCh = createCyblogChannel({ thread: 'bckd' });\n\n// eslint-disable-next-line import/prefer-default-export\nexport class SyncService {\n  private isInitialized$: Observable<boolean>;\n\n  private channelApi = new BroadcastChannelSender();\n\n  private loops: Partial<Record<SyncEntryName, BaseSyncLoop>> = {};\n\n  constructor(deps: ServiceDeps) {\n    const { dbInstance$, ipfsInstance$ } = deps;\n    this.isInitialized$ = combineLatest([dbInstance$, ipfsInstance$]).pipe(\n      map(([dbInstance, ipfsInstance]) => !!dbInstance && !!ipfsInstance)\n    );\n    // subscribe when started\n    this.isInitialized$.subscribe({\n      next: (result) => {\n        return result && this.channelApi.postServiceStatus('sync', 'started');\n      },\n      error: (err) => this.channelApi.postServiceStatus('sync', 'error', err),\n    });\n\n    const particlesResolver = new ParticlesResolverQueue(deps).start();\n\n    const communitySync$ = createCommunitySync$(deps);\n    communitySync$.subscribe((community) => {\n      cyblogCh.info('--> community fetched', {\n        unit: 'community',\n        data: community,\n      });\n    });\n\n    const followings$ = communitySync$.pipe(\n      map((c) => c.filter((i) => i.following)),\n      map((c) => c.map((i) => i.neuron))\n    );\n\n    // new SyncIpfsLoop(deps, particlesResolver).start();\n\n    new SyncTransactionsLoop('transactions', deps, particlesResolver).start();\n\n    new SyncParticlesLoop(\n      'particles',\n      MY_PARTICLES_SYNC_INTERVAL,\n      deps,\n      particlesResolver\n    ).start();\n\n    new SyncMyFriendsLoop(\n      'my-friends',\n      MY_FRIENDS_SYNC_INTERVAL,\n      { ...deps, followings$ },\n      particlesResolver\n      // { warmupMs: 1000 }\n    ).start();\n  }\n\n  public restart(name: SyncEntryName) {\n    this.loops[name]?.restart();\n  }\n}\n","import {\n  Observable,\n  combineLatest,\n  defer,\n  distinctUntilChanged,\n  filter,\n  map,\n  switchMap,\n} from 'rxjs';\n\nimport {\n  SyncCommunityResult,\n  fetchStoredSyncCommunity$,\n} from 'src/services/community/community';\nimport BroadcastChannelSender from 'src/services/backend/channels/BroadcastChannelSender';\nimport { CommunityDto } from 'src/services/CozoDb/types/dto';\nimport { ServiceDeps } from '../types';\n\n// eslint-disable-next-line import/no-unused-modules\nexport default function createCommunitySync$(\n  deps: ServiceDeps\n): Observable<CommunityDto[]> {\n  const { dbInstance$, ipfsInstance$, params$ } = deps;\n  const channel = new BroadcastChannelSender();\n\n  return combineLatest([\n    dbInstance$,\n    params$!.pipe(\n      map((params) => params.myAddress),\n      distinctUntilChanged()\n    ),\n    ipfsInstance$,\n  ]).pipe(\n    filter(\n      ([dbInstance, myAddress, ipfsInstance]) =>\n        !!dbInstance && !!ipfsInstance && !!myAddress\n    ),\n    switchMap(([dbApi, myAddress, ipfsInstance]) => {\n      const { waitForParticleResolve } = deps;\n      let community: CommunityDto[] = []; // Fix: Add type declaration for community array\n      return new Observable<CommunityDto[]>((observer) => {\n        observer.next([]);\n\n        fetchStoredSyncCommunity$(\n          dbApi!,\n          myAddress!,\n          waitForParticleResolve!\n        ).subscribe(({ action, items }: SyncCommunityResult) => {\n          channel.post({ type: 'load_community', value: { action, items } });\n\n          if (action === 'reset') {\n            community = [];\n          } else if (['add', 'complete'].some((s) => s === action)) {\n            community.push(...items);\n          }\n\n          if (action === 'complete') {\n            observer.next(community);\n            observer.complete();\n          }\n        });\n      });\n    })\n  );\n}\n","import {\n  BehaviorSubject,\n  defer,\n  Observable,\n  filter,\n  from,\n  mergeMap,\n  tap,\n} from 'rxjs';\nimport { IDeferredDbSaver } from 'src/services/QueueManager/types';\nimport { IPFSContent, IPFSContentMaybe } from 'src/services/ipfs/ipfs';\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { ParticleCid } from 'src/types/base';\nimport { mapParticleToEntity } from 'src/services/CozoDb/mapping';\nimport DbApi from '../dataSource/indexedDb/dbApiWrapper';\nimport { LinkDto } from 'src/services/CozoDb/types/dto';\n\ntype QueueItem = {\n  content?: IPFSContent;\n  links?: LinkDto[];\n};\n\ntype QueueMap = Map<ParticleCid | typeof uuidv4, QueueItem>;\n\nclass DeferredDbSaver implements IDeferredDbSaver {\n  private queue$ = new BehaviorSubject<QueueMap>(new Map());\n\n  private dbApi: DbApi | undefined;\n\n  public get queue(): QueueMap {\n    return this.queue$.getValue();\n  }\n\n  constructor(dbInstance$: Observable<DbApi | undefined>) {\n    dbInstance$.subscribe((db) => {\n      this.dbApi = db;\n    });\n\n    dbInstance$\n      .pipe(\n        filter((dbInstance) => !!dbInstance),\n        tap(() => cyblog.info('DeferredDbSaver - initialized')),\n        mergeMap(() => this.queue$), // Merge the queue$ stream here.\n        filter((queue) => queue.size > 0),\n        mergeMap((queue) => defer(() => from(this.processQueue(queue))))\n      )\n      .subscribe({\n        // next: () => console.log('Queue processed'),\n        error: (err) => console.error('Error processing IPFS queue', err),\n      });\n  }\n\n  public enqueueIpfsContent(content: IPFSContentMaybe) {\n    if (!content) {\n      return;\n    }\n    const { cid } = content;\n\n    this.queue$.next(new Map(this.queue$.value).set(cid, { content }));\n  }\n\n  public enqueueLinks(links: LinkDto[]) {\n    if (!links || !links.length) {\n      return;\n    }\n    const id = uuidv4();\n    this.queue$.next(new Map(this.queue$.value).set(id, { links }));\n  }\n\n  private async processQueue(queue: QueueMap) {\n    // const processingQueue = new Map(this.queue$.value); // Snapshot of the current queue\n    this.queue$.next(new Map());\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [cid, item] of queue) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.processQueueItem(item);\n      // console.log(' deffered DB done ', cid, item);\n\n      queue.delete(cid);\n    }\n    // this.queue$.next(queue);\n  }\n\n  private async processQueueItem(queueItem: QueueItem) {\n    const { content, links } = queueItem;\n    // console.log(`PostProcessing queue item: ${cid}`, item);\n    if (content) {\n      // eslint-disable-next-line no-await-in-loop\n      const entity = mapParticleToEntity(content);\n      await this.dbApi!.putParticles(entity);\n    }\n\n    if (links && links.length > 0) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.dbApi!.putCyberlinks(links);\n    }\n  }\n}\n\nexport default DeferredDbSaver;\n","import { ProxyMarked, Remote, proxy } from 'comlink';\n\nimport { initIpfsNode } from 'src/services/ipfs/node/factory';\n\nimport {\n  CybIpfsNode,\n  IpfsContentType,\n  IpfsOptsType,\n} from 'src/services/ipfs/ipfs';\n\nimport QueueManager from 'src/services/QueueManager/QueueManager';\n\n// import { CozoDbWorkerApi } from 'src/services/backend/workers/db/worker';\n\nimport {\n  QueueItemCallback,\n  QueueItemOptions,\n  QueuePriority,\n} from 'src/services/QueueManager/types';\nimport { ParticleCid } from 'src/types/base';\nimport { LinkDto } from 'src/services/CozoDb/types/dto';\nimport { BehaviorSubject, Subject } from 'rxjs';\n\nimport { exposeWorkerApi } from '../factoryMethods';\n\nimport { SyncService } from '../../services/sync/sync';\nimport { SyncServiceParams } from '../../services/sync/types';\n\nimport DbApi from '../../services/dataSource/indexedDb/dbApiWrapper';\n\nimport BroadcastChannelSender from '../../channels/BroadcastChannelSender';\nimport DeferredDbSaver from '../../services/DeferredDbSaver/DeferredDbSaver';\nimport { SyncEntryName } from '../../types/services';\n\nconst createBackgroundWorkerApi = () => {\n  const dbInstance$ = new Subject<DbApi | undefined>();\n\n  const ipfsInstance$ = new BehaviorSubject<CybIpfsNode | undefined>(undefined);\n\n  const params$ = new BehaviorSubject<SyncServiceParams>({\n    myAddress: null,\n  });\n\n  let ipfsNode: CybIpfsNode | undefined;\n  const defferedDbSaver = new DeferredDbSaver(dbInstance$);\n\n  const ipfsQueue = new QueueManager(ipfsInstance$, {\n    defferedDbSaver,\n  });\n  const broadcastApi = new BroadcastChannelSender();\n\n  // service to sync updates about cyberlinks, transactions, swarm etc.\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const syncService = new SyncService({\n    waitForParticleResolve: async (\n      cid: ParticleCid,\n      priority: QueuePriority = QueuePriority.MEDIUM\n    ) => ipfsQueue.enqueueAndWait(cid, { postProcessing: true, priority }),\n    dbInstance$,\n    ipfsInstance$,\n    params$,\n  });\n\n  const init = async (dbApiProxy: DbApi & ProxyMarked) => {\n    dbInstance$.next(dbApiProxy);\n  };\n\n  const stopIpfs = async () => {\n    if (ipfsNode) {\n      await ipfsNode.stop();\n    }\n    ipfsInstance$.next(undefined);\n    broadcastApi.postServiceStatus('ipfs', 'inactive');\n  };\n\n  const startIpfs = async (ipfsOpts: IpfsOptsType) => {\n    try {\n      if (ipfsNode) {\n        console.log('Ipfs node already started!');\n        await ipfsNode.stop();\n      }\n      broadcastApi.postServiceStatus('ipfs', 'starting');\n      ipfsNode = await initIpfsNode(ipfsOpts);\n\n      ipfsInstance$.next(ipfsNode);\n\n      setTimeout(() => broadcastApi.postServiceStatus('ipfs', 'started'), 0);\n      return true;\n    } catch (err) {\n      console.log('----ipfs node init error ', err);\n      const msg = err instanceof Error ? err.message : (err as string);\n      broadcastApi.postServiceStatus('ipfs', 'error', msg);\n      throw Error(msg);\n    }\n  };\n\n  const defferedDbApi = {\n    importCyberlinks: (links: LinkDto[]) => {\n      defferedDbSaver.enqueueLinks(links);\n    },\n  };\n\n  const ipfsApi = {\n    start: startIpfs,\n    stop: stopIpfs,\n    getIpfsNode: async () => ipfsNode && proxy(ipfsNode),\n    config: async () => ipfsNode?.config,\n    info: async () => ipfsNode?.info(),\n    fetchWithDetails: async (cid: string, parseAs?: IpfsContentType) =>\n      ipfsNode?.fetchWithDetails(cid, parseAs),\n    enqueue: async (\n      cid: string,\n      callback: QueueItemCallback,\n      options: QueueItemOptions\n    ) => ipfsQueue!.enqueue(cid, callback, options),\n    enqueueAndWait: async (cid: string, options?: QueueItemOptions) =>\n      ipfsQueue!.enqueueAndWait(cid, options),\n    dequeue: async (cid: string) => ipfsQueue.cancel(cid),\n    dequeueByParent: async (parent: string) => ipfsQueue.cancelByParent(parent),\n    clearQueue: async () => ipfsQueue.clear(),\n    addContent: async (content: string | File) => ipfsNode?.addContent(content),\n  };\n\n  return {\n    init,\n    isInitialized: () => !!ipfsInstance$.value,\n    // syncDrive,\n    ipfsApi: proxy(ipfsApi),\n    defferedDbApi: proxy(defferedDbApi),\n    ipfsQueue: proxy(ipfsQueue),\n    restartSync: (name: SyncEntryName) => syncService.restart(name),\n    setParams: (params: Partial<SyncServiceParams>) =>\n      params$.next({ ...params$.value, ...params }),\n  };\n};\n\nconst backgroundWorker = createBackgroundWorkerApi();\n\nexport type BackgroundWorker = typeof backgroundWorker;\n\n// Expose the API to the main thread as shared/regular worker\nexposeWorkerApi(self, backgroundWorker);\n","export const CYBLOG_LOG_SHOW = 'cyblog_show';\n\nexport const CYBLOG_BROADCAST_CHANNEL_NAME = 'CYBLOG_BROADCST_CHANNEL';\n\nexport const CYBLOG_CONSOLE_PARAMS_DEFAULT = {\n  thread: 'all',\n  unit: 'all',\n  module: 'all',\n};\n","import _, { isEmpty } from 'lodash';\nimport { ConsoleLogParams, LogContext, LogItem, LogLevel } from './types';\nimport { CYBLOG_BROADCAST_CHANNEL_NAME } from './constants';\n\nconst logList: LogItem[] = [];\n\nfunction createCybLog<T>(defaultContext: Partial<LogContext<T>> = {}) {\n  function appendLog(logItem: LogItem, truncate = true) {\n    logList.push(logItem);\n\n    while (truncate && logList.length > 1000) {\n      logList.shift(); // Remove the first element to keep the list size <= 1000\n    }\n  }\n  let consoleLogParams = {} as ConsoleLogParams;\n\n  const channel = new BroadcastChannel(CYBLOG_BROADCAST_CHANNEL_NAME);\n\n  channel.onmessage = (event) => {\n    if (event.data.type === 'params') {\n      consoleLogParams = { ...consoleLogParams, ...event.data.value };\n    }\n  };\n\n  const getConsoleLogParams = () => consoleLogParams;\n\n  function consoleLog<T>(\n    level: LogLevel,\n    message: T,\n    context: Partial<LogContext<T>>\n  ) {\n    const ctx = _.omit(context, [\n      'formatter',\n      'thread',\n      'module',\n      'unit',\n      'data',\n    ]);\n    const { thread = '', module = '', unit = '', data = '' } = context;\n    const ctxItem = isEmpty(ctx) ? '' : ctx;\n\n    if (Array.isArray(message)) {\n      console[level](...message, ctxItem);\n      return;\n    }\n\n    if (context?.formatter) {\n      console[level](context?.formatter(message), ctxItem);\n      return;\n    }\n\n    console[level](`[${thread}:${module}:${unit}] ${message}`, data, ctxItem);\n  }\n\n  // eslint-disable-next-line import/no-unused-modules\n  function log<T>(\n    level: LogLevel,\n    message: string | T,\n    context: LogContext<any> = defaultContext\n  ) {\n    try {\n      const formattedMessage = context?.formatter\n        ? context?.formatter(message)\n        : message;\n\n      const logEntry = {\n        timestamp: new Date(),\n        level,\n        message: formattedMessage,\n        stacktrace: context?.stacktrace,\n        context: _.omit(context, ['formatter', 'stacktrace']),\n      };\n\n      appendLog(logEntry);\n      // !!localStorage.getItem(LOCAL_STORAGE_USE_CONSOLE_LOG_KEY) &&\n      const showConsoleLog = Object.keys(consoleLogParams).reduce(\n        (acc: boolean, key: string) => {\n          const params = consoleLogParams[key];\n          const contextItem = context[key];\n          if (params && contextItem) {\n            return (\n              acc ||\n              params === 'all' ||\n              params.length === 0 ||\n              params.some((p) => p === contextItem)\n            );\n          }\n          return acc;\n        },\n        false\n      );\n\n      if (showConsoleLog) {\n        consoleLog(level, message, context);\n      }\n    } catch (error) {\n      console.log('cyblog error', error);\n    }\n  }\n\n  function info<T>(message: T, context?: LogContext<string | T>) {\n    return log('info', message, context);\n  }\n\n  function error<T>(message: T, context?: LogContext<string | T>) {\n    return log('error', message, context);\n  }\n\n  function warn<T>(message: T, context?: LogContext<string | T>) {\n    return log('warn', message, context);\n  }\n\n  function trace<T>(message: T, context?: LogContext<string | T>) {\n    return log('warn', message, context);\n  }\n\n  function normalizeLog() {\n    return logList.map((logItem) => {\n      const { context, ...rest } = logItem;\n      const {\n        unit = '',\n        module = '',\n        thread = '',\n        data = '',\n        error = '',\n        stacktrace = '',\n      } = context || {};\n      return {\n        ...rest,\n        unit,\n        module,\n        thread,\n        data, //: JSON.stringify(data),\n        error,\n        stacktrace,\n      };\n    });\n  }\n\n  return {\n    log,\n    info,\n    error,\n    warn,\n    trace,\n    logList,\n    getLogs: () => normalizeLog(),\n    clear: () => logList.splice(0, logList.length),\n    getConsoleLogParams,\n  };\n}\n\nexport const createCyblogChannel = (\n  defaultContext: Partial<LogContext<T>> = {}\n) => {\n  const channel = new BroadcastChannel(CYBLOG_BROADCAST_CHANNEL_NAME);\n\n  function postLogToChannel<T>(\n    level: LogLevel,\n    message: T,\n    context?: LogContext<string | T>\n  ) {\n    const ctx = { ...defaultContext, ...context };\n    if (context?.error) {\n      ctx.error = JSON.stringify(context.error);\n    }\n    channel.postMessage({\n      type: 'log',\n      value: { level, message, context: ctx },\n    });\n  }\n\n  function info<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('info', message, context);\n  }\n\n  function error<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('error', message, context);\n  }\n\n  function warn<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('warn', message, context);\n  }\n\n  function trace<T>(message: T, context?: LogContext<string | T>) {\n    return postLogToChannel('warn', message, context);\n  }\n\n  return { info, error, warn, trace };\n};\n\nconst cyblog = createCybLog({ thread: 'main' });\n\nexport type LogFunc = (message: T, context?: LogContext<string | T>) => void;\n\nexport type CyblogChannel = ReturnType<typeof createCyblogChannel>;\n\nexport default cyblog;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [912,393,698,724], function() { return __webpack_require__(60427); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdO = {};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"393\":\"d8cfa458\",\"698\":\"d0b17df8\",\"724\":\"0892e360\",\"827\":\"89ce62da\",\"912\":\"ecb020b3\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t73: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkcyb\"] = self[\"webpackChunkcyb\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","stringToCid","s","stringToIpfsPath","CYBER_NODE_SWARM_PEER_ID","CYBERNODE_SWARM_ADDR_WSS","CYBERNODE_SWARM_ADDR_TCP","CYBER_GATEWAY_URL","nodeType","_config","_isStarted","config","this","isStarted","response","node","get","gatewayUrl","address","nodeAddress","port","async","options","initConfig","window","toCid","console","log","swarm","localAddrs","map","a","toString","cid","files","stat","withLocal","size","then","result","type","sizeLocal","local","blocks","cat","content","add","pin","peers","c","peer","addr","bootstrap","connect","ls","repoSize","stats","repo","responseId","id","agentVersion","addOptionsV0","cidVersion","rawLeaves","blockstore","open","datastore","libp2p","bootstrapList","transports","rtcConfiguration","iceServers","urls","credential","username","discoverRelays","connectionEncryption","streamMuxers","connectionGater","denyDialMultiaddr","peerDiscovery","list","services","identify","libp2pFactory","fs","addEventListener","evt","peerId","detail","conn","getConnections","transportsByAddr","Object","fromEntries","remoteAddr","protoCodes","v","name","debug","getMultiaddrs","fileSize","localFileSize","dagSize","mtime","optionsV0","File","fileName","arrayBuffer","data","Uint8Array","addFile","path","TextEncoder","encode","addBytes","cid_","pins","isPinned","remotePeer","stop","start","dial","iterable","item","metadata","toV0","mapToLsResult","host","relay","enabled","hop","preload","API","HTTPHeaders","Addresses","Gateway","Swarm","Delegates","Discovery","MDNS","Enabled","Interval","webRTCStar","Bootstrap","Pubsub","ConnMgr","HighWater","LowWater","DisableNatPortMap","Routing","Type","filter","filters","nat","EXPERIMENTAL","ipnsPubsub","Number","getMimeFromUint8Array","raw","fileType","mime","PATTERN_IPFS_HASH","PATTERN_HTTP","createImgData","rawData","basic","parseArrayLikeToDetails","onProgress","meta","link","gateway","initialType","includes","detectContentType","indexOf","bytesDownloaded","byteLength","chunks","ReadableStream","reader","getReader","readStream","done","value","push","read","Symbol","asyncIterator","chunk","error","getResponseResult","Buffer","from","dataBase64","length","match","string","newString","trim","slice","test","isHtml","text","shortenString","blob","Blob","URL","createObjectURL","e","createTextPreview","array","previewLength","db","version","stores","following","ipfsContentAddtToInddexdDB","dbValue","cluster","file","dataFile","status","loadIPFSContentFromDb","textPreview","source","emptyMeta","fetchIPFSContentMeta","signal","fetchIPFSContentFromNode","controller","controllerLegacy","AbortController","timer","setTimeout","abort","startTime","Date","now","statsDoneTime","statsTime","allowedSize","clearTimeout","availableDownload","firstChunk","offset","fullyDownloaded","stream","catTime","pinTime","fetchIPFSContentFromGateway","isExternalNode","contentUrl","fetch","method","body","flushResults","Promise","resolve","flush","firstChunkStream","fullStream","tee","firstReader","restReader","asyncIterable","toAsyncIterableWithMime","getIPFSContent","callBackFuncStatus","dataRsponseDb","addContenToIpfs","contentToUint8Array","nodeClassMap","helia","embedded","external","initIpfsNode","ipfsNodeType","restOptions","EnhancedClass","Base","parseAs","details","super","getPeers","find","swarmPeerId","lastConnectedTimestamp","isConnectedToSwarm","connectPeer","swarmPeerAddress","catch","err","message","withCybFeatures","instance","init","url","urlOpts","reconnectToSwarm","QueueStrategy","constructor","settings","order","getNextSource","index","QueueItemTimeoutError","Error","timeoutMs","setPrototypeOf","prototype","isParticle","Boolean","EntryType","SyncQueueStatus","initialState","isLoading","chats","summary","unreadCount","total","particles","neurons","formatApiData","entryType","chat","to","particle","formatted","timestamp","toISOString","transactionHash","hash","transaction_hash","memo","senseChatId","transactions","ownerId","fromAddress","inputs","assign","neuron","fromLog","getSenseList","senseApi","getList","getSenseChat","getLinks","getFriendItems","markAsRead","newChatStructure","checkIfMessageExists","newMessage","some","msg","reducers","updateSenseList","reducer","state","action","payload","forEach","concat","caseReducers","orderSenseList","prepare","addSenseItem","newList","unshift","updateSenseItem","chatId","txHash","isSuccess","sorted","keys","reduce","acc","lastMsg","sort","b","parse","i","reset","extraReducers","builder","addCase","pending","fulfilled","rejected","arg","sense","unreadCountParticle","unreadCountNeuron","values","actions","channel","BroadcastChannel","postServiceStatus","postMessage","postSyncEntryProgress","entry","postSenseUpdate","senseList","post","getQueueItemTotalPriority","priority","viewPortPriority","strategies","timeout","maxConcurrentExecutions","ipfsInstance$","strategy","queueDebounceMs","defferedDbSaver","queue$","BehaviorSubject","Map","lastNodeCallTime","executing","Set","subscribe","setNode","interval","pipe","debounceTime","queue","cancelDeprioritizedItems","mergeMap","workItems","getItemBySourceAndPriority","merge","fetchData$","E","callbacks","callback","delete","removeAndNext","nextSource","switchSourceAndNext","postSummary","switchStrategy","customStrategy","pendingItems","pendingBySource","itemsToExecute","queueSource","items","entries","executeCount","itemsByPriority","queueItem","set","executionTime","promiseFactory","res","fetchIpfsContent","enqueueIpfsContent","Observable","observer","complete","each","with","throwError","catchError","of","mutateQueueItem","changes","Array","releaseExecution","key","enqueue","existingItem","initialSource","postProcessing","enqueueAndWait","updateViewPortPriority","cancel","cancelByParent","parent","clear","getQueueMap","getQueueList","getStats","fn","QueuePriority","createAsyncIterable","promise","onmessage","event","IPFSContentTransferHandler","canHandle","obj","serialize","rest","port1","port2","MessageChannel","close","deserialize","serializedObj","SharedWorker","process","env","IS_DEV","installTransferHandlers","overrideLogging","worker","consoleLogMap","original","warn","replaceConsoleLog","args","apply","serializableArgs","JSON","stringify","String","safeStringify","broadcastStatus","channelApi","sendStatus","progress","asyncIterableBatchProcessor","batchProcess","batchSize","batch","CID_TWEET","CID_FOLLOW","RegExp","SENSE_FRIEND_PARTICLES","deps","statusApi","_syncQueue$","waitForParticleResolve","dbInstance$","loadSyncQueue","isInitialized$","combineLatest","dbInstance","ipfsInstance","getValue","loop$","_loop$","all","MEDIUM","updateSyncQueue","removeSyncQueue","source$","tap","q","isInitialized","processSyncQueue","share","URGENT","cids","putSyncQueue","getSyncQueue","statuses","isoString","endsWith","mapIndexerTransactionToEntity","tx","transaction","block","height","success","blockHeight","mapLinkFromIndexerToDbEntity","throwIfAborted","func","aborted","DOMException","CYBER_NODE_URL_LCD","CYBER_INDEX_WSS","CYBER_NODE_URL_WS","MSG_SEND_TRANSACTION_TYPE","MSG_MULTI_SEND_TRANSACTION_TYPE","mapWebsocketTxToTransactions","events","transactionType","messages","Tx","msgType","typeUrl","MsgSend","MsgMultiSend","extractTxData","TxResult","fetchIterable","fetchFunction","params","cyberGraphQLWsLink","shouldRetry","errOrCloseEvent","retryAttempts","retryWait","retries","Math","min","createIndexerClient","abortSignal","cyberlinksByParticle","cyberlinksCountByNeuron","fetchCyberlinks","particleCid","timestampFrom","request","limit","orderBy","where","_or","particle_to","_eq","particle_from","_gt","cyberlinks","fetchCyberlinksByNeroun","particlesFrom","_and","_in","fetchCyberlinksByNerounIterable","getUniqueParticlesFromLinks","links","fetchCyberlinksAndResolveParticles","timestampUpdate","particlesResolver","queuePriority","cyberlinksIterable","fetchCyberlinksIterable","enqueueBatch","mapMessagesByAddressVariables","types","orderDirection","timestamp_from","t","join","order_direction","gqlMessagesByAddress","fetchTransactions","messages_by_address","transactionsCountByNeuron","updateSenseChat","amount","isSender","userAddress","lastSendTimestamp","last","direction","syncMyChats","myAddress","shouldUpdateTimestamp","syncItems","findSyncStatus","syncItemsMap","myChats","outputs","coins","toAddress","extractSenseChats","getTransactions","results","syncItem","lastTransaction","at","transactionTimestamp","syncItemHeader","timestampRead","prevUnreadCount","lastTimestampRead","max","timestampUpdateContent","timestampUpdateChat","timestampUnreadFrom","newTimestampUpdateChat","syncStatusChanges","updateSyncStatus","newItem","disabled","putSyncStatus","ProgressTracker","onProgressUpdate","requestRecords","totalRequests","completedRequests","estimatedTime","totalCount","completeCount","extraRequests","trackProgress","processedCount","addRequestRecord","shift","estimatedRemainingTime","calculateAverageTimePerItem","round","itemCount","totalDiff","totalItems","timeDiff","progressTracker","abortController","cyblogCh","thread","module","params$","createIsInitializedObserver","info","switchMap","createRestartObserver","restart","initAbortController","distinctUntilChanged","addrBefore","addrAfter","switchWhenInitialized","actionObservable$","onChange","initialized","reloadTrigger$","Subject","startWith","createInitObservable","createClientObservable","onUpdate","syncQueueInitialized","variables","indexerObservable$","query","apolloObservable","ApolloClient","cache","subscriber","subscription","unsubscribe","createIndexerWebsocket","nodeObservample$","ws","WebSocket","onopen","send","jsonrpc","onerror","onclose","createNodeWebsocketObservable","ctx","unit","isEmpty","defer","initSync","getSyncStatus","lastTransactionTimestamp","syncTransactions","syncStatusItems","processBatchTransactions","putTransactions","syncLinks","lastTimestampFrom","newSyncItem","totalMessageCount","messages_by_address_aggregate","aggregate","count","fetchTransactionMessagesCount","ceil","transactionsAsyncIterable","fetchTransactionsIterable","transactionCount","tweets","particlesFound","l","txLink","extractCybelinksFromTransaction","putCyberlinks","tweetParticles","nonTweetParticles","HIGH","LOW","snakeToCamel","str","replace","group","toUpperCase","entityToDto","dbEntity","dto","hasOwnProperty","call","camelCaseKey","isArray","getLastReadInfo","prevTimestampRead","lastMyLinkIndex","findLastIndex","changeSyncStatus","statusEntity","lastLink","isAbortException","intervalMs","warmupMs","restartLoop","onStartInterval","onError","retryDelayMs","restartTrigger$","intervalOrRestart$","delay","exhaustMap","retry","createLoopObservable","doSync","sync","isAborted","particleResolverInitialized","syncItemParticles","newLinkCount","particles_from","cyberlinks_aggregate","fetchCyberlinksCount","newSyncItemParticles","fetchNewTweets","syncParticles","tweetsAsyncIterable","newTweets","tweetsBatch","syncStatusEntities","updatedSyncItems","followings$","followings","followingsInitialized$","followingsInitialized","syncUpdates","linksAsyncIterable","linksBatch","newTimestampRead","newUnreadCount","newTimestampUpdateContent","reject","buffer","marshal","DAGNode","dagNode","toBaseEncodedString","fetchStoredSyncCommunity$","dbApi","fetchParticleAsync","storedCommunity","getCommunity","communityUpdatesMap","getExistingOrDefault","follower","followsCids","txs","followers","addressHash","newFollowerCids","newFollowingNeurons","followersCommunity","communityItem","putCommunity","SyncService","loops","communitySync$","community","createCommunitySync$","processQueue","enqueueLinks","processQueueItem","entity","size_local","mapParticleToEntity","putParticles","backgroundWorker","ipfsNode","ipfsQueue","broadcastApi","syncService","defferedDbApi","importCyberlinks","ipfsApi","ipfsOpts","getIpfsNode","fetchWithDetails","dequeue","dequeueByParent","clearQueue","addContent","dbApiProxy","restartSync","setParams","createBackgroundWorkerApi","api","self","onconnect","ports","CYBLOG_BROADCAST_CHANNEL_NAME","logList","createCyblogChannel","defaultContext","postLogToChannel","level","context","trace","cyblog","consoleLogParams","formattedMessage","formatter","logItem","truncate","appendLog","stacktrace","contextItem","p","ctxItem","consoleLog","getLogs","splice","getConsoleLogParams","createCybLog","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","loaded","__webpack_modules__","m","x","__webpack_exports__","O","amdO","chunkIds","notFulfilled","Infinity","j","every","r","n","getter","__esModule","d","getPrototypeOf","__proto__","mode","ns","create","def","current","getOwnPropertyNames","definition","o","defineProperty","enumerable","f","chunkId","promises","u","miniCssF","g","globalThis","Function","prop","toStringTag","nmd","paths","children","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}