{"version":3,"file":"644.2e2b2aee.js","mappings":"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","sources":["webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/minimal.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/eventemitter3/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/eventemitter3/index.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multihashes/src/index.js","webpack://cyb/./node_modules/@multiformats/multiaddr-to-uri/node_modules/varint/index.js","webpack://cyb/./node_modules/@vascosantos/moving-average/index.js","webpack://cyb/./node_modules/denque/index.js","webpack://cyb/./node_modules/event-iterator/lib/dom.js","webpack://cyb/./node_modules/hashlru/index.js","webpack://cyb/./node_modules/helia/node_modules/eventemitter3/index.js","webpack://cyb/./node_modules/helia/node_modules/rate-limiter-flexible/index.js","webpack://cyb/./node_modules/ieee754/index.js","webpack://cyb/./node_modules/iso-url/index.js","webpack://cyb/./node_modules/iterable-ndjson/browser.js","webpack://cyb/./node_modules/iterable-ndjson/parse.browser.js","webpack://cyb/./node_modules/iterable-ndjson/stringify.js","webpack://cyb/./node_modules/libp2p/node_modules/eventemitter3/index.js","webpack://cyb/./node_modules/libp2p/node_modules/rate-limiter-flexible/index.js","webpack://cyb/./node_modules/merge-options/index.js","webpack://cyb/./node_modules/p-queue/node_modules/eventemitter3/index.js","webpack://cyb/./node_modules/sanitize-filename/index.js","webpack://cyb/./node_modules/timeout-abort-controller/index.js","webpack://cyb/./node_modules/timestamp-nano/dist/timestamp.min.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/crypto/dist/src/random-bytes.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/dist/src/constants.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/dist/src/logger.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@chainsafe/libp2p-yamux/node_modules/@libp2p/logger/dist/src/index.js","webpack://cyb/./node_modules/@chainsafe/libp2p-yamux/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/@chainsafe/libp2p-yamux/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js","webpack://cyb/./node_modules/@chainsafe/libp2p-yamux/dist/src/config.js","webpack://cyb/./node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js","webpack://cyb/./node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js","webpack://cyb/./node_modules/@ipld/dag-cbor/src/index.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/bootstrap/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/bootstrap/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/content-routing/index.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/errors.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/events.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/metrics/tracked-map.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/peer-discovery/index.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/peer-id/index.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/peer-routing/index.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/pubsub/index.js","webpack://cyb/./node_modules/@libp2p/interface/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/@libp2p/interface/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/interface/dist/src/transport/index.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/p-queue/dist/priority-queue.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/p-queue/dist/index.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/constants.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/record/record.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/message/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/interface-datastore/dist/src/key.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/utils.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/p-queue/dist/priority-queue.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/p-queue/dist/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/providers.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/query/query-path.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/dual-kad-dht.js","webpack://cyb/./node_modules/@libp2p/kad-dht/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@libp2p/crypto/dist/src/random-bytes.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@libp2p/crypto/dist/src/util.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/bases/base64.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/kad-dht/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/@libp2p/crypto/dist/src/random-bytes.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/bases/base64.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/peer-collections/dist/src/map.js","webpack://cyb/./node_modules/@libp2p/peer-collections/dist/src/set.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/peer-collections/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/@libp2p/logger/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/error.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/util.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/maconn.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/webrtc/index.browser.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/pb/message.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/private-to-private/handler.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/private-to-public/sdp.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/private-to-public/util.js","webpack://cyb/./node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/webrtc/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/it-ws/dist/src/web-socket.browser.js","webpack://cyb/./node_modules/@libp2p/websockets/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/@libp2p/websockets/dist/src/socket-to-conn.js","webpack://cyb/./node_modules/@libp2p/websockets/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webtransport/dist/src/stream.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webtransport/dist/src/utils/parse-multiaddr.js","webpack://cyb/./node_modules/@libp2p/webtransport/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/src/basics.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/@libp2p/webtransport/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/@multiformats/mafmt/dist/src/index.js","webpack://cyb/./node_modules/@multiformats/multiaddr-matcher/dist/src/index.js","webpack://cyb/./node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://cyb/./node_modules/blockstore-core/dist/src/errors.js","webpack://cyb/./node_modules/blockstore-core/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/blockstore-core/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/blockstore-core/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/blockstore-core/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/blockstore-core/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/cborg/esm/lib/byte-utils.js","webpack://cyb/./node_modules/cborg/esm/lib/common.js","webpack://cyb/./node_modules/cborg/esm/lib/decode.js","webpack://cyb/./node_modules/cborg/esm/lib/encode.js","webpack://cyb/./node_modules/cborg/esm/lib/jump.js","webpack://cyb/./node_modules/cborg/esm/lib/token.js","webpack://cyb/./node_modules/helia/node_modules/@libp2p/logger/dist/src/index.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/@libp2p/logger/dist/src/index.js","webpack://cyb/./node_modules/ipfs-bitswap/dist/src/message/index.js","webpack://cyb/./node_modules/ipfs-bitswap/dist/src/wantlist/index.js","webpack://cyb/./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js","webpack://cyb/./node_modules/ipfs-bitswap/dist/src/constants.js","webpack://cyb/./node_modules/helia/node_modules/p-queue/dist/priority-queue.js","webpack://cyb/./node_modules/helia/node_modules/p-queue/dist/index.js","webpack://cyb/./node_modules/helia/dist/src/pins.js","webpack://cyb/./node_modules/helia/dist/src/utils/datastore-version.js","webpack://cyb/./node_modules/helia/dist/src/helia.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/logger/dist/src/index.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/multiaddr.js","webpack://cyb/./node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js","webpack://cyb/./node_modules/helia/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/helia/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/helia/node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/helia/node_modules/@libp2p/mplex/dist/src/message-types.js","webpack://cyb/./node_modules/helia/node_modules/it-batched-bytes/dist/src/index.js","webpack://cyb/./node_modules/helia/node_modules/@libp2p/mplex/dist/src/encode.js","webpack://cyb/./node_modules/helia/node_modules/@libp2p/mplex/dist/src/mplex.js","webpack://cyb/./node_modules/helia/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/helia/node_modules/ipns/dist/src/pb/ipns.js","webpack://cyb/./node_modules/helia/node_modules/ipns/dist/src/utils.js","webpack://cyb/./node_modules/helia/node_modules/ipns/dist/src/validator.js","webpack://cyb/./node_modules/helia/dist/src/index.js","webpack://cyb/./node_modules/helia/node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://cyb/./node_modules/helia/node_modules/cborg/lib/byte-utils.js","webpack://cyb/./node_modules/helia/node_modules/cborg/lib/common.js","webpack://cyb/./node_modules/helia/node_modules/cborg/lib/decode.js","webpack://cyb/./node_modules/helia/node_modules/cborg/lib/encode.js","webpack://cyb/./node_modules/helia/node_modules/cborg/lib/jump.js","webpack://cyb/./node_modules/helia/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/helia/node_modules/multiformats/src/bases/base36.js","webpack://cyb/./node_modules/helia/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/helia/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/helia/node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/ip-regex/index.js","webpack://cyb/./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/ipfs-bitswap/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/it-byte-stream/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/it-byte-stream/dist/src/index.js","webpack://cyb/./node_modules/it-length-prefixed-stream/dist/src/index.js","webpack://cyb/./node_modules/it-length-prefixed/dist/src/encode.js","webpack://cyb/./node_modules/it-length-prefixed/dist/src/decode.js","webpack://cyb/./node_modules/it-parallel/dist/src/index.js","webpack://cyb/./node_modules/it-pipe/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/libp2p/dist/src/autonat/pb/index.js","webpack://cyb/./node_modules/libp2p/dist/src/autonat/index.js","webpack://cyb/./node_modules/libp2p/dist/src/circuit-relay/constants.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js","webpack://cyb/./node_modules/libp2p/dist/src/circuit-relay/transport/discovery.js","webpack://cyb/./node_modules/libp2p/dist/src/circuit-relay/transport/listener.js","webpack://cyb/./node_modules/libp2p/dist/src/circuit-relay/transport/reservation-store.js","webpack://cyb/./node_modules/libp2p/dist/src/circuit-relay/transport/index.js","webpack://cyb/./node_modules/libp2p/dist/src/circuit-relay/pb/index.js","webpack://cyb/./node_modules/libp2p/dist/src/circuit-relay/utils.js","webpack://cyb/./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js","webpack://cyb/./node_modules/libp2p/node_modules/delay/index.js","webpack://cyb/./node_modules/libp2p/dist/src/dcutr/pb/message.js","webpack://cyb/./node_modules/libp2p/dist/src/dcutr/dcutr.js","webpack://cyb/./node_modules/libp2p/dist/src/errors.js","webpack://cyb/./node_modules/libp2p/dist/src/identify/consts.js","webpack://cyb/./node_modules/libp2p/dist/src/identify/pb/message.js","webpack://cyb/./node_modules/libp2p/dist/src/identify/identify.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/keychain/node_modules/interface-datastore/dist/src/key.js","webpack://cyb/./node_modules/@libp2p/keychain/dist/src/errors.js","webpack://cyb/./node_modules/@libp2p/keychain/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js","webpack://cyb/./node_modules/@libp2p/peer-store/dist/src/pb/peer.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/peer-store/node_modules/interface-datastore/dist/src/key.js","webpack://cyb/./node_modules/@libp2p/peer-store/dist/src/index.js","webpack://cyb/./node_modules/libp2p/dist/src/address-manager/index.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/utils/dist/src/address-sort.js","webpack://cyb/./node_modules/libp2p/node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js","webpack://cyb/./node_modules/libp2p/dist/src/config.js","webpack://cyb/./node_modules/libp2p/dist/src/get-peer.js","webpack://cyb/./node_modules/libp2p/dist/src/connection-manager/auto-dial.js","webpack://cyb/./node_modules/libp2p/dist/src/connection-manager/connection-pruner.js","webpack://cyb/./node_modules/libp2p/dist/src/connection-manager/utils.js","webpack://cyb/./node_modules/libp2p/dist/src/connection-manager/dial-queue.js","webpack://cyb/./node_modules/libp2p/dist/src/connection-manager/index.js","webpack://cyb/./node_modules/libp2p/node_modules/it-merge/node_modules/it-pushable/dist/src/index.js","webpack://cyb/./node_modules/libp2p/dist/src/peer-routing.js","webpack://cyb/./node_modules/libp2p/dist/src/registrar.js","webpack://cyb/./node_modules/libp2p/dist/src/transport-manager.js","webpack://cyb/./node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/@libp2p/multistream-select/node_modules/abortable-iterator/dist/src/abort-error.js","webpack://cyb/./node_modules/@libp2p/multistream-select/dist/src/multistream.js","webpack://cyb/./node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/from-string.js","webpack://cyb/./node_modules/@libp2p/multistream-select/dist/src/select.js","webpack://cyb/./node_modules/@libp2p/multistream-select/dist/src/handle.js","webpack://cyb/./node_modules/libp2p/dist/src/connection/index.js","webpack://cyb/./node_modules/libp2p/dist/src/upgrader.js","webpack://cyb/./node_modules/libp2p/dist/src/libp2p.js","webpack://cyb/./node_modules/libp2p/dist/src/ping/index.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/crypto/dist/src/random-bytes.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js","webpack://cyb/./node_modules/libp2p/node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js","webpack://cyb/./node_modules/libp2p/node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://cyb/./node_modules/libp2p/node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://cyb/./node_modules/libp2p/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://cyb/./node_modules/libp2p/node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/src/bases/base58.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/src/cid.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/src/hashes/digest.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/vendor/varint.js","webpack://cyb/./node_modules/libp2p/node_modules/multiformats/src/varint.js","webpack://cyb/./node_modules/libp2p/node_modules/p-queue/dist/priority-queue.js","webpack://cyb/./node_modules/libp2p/node_modules/p-queue/dist/index.js","webpack://cyb/./node_modules/libp2p/node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/mortice/node_modules/p-timeout/index.js","webpack://cyb/./node_modules/observable-webworkers/dist/src/index.js","webpack://cyb/./node_modules/multiformats/src/bases/base32.js","webpack://cyb/./node_modules/multiformats/src/bases/base36.js","webpack://cyb/./node_modules/multiformats/src/bases/base64.js","webpack://cyb/./node_modules/multiformats/src/basics.js","webpack://cyb/./node_modules/multiformats/src/bytes.js","webpack://cyb/./node_modules/multiformats/src/codecs/json.js","webpack://cyb/./node_modules/multiformats/src/codecs/raw.js","webpack://cyb/./node_modules/multiformats/src/hashes/identity.js","webpack://cyb/./node_modules/multiformats/src/hashes/sha2-browser.js","webpack://cyb/./node_modules/p-event/node_modules/p-timeout/index.js","webpack://cyb/./node_modules/p-queue/dist/priority-queue.js","webpack://cyb/./node_modules/p-queue/dist/index.js","webpack://cyb/./node_modules/p-timeout/index.js","webpack://cyb/./node_modules/private-ip/lib/index.js","webpack://cyb/./node_modules/private-ip/index.js","webpack://cyb/./node_modules/progress-events/dist/src/index.js","webpack://cyb/./node_modules/uint8arraylist/dist/src/index.js","webpack://cyb/./node_modules/uint8arrays/dist/src/util/bases.js","webpack://cyb/./node_modules/wherearewe/src/index.js"],"sourcesContent":["// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\n * Multihash implementation in JavaScript.\n */\n'use strict'\n\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\n\nconst codes = /** @type {import('./types').CodeNameMap} */({})\n\n// eslint-disable-next-line guard-for-in\nfor (const key in names) {\n  const name = /** @type {HashName} */(key)\n  codes[names[name]] = name\n}\nObject.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(hash, 'base16')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString (hash) {\n  return uint8ArrayFromString(hash, 'base16')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? uint8ArrayToString(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = /** @type {HashCode} */(varint.decode(bytes))\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  const len = varint.decode(bytes)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  }\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  // @ts-ignore\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode (code) {\n  if (isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  decode(multihash) // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix (multihash) {\n  validate(multihash)\n\n  return multihash.subarray(0, 2)\n}\n\nmodule.exports = {\n  names,\n  codes,\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n}\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","'use strict'\n\nconst exp = Math.exp\n\nexports =\nmodule.exports =\nfunction MovingAverage (timespan) {\n  if (typeof timespan !== 'number') { throw new Error('must provide a timespan to the moving average constructor') }\n\n  if (timespan <= 0) { throw new Error('must provide a timespan > 0 to the moving average constructor') }\n\n  let ma     // moving average\n  let v = 0  // variance\n  let d = 0  // deviation\n  let f = 0  // forecast\n\n  let previousTime\n\n  let ret = {}\n\n  function alpha (t, pt) {\n    return 1 - (exp(-(t - pt) / timespan))\n  }\n\n  ret.push =\n  function push (time, value) {\n    if (previousTime) {\n      // calculate moving average\n      const a = alpha(time, previousTime)\n      const diff = value - ma\n      const incr = a * diff\n      ma = a * value + (1 - a) * ma\n      // calculate variance & deviation\n      v = (1 - a) * (v + diff * incr)\n      d = Math.sqrt(v)\n      // calculate forecast\n      f = ma + a * diff\n    } else {\n      ma = value\n    }\n    previousTime = time\n  }\n\n  // Exponential Moving Average\n\n  ret.movingAverage =\n  function movingAverage () {\n    return ma\n  }\n\n  // Variance\n  ret.variance =\n  function variance () {\n    return v\n  }\n\n  ret.deviation =\n  function deviation () {\n    return d\n  }\n\n  ret.forecast =\n  function forecast () {\n    return f\n  }\n\n  return ret\n}\n","'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array, options) {\n  var options = options || {};\n  this._capacity = options.capacity;\n\n  this._head = 0;\n  this._tail = 0;\n\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  } else {\n    this._capacityMask = 0x3;\n    this._list = new Array(4);\n  }\n}\n\n/**\n * --------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peekAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (arguments.length === 0) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._capacity && this.size() > this._capacity) this.pop();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (arguments.length === 0) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n  if (this._capacity && this.size() > this._capacity) {\n    this.shift();\n  }\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = (i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._list = new Array(this._list.length);\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  var length = array.length;\n  var capacity = this._nextPowerOf2(length);\n\n  this._list = new Array(capacity);\n  this._capacityMask = capacity - 1;\n  this._tail = length;\n\n  for (var i = 0; i < length; i++) this._list[i] = array[i];\n};\n\n/**\n *\n * @param fullCopy\n * @param size Initialize the array with a specific size. Will default to the current list size\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy, size) {\n  var src = this._list;\n  var capacity = src.length;\n  var length = this.length;\n  size = size | length;\n\n  // No prealloc requested and the buffer is contiguous\n  if (size == length && this._head < this._tail) {\n    // Simply do a fast slice copy\n    return this._list.slice(this._head, this._tail);\n  }\n\n  var dest = new Array(size);\n\n  var k = 0;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < capacity; i++) dest[k++] = src[i];\n    for (i = 0; i < this._tail; i++) dest[k++] = src[i];\n  } else {\n    for (i = this._head; i < this._tail; i++) dest[k++] = src[i];\n  }\n\n  return dest;\n}\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head != 0) {\n    // double array size and copy existing data, head to end, then beginning to tail.\n    var newList = this._copyArray(true, this._list.length << 1);\n\n    this._tail = this._list.length;\n    this._head = 0;\n\n    this._list = newList;\n  } else {\n    this._tail = this._list.length;\n    this._list.length <<= 1;\n  }\n\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n/**\n * Find the next power of 2, at least 4\n * @private\n * @param {number} num \n * @returns {number}\n */\nDenque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {\n  var log2 = Math.log(num) / Math.log(2);\n  var nextPow2 = 1 << (log2 + 1);\n\n  return Math.max(nextPow2, 4);\n}\n\nmodule.exports = Denque;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst event_iterator_1 = require(\"./event-iterator\");\nexports.EventIterator = event_iterator_1.EventIterator;\nfunction subscribe(event, options, evOptions) {\n    return new event_iterator_1.EventIterator(({ push }) => {\n        this.addEventListener(event, push, options);\n        return () => this.removeEventListener(event, push, options);\n    }, evOptions);\n}\nexports.subscribe = subscribe;\nexports.default = event_iterator_1.EventIterator;\n","module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","const RateLimiterRedis = require('./lib/RateLimiterRedis');\nconst RateLimiterMongo = require('./lib/RateLimiterMongo');\nconst RateLimiterMySQL = require('./lib/RateLimiterMySQL');\nconst RateLimiterPostgres = require('./lib/RateLimiterPostgres');\nconst {RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster} = require('./lib/RateLimiterCluster');\nconst RateLimiterMemory = require('./lib/RateLimiterMemory');\nconst RateLimiterMemcache = require('./lib/RateLimiterMemcache');\nconst RLWrapperBlackAndWhite = require('./lib/RLWrapperBlackAndWhite');\nconst RateLimiterUnion = require('./lib/RateLimiterUnion');\nconst RateLimiterQueue = require('./lib/RateLimiterQueue');\nconst BurstyRateLimiter = require('./lib/BurstyRateLimiter');\nconst RateLimiterRes = require('./lib/RateLimiterRes');\n\nmodule.exports = {\n  RateLimiterRedis,\n  RateLimiterMongo,\n  RateLimiterMySQL,\n  RateLimiterPostgres,\n  RateLimiterMemory,\n  RateLimiterMemcache,\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster,\n  RLWrapperBlackAndWhite,\n  RateLimiterUnion,\n  RateLimiterQueue,\n  BurstyRateLimiter,\n  RateLimiterRes,\n};\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict'\n\nconst {\n  URLWithLegacySupport,\n  format,\n  URLSearchParams,\n  defaultBase\n} = require('./src/url')\nconst relative = require('./src/relative')\n\nmodule.exports = {\n  URL: URLWithLegacySupport,\n  URLSearchParams,\n  format,\n  relative,\n  defaultBase\n}\n","module.exports = require('./parse.browser')\nmodule.exports.parse = require('./parse.browser')\nmodule.exports.stringify = require('./stringify')\n","/* eslint-env browser */\n\nmodule.exports = source => (async function * () {\n  const matcher = /\\r?\\n/\n  const decoder = new TextDecoder('utf8')\n  let buffer = ''\n  for await (let chunk of source) {\n    if (typeof chunk === 'string') {\n      chunk = new TextEncoder().encode(chunk)\n    }\n    buffer += decoder.decode(chunk, { stream: true })\n    const parts = buffer.split(matcher)\n    buffer = parts.pop()\n    for (let i = 0; i < parts.length; i++) yield JSON.parse(parts[i])\n  }\n  buffer += decoder.decode()\n  if (buffer) yield JSON.parse(buffer)\n})()\n","module.exports = source => (async function * () {\n  for await (const obj of source) {\n    yield JSON.stringify(obj) + '\\n'\n  }\n})()\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","const RateLimiterRedis = require('./lib/RateLimiterRedis');\nconst RateLimiterMongo = require('./lib/RateLimiterMongo');\nconst RateLimiterMySQL = require('./lib/RateLimiterMySQL');\nconst RateLimiterPostgres = require('./lib/RateLimiterPostgres');\nconst {RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster} = require('./lib/RateLimiterCluster');\nconst RateLimiterMemory = require('./lib/RateLimiterMemory');\nconst RateLimiterMemcache = require('./lib/RateLimiterMemcache');\nconst RLWrapperBlackAndWhite = require('./lib/RLWrapperBlackAndWhite');\nconst RateLimiterUnion = require('./lib/RateLimiterUnion');\nconst RateLimiterQueue = require('./lib/RateLimiterQueue');\nconst BurstyRateLimiter = require('./lib/BurstyRateLimiter');\nconst RateLimiterRes = require('./lib/RateLimiterRes');\n\nmodule.exports = {\n  RateLimiterRedis,\n  RateLimiterMongo,\n  RateLimiterMySQL,\n  RateLimiterPostgres,\n  RateLimiterMemory,\n  RateLimiterMemcache,\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster,\n  RLWrapperBlackAndWhite,\n  RateLimiterUnion,\n  RateLimiterQueue,\n  BurstyRateLimiter,\n  RateLimiterRes,\n};\n","'use strict';\nconst isOptionObject = require('is-plain-obj');\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/*jshint node:true*/\n'use strict';\n\n/**\n * Replaces characters in strings that are illegal/unsafe for filenames.\n * Unsafe characters are either removed or replaced by a substitute set\n * in the optional `options` object.\n *\n * Illegal Characters on Various Operating Systems\n * / ? < > \\ : * | \"\n * https://kb.acronis.com/content/39790\n *\n * Unicode Control codes\n * C0 0x00-0x1f & C1 (0x80-0x9f)\n * http://en.wikipedia.org/wiki/C0_and_C1_control_codes\n *\n * Reserved filenames on Unix-based systems (\".\", \"..\")\n * Reserved filenames in Windows (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\",\n * \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\",\n * \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", and\n * \"LPT9\") case-insesitively and with or without filename extensions.\n *\n * Capped at 255 characters in length.\n * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs\n *\n * @param  {String} input   Original filename\n * @param  {Object} options {replacement: String | Function }\n * @return {String}         Sanitized filename\n */\n\nvar truncate = require(\"truncate-utf8-bytes\");\n\nvar illegalRe = /[\\/\\?<>\\\\:\\*\\|\"]/g;\nvar controlRe = /[\\x00-\\x1f\\x80-\\x9f]/g;\nvar reservedRe = /^\\.+$/;\nvar windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\\..*)?$/i;\nvar windowsTrailingRe = /[\\. ]+$/;\n\nfunction sanitize(input, replacement) {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be string');\n  }\n  var sanitized = input\n    .replace(illegalRe, replacement)\n    .replace(controlRe, replacement)\n    .replace(reservedRe, replacement)\n    .replace(windowsReservedRe, replacement)\n    .replace(windowsTrailingRe, replacement);\n  return truncate(sanitized, 255);\n}\n\nmodule.exports = function (input, options) {\n  var replacement = (options && options.replacement) || '';\n  var output = sanitize(input, replacement);\n  if (replacement === '') {\n    return output;\n  }\n  return sanitize(output, '');\n};\n","'use strict'\n\nconst { AbortController } = globalThis\n\n// @ts-expect-error no types\nconst retimer = require('retimer')\n\nclass TimeoutController extends AbortController {\n  /**\n   * @constructor\n   * @param {number} ms milliseconds\n   */\n  constructor (ms) {\n    super()\n    this._ms = ms\n    this._timer = retimer(() => this.abort(), ms)\n    // Patch for safari not supported extending built in classes\n    Object.setPrototypeOf(this, TimeoutController.prototype)\n  }\n\n  /**\n   * Aborts the controller and clears the timer\n   */\n  abort () {\n    this._timer.clear()\n    return super.abort()\n  }\n\n  /**\n   * Clears the timer\n   */\n  clear () {\n    this._timer.clear()\n  }\n\n  /**\n   * Resets the timer\n   */\n  reset () {\n    this._timer.clear()\n    this._timer = retimer(() => this.abort(), this._ms)\n  }\n}\n\nmodule.exports = {\n  TimeoutController\n}\n","var Timestamp=function(){\"undefined\"!=typeof module&&(module.exports=d);var l=86400,s=3200,T=146097*s/400,e=l*T,f=1e3*e,c=864e13,g=4294967296,h=1e6,u=\"000000000\",m=Math.trunc||function(n){var t=n-n%1;return 0==t&&(n<0||0===n&&1/n!=1/0)?-0:t},n=d.prototype,o=(d.fromDate=function(n){return new d(+n)},d.fromInt64BE=r(0,1,2,3,0,4),d.fromInt64LE=r(3,2,1,0,4,0),d.fromString=function(n){var e,r=new d,n=(n+=\"\").replace(/^\\s*[+\\-]?\\d+/,function(n){var n=+n,t=1970+(n-1970)%400;return r.year=n-t,t}).replace(/(?:Z|([+\\-]\\d{2}):?(\\d{2}))$/,function(n,t,r){return t<0&&(r*=-1),e=6e4*(60*+t+ +r),\"\"}).replace(/\\.\\d+$/,function(n){return r.nano=+(n+u).substr(1,9),\"\"}).split(/\\D+/);1<n.length?n[1]--:n[1]=0;if(r.time=e=Date.UTC.apply(Date,n)-(e||0),isNaN(e))throw new TypeError(\"Invalid Date\");return p(r)},d.fromTimeT=function(n){return y(n,0)},n.year=0,n.time=0,n.nano=0,n.addNano=function(n){return this.nano+=+n||0,this},n.getNano=function(){var n=p(this);return(n.time%1e3*h+ +n.nano+1e9)%1e9},n.getTimeT=function(){var n=p(this),t=Math.floor(n.time/1e3),n=n.year;n&&(t+=n*T*l/s);return t},n.getYear=function(){return this.toDate().getUTCFullYear()+this.year},n.toDate=function(){return M(p(this).time)},n.toJSON=function(){return this.toString().replace(/0{1,6}Z$/,\"Z\")},n.toString=function(n){var t=this,r=t.toDate(),u={H:function(){return C(r.getUTCHours())},L:function(){return D(r.getUTCMilliseconds(),3)},M:function(){return C(r.getUTCMinutes())},N:function(){return D(t.getNano(),9)},S:function(){return C(r.getUTCSeconds())},Y:function(){var n=t.getYear();return 999999<n?\"+\"+n:9999<n?\"+\"+D(n,6):0<=n?D(n,4):-999999<=n?\"-\"+D(-n,6):n},a:function(){return a[r.getUTCDay()]},b:function(){return i[r.getUTCMonth()]},d:function(){return C(r.getUTCDate())},e:function(){return function(n){return(9<n?\"\":\" \")+(0|n)}(r.getUTCDate())},m:function(){return C(r.getUTCMonth()+1)}};return function e(n){return n.replace(/%./g,function(n){var t=n[1],r=v[t],t=u[t];return r?e(r):t?t():n})}(n||o)},n.writeInt64BE=t(0,1,2,3,0,4),n.writeInt64LE=t(3,2,1,0,4,0),\"%Y-%m-%dT%H:%M:%S.%NZ\"),i=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],a=[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],v={\"%\":\"%\",F:\"%Y-%m-%d\",n:\"\\n\",R:\"%H:%M\",T:\"%H:%M:%S\",t:\"\\t\",X:\"%T\",Z:\"GMT\",z:\"+0000\"};return d;function d(n,t,r){var e=this;if(!(e instanceof d))return new d(n,t,r);e.time=+n||0,e.nano=+t||0,e.year=+r||0,p(e)}function p(n){var t,r,e,u=n.year,o=n.time,i=n.nano,a=((i<0||h<=i)&&(i-=(r=Math.floor(i/h))*h,o+=r,r=1),u%s);return(o<-c||c<o||a)&&((t=m(o/f))&&(u+=t*s,o-=t*f),(e=M(o)).setUTCFullYear(a+e.getUTCFullYear()),e=(o=+e)+(t=m((u-=a)/s))*f,t&&-c<=e&&e<=c&&(u-=t*s,o=e),r=1),r&&(n.year=u,n.time=o,n.nano=i),n}function M(n){var t=new Date(0);return t.setTime(n),t}function y(n,t){n=+n||0;var r=m((t=(t|0)*g)/e)+m(n/e),t=t%e+n%e,n=m(t/e);return n&&(r+=n,t-=n*e),new d(1e3*t,0,r*s)}function t(e,u,o,i,a,f){return function(n,t){var r=p(this);n=n||new Array(8);w(n,t|=0);var e=Math.floor(r.time/1e3),r=r.year*(T*l/s),u=m(r/g)+m(e/g),r=r%g+e%g,e=Math.floor(r/g);e&&(u+=e,r-=e*g);return c(n,t+a,u),c(n,t+f,r),n};function c(n,t,r){n[t+e]=r>>24&255,n[t+u]=r>>16&255,n[t+o]=r>>8&255,n[t+i]=255&r}}function r(r,e,u,o,i,a){return function(n,t){w(n,t|=0);var r=f(n,t+i);return y(f(n,t+a),r)};function f(n,t){return 16777216*n[t+r]+(n[t+e]<<16|n[t+u]<<8|n[t+o])}}function w(n,t){n=n&&n.length;if(null==n)throw new TypeError(\"Invalid Buffer\");if(n<t+8)throw new RangeError(\"Out of range\")}function C(n){return(9<n?\"\":\"0\")+(0|n)}function D(n,t){return(u+(0|n)).substr(-t)}}();","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { randomBytes as randB } from '@noble/hashes/utils';\nexport default function randomBytes(length) {\n    if (isNaN(length) || length <= 0) {\n        throw new CodeError('random bytes length must be a Number bigger than 0', 'ERR_INVALID_LENGTH');\n    }\n    return randB(length);\n}\n//# sourceMappingURL=random-bytes.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","export const NOISE_MSG_MAX_LENGTH_BYTES = 65535;\nexport const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;\nexport const DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);\n//# sourceMappingURL=constants.js.map","import { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nconst allocUnsafe = (len) => {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.allocUnsafe(len);\n    }\n    return new Uint8Array(len);\n};\nexport const uint16BEEncode = (value) => {\n    const target = allocUnsafe(2);\n    new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false);\n    return target;\n};\nuint16BEEncode.bytes = 2;\nexport const uint16BEDecode = (data) => {\n    if (data.length < 2)\n        throw RangeError('Could not decode int16BE');\n    if (data instanceof Uint8Array) {\n        return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);\n    }\n    return data.getUint16(0);\n};\nuint16BEDecode.bytes = 2;\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\nexport function encode0(message) {\n    return uint8ArrayConcat([message.ne, message.ciphertext], message.ne.length + message.ciphertext.length);\n}\nexport function encode1(message) {\n    return uint8ArrayConcat([message.ne, message.ns, message.ciphertext], message.ne.length + message.ns.length + message.ciphertext.length);\n}\nexport function encode2(message) {\n    return uint8ArrayConcat([message.ns, message.ciphertext], message.ns.length + message.ciphertext.length);\n}\nexport function decode0(input) {\n    if (input.length < 32) {\n        throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');\n    }\n    return {\n        ne: input.subarray(0, 32),\n        ciphertext: input.subarray(32, input.length),\n        ns: new Uint8Array(0)\n    };\n}\nexport function decode1(input) {\n    if (input.length < 80) {\n        throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');\n    }\n    return {\n        ne: input.subarray(0, 32),\n        ns: input.subarray(32, 80),\n        ciphertext: input.subarray(80, input.length)\n    };\n}\nexport function decode2(input) {\n    if (input.length < 48) {\n        throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');\n    }\n    return {\n        ne: new Uint8Array(0),\n        ns: input.subarray(0, 48),\n        ciphertext: input.subarray(48, input.length)\n    };\n}\n//# sourceMappingURL=encoder.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var NoiseExtensions;\n(function (NoiseExtensions) {\n    let _codec;\n    NoiseExtensions.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.webtransportCerthashes != null) {\n                    for (const value of obj.webtransportCerthashes) {\n                        w.uint32(10);\n                        w.bytes(value);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    webtransportCerthashes: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.webtransportCerthashes.push(reader.bytes());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    NoiseExtensions.encode = (obj) => {\n        return encodeMessage(obj, NoiseExtensions.codec());\n    };\n    NoiseExtensions.decode = (buf) => {\n        return decodeMessage(buf, NoiseExtensions.codec());\n    };\n})(NoiseExtensions || (NoiseExtensions = {}));\nexport var NoiseHandshakePayload;\n(function (NoiseHandshakePayload) {\n    let _codec;\n    NoiseHandshakePayload.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (opts.writeDefaults === true || (obj.identityKey != null && obj.identityKey.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.identityKey ?? new Uint8Array(0));\n                }\n                if (opts.writeDefaults === true || (obj.identitySig != null && obj.identitySig.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.identitySig ?? new Uint8Array(0));\n                }\n                if (obj.extensions != null) {\n                    w.uint32(34);\n                    NoiseExtensions.codec().encode(obj.extensions, w, {\n                        writeDefaults: false\n                    });\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    identityKey: new Uint8Array(0),\n                    identitySig: new Uint8Array(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.identityKey = reader.bytes();\n                            break;\n                        case 2:\n                            obj.identitySig = reader.bytes();\n                            break;\n                        case 4:\n                            obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    NoiseHandshakePayload.encode = (obj) => {\n        return encodeMessage(obj, NoiseHandshakePayload.codec());\n    };\n    NoiseHandshakePayload.decode = (buf) => {\n        return decodeMessage(buf, NoiseHandshakePayload.codec());\n    };\n})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));\n//# sourceMappingURL=payload.js.map","import { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { DUMP_SESSION_KEYS } from './constants.js';\nconst log = logger('libp2p:noise');\nexport { log as logger };\nlet keyLogger;\nif (DUMP_SESSION_KEYS) {\n    keyLogger = log;\n}\nelse {\n    keyLogger = Object.assign(() => { }, {\n        enabled: false,\n        trace: () => { },\n        error: () => { }\n    });\n}\nexport function logLocalStaticKeys(s) {\n    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${uint8ArrayToString(s.publicKey, 'hex')}`);\n    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${uint8ArrayToString(s.privateKey, 'hex')}`);\n}\nexport function logLocalEphemeralKeys(e) {\n    if (e) {\n        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${uint8ArrayToString(e.publicKey, 'hex')}`);\n        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${uint8ArrayToString(e.privateKey, 'hex')}`);\n    }\n    else {\n        keyLogger('Missing local ephemeral keys.');\n    }\n}\nexport function logRemoteStaticKey(rs) {\n    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${uint8ArrayToString(rs, 'hex')}`);\n}\nexport function logRemoteEphemeralKey(re) {\n    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${uint8ArrayToString(re, 'hex')}`);\n}\nexport function logCipherState(session) {\n    if (session.cs1 && session.cs2) {\n        keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${uint8ArrayToString(session.cs1.k, 'hex')}`);\n        keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${uint8ArrayToString(session.cs2.k, 'hex')}`);\n    }\n    else {\n        keyLogger('Missing cipher state.');\n    }\n}\n//# sourceMappingURL=logger.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import debug from 'debug';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64 } from 'multiformats/bases/base64';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n//# sourceMappingURL=index.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","// Protocol violation errors\nexport const ERR_INVALID_FRAME = 'ERR_INVALID_FRAME';\nexport const ERR_UNREQUESTED_PING = 'ERR_UNREQUESTED_PING';\nexport const ERR_NOT_MATCHING_PING = 'ERR_NOT_MATCHING_PING';\nexport const ERR_STREAM_ALREADY_EXISTS = 'ERR_STREAM_ALREADY_EXISTS';\nexport const ERR_DECODE_INVALID_VERSION = 'ERR_DECODE_INVALID_VERSION';\nexport const ERR_BOTH_CLIENTS = 'ERR_BOTH_CLIENTS';\nexport const ERR_RECV_WINDOW_EXCEEDED = 'ERR_RECV_WINDOW_EXCEEDED';\nexport const PROTOCOL_ERRORS = new Set([\n    ERR_INVALID_FRAME,\n    ERR_UNREQUESTED_PING,\n    ERR_NOT_MATCHING_PING,\n    ERR_STREAM_ALREADY_EXISTS,\n    ERR_DECODE_INVALID_VERSION,\n    ERR_BOTH_CLIENTS,\n    ERR_RECV_WINDOW_EXCEEDED\n]);\n// local errors\nexport const ERR_INVALID_CONFIG = 'ERR_INVALID_CONFIG';\nexport const ERR_MUXER_LOCAL_CLOSED = 'ERR_MUXER_LOCAL_CLOSED';\nexport const ERR_MUXER_REMOTE_CLOSED = 'ERR_MUXER_REMOTE_CLOSED';\nexport const ERR_STREAM_RESET = 'ERR_STREAM_RESET';\nexport const ERR_STREAM_ABORT = 'ERR_STREAM_ABORT';\nexport const ERR_MAX_OUTBOUND_STREAMS_EXCEEDED = 'ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED';\nexport const ERR_DECODE_IN_PROGRESS = 'ERR_DECODE_IN_PROGRESS';\n/**\n * INITIAL_STREAM_WINDOW is the initial stream window size.\n *\n * Not an implementation choice, this is defined in the specification\n */\nexport const INITIAL_STREAM_WINDOW = 256 * 1024;\n/**\n * Default max stream window\n */\nexport const MAX_STREAM_WINDOW = 16 * 1024 * 1024;\n//# sourceMappingURL=constants.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { ERR_INVALID_CONFIG, INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js';\nexport const defaultConfig = {\n    log: logger('libp2p:yamux'),\n    enableKeepAlive: true,\n    keepAliveInterval: 30000,\n    maxInboundStreams: 1000,\n    maxOutboundStreams: 1000,\n    initialStreamWindowSize: INITIAL_STREAM_WINDOW,\n    maxStreamWindowSize: MAX_STREAM_WINDOW,\n    maxMessageSize: 64 * 1024\n};\nexport function verifyConfig(config) {\n    if (config.keepAliveInterval <= 0) {\n        throw new CodeError('keep-alive interval must be positive', ERR_INVALID_CONFIG);\n    }\n    if (config.maxInboundStreams < 0) {\n        throw new CodeError('max inbound streams must be larger or equal 0', ERR_INVALID_CONFIG);\n    }\n    if (config.maxOutboundStreams < 0) {\n        throw new CodeError('max outbound streams must be larger or equal 0', ERR_INVALID_CONFIG);\n    }\n    if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {\n        throw new CodeError('InitialStreamWindowSize must be larger or equal 256 kB', ERR_INVALID_CONFIG);\n    }\n    if (config.maxStreamWindowSize < config.initialStreamWindowSize) {\n        throw new CodeError('MaxStreamWindowSize must be larger than the InitialStreamWindowSize', ERR_INVALID_CONFIG);\n    }\n    if (config.maxStreamWindowSize > 2 ** 32 - 1) {\n        throw new CodeError('MaxStreamWindowSize must be less than equal MAX_UINT32', ERR_INVALID_CONFIG);\n    }\n    if (config.maxMessageSize < 1024) {\n        throw new CodeError('MaxMessageSize must be greater than a kilobyte', ERR_INVALID_CONFIG);\n    }\n}\n//# sourceMappingURL=config.js.map","export var FrameType;\n(function (FrameType) {\n    /** Used to transmit data. May transmit zero length payloads depending on the flags. */\n    FrameType[FrameType[\"Data\"] = 0] = \"Data\";\n    /** Used to updated the senders receive window size. This is used to implement per-session flow control. */\n    FrameType[FrameType[\"WindowUpdate\"] = 1] = \"WindowUpdate\";\n    /** Used to measure RTT. It can also be used to heart-beat and do keep-alives over TCP. */\n    FrameType[FrameType[\"Ping\"] = 2] = \"Ping\";\n    /** Used to close a session. */\n    FrameType[FrameType[\"GoAway\"] = 3] = \"GoAway\";\n})(FrameType || (FrameType = {}));\nexport var Flag;\n(function (Flag) {\n    /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */\n    Flag[Flag[\"SYN\"] = 1] = \"SYN\";\n    /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */\n    Flag[Flag[\"ACK\"] = 2] = \"ACK\";\n    /** Performs a half-close of a stream. May be sent with a data message or window update. */\n    Flag[Flag[\"FIN\"] = 4] = \"FIN\";\n    /** Reset a stream immediately. May be sent with a data or window update message. */\n    Flag[Flag[\"RST\"] = 8] = \"RST\";\n})(Flag || (Flag = {}));\nconst flagCodes = Object.values(Flag).filter((x) => typeof x !== 'string');\nexport const YAMUX_VERSION = 0;\nexport var GoAwayCode;\n(function (GoAwayCode) {\n    GoAwayCode[GoAwayCode[\"NormalTermination\"] = 0] = \"NormalTermination\";\n    GoAwayCode[GoAwayCode[\"ProtocolError\"] = 1] = \"ProtocolError\";\n    GoAwayCode[GoAwayCode[\"InternalError\"] = 2] = \"InternalError\";\n})(GoAwayCode || (GoAwayCode = {}));\nexport const HEADER_LENGTH = 12;\nexport function stringifyHeader(header) {\n    const flags = flagCodes.filter(f => (header.flag & f) === f).map(f => Flag[f]).join('|');\n    return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`;\n}\n//# sourceMappingURL=frame.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { AbstractStream } from '@libp2p/interface/stream-muxer/stream';\nimport each from 'it-foreach';\nimport { ERR_RECV_WINDOW_EXCEEDED, ERR_STREAM_ABORT, INITIAL_STREAM_WINDOW } from './constants.js';\nimport { Flag, FrameType, HEADER_LENGTH } from './frame.js';\nexport var StreamState;\n(function (StreamState) {\n    StreamState[StreamState[\"Init\"] = 0] = \"Init\";\n    StreamState[StreamState[\"SYNSent\"] = 1] = \"SYNSent\";\n    StreamState[StreamState[\"SYNReceived\"] = 2] = \"SYNReceived\";\n    StreamState[StreamState[\"Established\"] = 3] = \"Established\";\n    StreamState[StreamState[\"Finished\"] = 4] = \"Finished\";\n})(StreamState || (StreamState = {}));\n/** YamuxStream is used to represent a logical stream within a session */\nexport class YamuxStream extends AbstractStream {\n    name;\n    state;\n    config;\n    _id;\n    /** The number of available bytes to send */\n    sendWindowCapacity;\n    /** Callback to notify that the sendWindowCapacity has been updated */\n    sendWindowCapacityUpdate;\n    /** The number of bytes available to receive in a full window */\n    recvWindow;\n    /** The number of available bytes to receive */\n    recvWindowCapacity;\n    /**\n     * An 'epoch' is the time it takes to process and read data\n     *\n     * Used in conjunction with RTT to determine whether to increase the recvWindow\n     */\n    epochStart;\n    getRTT;\n    sendFrame;\n    constructor(init) {\n        super({\n            ...init,\n            onEnd: (err) => {\n                this.state = StreamState.Finished;\n                init.onEnd?.(err);\n            }\n        });\n        this.config = init.config;\n        this._id = parseInt(init.id, 10);\n        this.name = init.name;\n        this.state = init.state;\n        this.sendWindowCapacity = INITIAL_STREAM_WINDOW;\n        this.recvWindow = this.config.initialStreamWindowSize;\n        this.recvWindowCapacity = this.recvWindow;\n        this.epochStart = Date.now();\n        this.getRTT = init.getRTT;\n        this.sendFrame = init.sendFrame;\n        this.source = each(this.source, () => {\n            this.sendWindowUpdate();\n        });\n    }\n    /**\n     * Send a message to the remote muxer informing them a new stream is being\n     * opened.\n     *\n     * This is a noop for Yamux because the first window update is sent when\n     * .newStream is called on the muxer which opens the stream on the remote.\n     */\n    async sendNewStream() {\n    }\n    /**\n     * Send a data message to the remote muxer\n     */\n    async sendData(buf, options = {}) {\n        buf = buf.sublist();\n        // send in chunks, waiting for window updates\n        while (buf.byteLength !== 0) {\n            // wait for the send window to refill\n            if (this.sendWindowCapacity === 0) {\n                await this.waitForSendWindowCapacity(options);\n            }\n            // check we didn't close while waiting for send window capacity\n            if (this.status !== 'open') {\n                return;\n            }\n            // send as much as we can\n            const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf.length);\n            const flags = this.getSendFlags();\n            this.sendFrame({\n                type: FrameType.Data,\n                flag: flags,\n                streamID: this._id,\n                length: toSend\n            }, buf.subarray(0, toSend));\n            this.sendWindowCapacity -= toSend;\n            buf.consume(toSend);\n        }\n    }\n    /**\n     * Send a reset message to the remote muxer\n     */\n    async sendReset() {\n        this.sendFrame({\n            type: FrameType.WindowUpdate,\n            flag: Flag.RST,\n            streamID: this._id,\n            length: 0\n        });\n    }\n    /**\n     * Send a message to the remote muxer, informing them no more data messages\n     * will be sent by this end of the stream\n     */\n    async sendCloseWrite() {\n        const flags = this.getSendFlags() | Flag.FIN;\n        this.sendFrame({\n            type: FrameType.WindowUpdate,\n            flag: flags,\n            streamID: this._id,\n            length: 0\n        });\n    }\n    /**\n     * Send a message to the remote muxer, informing them no more data messages\n     * will be read by this end of the stream\n     */\n    async sendCloseRead() {\n    }\n    /**\n     * Wait for the send window to be non-zero\n     *\n     * Will throw with ERR_STREAM_ABORT if the stream gets aborted\n     */\n    async waitForSendWindowCapacity(options = {}) {\n        if (this.sendWindowCapacity > 0) {\n            return;\n        }\n        let resolve;\n        let reject;\n        const abort = () => {\n            if (this.status === 'open') {\n                reject(new CodeError('stream aborted', ERR_STREAM_ABORT));\n            }\n            else {\n                // the stream was closed already, ignore the failure to send\n                resolve();\n            }\n        };\n        options.signal?.addEventListener('abort', abort);\n        try {\n            await new Promise((_resolve, _reject) => {\n                this.sendWindowCapacityUpdate = () => {\n                    _resolve();\n                };\n                reject = _reject;\n                resolve = _resolve;\n            });\n        }\n        finally {\n            options.signal?.removeEventListener('abort', abort);\n        }\n    }\n    /**\n     * handleWindowUpdate is called when the stream receives a window update frame\n     */\n    handleWindowUpdate(header) {\n        this.log?.trace('stream received window update id=%s', this._id);\n        this.processFlags(header.flag);\n        // increase send window\n        const available = this.sendWindowCapacity;\n        this.sendWindowCapacity += header.length;\n        // if the update increments a 0 availability, notify the stream that sending can resume\n        if (available === 0 && header.length > 0) {\n            this.sendWindowCapacityUpdate?.();\n        }\n    }\n    /**\n     * handleData is called when the stream receives a data frame\n     */\n    async handleData(header, readData) {\n        this.log?.trace('stream received data id=%s', this._id);\n        this.processFlags(header.flag);\n        // check that our recv window is not exceeded\n        if (this.recvWindowCapacity < header.length) {\n            throw new CodeError('receive window exceeded', ERR_RECV_WINDOW_EXCEEDED, { available: this.recvWindowCapacity, recv: header.length });\n        }\n        const data = await readData();\n        this.recvWindowCapacity -= header.length;\n        this.sourcePush(data);\n    }\n    /**\n     * processFlags is used to update the state of the stream based on set flags, if any.\n     */\n    processFlags(flags) {\n        if ((flags & Flag.ACK) === Flag.ACK) {\n            if (this.state === StreamState.SYNSent) {\n                this.state = StreamState.Established;\n            }\n        }\n        if ((flags & Flag.FIN) === Flag.FIN) {\n            this.remoteCloseWrite();\n        }\n        if ((flags & Flag.RST) === Flag.RST) {\n            this.reset();\n        }\n    }\n    /**\n     * getSendFlags determines any flags that are appropriate\n     * based on the current stream state.\n     *\n     * The state is updated as a side-effect.\n     */\n    getSendFlags() {\n        switch (this.state) {\n            case StreamState.Init:\n                this.state = StreamState.SYNSent;\n                return Flag.SYN;\n            case StreamState.SYNReceived:\n                this.state = StreamState.Established;\n                return Flag.ACK;\n            default:\n                return 0;\n        }\n    }\n    /**\n     * potentially sends a window update enabling further writes to take place.\n     */\n    sendWindowUpdate() {\n        // determine the flags if any\n        const flags = this.getSendFlags();\n        // If the stream has already been established\n        // and we've processed data within the time it takes for 4 round trips\n        // then we (up to) double the recvWindow\n        const now = Date.now();\n        const rtt = this.getRTT();\n        if (flags === 0 && rtt > 0 && now - this.epochStart < rtt * 4) {\n            // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32\n            this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize);\n        }\n        if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {\n            // a window update isn't needed\n            return;\n        }\n        // update the receive window\n        const delta = this.recvWindow - this.recvWindowCapacity;\n        this.recvWindowCapacity = this.recvWindow;\n        // update the epoch start\n        this.epochStart = now;\n        // send window update\n        this.sendFrame({\n            type: FrameType.WindowUpdate,\n            flag: flags,\n            streamID: this._id,\n            length: delta\n        });\n    }\n}\n//# sourceMappingURL=stream.js.map","import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(data, decodeOptions)\n","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","import { EventEmitter } from '@libp2p/interface/events';\nimport { peerDiscovery } from '@libp2p/interface/peer-discovery';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { P2P } from '@multiformats/mafmt';\nimport { multiaddr } from '@multiformats/multiaddr';\nconst log = logger('libp2p:bootstrap');\nconst DEFAULT_BOOTSTRAP_TAG_NAME = 'bootstrap';\nconst DEFAULT_BOOTSTRAP_TAG_VALUE = 50;\nconst DEFAULT_BOOTSTRAP_TAG_TTL = 120000;\nconst DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1000;\n/**\n * Emits 'peer' events on a regular interval for each peer in the provided list.\n */\nclass Bootstrap extends EventEmitter {\n    static tag = 'bootstrap';\n    timer;\n    list;\n    timeout;\n    components;\n    _init;\n    constructor(components, options = { list: [] }) {\n        if (options.list == null || options.list.length === 0) {\n            throw new Error('Bootstrap requires a list of peer addresses');\n        }\n        super();\n        this.components = components;\n        this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;\n        this.list = [];\n        for (const candidate of options.list) {\n            if (!P2P.matches(candidate)) {\n                log.error('Invalid multiaddr');\n                continue;\n            }\n            const ma = multiaddr(candidate);\n            const peerIdStr = ma.getPeerId();\n            if (peerIdStr == null) {\n                log.error('Invalid bootstrap multiaddr without peer id');\n                continue;\n            }\n            const peerData = {\n                id: peerIdFromString(peerIdStr),\n                multiaddrs: [ma],\n                protocols: []\n            };\n            this.list.push(peerData);\n        }\n        this._init = options;\n    }\n    [peerDiscovery] = this;\n    [Symbol.toStringTag] = '@libp2p/bootstrap';\n    isStarted() {\n        return Boolean(this.timer);\n    }\n    /**\n     * Start emitting events\n     */\n    start() {\n        if (this.isStarted()) {\n            return;\n        }\n        log('Starting bootstrap node discovery, discovering peers after %s ms', this.timeout);\n        this.timer = setTimeout(() => {\n            void this._discoverBootstrapPeers()\n                .catch(err => {\n                log.error(err);\n            });\n        }, this.timeout);\n    }\n    /**\n     * Emit each address in the list as a PeerInfo\n     */\n    async _discoverBootstrapPeers() {\n        if (this.timer == null) {\n            return;\n        }\n        for (const peerData of this.list) {\n            await this.components.peerStore.merge(peerData.id, {\n                tags: {\n                    [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {\n                        value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,\n                        ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL\n                    }\n                }\n            });\n            // check we are still running\n            if (this.timer == null) {\n                return;\n            }\n            this.safeDispatchEvent('peer', { detail: peerData });\n        }\n    }\n    /**\n     * Stop emitting events\n     */\n    stop() {\n        if (this.timer != null) {\n            clearTimeout(this.timer);\n        }\n        this.timer = undefined;\n    }\n}\nexport function bootstrap(init) {\n    return (components) => new Bootstrap(components, init);\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","/**\n * Any object that implements this Symbol as a property should return a\n * ContentRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```js\n * import { contentRouting, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRouting = Symbol.for('@libp2p/content-routing');\n//# sourceMappingURL=index.js.map","/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n    code;\n    type;\n    constructor(message = 'The operation was aborted') {\n        super(message);\n        this.code = AbortError.code;\n        this.type = AbortError.type;\n    }\n    static code = 'ABORT_ERR';\n    static type = 'aborted';\n}\nexport class CodeError extends Error {\n    code;\n    props;\n    constructor(message, code, props) {\n        super(message);\n        this.code = code;\n        this.name = props?.name ?? 'CodeError';\n        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions\n    }\n}\nexport class UnexpectedPeerError extends Error {\n    code;\n    constructor(message = 'Unexpected Peer') {\n        super(message);\n        this.code = UnexpectedPeerError.code;\n    }\n    static code = 'ERR_UNEXPECTED_PEER';\n}\nexport class InvalidCryptoExchangeError extends Error {\n    code;\n    constructor(message = 'Invalid crypto exchange') {\n        super(message);\n        this.code = InvalidCryptoExchangeError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_EXCHANGE';\n}\nexport class InvalidCryptoTransmissionError extends Error {\n    code;\n    constructor(message = 'Invalid crypto transmission') {\n        super(message);\n        this.code = InvalidCryptoTransmissionError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_TRANSMISSION';\n}\n//# sourceMappingURL=errors.js.map","/**\n * Adds types to the EventTarget class. Hopefully this won't be necessary forever.\n *\n * https://github.com/microsoft/TypeScript/issues/28357\n * https://github.com/microsoft/TypeScript/issues/43477\n * https://github.com/microsoft/TypeScript/issues/299\n * etc\n */\nexport class EventEmitter extends EventTarget {\n    #listeners = new Map();\n    listenerCount(type) {\n        const listeners = this.#listeners.get(type);\n        if (listeners == null) {\n            return 0;\n        }\n        return listeners.length;\n    }\n    addEventListener(type, listener, options) {\n        super.addEventListener(type, listener, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            list = [];\n            this.#listeners.set(type, list);\n        }\n        list.push({\n            callback: listener,\n            once: (options !== true && options !== false && options?.once) ?? false\n        });\n    }\n    removeEventListener(type, listener, options) {\n        super.removeEventListener(type.toString(), listener ?? null, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            return;\n        }\n        list = list.filter(({ callback }) => callback !== listener);\n        this.#listeners.set(type, list);\n    }\n    dispatchEvent(event) {\n        const result = super.dispatchEvent(event);\n        let list = this.#listeners.get(event.type);\n        if (list == null) {\n            return result;\n        }\n        list = list.filter(({ once }) => !once);\n        this.#listeners.set(event.type, list);\n        return result;\n    }\n    safeDispatchEvent(type, detail) {\n        return this.dispatchEvent(new CustomEvent(type, detail));\n    }\n}\n/**\n * CustomEvent is a standard event but it's not supported by node.\n *\n * Remove this when https://github.com/nodejs/node/issues/40678 is closed.\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n */\nclass CustomEventPolyfill extends Event {\n    /** Returns any custom data event was created with. Typically used for synthetic events. */\n    detail;\n    constructor(message, data) {\n        super(message, data);\n        // @ts-expect-error could be undefined\n        this.detail = data?.detail;\n    }\n}\nexport const CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;\n//# sourceMappingURL=events.js.map","class TrackedMap extends Map {\n    metric;\n    constructor(init) {\n        super();\n        const { name, metrics } = init;\n        this.metric = metrics.registerMetric(name);\n        this.updateComponentMetric();\n    }\n    set(key, value) {\n        super.set(key, value);\n        this.updateComponentMetric();\n        return this;\n    }\n    delete(key) {\n        const deleted = super.delete(key);\n        this.updateComponentMetric();\n        return deleted;\n    }\n    clear() {\n        super.clear();\n        this.updateComponentMetric();\n    }\n    updateComponentMetric() {\n        this.metric.update(this.size);\n    }\n}\nexport function trackedMap(config) {\n    const { name, metrics } = config;\n    let map;\n    if (metrics != null) {\n        map = new TrackedMap({ name, metrics });\n    }\n    else {\n        map = new Map();\n    }\n    return map;\n}\n//# sourceMappingURL=tracked-map.js.map","/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```js\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscovery = Symbol.for('@libp2p/peer-discovery');\n//# sourceMappingURL=index.js.map","export const symbol = Symbol.for('@libp2p/peer-id');\nexport function isPeerId(other) {\n    return other != null && Boolean(other[symbol]);\n}\n//# sourceMappingURL=index.js.map","/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```js\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRouting = Symbol.for('@libp2p/peer-routing');\n//# sourceMappingURL=index.js.map","/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign';\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign';\nexport var TopicValidatorResult;\n(function (TopicValidatorResult) {\n    /**\n     * The message is considered valid, and it should be delivered and forwarded to the network\n     */\n    TopicValidatorResult[\"Accept\"] = \"accept\";\n    /**\n     * The message is neither delivered nor forwarded to the network\n     */\n    TopicValidatorResult[\"Ignore\"] = \"ignore\";\n    /**\n     * The message is considered invalid, and it should be rejected\n     */\n    TopicValidatorResult[\"Reject\"] = \"reject\";\n})(TopicValidatorResult || (TopicValidatorResult = {}));\n//# sourceMappingURL=index.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","export const symbol = Symbol.for('@libp2p/transport');\nexport function isTransport(other) {\n    return other != null && Boolean(other[symbol]);\n}\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport var FaultTolerance;\n(function (FaultTolerance) {\n    /**\n     * should be used for failing in any listen circumstance\n     */\n    FaultTolerance[FaultTolerance[\"FATAL_ALL\"] = 0] = \"FATAL_ALL\";\n    /**\n     * should be used for not failing when not listening\n     */\n    FaultTolerance[FaultTolerance[\"NO_FATAL\"] = 1] = \"NO_FATAL\";\n})(FaultTolerance || (FaultTolerance = {}));\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_queue;\nimport lowerBound from './lower-bound.js';\nclass PriorityQueue {\n    constructor() {\n        _PriorityQueue_queue.set(this, []);\n    }\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\")[this.size - 1].priority >= options.priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").push(element);\n            return;\n        }\n        const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, \"f\"), element, (a, b) => b.priority - a.priority);\n        __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").splice(index, 0, element);\n    }\n    dequeue() {\n        const item = __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").length;\n    }\n}\n_PriorityQueue_queue = new WeakMap();\nexport default PriorityQueue;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\nexport default PQueue;\n","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { anySignal } from 'any-signal';\nimport toIt from 'browser-readablestream-to-it';\n// @ts-expect-error no types\nimport ndjson from 'iterable-ndjson';\nimport defer from 'p-defer';\nimport PQueue from 'p-queue';\nconst log = logger('ipni-content-routing');\nconst defaultValues = {\n    concurrentRequests: 4,\n    timeout: 30e3\n};\n/**\n * An implementation of content routing, using a delegated peer\n */\nclass IpniContentRouting {\n    started;\n    httpQueue;\n    shutDownController;\n    clientUrl;\n    timeout;\n    /**\n     * Create a new DelegatedContentRouting instance\n     */\n    constructor(url, init = {}) {\n        log('enabled IPNI routing via', url);\n        this.started = false;\n        this.shutDownController = new AbortController();\n        this.httpQueue = new PQueue({\n            concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests\n        });\n        this.clientUrl = url instanceof URL ? url : new URL(url);\n        this.timeout = init.timeout ?? defaultValues.timeout;\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.started = true;\n    }\n    stop() {\n        this.httpQueue.clear();\n        this.shutDownController.abort();\n        this.started = false;\n    }\n    async *findProviders(key, options = {}) {\n        log('findProviders starts: %c', key);\n        const signal = anySignal([this.shutDownController.signal, options.signal, AbortSignal.timeout(this.timeout)]);\n        const onStart = defer();\n        const onFinish = defer();\n        void this.httpQueue.add(async () => {\n            onStart.resolve();\n            return onFinish.promise;\n        });\n        try {\n            await onStart.promise;\n            const resource = `${this.clientUrl}cid/${key.toString()}?cascade=ipfs-dht`;\n            const getOptions = { headers: { Accept: 'application/x-ndjson' }, signal };\n            const a = await fetch(resource, getOptions);\n            if (a.body == null) {\n                throw new CodeError('IPNI response had no body', 'ERR_BAD_RESPONSE');\n            }\n            for await (const event of ndjson(toIt(a.body))) {\n                if (event.Metadata !== 'gBI=') {\n                    continue;\n                }\n                yield this.mapEvent(event);\n            }\n        }\n        catch (err) {\n            log.error('findProviders errored:', err);\n        }\n        finally {\n            signal.clear();\n            onFinish.resolve();\n            log('findProviders finished: %c', key);\n        }\n    }\n    mapEvent(event) {\n        const peer = peerIdFromString(event.Provider.ID);\n        const ma = [];\n        for (const strAddr of event.Provider.Addrs) {\n            const addr = multiaddr(strAddr);\n            ma.push(addr);\n        }\n        const pi = {\n            id: peer,\n            multiaddrs: ma,\n            protocols: []\n        };\n        return pi;\n    }\n    async provide() {\n        // noop\n    }\n    async put() {\n        // noop\n    }\n    async get() {\n        throw new CodeError('Not found', 'ERR_NOT_FOUND');\n    }\n}\nexport function ipniContentRouting(url, init = {}) {\n    return () => new IpniContentRouting(url, init);\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import debug from 'debug';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64 } from 'multiformats/bases/base64';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","// MaxRecordAge specifies the maximum time that any node will hold onto a record\n// from the time its received. This does not apply to any other forms of validity that\n// the record may contain.\n// For example, a record may contain an ipns entry with an EOL saying its valid\n// until the year 2020 (a great time in the future). For that record to stick around\n// it must be rebroadcasted more frequently than once every 'MaxRecordAge'\nexport const second = 1000;\nexport const minute = 60 * second;\nexport const hour = 60 * minute;\nexport const MAX_RECORD_AGE = 36 * hour;\nexport const LAN_PREFIX = '/lan';\nexport const PROTOCOL_PREFIX = '/ipfs';\nexport const PROTOCOL_DHT = '/kad/1.0.0';\nexport const RECORD_KEY_PREFIX = '/dht/record';\nexport const PROVIDER_KEY_PREFIX = '/dht/provider';\nexport const PROVIDERS_LRU_CACHE_SIZE = 256;\nexport const PROVIDERS_VALIDITY = 24 * hour;\nexport const PROVIDERS_CLEANUP_INTERVAL = hour;\nexport const READ_MESSAGE_TIMEOUT = 10 * second;\n// The number of records that will be retrieved on a call to getMany()\nexport const GET_MANY_RECORD_COUNT = 16;\n// K is the maximum number of requests to perform before returning failure\nexport const K = 20;\n// Alpha is the concurrency for asynchronous requests\nexport const ALPHA = 3;\n// How often we look for our closest DHT neighbours\nexport const QUERY_SELF_INTERVAL = Number(5 * minute);\n// How often we look for the first set of our closest DHT neighbours\nexport const QUERY_SELF_INITIAL_INTERVAL = Number(Number(second));\n// How long to look for our closest DHT neighbours for\nexport const QUERY_SELF_TIMEOUT = Number(5 * second);\n// How often we try to find new peers\nexport const TABLE_REFRESH_INTERVAL = Number(5 * minute);\n// How how long to look for new peers for\nexport const TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second);\n// When a timeout is not specified, run a query for this long\nexport const DEFAULT_QUERY_TIMEOUT = Number(30 * second);\n//# sourceMappingURL=constants.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Record;\n(function (Record) {\n    let _codec;\n    Record.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.key != null && obj.key.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.key);\n                }\n                if ((obj.value != null && obj.value.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.value);\n                }\n                if ((obj.timeReceived != null && obj.timeReceived !== '')) {\n                    w.uint32(42);\n                    w.string(obj.timeReceived);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    key: new Uint8Array(0),\n                    value: new Uint8Array(0),\n                    timeReceived: ''\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.key = reader.bytes();\n                            break;\n                        case 2:\n                            obj.value = reader.bytes();\n                            break;\n                        case 5:\n                            obj.timeReceived = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Record.encode = (obj) => {\n        return encodeMessage(obj, Record.codec());\n    };\n    Record.decode = (buf) => {\n        return decodeMessage(buf, Record.codec());\n    };\n})(Record || (Record = {}));\n//# sourceMappingURL=record.js.map","import { peerIdFromBytes } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { Libp2pRecord } from '../record/index.js';\nimport { Message as PBMessage } from './dht.js';\nexport const MESSAGE_TYPE = PBMessage.MessageType;\nexport const CONNECTION_TYPE = PBMessage.ConnectionType;\nexport const MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);\n/**\n * Represents a single DHT control message.\n */\nexport class Message {\n    type;\n    key;\n    clusterLevelRaw;\n    closerPeers;\n    providerPeers;\n    record;\n    constructor(type, key, level) {\n        if (!(key instanceof Uint8Array)) {\n            throw new Error('Key must be a Uint8Array');\n        }\n        this.type = type;\n        this.key = key;\n        this.clusterLevelRaw = level;\n        this.closerPeers = [];\n        this.providerPeers = [];\n        this.record = undefined;\n    }\n    /**\n     * @type {number}\n     */\n    get clusterLevel() {\n        const level = this.clusterLevelRaw - 1;\n        if (level < 0) {\n            return 0;\n        }\n        return level;\n    }\n    set clusterLevel(level) {\n        this.clusterLevelRaw = level;\n    }\n    /**\n     * Encode into protobuf\n     */\n    serialize() {\n        return PBMessage.encode({\n            key: this.key,\n            type: this.type,\n            clusterLevelRaw: this.clusterLevelRaw,\n            closerPeers: this.closerPeers.map(toPbPeer),\n            providerPeers: this.providerPeers.map(toPbPeer),\n            record: this.record == null ? undefined : this.record.serialize().subarray()\n        });\n    }\n    /**\n     * Decode from protobuf\n     */\n    static deserialize(raw) {\n        const dec = PBMessage.decode(raw);\n        const msg = new Message(dec.type ?? PBMessage.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0);\n        msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n        msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n        if (dec.record?.length != null) {\n            msg.record = Libp2pRecord.deserialize(dec.record);\n        }\n        return msg;\n    }\n}\nfunction toPbPeer(peer) {\n    const output = {\n        id: peer.id.toBytes(),\n        addrs: (peer.multiaddrs ?? []).map((m) => m.bytes),\n        connection: CONNECTION_TYPE.CONNECTED\n    };\n    return output;\n}\nfunction fromPbPeer(peer) {\n    if (peer.id == null) {\n        throw new Error('Invalid peer in message');\n    }\n    return {\n        id: peerIdFromBytes(peer.id),\n        multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),\n        protocols: []\n    };\n}\n//# sourceMappingURL=index.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { nanoid } from 'nanoid';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n    _buf;\n    /**\n     * @param {string | Uint8Array} s\n     * @param {boolean} [clean]\n     */\n    constructor(s, clean) {\n        if (typeof s === 'string') {\n            this._buf = uint8ArrayFromString(s);\n        }\n        else if (s instanceof Uint8Array) {\n            this._buf = s;\n        }\n        else {\n            throw new Error('Invalid key, should be String of Uint8Array');\n        }\n        if (clean == null) {\n            clean = true;\n        }\n        if (clean) {\n            this.clean();\n        }\n        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n            throw new Error('Invalid key');\n        }\n    }\n    /**\n     * Convert to the string representation\n     *\n     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n     * @returns {string}\n     */\n    toString(encoding = 'utf8') {\n        return uint8ArrayToString(this._buf, encoding);\n    }\n    /**\n     * Return the Uint8Array representation of the key\n     *\n     * @returns {Uint8Array}\n     */\n    uint8Array() {\n        return this._buf;\n    }\n    /**\n     * Return string representation of the key\n     *\n     * @returns {string}\n     */\n    get [Symbol.toStringTag]() {\n        return `Key(${this.toString()})`;\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list - The array of namespaces\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     * ```\n     */\n    static withNamespaces(list) {\n        return new Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.random()\n     * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n     * ```\n     */\n    static random() {\n        return new Key(nanoid().replace(/-/g, ''));\n    }\n    /**\n     * @param {*} other\n     */\n    static asKey(other) {\n        if (other instanceof Uint8Array || typeof other === 'string') {\n            // we can create a key from this\n            return new Key(other);\n        }\n        if (typeof other.uint8Array === 'function') {\n            // this is an older version or may have crossed the esm/cjs boundary\n            return new Key(other.uint8Array());\n        }\n        return null;\n    }\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    clean() {\n        if (this._buf == null || this._buf.byteLength === 0) {\n            this._buf = pathSepB;\n        }\n        if (this._buf[0] !== pathSep) {\n            const bytes = new Uint8Array(this._buf.byteLength + 1);\n            bytes.fill(pathSep, 0, 1);\n            bytes.set(this._buf, 1);\n            this._buf = bytes;\n        }\n        // normalize does not remove trailing slashes\n        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n            this._buf = this._buf.subarray(0, -1);\n        }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key - The other Key to check against\n     * @returns {boolean}\n     */\n    less(key) {\n        const list1 = this.list();\n        const list2 = key.list();\n        for (let i = 0; i < list1.length; i++) {\n            if (list2.length < i + 1) {\n                return false;\n            }\n            const c1 = list1[i];\n            const c2 = list2[i];\n            if (c1 < c2) {\n                return true;\n            }\n            else if (c1 > c2) {\n                return false;\n            }\n        }\n        return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     * ```\n     */\n    reverse() {\n        return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n    namespaces() {\n        return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     * ```\n     */\n    baseNamespace() {\n        const ns = this.namespaces();\n        return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     * ```\n     */\n    list() {\n        return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     * ```\n     */\n    type() {\n        return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     * ```\n     */\n    name() {\n        return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s - The string to append.\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    instance(s) {\n        return new Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     * ```\n     */\n    path() {\n        let p = this.parent().toString();\n        if (!p.endsWith(pathSepS)) {\n            p += pathSepS;\n        }\n        p += this.type();\n        return new Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     * ```\n     */\n    parent() {\n        const list = this.list();\n        if (list.length === 1) {\n            return new Key(pathSepS);\n        }\n        return new Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key - The child Key to add\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    child(key) {\n        if (this.toString() === pathSepS) {\n            return key;\n        }\n        else if (key.toString() === pathSepS) {\n            return this;\n        }\n        return new Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other - The other key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     * ```\n     */\n    isAncestorOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other - The other Key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     * ```\n     */\n    isDecendantOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Checks if this key has only one namespace.\n     *\n     * @returns {boolean}\n     */\n    isTopLevel() {\n        return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys - The array of keys to concatenate\n     * @returns {Key}\n     */\n    concat(...keys) {\n        return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n    }\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType(ns) {\n    const parts = ns.split(':');\n    if (parts.length < 2) {\n        return '';\n    }\n    return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue(ns) {\n    const parts = ns.split(':');\n    return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten(arr) {\n    return ([]).concat(...arr);\n}\n//# sourceMappingURL=key.js.map","import { peerIdFromBytes } from '@libp2p/peer-id';\nimport { Key } from 'interface-datastore/key';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport isPrivateIp from 'private-ip';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { RECORD_KEY_PREFIX } from './constants.js';\nimport { Libp2pRecord } from './record/index.js';\n// const IPNS_PREFIX = uint8ArrayFromString('/ipns/')\nconst PK_PREFIX = uint8ArrayFromString('/pk/');\nexport function removePrivateAddresses(peer) {\n    return {\n        ...peer,\n        multiaddrs: peer.multiaddrs.filter(multiaddr => {\n            const [[type, addr]] = multiaddr.stringTuples();\n            // treat /dns, /dns4, and /dns6 addrs as public\n            if (type === 53 || type === 54 || type === 55) {\n                // localhost can be a dns address but it's private\n                if (addr === 'localhost') {\n                    return false;\n                }\n                return true;\n            }\n            if (type !== 4 && type !== 6) {\n                return false;\n            }\n            if (addr == null) {\n                return false;\n            }\n            const isPrivate = isPrivateIp(addr);\n            if (isPrivate == null) {\n                // not an ip address\n                return true;\n            }\n            return !isPrivate;\n        })\n    };\n}\nexport function removePublicAddresses(peer) {\n    return {\n        ...peer,\n        multiaddrs: peer.multiaddrs.filter(multiaddr => {\n            const [[type, addr]] = multiaddr.stringTuples();\n            if (addr === 'localhost') {\n                return true;\n            }\n            if (type !== 4 && type !== 6) {\n                return false;\n            }\n            if (addr == null) {\n                return false;\n            }\n            const isPrivate = isPrivateIp(addr);\n            if (isPrivate == null) {\n                // not an ip address\n                return false;\n            }\n            return isPrivate;\n        })\n    };\n}\n/**\n * Creates a DHT ID by hashing a given Uint8Array\n */\nexport async function convertBuffer(buf) {\n    const multihash = await sha256.digest(buf);\n    return multihash.digest;\n}\n/**\n * Creates a DHT ID by hashing a Peer ID\n */\nexport async function convertPeerId(peerId) {\n    return convertBuffer(peerId.toBytes());\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToKey(buf) {\n    return new Key('/' + uint8ArrayToString(buf, 'base32'), false);\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToRecordKey(buf) {\n    return new Key(`${RECORD_KEY_PREFIX}/${uint8ArrayToString(buf, 'base32')}`, false);\n}\n/**\n * Generate the key for a public key.\n */\nexport function keyForPublicKey(peer) {\n    return uint8ArrayConcat([\n        PK_PREFIX,\n        peer.toBytes()\n    ]);\n}\nexport function isPublicKeyKey(key) {\n    return uint8ArrayToString(key.subarray(0, 4)) === '/pk/';\n}\nexport function isIPNSKey(key) {\n    return uint8ArrayToString(key.subarray(0, 4)) === '/ipns/';\n}\nexport function fromPublicKeyKey(key) {\n    return peerIdFromBytes(key.subarray(4));\n}\n/**\n * Create a new put record, encodes and signs it if enabled\n */\nexport function createPutRecord(key, value) {\n    const timeReceived = new Date();\n    const rec = new Libp2pRecord(key, value, timeReceived);\n    return rec.serialize();\n}\nexport function debounce(callback, wait = 100) {\n    let timeout;\n    return () => {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => { callback(); }, wait);\n    };\n}\n//# sourceMappingURL=utils.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { base64urlToBuffer } from '../util.js';\nimport webcrypto from '../webcrypto.js';\nconst bits = {\n    'P-256': 256,\n    'P-384': 384,\n    'P-521': 521\n};\nconst curveTypes = Object.keys(bits);\nconst names = curveTypes.join(' / ');\nexport async function generateEphmeralKeyPair(curve) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const pair = await webcrypto.get().subtle.generateKey({\n        name: 'ECDH',\n        namedCurve: curve\n    }, true, ['deriveBits']);\n    // forcePrivate is used for testing only\n    const genSharedKey = async (theirPub, forcePrivate) => {\n        let privateKey;\n        if (forcePrivate != null) {\n            privateKey = await webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n                name: 'ECDH',\n                namedCurve: curve\n            }, false, ['deriveBits']);\n        }\n        else {\n            privateKey = pair.privateKey;\n        }\n        const key = await webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n            name: 'ECDH',\n            namedCurve: curve\n        }, false, []);\n        const buffer = await webcrypto.get().subtle.deriveBits({\n            name: 'ECDH',\n            // @ts-expect-error namedCurve is missing from the types\n            namedCurve: curve,\n            public: key\n        }, privateKey, bits[curve]);\n        return new Uint8Array(buffer, 0, buffer.byteLength);\n    };\n    const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n    const ecdhKey = {\n        key: marshalPublicKey(publicKey),\n        genSharedKey\n    };\n    return ecdhKey;\n}\nconst curveLengths = {\n    'P-256': 32,\n    'P-384': 48,\n    'P-521': 66\n};\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey(jwk) {\n    if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n        throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n    }\n    if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n        throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const byteLen = curveLengths[jwk.crv];\n    return uint8ArrayConcat([\n        Uint8Array.from([4]),\n        base64urlToBuffer(jwk.x, byteLen),\n        base64urlToBuffer(jwk.y, byteLen)\n    ], 1 + byteLen * 2);\n}\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey(curve, key) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const byteLen = curveLengths[curve];\n    if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n        throw new CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT');\n    }\n    return {\n        kty: 'EC',\n        crv: curve,\n        x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n        y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n        ext: true\n    };\n}\nconst unmarshalPrivateKey = (curve, key) => ({\n    ...unmarshalPublicKey(curve, key.public),\n    d: uint8ArrayToString(key.private, 'base64url')\n});\n//# sourceMappingURL=ecdh-browser.js.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_queue;\nimport lowerBound from './lower-bound.js';\nclass PriorityQueue {\n    constructor() {\n        _PriorityQueue_queue.set(this, []);\n    }\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\")[this.size - 1].priority >= options.priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").push(element);\n            return;\n        }\n        const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, \"f\"), element, (a, b) => b.priority - a.priority);\n        __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").splice(index, 0, element);\n    }\n    dequeue() {\n        const item = __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").length;\n    }\n}\n_PriorityQueue_queue = new WeakMap();\nexport default PriorityQueue;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\nexport default PQueue;\n","import { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport cache from 'hashlru';\nimport { Key } from 'interface-datastore/key';\nimport Queue from 'p-queue';\nimport * as varint from 'uint8-varint';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { PROVIDERS_CLEANUP_INTERVAL, PROVIDERS_VALIDITY, PROVIDERS_LRU_CACHE_SIZE, PROVIDER_KEY_PREFIX } from './constants.js';\nconst log = logger('libp2p:kad-dht:providers');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nexport class Providers {\n    components;\n    cache;\n    cleanupInterval;\n    provideValidity;\n    syncQueue;\n    started;\n    cleaner;\n    constructor(components, init = {}) {\n        const { cacheSize, cleanupInterval, provideValidity } = init;\n        this.components = components;\n        this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;\n        this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;\n        this.cache = cache(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);\n        this.syncQueue = new Queue({ concurrency: 1 });\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    /**\n     * Start the provider cleanup service\n     */\n    async start() {\n        if (this.started) {\n            return;\n        }\n        this.started = true;\n        this.cleaner = setInterval(() => {\n            this._cleanup().catch(err => {\n                log.error(err);\n            });\n        }, this.cleanupInterval);\n    }\n    /**\n     * Release any resources.\n     */\n    async stop() {\n        this.started = false;\n        if (this.cleaner != null) {\n            clearInterval(this.cleaner);\n            this.cleaner = undefined;\n        }\n    }\n    /**\n     * Check all providers if they are still valid, and if not delete them\n     */\n    async _cleanup() {\n        await this.syncQueue.add(async () => {\n            const start = Date.now();\n            let count = 0;\n            let deleteCount = 0;\n            const deleted = new Map();\n            const batch = this.components.datastore.batch();\n            // Get all provider entries from the datastore\n            const query = this.components.datastore.query({ prefix: PROVIDER_KEY_PREFIX });\n            for await (const entry of query) {\n                try {\n                    // Add a delete to the batch for each expired entry\n                    const { cid, peerId } = parseProviderKey(entry.key);\n                    const time = readTime(entry.value).getTime();\n                    const now = Date.now();\n                    const delta = now - time;\n                    const expired = delta > this.provideValidity;\n                    log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '');\n                    if (expired) {\n                        deleteCount++;\n                        batch.delete(entry.key);\n                        const peers = deleted.get(cid) ?? new Set();\n                        peers.add(peerId);\n                        deleted.set(cid, peers);\n                    }\n                    count++;\n                }\n                catch (err) {\n                    log.error(err.message);\n                }\n            }\n            // Commit the deletes to the datastore\n            if (deleted.size > 0) {\n                log('deleting %d / %d entries', deleteCount, count);\n                await batch.commit();\n            }\n            else {\n                log('nothing to delete');\n            }\n            // Clear expired entries from the cache\n            for (const [cid, peers] of deleted) {\n                const key = makeProviderKey(cid);\n                const provs = this.cache.get(key);\n                if (provs != null) {\n                    for (const peerId of peers) {\n                        provs.delete(peerId);\n                    }\n                    if (provs.size === 0) {\n                        this.cache.remove(key);\n                    }\n                    else {\n                        this.cache.set(key, provs);\n                    }\n                }\n            }\n            log('Cleanup successful (%dms)', Date.now() - start);\n        });\n    }\n    /**\n     * Get the currently known provider peer ids for a given CID\n     */\n    async _getProvidersMap(cid) {\n        const cacheKey = makeProviderKey(cid);\n        let provs = this.cache.get(cacheKey);\n        if (provs == null) {\n            provs = await loadProviders(this.components.datastore, cid);\n            this.cache.set(cacheKey, provs);\n        }\n        return provs;\n    }\n    /**\n     * Add a new provider for the given CID\n     */\n    async addProvider(cid, provider) {\n        await this.syncQueue.add(async () => {\n            log('%p provides %s', provider, cid);\n            const provs = await this._getProvidersMap(cid);\n            log('loaded %s provs', provs.size);\n            const now = new Date();\n            provs.set(provider.toString(), now);\n            const dsKey = makeProviderKey(cid);\n            this.cache.set(dsKey, provs);\n            await writeProviderEntry(this.components.datastore, cid, provider, now);\n        });\n    }\n    /**\n     * Get a list of providers for the given CID\n     */\n    async getProviders(cid) {\n        return this.syncQueue.add(async () => {\n            log('get providers for %s', cid);\n            const provs = await this._getProvidersMap(cid);\n            return [...provs.keys()].map(peerIdStr => {\n                return peerIdFromString(peerIdStr);\n            });\n        }, {\n            // no timeout is specified for this queue so it will not\n            // throw, but this is required to get the right return\n            // type since p-queue@7.3.4\n            throwOnTimeout: true\n        });\n    }\n}\n/**\n * Encode the given key its matching datastore key\n */\nfunction makeProviderKey(cid) {\n    const cidStr = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32');\n    return `${PROVIDER_KEY_PREFIX}/${cidStr}`;\n}\n/**\n * Write a provider into the given store\n */\nasync function writeProviderEntry(store, cid, peer, time) {\n    const dsKey = [\n        makeProviderKey(cid),\n        '/',\n        peer.toString()\n    ].join('');\n    const key = new Key(dsKey);\n    const buffer = varint.encode(time.getTime());\n    await store.put(key, buffer);\n}\n/**\n * Parse the CID and provider peer id from the key\n */\nfunction parseProviderKey(key) {\n    const parts = key.toString().split('/');\n    if (parts.length !== 5) {\n        throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);\n    }\n    return {\n        cid: parts[3],\n        peerId: parts[4]\n    };\n}\n/**\n * Load providers for the given CID from the store\n */\nasync function loadProviders(store, cid) {\n    const providers = new Map();\n    const query = store.query({ prefix: makeProviderKey(cid) });\n    for await (const entry of query) {\n        const { peerId } = parseProviderKey(entry.key);\n        providers.set(peerId, readTime(entry.value));\n    }\n    return providers;\n}\nfunction readTime(buf) {\n    return new Date(varint.decode(buf));\n}\n//# sourceMappingURL=providers.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { anySignal } from 'any-signal';\nimport defer from 'p-defer';\nimport Queue from 'p-queue';\nimport { toString } from 'uint8arrays/to-string';\nimport { xor } from 'uint8arrays/xor';\nimport { convertPeerId, convertBuffer } from '../utils.js';\nimport { queryErrorEvent } from './events.js';\nconst MAX_XOR = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before\n */\nexport async function* queryPath(options) {\n    const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log, peersSeen } = options;\n    // Only ALPHA node/value lookups are allowed at any given time for each process\n    // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n    const queue = new Queue({\n        concurrency: alpha\n    });\n    // perform lookups on kadId, not the actual value\n    const kadId = await convertBuffer(key);\n    /**\n     * Adds the passed peer to the query queue if it's not us and no\n     * other path has passed through this peer\n     */\n    function queryPeer(peer, peerKadId) {\n        if (peer == null) {\n            return;\n        }\n        peersSeen.add(peer);\n        const peerXor = BigInt('0x' + toString(xor(peerKadId, kadId), 'base16'));\n        queue.add(async () => {\n            const signals = [signal];\n            if (queryFuncTimeout != null) {\n                signals.push(AbortSignal.timeout(queryFuncTimeout));\n            }\n            const compoundSignal = anySignal(signals);\n            try {\n                for await (const event of query({\n                    key,\n                    peer,\n                    signal: compoundSignal,\n                    pathIndex,\n                    numPaths\n                })) {\n                    if (compoundSignal.aborted) {\n                        return;\n                    }\n                    // if there are closer peers and the query has not completed, continue the query\n                    if (event.name === 'PEER_RESPONSE') {\n                        for (const closerPeer of event.closer) {\n                            if (peersSeen.has(closerPeer.id)) { // eslint-disable-line max-depth\n                                log('already seen %p in query', closerPeer.id);\n                                continue;\n                            }\n                            if (ourPeerId.equals(closerPeer.id)) { // eslint-disable-line max-depth\n                                log('not querying ourselves');\n                                continue;\n                            }\n                            const closerPeerKadId = await convertPeerId(closerPeer.id);\n                            const closerPeerXor = BigInt('0x' + toString(xor(closerPeerKadId, kadId), 'base16'));\n                            // only continue query if closer peer is actually closer\n                            if (closerPeerXor > peerXor) { // eslint-disable-line max-depth\n                                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer);\n                                continue;\n                            }\n                            log('querying closer peer %p', closerPeer.id);\n                            queryPeer(closerPeer.id, closerPeerKadId);\n                        }\n                    }\n                    queue.emit('completed', event);\n                }\n            }\n            catch (err) {\n                if (!signal.aborted) {\n                    return queryErrorEvent({\n                        from: peer,\n                        error: err\n                    }, options);\n                }\n            }\n            finally {\n                compoundSignal.clear();\n            }\n        }, {\n            // use xor value as the queue priority - closer peers should execute first\n            // subtract it from MAX_XOR because higher priority values execute sooner\n            // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts\n            // as long as all priorities are BigInts since we won't mix BigInts and Number\n            // values in arithmetic operations\n            priority: MAX_XOR - peerXor\n        }).catch(err => {\n            log.error(err);\n        });\n    }\n    // begin the query with the starting peer\n    queryPeer(startingPeer, await convertPeerId(startingPeer));\n    // yield results as they come in\n    yield* toGenerator(queue, signal, cleanUp, log);\n}\nasync function* toGenerator(queue, signal, cleanUp, log) {\n    let deferred = defer();\n    let running = true;\n    const results = [];\n    const cleanup = () => {\n        if (!running) {\n            return;\n        }\n        log('clean up queue, results %d, queue size %d, pending tasks %d', results.length, queue.size, queue.pending);\n        running = false;\n        queue.clear();\n        results.splice(0, results.length);\n    };\n    queue.on('completed', result => {\n        results.push(result);\n        deferred.resolve();\n    });\n    queue.on('error', err => {\n        log('queue error', err);\n        cleanup();\n        deferred.reject(err);\n    });\n    queue.on('idle', () => {\n        log('queue idle');\n        running = false;\n        deferred.resolve();\n    });\n    // clear the queue and throw if the query is aborted\n    signal.addEventListener('abort', () => {\n        log('abort queue');\n        const wasRunning = running;\n        cleanup();\n        if (wasRunning) {\n            deferred.reject(new CodeError('Query aborted', 'ERR_QUERY_ABORTED'));\n        }\n    });\n    // the user broke out of the loop early, ensure we resolve the deferred result\n    // promise and clear the queue of any remaining jobs\n    cleanUp.addEventListener('cleanup', () => {\n        cleanup();\n        deferred.resolve();\n    });\n    while (running) { // eslint-disable-line no-unmodified-loop-condition\n        await deferred.promise;\n        deferred = defer();\n        // yield all available results\n        while (results.length > 0) {\n            const result = results.shift();\n            if (result != null) {\n                yield result;\n            }\n        }\n    }\n    // yield any remaining results\n    yield* results;\n}\n//# sourceMappingURL=query-path.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { CID } from 'multiformats/cid';\nconst log = logger('libp2p:kad-dht:rpc:handlers:add-provider');\nexport class AddProviderHandler {\n    providers;\n    constructor(init) {\n        const { providers } = init;\n        this.providers = providers;\n    }\n    async handle(peerId, msg) {\n        log('start');\n        if (msg.key == null || msg.key.length === 0) {\n            throw new CodeError('Missing key', 'ERR_MISSING_KEY');\n        }\n        let cid;\n        try {\n            // this is actually just the multihash, not the whole CID\n            cid = CID.decode(msg.key);\n        }\n        catch (err) {\n            throw new CodeError('Invalid CID', 'ERR_INVALID_CID');\n        }\n        if (msg.providerPeers == null || msg.providerPeers.length === 0) {\n            log.error('no providers found in message');\n        }\n        await Promise.all(msg.providerPeers.map(async (pi) => {\n            // Ignore providers not from the originator\n            if (!pi.id.equals(peerId)) {\n                log('invalid provider peer %p from %p', pi.id, peerId);\n                return;\n            }\n            if (pi.multiaddrs.length < 1) {\n                log('no valid addresses for provider %p. Ignore', peerId);\n                return;\n            }\n            log('received provider %p for %s (addrs %s)', peerId, cid, pi.multiaddrs.map((m) => m.toString()));\n            await this.providers.addProvider(cid, pi.id);\n        }));\n        return undefined;\n    }\n}\n//# sourceMappingURL=add-provider.js.map","import { logger } from '@libp2p/logger';\nimport { protocols } from '@multiformats/multiaddr';\nimport { equals as uint8ArrayEquals } from 'uint8arrays';\nimport { Message } from '../../message/index.js';\nimport { removePrivateAddresses, removePublicAddresses } from '../../utils.js';\nconst log = logger('libp2p:kad-dht:rpc:handlers:find-node');\nexport class FindNodeHandler {\n    peerRouting;\n    lan;\n    components;\n    constructor(components, init) {\n        const { peerRouting, lan } = init;\n        this.components = components;\n        this.peerRouting = peerRouting;\n        this.lan = Boolean(lan);\n    }\n    /**\n     * Process `FindNode` DHT messages\n     */\n    async handle(peerId, msg) {\n        log('incoming request from %p for peers closer to %b', peerId, msg.key);\n        let closer = [];\n        if (uint8ArrayEquals(this.components.peerId.toBytes(), msg.key)) {\n            closer = [{\n                    id: this.components.peerId,\n                    multiaddrs: this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code)),\n                    protocols: []\n                }];\n        }\n        else {\n            closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);\n        }\n        closer = closer\n            .map(this.lan ? removePublicAddresses : removePrivateAddresses)\n            .filter(({ multiaddrs }) => multiaddrs.length);\n        const response = new Message(msg.type, new Uint8Array(0), msg.clusterLevel);\n        if (closer.length > 0) {\n            response.closerPeers = closer;\n        }\n        else {\n            log('could not find any peers closer to %b than %p', msg.key, peerId);\n        }\n        return response;\n    }\n}\n//# sourceMappingURL=find-node.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { CID } from 'multiformats/cid';\nimport { Message } from '../../message/index.js';\nimport { removePrivateAddresses, removePublicAddresses } from '../../utils.js';\nconst log = logger('libp2p:kad-dht:rpc:handlers:get-providers');\nexport class GetProvidersHandler {\n    components;\n    peerRouting;\n    providers;\n    lan;\n    constructor(components, init) {\n        const { peerRouting, providers, lan } = init;\n        this.components = components;\n        this.peerRouting = peerRouting;\n        this.providers = providers;\n        this.lan = Boolean(lan);\n    }\n    async handle(peerId, msg) {\n        let cid;\n        try {\n            cid = CID.decode(msg.key);\n        }\n        catch (err) {\n            throw new CodeError('Invalid CID', 'ERR_INVALID_CID');\n        }\n        log('%p asking for providers for %s', peerId, cid);\n        const [peers, closer] = await Promise.all([\n            this.providers.getProviders(cid),\n            this.peerRouting.getCloserPeersOffline(msg.key, peerId)\n        ]);\n        const providerPeers = await this._getPeers(peers);\n        const closerPeers = await this._getPeers(closer.map(({ id }) => id));\n        const response = new Message(msg.type, msg.key, msg.clusterLevel);\n        if (providerPeers.length > 0) {\n            response.providerPeers = providerPeers;\n        }\n        if (closerPeers.length > 0) {\n            response.closerPeers = closerPeers;\n        }\n        log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length);\n        return response;\n    }\n    async _getAddresses(peerId) {\n        return [];\n    }\n    async _getPeers(peerIds) {\n        const output = [];\n        const addrFilter = this.lan ? removePublicAddresses : removePrivateAddresses;\n        for (const peerId of peerIds) {\n            try {\n                const peer = await this.components.peerStore.get(peerId);\n                const peerAfterFilter = addrFilter({\n                    id: peerId,\n                    multiaddrs: peer.addresses.map(({ multiaddr }) => multiaddr),\n                    protocols: peer.protocols\n                });\n                if (peerAfterFilter.multiaddrs.length > 0) {\n                    output.push(peerAfterFilter);\n                }\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n        }\n        return output;\n    }\n}\n//# sourceMappingURL=get-providers.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { MAX_RECORD_AGE } from '../../constants.js';\nimport { Message, MESSAGE_TYPE } from '../../message/index.js';\nimport { Libp2pRecord } from '../../record/index.js';\nimport { bufferToRecordKey, isPublicKeyKey, fromPublicKeyKey } from '../../utils.js';\nconst log = logger('libp2p:kad-dht:rpc:handlers:get-value');\nexport class GetValueHandler {\n    components;\n    peerRouting;\n    constructor(components, init) {\n        const { peerRouting } = init;\n        this.components = components;\n        this.peerRouting = peerRouting;\n    }\n    async handle(peerId, msg) {\n        const key = msg.key;\n        log('%p asked for key %b', peerId, key);\n        if (key == null || key.length === 0) {\n            throw new CodeError('Invalid key', 'ERR_INVALID_KEY');\n        }\n        const response = new Message(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);\n        if (isPublicKeyKey(key)) {\n            log('is public key');\n            const idFromKey = fromPublicKeyKey(key);\n            let pubKey;\n            try {\n                const peer = await this.components.peerStore.get(idFromKey);\n                if (peer.id.publicKey == null) {\n                    throw new CodeError('No public key found in key book', 'ERR_NOT_FOUND');\n                }\n                pubKey = peer.id.publicKey;\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n            if (pubKey != null) {\n                log('returning found public key');\n                response.record = new Libp2pRecord(key, pubKey, new Date());\n                return response;\n            }\n        }\n        const [record, closer] = await Promise.all([\n            this._checkLocalDatastore(key),\n            this.peerRouting.getCloserPeersOffline(msg.key, peerId)\n        ]);\n        if (record != null) {\n            log('had record for %b in local datastore', key);\n            response.record = record;\n        }\n        if (closer.length > 0) {\n            log('had %s closer peers in routing table', closer.length);\n            response.closerPeers = closer;\n        }\n        return response;\n    }\n    /**\n     * Try to fetch a given record by from the local datastore.\n     * Returns the record if it is still valid, meaning\n     * - it was either authored by this node, or\n     * - it was received less than `MAX_RECORD_AGE` ago.\n     */\n    async _checkLocalDatastore(key) {\n        log('checkLocalDatastore looking for %b', key);\n        const dsKey = bufferToRecordKey(key);\n        // Fetch value from ds\n        let rawRecord;\n        try {\n            rawRecord = await this.components.datastore.get(dsKey);\n        }\n        catch (err) {\n            if (err.code === 'ERR_NOT_FOUND') {\n                return undefined;\n            }\n            throw err;\n        }\n        // Create record from the returned bytes\n        const record = Libp2pRecord.deserialize(rawRecord);\n        if (record == null) {\n            throw new CodeError('Invalid record', 'ERR_INVALID_RECORD');\n        }\n        // Check validity: compare time received with max record age\n        if (record.timeReceived == null ||\n            Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {\n            // If record is bad delete it and return\n            await this.components.datastore.delete(dsKey);\n            return undefined;\n        }\n        // Record is valid\n        return record;\n    }\n}\n//# sourceMappingURL=get-value.js.map","import { logger } from '@libp2p/logger';\nconst log = logger('libp2p:kad-dht:rpc:handlers:ping');\nexport class PingHandler {\n    async handle(peerId, msg) {\n        log('ping from %p', peerId);\n        return msg;\n    }\n}\n//# sourceMappingURL=ping.js.map","import { contentRouting } from '@libp2p/interface/content-routing';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { EventEmitter, CustomEvent } from '@libp2p/interface/events';\nimport { peerDiscovery } from '@libp2p/interface/peer-discovery';\nimport { peerRouting } from '@libp2p/interface/peer-routing';\nimport { logger } from '@libp2p/logger';\nimport drain from 'it-drain';\nimport merge from 'it-merge';\nimport isPrivate from 'private-ip';\nimport { DefaultKadDHT } from './kad-dht.js';\nimport { queryErrorEvent } from './query/events.js';\nconst log = logger('libp2p:kad-dht');\n/**\n * Wrapper class to convert events into returned values\n */\nclass DHTContentRouting {\n    dht;\n    constructor(dht) {\n        this.dht = dht;\n    }\n    async provide(cid, options = {}) {\n        await drain(this.dht.provide(cid, options));\n    }\n    async *findProviders(cid, options = {}) {\n        for await (const event of this.dht.findProviders(cid, options)) {\n            if (event.name === 'PROVIDER') {\n                yield* event.providers;\n            }\n        }\n    }\n    async put(key, value, options) {\n        await drain(this.dht.put(key, value, options));\n    }\n    async get(key, options) {\n        for await (const event of this.dht.get(key, options)) {\n            if (event.name === 'VALUE') {\n                return event.value;\n            }\n        }\n        throw new CodeError('Not found', 'ERR_NOT_FOUND');\n    }\n}\n/**\n * Wrapper class to convert events into returned values\n */\nclass DHTPeerRouting {\n    dht;\n    constructor(dht) {\n        this.dht = dht;\n    }\n    async findPeer(peerId, options = {}) {\n        for await (const event of this.dht.findPeer(peerId, options)) {\n            if (event.name === 'FINAL_PEER') {\n                return event.peer;\n            }\n        }\n        throw new CodeError('Not found', 'ERR_NOT_FOUND');\n    }\n    async *getClosestPeers(key, options = {}) {\n        for await (const event of this.dht.getClosestPeers(key, options)) {\n            if (event.name === 'FINAL_PEER') {\n                yield event.peer;\n            }\n        }\n    }\n}\n// see https://github.com/multiformats/multiaddr/blob/master/protocols.csv\nconst P2P_CIRCUIT_CODE = 290;\nconst DNS4_CODE = 54;\nconst DNS6_CODE = 55;\nconst DNSADDR_CODE = 56;\nconst IP4_CODE = 4;\nconst IP6_CODE = 41;\nfunction multiaddrIsPublic(multiaddr) {\n    const tuples = multiaddr.stringTuples();\n    // p2p-circuit should not enable server mode\n    for (const tuple of tuples) {\n        if (tuple[0] === P2P_CIRCUIT_CODE) {\n            return false;\n        }\n    }\n    // dns4 or dns6 or dnsaddr\n    if (tuples[0][0] === DNS4_CODE || tuples[0][0] === DNS6_CODE || tuples[0][0] === DNSADDR_CODE) {\n        log('%m is public %s', multiaddr, true);\n        return true;\n    }\n    // ip4 or ip6\n    if (tuples[0][0] === IP4_CODE || tuples[0][0] === IP6_CODE) {\n        const result = isPrivate(`${tuples[0][1]}`);\n        const isPublic = result == null || !result;\n        log('%m is public %s', multiaddr, isPublic);\n        return isPublic;\n    }\n    return false;\n}\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nexport class DefaultDualKadDHT extends EventEmitter {\n    wan;\n    lan;\n    components;\n    contentRouting;\n    peerRouting;\n    constructor(components, init = {}) {\n        super();\n        this.components = components;\n        this.wan = new DefaultKadDHT(components, {\n            protocolPrefix: '/ipfs',\n            ...init,\n            lan: false\n        });\n        this.lan = new DefaultKadDHT(components, {\n            protocolPrefix: '/ipfs',\n            ...init,\n            clientMode: false,\n            lan: true\n        });\n        this.contentRouting = new DHTContentRouting(this);\n        this.peerRouting = new DHTPeerRouting(this);\n        // handle peers being discovered during processing of DHT messages\n        this.wan.addEventListener('peer', (evt) => {\n            this.dispatchEvent(new CustomEvent('peer', {\n                detail: evt.detail\n            }));\n        });\n        this.lan.addEventListener('peer', (evt) => {\n            this.dispatchEvent(new CustomEvent('peer', {\n                detail: evt.detail\n            }));\n        });\n        // if client mode has not been explicitly specified, auto-switch to server\n        // mode when the node's peer data is updated with publicly dialable addresses\n        if (init.clientMode == null) {\n            components.events.addEventListener('self:peer:update', (evt) => {\n                log('received update of self-peer info');\n                const hasPublicAddress = evt.detail.peer.addresses\n                    .some(({ multiaddr }) => {\n                    const isPublic = multiaddrIsPublic(multiaddr);\n                    log('%m is public %s', multiaddr, isPublic);\n                    return isPublic;\n                });\n                this.getMode()\n                    .then(async (mode) => {\n                    if (hasPublicAddress && mode === 'client') {\n                        await this.setMode('server');\n                    }\n                    else if (mode === 'server' && !hasPublicAddress) {\n                        await this.setMode('client');\n                    }\n                })\n                    .catch(err => {\n                    log.error('error setting dht server mode', err);\n                });\n            });\n        }\n    }\n    [Symbol.toStringTag] = '@libp2p/dual-kad-dht';\n    get [contentRouting]() {\n        return this.contentRouting;\n    }\n    get [peerRouting]() {\n        return this.peerRouting;\n    }\n    get [peerDiscovery]() {\n        return this;\n    }\n    /**\n     * Is this DHT running.\n     */\n    isStarted() {\n        return this.wan.isStarted() && this.lan.isStarted();\n    }\n    /**\n     * If 'server' this node will respond to DHT queries, if 'client' this node will not\n     */\n    async getMode() {\n        return this.wan.getMode();\n    }\n    /**\n     * If 'server' this node will respond to DHT queries, if 'client' this node will not\n     */\n    async setMode(mode) {\n        await this.wan.setMode(mode);\n    }\n    /**\n     * Start listening to incoming connections.\n     */\n    async start() {\n        await Promise.all([\n            this.lan.start(),\n            this.wan.start()\n        ]);\n    }\n    /**\n     * Stop accepting incoming connections and sending outgoing\n     * messages.\n     */\n    async stop() {\n        await Promise.all([\n            this.lan.stop(),\n            this.wan.stop()\n        ]);\n    }\n    /**\n     * Store the given key/value pair in the DHT\n     */\n    async *put(key, value, options = {}) {\n        for await (const event of merge(this.lan.put(key, value, options), this.wan.put(key, value, options))) {\n            yield event;\n        }\n    }\n    /**\n     * Get the value that corresponds to the passed key\n     */\n    async *get(key, options = {}) {\n        let queriedPeers = false;\n        let foundValue = false;\n        for await (const event of merge(this.lan.get(key, options), this.wan.get(key, options))) {\n            yield event;\n            if (event.name === 'DIAL_PEER') {\n                queriedPeers = true;\n            }\n            if (event.name === 'VALUE') {\n                queriedPeers = true;\n                if (event.value != null) {\n                    foundValue = true;\n                }\n            }\n            if (event.name === 'SEND_QUERY') {\n                queriedPeers = true;\n            }\n        }\n        if (!queriedPeers) {\n            throw new CodeError('No peers found in routing table!', 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n        }\n        if (!foundValue) {\n            yield queryErrorEvent({\n                from: this.components.peerId,\n                error: new CodeError('Not found', 'ERR_NOT_FOUND')\n            }, options);\n        }\n    }\n    // ----------- Content Routing\n    /**\n     * Announce to the network that we can provide given key's value\n     */\n    async *provide(key, options = {}) {\n        let sent = 0;\n        let success = 0;\n        const errors = [];\n        const dhts = [this.lan];\n        // only run provide on the wan if we are in server mode\n        if ((await this.wan.getMode()) === 'server') {\n            dhts.push(this.wan);\n        }\n        for await (const event of merge(...dhts.map(dht => dht.provide(key, options)))) {\n            yield event;\n            if (event.name === 'SEND_QUERY') {\n                sent++;\n            }\n            if (event.name === 'QUERY_ERROR') {\n                errors.push(event.error);\n            }\n            if (event.name === 'PEER_RESPONSE' && event.messageName === 'ADD_PROVIDER') {\n                log('sent provider record for %s to %p', key, event.from);\n                success++;\n            }\n        }\n        if (success === 0) {\n            if (errors.length > 0) {\n                // if all sends failed, throw an error to inform the caller\n                throw new CodeError(`Failed to provide to ${errors.length} of ${sent} peers`, 'ERR_PROVIDES_FAILED', { errors });\n            }\n            throw new CodeError('Failed to provide - no peers found', 'ERR_PROVIDES_FAILED');\n        }\n    }\n    /**\n     * Search the dht for up to `K` providers of the given CID\n     */\n    async *findProviders(key, options = {}) {\n        yield* merge(this.lan.findProviders(key, options), this.wan.findProviders(key, options));\n    }\n    // ----------- Peer Routing -----------\n    /**\n     * Search for a peer with the given ID\n     */\n    async *findPeer(id, options = {}) {\n        let queriedPeers = false;\n        for await (const event of merge(this.lan.findPeer(id, options), this.wan.findPeer(id, options))) {\n            yield event;\n            if (event.name === 'SEND_QUERY' || event.name === 'FINAL_PEER') {\n                queriedPeers = true;\n            }\n        }\n        if (!queriedPeers) {\n            throw new CodeError('Peer lookup failed', 'ERR_LOOKUP_FAILED');\n        }\n    }\n    /**\n     * Kademlia 'node lookup' operation\n     */\n    async *getClosestPeers(key, options = {}) {\n        yield* merge(this.lan.getClosestPeers(key, options), this.wan.getClosestPeers(key, options));\n    }\n    async refreshRoutingTable() {\n        await Promise.all([\n            this.lan.refreshRoutingTable(),\n            this.wan.refreshRoutingTable()\n        ]);\n    }\n}\n//# sourceMappingURL=dual-kad-dht.js.map","import { DefaultDualKadDHT } from './dual-kad-dht.js';\n/**\n * The types of events emitted during DHT queries\n */\nexport var EventTypes;\n(function (EventTypes) {\n    EventTypes[EventTypes[\"SEND_QUERY\"] = 0] = \"SEND_QUERY\";\n    EventTypes[EventTypes[\"PEER_RESPONSE\"] = 1] = \"PEER_RESPONSE\";\n    EventTypes[EventTypes[\"FINAL_PEER\"] = 2] = \"FINAL_PEER\";\n    EventTypes[EventTypes[\"QUERY_ERROR\"] = 3] = \"QUERY_ERROR\";\n    EventTypes[EventTypes[\"PROVIDER\"] = 4] = \"PROVIDER\";\n    EventTypes[EventTypes[\"VALUE\"] = 5] = \"VALUE\";\n    EventTypes[EventTypes[\"ADD_PEER\"] = 6] = \"ADD_PEER\";\n    EventTypes[EventTypes[\"DIAL_PEER\"] = 7] = \"DIAL_PEER\";\n})(EventTypes || (EventTypes = {}));\n/**\n * The types of messages sent to peers during DHT queries\n */\nexport var MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"PUT_VALUE\"] = 0] = \"PUT_VALUE\";\n    MessageType[MessageType[\"GET_VALUE\"] = 1] = \"GET_VALUE\";\n    MessageType[MessageType[\"ADD_PROVIDER\"] = 2] = \"ADD_PROVIDER\";\n    MessageType[MessageType[\"GET_PROVIDERS\"] = 3] = \"GET_PROVIDERS\";\n    MessageType[MessageType[\"FIND_NODE\"] = 4] = \"FIND_NODE\";\n    MessageType[MessageType[\"PING\"] = 5] = \"PING\";\n})(MessageType || (MessageType = {}));\nexport function kadDHT(init) {\n    return (components) => new DefaultDualKadDHT(components, init);\n}\n//# sourceMappingURL=index.js.map","import { concat } from 'uint8arrays/concat';\nimport { fromString } from 'uint8arrays/from-string';\nimport webcrypto from '../webcrypto.js';\n// WebKit on Linux does not support deriving a key from an empty PBKDF2 key.\n// So, as a workaround, we provide the generated key as a constant. We test that\n// this generated key is accurate in test/workaround.spec.ts\n// Generated via:\n// await crypto.subtle.exportKey('jwk',\n//   await crypto.subtle.deriveKey(\n//     { name: 'PBKDF2', salt: new Uint8Array(16), iterations: 32767, hash: { name: 'SHA-256' } },\n//     await crypto.subtle.importKey('raw', new Uint8Array(0), { name: 'PBKDF2' }, false, ['deriveKey']),\n//     { name: 'AES-GCM', length: 128 }, true, ['encrypt', 'decrypt'])\n// )\nexport const derivedEmptyPasswordKey = { alg: 'A128GCM', ext: true, k: 'scm9jmO_4BJAgdwWGVulLg', key_ops: ['encrypt', 'decrypt'], kty: 'oct' };\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\nexport function create(opts) {\n    const algorithm = opts?.algorithm ?? 'AES-GCM';\n    let keyLength = opts?.keyLength ?? 16;\n    const nonceLength = opts?.nonceLength ?? 12;\n    const digest = opts?.digest ?? 'SHA-256';\n    const saltLength = opts?.saltLength ?? 16;\n    const iterations = opts?.iterations ?? 32767;\n    const crypto = webcrypto.get();\n    keyLength *= 8; // Browser crypto uses bits instead of bytes\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to encrypt the data.\n     */\n    async function encrypt(data, password) {\n        const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n        const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = fromString(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['encrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            }\n        }\n        else {\n            // Derive a key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt']);\n        }\n        // Encrypt the string.\n        const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n        return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n    }\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to decrypt the data. The options used to create\n     * this decryption cipher must be the same as those used to create\n     * the encryption cipher.\n     */\n    async function decrypt(data, password) {\n        const salt = data.subarray(0, saltLength);\n        const nonce = data.subarray(saltLength, saltLength + nonceLength);\n        const ciphertext = data.subarray(saltLength + nonceLength);\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = fromString(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['decrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['decrypt']);\n            }\n        }\n        else {\n            // Derive the key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt']);\n        }\n        // Decrypt the string.\n        const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n        return new Uint8Array(plaintext);\n    }\n    const cipher = {\n        encrypt,\n        decrypt\n    };\n    return cipher;\n}\n//# sourceMappingURL=aes-gcm.browser.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { randomBytes as randB } from '@noble/hashes/utils';\nexport default function randomBytes(length) {\n    if (isNaN(length) || length <= 0) {\n        throw new CodeError('random bytes length must be a Number bigger than 0', 'ERR_INVALID_LENGTH');\n    }\n    return randB(length);\n}\n//# sourceMappingURL=random-bytes.js.map","import 'node-forge/lib/util.js';\nimport 'node-forge/lib/jsbn.js';\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport function bigIntegerToUintBase64url(num, len) {\n    // Call `.abs()` to convert to unsigned\n    let buf = Uint8Array.from(num.abs().toByteArray()); // toByteArray converts to big endian\n    // toByteArray() gives us back a signed array, which will include a leading 0\n    // byte if the most significant bit of the number is 1:\n    // https://docs.microsoft.com/en-us/windows/win32/seccertenroll/about-integer\n    // Our number will always be positive so we should remove the leading padding.\n    buf = buf[0] === 0 ? buf.subarray(1) : buf;\n    if (len != null) {\n        if (buf.length > len)\n            throw new Error('byte array longer than desired length');\n        buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);\n    }\n    return uint8ArrayToString(buf, 'base64url');\n}\n// Convert a base64url encoded string to a BigInteger\nexport function base64urlToBigInteger(str) {\n    const buf = base64urlToBuffer(str);\n    return new forge.jsbn.BigInteger(uint8ArrayToString(buf, 'base16'), 16);\n}\nexport function base64urlToBuffer(str, len) {\n    let buf = uint8ArrayFromString(str, 'base64urlpad');\n    if (len != null) {\n        if (buf.length > len)\n            throw new Error('byte array longer than desired length');\n        buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);\n    }\n    return buf;\n}\n//# sourceMappingURL=util.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { concat } from 'uint8arrays/concat';\nimport { fromString } from 'uint8arrays/from-string';\nimport webcrypto from '../webcrypto.js';\n// WebKit on Linux does not support deriving a key from an empty PBKDF2 key.\n// So, as a workaround, we provide the generated key as a constant. We test that\n// this generated key is accurate in test/workaround.spec.ts\n// Generated via:\n// await crypto.subtle.exportKey('jwk',\n//   await crypto.subtle.deriveKey(\n//     { name: 'PBKDF2', salt: new Uint8Array(16), iterations: 32767, hash: { name: 'SHA-256' } },\n//     await crypto.subtle.importKey('raw', new Uint8Array(0), { name: 'PBKDF2' }, false, ['deriveKey']),\n//     { name: 'AES-GCM', length: 128 }, true, ['encrypt', 'decrypt'])\n// )\nexport const derivedEmptyPasswordKey = { alg: 'A128GCM', ext: true, k: 'scm9jmO_4BJAgdwWGVulLg', key_ops: ['encrypt', 'decrypt'], kty: 'oct' };\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\nexport function create(opts) {\n    const algorithm = opts?.algorithm ?? 'AES-GCM';\n    let keyLength = opts?.keyLength ?? 16;\n    const nonceLength = opts?.nonceLength ?? 12;\n    const digest = opts?.digest ?? 'SHA-256';\n    const saltLength = opts?.saltLength ?? 16;\n    const iterations = opts?.iterations ?? 32767;\n    const crypto = webcrypto.get();\n    keyLength *= 8; // Browser crypto uses bits instead of bytes\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to encrypt the data.\n     */\n    async function encrypt(data, password) {\n        const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n        const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = fromString(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['encrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            }\n        }\n        else {\n            // Derive a key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt']);\n        }\n        // Encrypt the string.\n        const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n        return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n    }\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to decrypt the data. The options used to create\n     * this decryption cipher must be the same as those used to create\n     * the encryption cipher.\n     */\n    async function decrypt(data, password) {\n        const salt = data.subarray(0, saltLength);\n        const nonce = data.subarray(saltLength, saltLength + nonceLength);\n        const ciphertext = data.subarray(saltLength + nonceLength);\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = fromString(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['decrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['decrypt']);\n            }\n        }\n        else {\n            // Derive the key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt']);\n        }\n        // Decrypt the string.\n        const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n        return new Uint8Array(plaintext);\n    }\n    const cipher = {\n        encrypt,\n        decrypt\n    };\n    return cipher;\n}\n//# sourceMappingURL=aes-gcm.browser.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { randomBytes as randB } from '@noble/hashes/utils';\nexport default function randomBytes(length) {\n    if (isNaN(length) || length <= 0) {\n        throw new CodeError('random bytes length must be a Number bigger than 0', 'ERR_INVALID_LENGTH');\n    }\n    return randB(length);\n}\n//# sourceMappingURL=random-bytes.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap {\n    map;\n    constructor(map) {\n        this.map = new Map();\n        if (map != null) {\n            for (const [key, value] of map.entries()) {\n                this.map.set(key.toString(), value);\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(peer) {\n        this.map.delete(peer.toString());\n    }\n    entries() {\n        return mapIterable(this.map.entries(), (val) => {\n            return [peerIdFromString(val[0]), val[1]];\n        });\n    }\n    forEach(fn) {\n        this.map.forEach((value, key) => {\n            fn(value, peerIdFromString(key), this);\n        });\n    }\n    get(peer) {\n        return this.map.get(peer.toString());\n    }\n    has(peer) {\n        return this.map.has(peer.toString());\n    }\n    set(peer, value) {\n        this.map.set(peer.toString(), value);\n    }\n    keys() {\n        return mapIterable(this.map.keys(), (val) => {\n            return peerIdFromString(val);\n        });\n    }\n    values() {\n        return this.map.values();\n    }\n    get size() {\n        return this.map.size;\n    }\n}\n//# sourceMappingURL=map.js.map","import { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nexport class PeerSet {\n    set;\n    constructor(set) {\n        this.set = new Set();\n        if (set != null) {\n            for (const key of set) {\n                this.set.add(key.toString());\n            }\n        }\n    }\n    get size() {\n        return this.set.size;\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n    add(peer) {\n        this.set.add(peer.toString());\n    }\n    clear() {\n        this.set.clear();\n    }\n    delete(peer) {\n        this.set.delete(peer.toString());\n    }\n    entries() {\n        return mapIterable(this.set.entries(), (val) => {\n            const peerId = peerIdFromString(val[0]);\n            return [peerId, peerId];\n        });\n    }\n    forEach(predicate) {\n        this.set.forEach((str) => {\n            const id = peerIdFromString(str);\n            predicate(id, id, this);\n        });\n    }\n    has(peer) {\n        return this.set.has(peer.toString());\n    }\n    values() {\n        return mapIterable(this.set.values(), (val) => {\n            return peerIdFromString(val);\n        });\n    }\n    intersection(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            if (this.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    difference(other) {\n        const output = new PeerSet();\n        for (const peerId of this) {\n            if (!other.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    union(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            output.add(peerId);\n        }\n        for (const peerId of this) {\n            output.add(peerId);\n        }\n        return output;\n    }\n}\n//# sourceMappingURL=set.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import debug from 'debug';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64 } from 'multiformats/bases/base64';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nexport var codes;\n(function (codes) {\n    codes[\"ERR_ALREADY_ABORTED\"] = \"ERR_ALREADY_ABORTED\";\n    codes[\"ERR_DATA_CHANNEL\"] = \"ERR_DATA_CHANNEL\";\n    codes[\"ERR_CONNECTION_CLOSED\"] = \"ERR_CONNECTION_CLOSED\";\n    codes[\"ERR_HASH_NOT_SUPPORTED\"] = \"ERR_HASH_NOT_SUPPORTED\";\n    codes[\"ERR_INVALID_MULTIADDR\"] = \"ERR_INVALID_MULTIADDR\";\n    codes[\"ERR_INVALID_FINGERPRINT\"] = \"ERR_INVALID_FINGERPRINT\";\n    codes[\"ERR_INVALID_PARAMETERS\"] = \"ERR_INVALID_PARAMETERS\";\n    codes[\"ERR_NOT_IMPLEMENTED\"] = \"ERR_NOT_IMPLEMENTED\";\n    codes[\"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\";\n    codes[\"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\";\n})(codes || (codes = {}));\nexport class WebRTCTransportError extends CodeError {\n    constructor(msg, code) {\n        super(`WebRTC transport error: ${msg}`, code ?? '');\n        this.name = 'WebRTCTransportError';\n    }\n}\nexport class ConnectionClosedError extends WebRTCTransportError {\n    constructor(state, msg) {\n        super(`peerconnection moved to state: ${state}: ${msg}`, codes.ERR_CONNECTION_CLOSED);\n        this.name = 'WebRTC/ConnectionClosed';\n    }\n}\nexport function connectionClosedError(state, msg) {\n    return new ConnectionClosedError(state, msg);\n}\nexport class DataChannelError extends WebRTCTransportError {\n    constructor(streamLabel, msg) {\n        super(`[stream: ${streamLabel}] data channel error: ${msg}`, codes.ERR_DATA_CHANNEL);\n        this.name = 'WebRTC/DataChannelError';\n    }\n}\nexport function dataChannelError(streamLabel, msg) {\n    return new DataChannelError(streamLabel, msg);\n}\nexport class InappropriateMultiaddrError extends WebRTCTransportError {\n    constructor(msg) {\n        super(`There was a problem with the Multiaddr which was passed in: ${msg}`, codes.ERR_INVALID_MULTIADDR);\n        this.name = 'WebRTC/InappropriateMultiaddrError';\n    }\n}\nexport function inappropriateMultiaddr(msg) {\n    return new InappropriateMultiaddrError(msg);\n}\nexport class InvalidArgumentError extends WebRTCTransportError {\n    constructor(msg) {\n        super(`There was a problem with a provided argument: ${msg}`, codes.ERR_INVALID_PARAMETERS);\n        this.name = 'WebRTC/InvalidArgumentError';\n    }\n}\nexport function invalidArgument(msg) {\n    return new InvalidArgumentError(msg);\n}\nexport class InvalidFingerprintError extends WebRTCTransportError {\n    constructor(fingerprint, source) {\n        super(`Invalid fingerprint \"${fingerprint}\" within ${source}`, codes.ERR_INVALID_FINGERPRINT);\n        this.name = 'WebRTC/InvalidFingerprintError';\n    }\n}\nexport function invalidFingerprint(fingerprint, source) {\n    return new InvalidFingerprintError(fingerprint, source);\n}\nexport class OperationAbortedError extends WebRTCTransportError {\n    constructor(context, abortReason) {\n        super(`Signalled to abort because (${abortReason}}) ${context}`, codes.ERR_ALREADY_ABORTED);\n        this.name = 'WebRTC/OperationAbortedError';\n    }\n}\nexport function operationAborted(context, reason) {\n    return new OperationAbortedError(context, reason);\n}\nexport class OverStreamLimitError extends WebRTCTransportError {\n    constructor(msg) {\n        const code = msg.startsWith('inbound') ? codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS : codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS;\n        super(msg, code);\n        this.name = 'WebRTC/OverStreamLimitError';\n    }\n}\nexport function overStreamLimit(dir, proto) {\n    return new OverStreamLimitError(`${dir} stream limit reached for protocol - ${proto}`);\n}\nexport class UnimplementedError extends WebRTCTransportError {\n    constructor(methodName) {\n        super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`, codes.ERR_NOT_IMPLEMENTED);\n        this.name = 'WebRTC/UnimplementedError';\n    }\n}\nexport function unimplemented(methodName) {\n    return new UnimplementedError(methodName);\n}\nexport class UnsupportedHashAlgorithmError extends WebRTCTransportError {\n    constructor(algo) {\n        super(`unsupported hash algorithm: ${algo}`, codes.ERR_HASH_NOT_SUPPORTED);\n        this.name = 'WebRTC/UnsupportedHashAlgorithmError';\n    }\n}\nexport function unsupportedHashAlgorithm(algorithm) {\n    return new UnsupportedHashAlgorithmError(algorithm);\n}\n//# sourceMappingURL=error.js.map","import { detect } from 'detect-browser';\nconst browser = detect();\nexport const isFirefox = ((browser != null) && browser.name === 'firefox');\nexport const nopSource = async function* nop() { };\nexport const nopSink = async (_) => { };\n//# sourceMappingURL=util.js.map","import { logger } from '@libp2p/logger';\nimport { nopSink, nopSource } from './util.js';\nconst log = logger('libp2p:webrtc:connection');\nexport class WebRTCMultiaddrConnection {\n    /**\n     * WebRTC Peer Connection\n     */\n    peerConnection;\n    /**\n     * The multiaddr address used to communicate with the remote peer\n     */\n    remoteAddr;\n    /**\n     * Holds the lifecycle times of the connection\n     */\n    timeline;\n    /**\n     * Optional metrics counter group for this connection\n     */\n    metrics;\n    /**\n     * The stream source, a no-op as the transport natively supports multiplexing\n     */\n    source = nopSource();\n    /**\n     * The stream destination, a no-op as the transport natively supports multiplexing\n     */\n    sink = nopSink;\n    constructor(init) {\n        this.remoteAddr = init.remoteAddr;\n        this.timeline = init.timeline;\n        this.peerConnection = init.peerConnection;\n        this.peerConnection.onconnectionstatechange = () => {\n            if (this.peerConnection.connectionState === 'closed' || this.peerConnection.connectionState === 'disconnected' || this.peerConnection.connectionState === 'failed') {\n                this.timeline.close = Date.now();\n            }\n        };\n    }\n    async close(options) {\n        log.trace('closing connection');\n        this.peerConnection.close();\n        this.timeline.close = Date.now();\n        this.metrics?.increment({ close: true });\n    }\n    abort(err) {\n        log.error('closing connection due to error', err);\n        this.peerConnection.close();\n        this.timeline.close = Date.now();\n        this.metrics?.increment({ abort: true });\n    }\n}\n//# sourceMappingURL=maconn.js.map","export const RTCPeerConnection = globalThis.RTCPeerConnection;\nexport const RTCSessionDescription = globalThis.RTCSessionDescription;\nexport const RTCIceCandidate = globalThis.RTCIceCandidate;\nexport function cleanup() { }\n//# sourceMappingURL=index.browser.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Message;\n(function (Message) {\n    let Flag;\n    (function (Flag) {\n        Flag[\"FIN\"] = \"FIN\";\n        Flag[\"STOP_SENDING\"] = \"STOP_SENDING\";\n        Flag[\"RESET\"] = \"RESET\";\n    })(Flag = Message.Flag || (Message.Flag = {}));\n    let __FlagValues;\n    (function (__FlagValues) {\n        __FlagValues[__FlagValues[\"FIN\"] = 0] = \"FIN\";\n        __FlagValues[__FlagValues[\"STOP_SENDING\"] = 1] = \"STOP_SENDING\";\n        __FlagValues[__FlagValues[\"RESET\"] = 2] = \"RESET\";\n    })(__FlagValues || (__FlagValues = {}));\n    (function (Flag) {\n        Flag.codec = () => {\n            return enumeration(__FlagValues);\n        };\n    })(Flag = Message.Flag || (Message.Flag = {}));\n    let _codec;\n    Message.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.flag != null) {\n                    w.uint32(8);\n                    Message.Flag.codec().encode(obj.flag, w);\n                }\n                if (obj.message != null) {\n                    w.uint32(18);\n                    w.bytes(obj.message);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.flag = Message.Flag.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.message = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Message.encode = (obj) => {\n        return encodeMessage(obj, Message.codec());\n    };\n    Message.decode = (buf) => {\n        return decodeMessage(buf, Message.codec());\n    };\n})(Message || (Message = {}));\n//# sourceMappingURL=message.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Message;\n(function (Message) {\n    let Type;\n    (function (Type) {\n        Type[\"SDP_OFFER\"] = \"SDP_OFFER\";\n        Type[\"SDP_ANSWER\"] = \"SDP_ANSWER\";\n        Type[\"ICE_CANDIDATE\"] = \"ICE_CANDIDATE\";\n    })(Type = Message.Type || (Message.Type = {}));\n    let __TypeValues;\n    (function (__TypeValues) {\n        __TypeValues[__TypeValues[\"SDP_OFFER\"] = 0] = \"SDP_OFFER\";\n        __TypeValues[__TypeValues[\"SDP_ANSWER\"] = 1] = \"SDP_ANSWER\";\n        __TypeValues[__TypeValues[\"ICE_CANDIDATE\"] = 2] = \"ICE_CANDIDATE\";\n    })(__TypeValues || (__TypeValues = {}));\n    (function (Type) {\n        Type.codec = () => {\n            return enumeration(__TypeValues);\n        };\n    })(Type = Message.Type || (Message.Type = {}));\n    let _codec;\n    Message.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.type != null) {\n                    w.uint32(8);\n                    Message.Type.codec().encode(obj.type, w);\n                }\n                if (obj.data != null) {\n                    w.uint32(18);\n                    w.string(obj.data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.type = Message.Type.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.data = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Message.encode = (obj) => {\n        return encodeMessage(obj, Message.codec());\n    };\n    Message.decode = (buf) => {\n        return decodeMessage(buf, Message.codec());\n    };\n})(Message || (Message = {}));\n//# sourceMappingURL=message.js.map","import { logger } from '@libp2p/logger';\nimport { isFirefox } from '../util.js';\nimport { RTCIceCandidate } from '../webrtc/index.js';\nimport { Message } from './pb/message.js';\nconst log = logger('libp2p:webrtc:peer:util');\nexport const readCandidatesUntilConnected = async (connectedPromise, pc, stream) => {\n    while (true) {\n        const readResult = await Promise.race([connectedPromise.promise, stream.read()]);\n        // check if readResult is a message\n        if (readResult instanceof Object) {\n            const message = readResult;\n            if (message.type !== Message.Type.ICE_CANDIDATE) {\n                throw new Error('expected only ice candidates');\n            }\n            // end of candidates has been signalled\n            if (message.data == null || message.data === '') {\n                log.trace('end-of-candidates received');\n                break;\n            }\n            log.trace('received new ICE candidate: %s', message.data);\n            try {\n                await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(message.data)));\n            }\n            catch (err) {\n                log.error('bad candidate received: ', err);\n                throw new Error('bad candidate received');\n            }\n        }\n        else {\n            // connected promise resolved\n            break;\n        }\n    }\n    await connectedPromise.promise;\n};\nexport function resolveOnConnected(pc, promise) {\n    pc[isFirefox ? 'oniceconnectionstatechange' : 'onconnectionstatechange'] = (_) => {\n        log.trace('receiver peerConnectionState state: ', pc.connectionState);\n        switch (isFirefox ? pc.iceConnectionState : pc.connectionState) {\n            case 'connected':\n                promise.resolve();\n                break;\n            case 'failed':\n            case 'disconnected':\n            case 'closed':\n                promise.reject(new Error('RTCPeerConnection was closed'));\n                break;\n            default:\n                break;\n        }\n    };\n}\n//# sourceMappingURL=util.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { pbStream } from 'it-protobuf-stream';\nimport pDefer, {} from 'p-defer';\nimport { DataChannelMuxerFactory } from '../muxer.js';\nimport { RTCPeerConnection, RTCSessionDescription } from '../webrtc/index.js';\nimport { Message } from './pb/message.js';\nimport { readCandidatesUntilConnected, resolveOnConnected } from './util.js';\nconst DEFAULT_TIMEOUT = 30 * 1000;\nconst log = logger('libp2p:webrtc:peer');\nexport async function handleIncomingStream({ rtcConfiguration, dataChannelOptions, stream: rawStream }) {\n    const signal = AbortSignal.timeout(DEFAULT_TIMEOUT);\n    const stream = pbStream(abortableDuplex(rawStream, signal)).pb(Message);\n    const pc = new RTCPeerConnection(rtcConfiguration);\n    try {\n        const muxerFactory = new DataChannelMuxerFactory({ peerConnection: pc, dataChannelOptions });\n        const connectedPromise = pDefer();\n        const answerSentPromise = pDefer();\n        signal.onabort = () => {\n            connectedPromise.reject(new CodeError('Timed out while trying to connect', 'ERR_TIMEOUT'));\n        };\n        // candidate callbacks\n        pc.onicecandidate = ({ candidate }) => {\n            answerSentPromise.promise.then(async () => {\n                await stream.write({\n                    type: Message.Type.ICE_CANDIDATE,\n                    data: (candidate != null) ? JSON.stringify(candidate.toJSON()) : ''\n                });\n            }, (err) => {\n                log.error('cannot set candidate since sending answer failed', err);\n                connectedPromise.reject(err);\n            });\n        };\n        resolveOnConnected(pc, connectedPromise);\n        // read an SDP offer\n        const pbOffer = await stream.read();\n        if (pbOffer.type !== Message.Type.SDP_OFFER) {\n            throw new Error(`expected message type SDP_OFFER, received: ${pbOffer.type ?? 'undefined'} `);\n        }\n        const offer = new RTCSessionDescription({\n            type: 'offer',\n            sdp: pbOffer.data\n        });\n        await pc.setRemoteDescription(offer).catch(err => {\n            log.error('could not execute setRemoteDescription', err);\n            throw new Error('Failed to set remoteDescription');\n        });\n        // create and write an SDP answer\n        const answer = await pc.createAnswer().catch(err => {\n            log.error('could not execute createAnswer', err);\n            answerSentPromise.reject(err);\n            throw new Error('Failed to create answer');\n        });\n        // write the answer to the remote\n        await stream.write({ type: Message.Type.SDP_ANSWER, data: answer.sdp });\n        await pc.setLocalDescription(answer).catch(err => {\n            log.error('could not execute setLocalDescription', err);\n            answerSentPromise.reject(err);\n            throw new Error('Failed to set localDescription');\n        });\n        answerSentPromise.resolve();\n        // wait until candidates are connected\n        await readCandidatesUntilConnected(connectedPromise, pc, stream);\n        const remoteAddress = parseRemoteAddress(pc.currentRemoteDescription?.sdp ?? '');\n        return { pc, muxerFactory, remoteAddress };\n    }\n    catch (err) {\n        pc.close();\n        throw err;\n    }\n}\nexport async function initiateConnection({ rtcConfiguration, dataChannelOptions, signal, stream: rawStream }) {\n    const stream = pbStream(abortableDuplex(rawStream, signal)).pb(Message);\n    // setup peer connection\n    const pc = new RTCPeerConnection(rtcConfiguration);\n    try {\n        const muxerFactory = new DataChannelMuxerFactory({ peerConnection: pc, dataChannelOptions });\n        const connectedPromise = pDefer();\n        resolveOnConnected(pc, connectedPromise);\n        // reject the connectedPromise if the signal aborts\n        signal.onabort = connectedPromise.reject;\n        // we create the channel so that the peerconnection has a component for which\n        // to collect candidates. The label is not relevant to connection initiation\n        // but can be useful for debugging\n        const channel = pc.createDataChannel('init');\n        // setup callback to write ICE candidates to the remote\n        // peer\n        pc.onicecandidate = ({ candidate }) => {\n            void stream.write({\n                type: Message.Type.ICE_CANDIDATE,\n                data: (candidate != null) ? JSON.stringify(candidate.toJSON()) : ''\n            })\n                .catch(err => {\n                log.error('error sending ICE candidate', err);\n            });\n        };\n        // create an offer\n        const offerSdp = await pc.createOffer();\n        // write the offer to the stream\n        await stream.write({ type: Message.Type.SDP_OFFER, data: offerSdp.sdp });\n        // set offer as local description\n        await pc.setLocalDescription(offerSdp).catch(err => {\n            log.error('could not execute setLocalDescription', err);\n            throw new Error('Failed to set localDescription');\n        });\n        // read answer\n        const answerMessage = await stream.read();\n        if (answerMessage.type !== Message.Type.SDP_ANSWER) {\n            throw new Error('remote should send an SDP answer');\n        }\n        const answerSdp = new RTCSessionDescription({ type: 'answer', sdp: answerMessage.data });\n        await pc.setRemoteDescription(answerSdp).catch(err => {\n            log.error('could not execute setRemoteDescription', err);\n            throw new Error('Failed to set remoteDescription');\n        });\n        await readCandidatesUntilConnected(connectedPromise, pc, stream);\n        channel.close();\n        const remoteAddress = parseRemoteAddress(pc.currentRemoteDescription?.sdp ?? '');\n        return { pc, muxerFactory, remoteAddress };\n    }\n    catch (err) {\n        pc.close();\n        throw err;\n    }\n}\nfunction parseRemoteAddress(sdp) {\n    // 'a=candidate:1746876089 1 udp 2113937151 0614fbad-b...ocal 54882 typ host generation 0 network-cost 999'\n    const candidateLine = sdp.split('\\r\\n').filter(line => line.startsWith('a=candidate')).pop();\n    const candidateParts = candidateLine?.split(' ');\n    if (candidateLine == null || candidateParts == null || candidateParts.length < 5) {\n        log('could not parse remote address from', candidateLine);\n        return '/webrtc';\n    }\n    return `/dnsaddr/${candidateParts[4]}/${candidateParts[2].toLowerCase()}/${candidateParts[5]}/webrtc`;\n}\n//# sourceMappingURL=handler.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/transport';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { WebRTC } from '@multiformats/multiaddr-matcher';\nimport { codes } from '../error.js';\nimport { WebRTCMultiaddrConnection } from '../maconn.js';\nimport { cleanup } from '../webrtc/index.js';\nimport { initiateConnection, handleIncomingStream } from './handler.js';\nimport { WebRTCPeerListener } from './listener.js';\nconst log = logger('libp2p:webrtc:peer');\nconst WEBRTC_TRANSPORT = '/webrtc';\nconst CIRCUIT_RELAY_TRANSPORT = '/p2p-circuit';\nconst SIGNALING_PROTO_ID = '/webrtc-signaling/0.0.1';\nexport class WebRTCTransport {\n    components;\n    init;\n    _started = false;\n    metrics;\n    constructor(components, init = {}) {\n        this.components = components;\n        this.init = init;\n        if (components.metrics != null) {\n            this.metrics = {\n                dialerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_dialer_events_total', {\n                    label: 'event',\n                    help: 'Total count of WebRTC dialer events by type'\n                }),\n                listenerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_listener_events_total', {\n                    label: 'event',\n                    help: 'Total count of WebRTC listener events by type'\n                })\n            };\n        }\n    }\n    isStarted() {\n        return this._started;\n    }\n    async start() {\n        await this.components.registrar.handle(SIGNALING_PROTO_ID, (data) => {\n            this._onProtocol(data).catch(err => { log.error('failed to handle incoming connect from %p', data.connection.remotePeer, err); });\n        }, {\n            runOnTransientConnection: true\n        });\n        this._started = true;\n    }\n    async stop() {\n        await this.components.registrar.unhandle(SIGNALING_PROTO_ID);\n        cleanup();\n        this._started = false;\n    }\n    createListener(options) {\n        return new WebRTCPeerListener(this.components);\n    }\n    [Symbol.toStringTag] = '@libp2p/webrtc';\n    [symbol] = true;\n    filter(multiaddrs) {\n        return multiaddrs.filter(WebRTC.exactMatch);\n    }\n    /*\n     * dial connects to a remote via the circuit relay or any other protocol\n     * and proceeds to upgrade to a webrtc connection.\n     * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>\n     * For a circuit relay, this will be of the form\n     * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>\n    */\n    async dial(ma, options) {\n        log.trace('dialing address: ', ma);\n        const { baseAddr, peerId } = splitAddr(ma);\n        if (options.signal == null) {\n            const controller = new AbortController();\n            options.signal = controller.signal;\n        }\n        this.metrics?.dialerEvents.increment({ open: true });\n        const connection = await this.components.transportManager.dial(baseAddr, options);\n        const signalingStream = await connection.newStream(SIGNALING_PROTO_ID, {\n            ...options,\n            runOnTransientConnection: true\n        });\n        try {\n            const { pc, muxerFactory, remoteAddress } = await initiateConnection({\n                stream: signalingStream,\n                rtcConfiguration: this.init.rtcConfiguration,\n                dataChannelOptions: this.init.dataChannel,\n                signal: options.signal\n            });\n            const result = await options.upgrader.upgradeOutbound(new WebRTCMultiaddrConnection({\n                peerConnection: pc,\n                timeline: { open: Date.now() },\n                remoteAddr: multiaddr(remoteAddress).encapsulate(`/p2p/${peerId.toString()}`),\n                metrics: this.metrics?.dialerEvents\n            }), {\n                skipProtection: true,\n                skipEncryption: true,\n                muxerFactory\n            });\n            // close the stream if SDP has been exchanged successfully\n            await signalingStream.close();\n            return result;\n        }\n        catch (err) {\n            this.metrics?.dialerEvents.increment({ error: true });\n            // reset the stream in case of any error\n            signalingStream.abort(err);\n            throw err;\n        }\n        finally {\n            // Close the signaling connection\n            await connection.close();\n        }\n    }\n    async _onProtocol({ connection, stream }) {\n        try {\n            const { pc, muxerFactory, remoteAddress } = await handleIncomingStream({\n                rtcConfiguration: this.init.rtcConfiguration,\n                connection,\n                stream,\n                dataChannelOptions: this.init.dataChannel\n            });\n            await this.components.upgrader.upgradeInbound(new WebRTCMultiaddrConnection({\n                peerConnection: pc,\n                timeline: { open: (new Date()).getTime() },\n                remoteAddr: multiaddr(remoteAddress).encapsulate(`/p2p/${connection.remotePeer.toString()}`),\n                metrics: this.metrics?.listenerEvents\n            }), {\n                skipEncryption: true,\n                skipProtection: true,\n                muxerFactory\n            });\n        }\n        catch (err) {\n            stream.abort(err);\n            throw err;\n        }\n        finally {\n            // Close the signaling connection\n            await connection.close();\n        }\n    }\n}\nexport function splitAddr(ma) {\n    const addrs = ma.toString().split(WEBRTC_TRANSPORT + '/');\n    if (addrs.length !== 2) {\n        throw new CodeError('webrtc protocol was not present in multiaddr', codes.ERR_INVALID_MULTIADDR);\n    }\n    if (!addrs[0].includes(CIRCUIT_RELAY_TRANSPORT)) {\n        throw new CodeError('p2p-circuit protocol was not present in multiaddr', codes.ERR_INVALID_MULTIADDR);\n    }\n    // look for remote peerId\n    let remoteAddr = multiaddr(addrs[0]);\n    const destination = multiaddr('/' + addrs[1]);\n    const destinationIdString = destination.getPeerId();\n    if (destinationIdString == null) {\n        throw new CodeError('destination peer id was missing', codes.ERR_INVALID_MULTIADDR);\n    }\n    const lastProtoInRemote = remoteAddr.protos().pop();\n    if (lastProtoInRemote === undefined) {\n        throw new CodeError('invalid multiaddr', codes.ERR_INVALID_MULTIADDR);\n    }\n    if (lastProtoInRemote.name !== 'p2p') {\n        remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`);\n    }\n    return { baseAddr: remoteAddr, peerId: peerIdFromString(destinationIdString) };\n}\n//# sourceMappingURL=transport.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { logger } from '@libp2p/logger';\nimport { bases } from 'multiformats/basics';\nimport * as multihashes from 'multihashes';\nimport { inappropriateMultiaddr, invalidArgument, invalidFingerprint, unsupportedHashAlgorithm } from '../error.js';\nimport { CERTHASH_CODE } from './transport.js';\nconst log = logger('libp2p:webrtc:sdp');\n/**\n * Get base2 | identity decoders\n */\n// @ts-expect-error - Not easy to combine these types.\nexport const mbdecoder = Object.values(bases).map(b => b.decoder).reduce((d, b) => d.or(b));\nexport function getLocalFingerprint(pc) {\n    // try to fetch fingerprint from local certificate\n    const localCert = pc.getConfiguration().certificates?.at(0);\n    if (localCert == null || localCert.getFingerprints == null) {\n        log.trace('fetching fingerprint from local SDP');\n        const localDescription = pc.localDescription;\n        if (localDescription == null) {\n            return undefined;\n        }\n        return getFingerprintFromSdp(localDescription.sdp);\n    }\n    log.trace('fetching fingerprint from local certificate');\n    if (localCert.getFingerprints().length === 0) {\n        return undefined;\n    }\n    const fingerprint = localCert.getFingerprints()[0].value;\n    if (fingerprint == null) {\n        throw invalidFingerprint('', 'no fingerprint on local certificate');\n    }\n    return fingerprint;\n}\nconst fingerprintRegex = /^a=fingerprint:(?:\\w+-[0-9]+)\\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;\nexport function getFingerprintFromSdp(sdp) {\n    const searchResult = sdp.match(fingerprintRegex);\n    return searchResult?.groups?.fingerprint;\n}\n/**\n * Get base2 | identity decoders\n */\nfunction ipv(ma) {\n    for (const proto of ma.protoNames()) {\n        if (proto.startsWith('ip')) {\n            return proto.toUpperCase();\n        }\n    }\n    log('Warning: multiaddr does not appear to contain IP4 or IP6, defaulting to IP6', ma);\n    return 'IP6';\n}\n// Extract the certhash from a multiaddr\nexport function certhash(ma) {\n    const tups = ma.stringTuples();\n    const certhash = tups.filter((tup) => tup[0] === CERTHASH_CODE).map((tup) => tup[1])[0];\n    if (certhash === undefined || certhash === '') {\n        throw inappropriateMultiaddr(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);\n    }\n    return certhash;\n}\n/**\n * Convert a certhash into a multihash\n */\nexport function decodeCerthash(certhash) {\n    const mbdecoded = mbdecoder.decode(certhash);\n    return multihashes.decode(mbdecoded);\n}\n/**\n * Extract the fingerprint from a multiaddr\n */\nexport function ma2Fingerprint(ma) {\n    const mhdecoded = decodeCerthash(certhash(ma));\n    const prefix = toSupportedHashFunction(mhdecoded.name);\n    const fingerprint = mhdecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n    const sdp = fingerprint.match(/.{1,2}/g);\n    if (sdp == null) {\n        throw invalidFingerprint(fingerprint, ma.toString());\n    }\n    return [`${prefix.toUpperCase()} ${sdp.join(':').toUpperCase()}`, fingerprint];\n}\n/**\n * Normalize the hash name from a given multihash has name\n */\nexport function toSupportedHashFunction(name) {\n    switch (name) {\n        case 'sha1':\n            return 'sha-1';\n        case 'sha2-256':\n            return 'sha-256';\n        case 'sha2-512':\n            return 'sha-512';\n        default:\n            throw unsupportedHashAlgorithm(name);\n    }\n}\n/**\n * Convert a multiaddr into a SDP\n */\nfunction ma2sdp(ma, ufrag) {\n    const { host, port } = ma.toOptions();\n    const ipVersion = ipv(ma);\n    const [CERTFP] = ma2Fingerprint(ma);\n    return `v=0\no=- 0 0 IN ${ipVersion} ${host}\ns=-\nc=IN ${ipVersion} ${host}\nt=0 0\na=ice-lite\nm=application ${port} UDP/DTLS/SCTP webrtc-datachannel\na=mid:0\na=setup:passive\na=ice-ufrag:${ufrag}\na=ice-pwd:${ufrag}\na=fingerprint:${CERTFP}\na=sctp-port:5000\na=max-message-size:16384\na=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host\\r\\n`;\n}\n/**\n * Create an answer SDP from a multiaddr\n */\nexport function fromMultiAddr(ma, ufrag) {\n    return {\n        type: 'answer',\n        sdp: ma2sdp(ma, ufrag)\n    };\n}\n/**\n * Replace (munge) the ufrag and password values in a SDP\n */\nexport function munge(desc, ufrag) {\n    if (desc.sdp === undefined) {\n        throw invalidArgument(\"Can't munge a missing SDP\");\n    }\n    desc.sdp = desc.sdp\n        .replace(/\\na=ice-ufrag:[^\\n]*\\n/, '\\na=ice-ufrag:' + ufrag + '\\n')\n        .replace(/\\na=ice-pwd:[^\\n]*\\n/, '\\na=ice-pwd:' + ufrag + '\\n');\n    return desc;\n}\n//# sourceMappingURL=sdp.js.map","const charset = Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/');\nexport const genUfrag = (len) => [...Array(len)].map(() => charset.at(Math.floor(Math.random() * charset.length))).join('');\n//# sourceMappingURL=util.js.map","import { noise as Noise } from '@chainsafe/libp2p-noise';\nimport { symbol } from '@libp2p/interface/transport';\nimport { logger } from '@libp2p/logger';\nimport * as p from '@libp2p/peer-id';\nimport { protocols } from '@multiformats/multiaddr';\nimport { WebRTCDirect } from '@multiformats/multiaddr-matcher';\nimport * as multihashes from 'multihashes';\nimport { concat } from 'uint8arrays/concat';\nimport { fromString as uint8arrayFromString } from 'uint8arrays/from-string';\nimport { dataChannelError, inappropriateMultiaddr, unimplemented, invalidArgument } from '../error.js';\nimport { WebRTCMultiaddrConnection } from '../maconn.js';\nimport { DataChannelMuxerFactory } from '../muxer.js';\nimport { createStream } from '../stream.js';\nimport { isFirefox } from '../util.js';\nimport { RTCPeerConnection } from '../webrtc/index.js';\nimport * as sdp from './sdp.js';\nimport { genUfrag } from './util.js';\nconst log = logger('libp2p:webrtc:transport');\n/**\n * The time to wait, in milliseconds, for the data channel handshake to complete\n */\nconst HANDSHAKE_TIMEOUT_MS = 10000;\n/**\n * Created by converting the hexadecimal protocol code to an integer.\n *\n * {@link https://github.com/multiformats/multiaddr/blob/master/protocols.csv}\n */\nexport const WEBRTC_CODE = protocols('webrtc-direct').code;\n/**\n * Created by converting the hexadecimal protocol code to an integer.\n *\n * {@link https://github.com/multiformats/multiaddr/blob/master/protocols.csv}\n */\nexport const CERTHASH_CODE = protocols('certhash').code;\nexport class WebRTCDirectTransport {\n    metrics;\n    components;\n    init;\n    constructor(components, init = {}) {\n        this.components = components;\n        this.init = init;\n        if (components.metrics != null) {\n            this.metrics = {\n                dialerEvents: components.metrics.registerCounterGroup('libp2p_webrtc-direct_dialer_events_total', {\n                    label: 'event',\n                    help: 'Total count of WebRTC-direct dial events by type'\n                })\n            };\n        }\n    }\n    /**\n     * Dial a given multiaddr\n     */\n    async dial(ma, options) {\n        const rawConn = await this._connect(ma, options);\n        log(`dialing address - ${ma.toString()}`);\n        return rawConn;\n    }\n    /**\n     * Create transport listeners no supported by browsers\n     */\n    createListener(options) {\n        throw unimplemented('WebRTCTransport.createListener');\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid addresses for the transport\n     */\n    filter(multiaddrs) {\n        return multiaddrs.filter(WebRTCDirect.exactMatch);\n    }\n    /**\n     * Implement toString() for WebRTCTransport\n     */\n    [Symbol.toStringTag] = '@libp2p/webrtc-direct';\n    /**\n     * Symbol.for('@libp2p/transport')\n     */\n    [symbol] = true;\n    /**\n     * Connect to a peer using a multiaddr\n     */\n    async _connect(ma, options) {\n        const controller = new AbortController();\n        const signal = controller.signal;\n        const remotePeerString = ma.getPeerId();\n        if (remotePeerString === null) {\n            throw inappropriateMultiaddr(\"we need to have the remote's PeerId\");\n        }\n        const theirPeerId = p.peerIdFromString(remotePeerString);\n        const remoteCerthash = sdp.decodeCerthash(sdp.certhash(ma));\n        // ECDSA is preferred over RSA here. From our testing we find that P-256 elliptic\n        // curve is supported by Pion, webrtc-rs, as well as Chromium (P-228 and P-384\n        // was not supported in Chromium). We use the same hash function as found in the\n        // multiaddr if it is supported.\n        const certificate = await RTCPeerConnection.generateCertificate({\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n            hash: sdp.toSupportedHashFunction(remoteCerthash.name)\n        });\n        const peerConnection = new RTCPeerConnection({ certificates: [certificate] });\n        try {\n            // create data channel for running the noise handshake. Once the data channel is opened,\n            // the remote will initiate the noise handshake. This is used to confirm the identity of\n            // the peer.\n            const dataChannelOpenPromise = new Promise((resolve, reject) => {\n                const handshakeDataChannel = peerConnection.createDataChannel('', { negotiated: true, id: 0 });\n                const handshakeTimeout = setTimeout(() => {\n                    const error = `Data channel was never opened: state: ${handshakeDataChannel.readyState}`;\n                    log.error(error);\n                    this.metrics?.dialerEvents.increment({ open_error: true });\n                    reject(dataChannelError('data', error));\n                }, HANDSHAKE_TIMEOUT_MS);\n                handshakeDataChannel.onopen = (_) => {\n                    clearTimeout(handshakeTimeout);\n                    resolve(handshakeDataChannel);\n                };\n                // ref: https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/error_event\n                handshakeDataChannel.onerror = (event) => {\n                    clearTimeout(handshakeTimeout);\n                    const errorTarget = event.target?.toString() ?? 'not specified';\n                    const error = `Error opening a data channel for handshaking: ${errorTarget}`;\n                    log.error(error);\n                    // NOTE: We use unknown error here but this could potentially be considered a reset by some standards.\n                    this.metrics?.dialerEvents.increment({ unknown_error: true });\n                    reject(dataChannelError('data', error));\n                };\n            });\n            const ufrag = 'libp2p+webrtc+v1/' + genUfrag(32);\n            // Create offer and munge sdp with ufrag == pwd. This allows the remote to\n            // respond to STUN messages without performing an actual SDP exchange.\n            // This is because it can infer the passwd field by reading the USERNAME\n            // attribute of the STUN message.\n            const offerSdp = await peerConnection.createOffer();\n            const mungedOfferSdp = sdp.munge(offerSdp, ufrag);\n            await peerConnection.setLocalDescription(mungedOfferSdp);\n            // construct answer sdp from multiaddr and ufrag\n            const answerSdp = sdp.fromMultiAddr(ma, ufrag);\n            await peerConnection.setRemoteDescription(answerSdp);\n            // wait for peerconnection.onopen to fire, or for the datachannel to open\n            const handshakeDataChannel = await dataChannelOpenPromise;\n            const myPeerId = this.components.peerId;\n            // Do noise handshake.\n            // Set the Noise Prologue to libp2p-webrtc-noise:<FINGERPRINTS> before starting the actual Noise handshake.\n            // <FINGERPRINTS> is the concatenation of the of the two TLS fingerprints of A and B in their multihash byte representation, sorted in ascending order.\n            const fingerprintsPrologue = this.generateNoisePrologue(peerConnection, remoteCerthash.code, ma);\n            // Since we use the default crypto interface and do not use a static key or early data,\n            // we pass in undefined for these parameters.\n            const noise = Noise({ prologueBytes: fingerprintsPrologue })();\n            const wrappedChannel = createStream({ channel: handshakeDataChannel, direction: 'inbound', dataChannelOptions: this.init.dataChannel });\n            const wrappedDuplex = {\n                ...wrappedChannel,\n                sink: wrappedChannel.sink.bind(wrappedChannel),\n                source: (async function* () {\n                    for await (const list of wrappedChannel.source) {\n                        for (const buf of list) {\n                            yield buf;\n                        }\n                    }\n                }())\n            };\n            // Creating the connection before completion of the noise\n            // handshake ensures that the stream opening callback is set up\n            const maConn = new WebRTCMultiaddrConnection({\n                peerConnection,\n                remoteAddr: ma,\n                timeline: {\n                    open: Date.now()\n                },\n                metrics: this.metrics?.dialerEvents\n            });\n            const eventListeningName = isFirefox ? 'iceconnectionstatechange' : 'connectionstatechange';\n            peerConnection.addEventListener(eventListeningName, () => {\n                switch (peerConnection.connectionState) {\n                    case 'failed':\n                    case 'disconnected':\n                    case 'closed':\n                        maConn.close().catch((err) => {\n                            log.error('error closing connection', err);\n                        }).finally(() => {\n                            // Remove the event listener once the connection is closed\n                            controller.abort();\n                        });\n                        break;\n                    default:\n                        break;\n                }\n            }, { signal });\n            // Track opened peer connection\n            this.metrics?.dialerEvents.increment({ peer_connection: true });\n            const muxerFactory = new DataChannelMuxerFactory({ peerConnection, metrics: this.metrics?.dialerEvents, dataChannelOptions: this.init.dataChannel });\n            // For outbound connections, the remote is expected to start the noise handshake.\n            // Therefore, we need to secure an inbound noise connection from the remote.\n            await noise.secureInbound(myPeerId, wrappedDuplex, theirPeerId);\n            return await options.upgrader.upgradeOutbound(maConn, { skipProtection: true, skipEncryption: true, muxerFactory });\n        }\n        catch (err) {\n            peerConnection.close();\n            throw err;\n        }\n    }\n    /**\n     * Generate a noise prologue from the peer connection's certificate.\n     * noise prologue = bytes('libp2p-webrtc-noise:') + noise-responder fingerprint + noise-initiator fingerprint\n     */\n    generateNoisePrologue(pc, hashCode, ma) {\n        if (pc.getConfiguration().certificates?.length === 0) {\n            throw invalidArgument('no local certificate');\n        }\n        const localFingerprint = sdp.getLocalFingerprint(pc);\n        if (localFingerprint == null) {\n            throw invalidArgument('no local fingerprint found');\n        }\n        const localFpString = localFingerprint.trim().toLowerCase().replaceAll(':', '');\n        const localFpArray = uint8arrayFromString(localFpString, 'hex');\n        const local = multihashes.encode(localFpArray, hashCode);\n        const remote = sdp.mbdecoder.decode(sdp.certhash(ma));\n        const prefix = uint8arrayFromString('libp2p-webrtc-noise:');\n        return concat([prefix, local, remote]);\n    }\n}\n//# sourceMappingURL=transport.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","/* eslint-env browser */\nexport default WebSocket;\n//# sourceMappingURL=web-socket.browser.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nconst log = logger('libp2p:websockets:socket');\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function socketToMaConn(stream, remoteAddr, options) {\n    options = options ?? {};\n    const maConn = {\n        async sink(source) {\n            if ((options?.signal) != null) {\n                source = abortableSource(source, options.signal);\n            }\n            try {\n                await stream.sink(source);\n            }\n            catch (err) {\n                if (err.type !== 'aborted') {\n                    log.error(err);\n                }\n            }\n        },\n        source: (options.signal != null) ? abortableSource(stream.source, options.signal) : stream.source,\n        remoteAddr,\n        timeline: { open: Date.now() },\n        async close(options = {}) {\n            const start = Date.now();\n            options.signal = options.signal ?? AbortSignal.timeout(CLOSE_TIMEOUT);\n            const listener = () => {\n                const { host, port } = maConn.remoteAddr.toOptions();\n                log('timeout closing stream to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n                this.abort(new CodeError('Socket close timeout', 'ERR_SOCKET_CLOSE_TIMEOUT'));\n            };\n            options.signal.addEventListener('abort', listener);\n            try {\n                await stream.close();\n            }\n            catch (err) {\n                log.error('error closing WebSocket gracefully', err);\n                this.abort(err);\n            }\n            finally {\n                options.signal.removeEventListener('abort', listener);\n                maConn.timeline.close = Date.now();\n            }\n        },\n        abort(err) {\n            const { host, port } = maConn.remoteAddr.toOptions();\n            log('timeout closing stream to %s:%s due to error', host, port, err);\n            stream.destroy();\n            maConn.timeline.close = Date.now();\n        }\n    };\n    stream.socket.addEventListener('close', () => {\n        // In instances where `close` was not explicitly called,\n        // such as an iterable stream ending, ensure we have set the close\n        // timeline\n        if (maConn.timeline.close == null) {\n            maConn.timeline.close = Date.now();\n        }\n    }, { once: true });\n    return maConn;\n}\n//# sourceMappingURL=socket-to-conn.js.map","import { AbortError, CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/transport';\nimport { logger } from '@libp2p/logger';\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri';\nimport { connect } from 'it-ws/client';\nimport pDefer from 'p-defer';\nimport { isBrowser, isWebWorker } from 'wherearewe';\nimport * as filters from './filters.js';\nimport { createListener } from './listener.js';\nimport { socketToMaConn } from './socket-to-conn.js';\nconst log = logger('libp2p:websockets');\nclass WebSockets {\n    init;\n    constructor(init) {\n        this.init = init;\n    }\n    [Symbol.toStringTag] = '@libp2p/websockets';\n    [symbol] = true;\n    async dial(ma, options) {\n        log('dialing %s', ma);\n        options = options ?? {};\n        const socket = await this._connect(ma, options);\n        const maConn = socketToMaConn(socket, ma);\n        log('new outbound connection %s', maConn.remoteAddr);\n        const conn = await options.upgrader.upgradeOutbound(maConn);\n        log('outbound connection %s upgraded', maConn.remoteAddr);\n        return conn;\n    }\n    async _connect(ma, options) {\n        if (options?.signal?.aborted === true) {\n            throw new AbortError();\n        }\n        const cOpts = ma.toOptions();\n        log('dialing %s:%s', cOpts.host, cOpts.port);\n        const errorPromise = pDefer();\n        const rawSocket = connect(toUri(ma), this.init);\n        rawSocket.socket.addEventListener('error', () => {\n            // the WebSocket.ErrorEvent type doesn't actually give us any useful\n            // information about what happened\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/error_event\n            const err = new CodeError(`Could not connect to ${ma.toString()}`, 'ERR_CONNECTION_FAILED');\n            log.error('connection error:', err);\n            errorPromise.reject(err);\n        });\n        if (options.signal == null) {\n            await Promise.race([rawSocket.connected(), errorPromise.promise]);\n            log('connected %s', ma);\n            return rawSocket;\n        }\n        // Allow abort via signal during connect\n        let onAbort;\n        const abort = new Promise((resolve, reject) => {\n            onAbort = () => {\n                reject(new AbortError());\n                rawSocket.close().catch(err => {\n                    log.error('error closing raw socket', err);\n                });\n            };\n            // Already aborted?\n            if (options?.signal?.aborted === true) {\n                onAbort();\n                return;\n            }\n            options?.signal?.addEventListener('abort', onAbort);\n        });\n        try {\n            await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n        }\n        finally {\n            if (onAbort != null) {\n                options?.signal?.removeEventListener('abort', onAbort);\n            }\n        }\n        log('connected %s', ma);\n        return rawSocket;\n    }\n    /**\n     * Creates a Websockets listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`\n     */\n    createListener(options) {\n        return createListener({ ...this.init, ...options });\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n     * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n     * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n     */\n    filter(multiaddrs) {\n        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n        if (this.init?.filter != null) {\n            return this.init?.filter(multiaddrs);\n        }\n        // Browser\n        if (isBrowser || isWebWorker) {\n            return filters.wss(multiaddrs);\n        }\n        return filters.all(multiaddrs);\n    }\n}\nexport function webSockets(init = {}) {\n    return () => {\n        return new WebSockets(init);\n    };\n}\n//# sourceMappingURL=index.js.map","import { logger } from '@libp2p/logger';\nimport { Uint8ArrayList } from 'uint8arraylist';\nconst log = logger('libp2p:webtransport:stream');\nexport async function webtransportBiDiStreamToStream(bidiStream, streamId, direction, activeStreams, onStreamEnd) {\n    const writer = bidiStream.writable.getWriter();\n    const reader = bidiStream.readable.getReader();\n    await writer.ready;\n    function cleanupStreamFromActiveStreams() {\n        const index = activeStreams.findIndex(s => s === stream);\n        if (index !== -1) {\n            activeStreams.splice(index, 1);\n            stream.timeline.close = Date.now();\n            onStreamEnd?.(stream);\n        }\n    }\n    let writerClosed = false;\n    let readerClosed = false;\n    (async function () {\n        const err = await writer.closed.catch((err) => err);\n        if (err != null) {\n            const msg = err.message;\n            if (!(msg.includes('aborted by the remote server') || msg.includes('STOP_SENDING'))) {\n                log.error(`WebTransport writer closed unexpectedly: streamId=${streamId} err=${err.message}`);\n            }\n        }\n        writerClosed = true;\n        if (writerClosed && readerClosed) {\n            cleanupStreamFromActiveStreams();\n        }\n    })().catch(() => {\n        log.error('WebTransport failed to cleanup closed stream');\n    });\n    (async function () {\n        const err = await reader.closed.catch((err) => err);\n        if (err != null) {\n            log.error(`WebTransport reader closed unexpectedly: streamId=${streamId} err=${err.message}`);\n        }\n        readerClosed = true;\n        if (writerClosed && readerClosed) {\n            cleanupStreamFromActiveStreams();\n        }\n    })().catch(() => {\n        log.error('WebTransport failed to cleanup closed stream');\n    });\n    let sinkSunk = false;\n    const stream = {\n        id: streamId,\n        status: 'open',\n        writeStatus: 'ready',\n        readStatus: 'ready',\n        abort(err) {\n            if (!writerClosed) {\n                writer.abort(err)\n                    .catch(err => {\n                    log.error('could not abort stream', err);\n                });\n                writerClosed = true;\n            }\n            readerClosed = true;\n            this.status = 'aborted';\n            this.writeStatus = 'closed';\n            this.readStatus = 'closed';\n            this.timeline.reset =\n                this.timeline.close =\n                    this.timeline.closeRead =\n                        this.timeline.closeWrite = Date.now();\n            cleanupStreamFromActiveStreams();\n        },\n        async close(options) {\n            this.status = 'closing';\n            await Promise.all([\n                stream.closeRead(options),\n                stream.closeWrite(options)\n            ]);\n            cleanupStreamFromActiveStreams();\n            this.status = 'closed';\n            this.timeline.close = Date.now();\n        },\n        async closeRead(options) {\n            if (!readerClosed) {\n                this.readStatus = 'closing';\n                try {\n                    await reader.cancel();\n                }\n                catch (err) {\n                    if (err.toString().includes('RESET_STREAM') === true) {\n                        writerClosed = true;\n                    }\n                }\n                this.timeline.closeRead = Date.now();\n                this.readStatus = 'closed';\n                readerClosed = true;\n            }\n            if (writerClosed) {\n                cleanupStreamFromActiveStreams();\n            }\n        },\n        async closeWrite(options) {\n            if (!writerClosed) {\n                writerClosed = true;\n                this.writeStatus = 'closing';\n                try {\n                    await writer.close();\n                }\n                catch (err) {\n                    if (err.toString().includes('RESET_STREAM') === true) {\n                        readerClosed = true;\n                    }\n                }\n                this.timeline.closeWrite = Date.now();\n                this.writeStatus = 'closed';\n            }\n            if (readerClosed) {\n                cleanupStreamFromActiveStreams();\n            }\n        },\n        direction,\n        timeline: { open: Date.now() },\n        metadata: {},\n        source: (async function* () {\n            while (true) {\n                const val = await reader.read();\n                if (val.done) {\n                    readerClosed = true;\n                    if (writerClosed) {\n                        cleanupStreamFromActiveStreams();\n                    }\n                    return;\n                }\n                yield new Uint8ArrayList(val.value);\n            }\n        })(),\n        sink: async function (source) {\n            if (sinkSunk) {\n                throw new Error('sink already called on stream');\n            }\n            sinkSunk = true;\n            try {\n                this.writeStatus = 'writing';\n                for await (const chunks of source) {\n                    if (chunks instanceof Uint8Array) {\n                        await writer.write(chunks);\n                    }\n                    else {\n                        for (const buf of chunks) {\n                            await writer.write(buf);\n                        }\n                    }\n                }\n                this.writeStatus = 'done';\n            }\n            finally {\n                this.timeline.closeWrite = Date.now();\n                this.writeStatus = 'closed';\n                await stream.closeWrite();\n            }\n        }\n    };\n    return stream;\n}\n//# sourceMappingURL=stream.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { protocols } from '@multiformats/multiaddr';\nimport { WebTransport } from '@multiformats/multiaddr-matcher';\nimport { bases, digest } from 'multiformats/basics';\n// @ts-expect-error - Not easy to combine these types.\nconst multibaseDecoder = Object.values(bases).map(b => b.decoder).reduce((d, b) => d.or(b));\nfunction decodeCerthashStr(s) {\n    return digest.decode(multibaseDecoder.decode(s));\n}\nexport function parseMultiaddr(ma) {\n    if (!WebTransport.matches(ma)) {\n        throw new CodeError('Invalid multiaddr, was not a WebTransport address', 'ERR_INVALID_MULTIADDR');\n    }\n    const parts = ma.stringTuples();\n    const certhashes = parts\n        .filter(([name, _]) => name === protocols('certhash').code)\n        .map(([_, value]) => decodeCerthashStr(value ?? ''));\n    // only take the first peer id in the multiaddr as it may be a relay\n    const remotePeer = parts\n        .filter(([name, _]) => name === protocols('p2p').code)\n        .map(([_, value]) => peerIdFromString(value ?? ''))[0];\n    const opts = ma.toOptions();\n    let host = opts.host;\n    if (opts.family === 6 && host?.includes(':')) {\n        /**\n         * This resolves cases where `new WebTransport()` fails to construct because of an invalid URL being passed.\n         *\n         * `new URL('https://::1:4001/blah')` will throw a `TypeError: Failed to construct 'URL': Invalid URL`\n         * `new URL('https://[::1]:4001/blah')` is valid and will not.\n         *\n         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2\n         */\n        host = `[${host}]`;\n    }\n    return {\n        // All webtransport urls are https\n        url: `https://${host}:${opts.port}`,\n        certhashes,\n        remotePeer\n    };\n}\n//# sourceMappingURL=parse-multiaddr.js.map","import { noise } from '@chainsafe/libp2p-noise';\nimport { symbol } from '@libp2p/interface/transport';\nimport { logger } from '@libp2p/logger';\nimport {} from '@multiformats/multiaddr';\nimport { WebTransport as WebTransportMatcher } from '@multiformats/multiaddr-matcher';\nimport { webtransportBiDiStreamToStream } from './stream.js';\nimport { inertDuplex } from './utils/inert-duplex.js';\nimport { isSubset } from './utils/is-subset.js';\nimport { parseMultiaddr } from './utils/parse-multiaddr.js';\nconst log = logger('libp2p:webtransport');\nclass WebTransportTransport {\n    components;\n    config;\n    metrics;\n    constructor(components, init = {}) {\n        this.components = components;\n        this.config = {\n            maxInboundStreams: init.maxInboundStreams ?? 1000\n        };\n        if (components.metrics != null) {\n            this.metrics = {\n                dialerEvents: components.metrics.registerCounterGroup('libp2p_webtransport_dialer_events_total', {\n                    label: 'event',\n                    help: 'Total count of WebTransport dialer events by type'\n                })\n            };\n        }\n    }\n    [Symbol.toStringTag] = '@libp2p/webtransport';\n    [symbol] = true;\n    async dial(ma, options) {\n        options?.signal?.throwIfAborted();\n        log('dialing %s', ma);\n        const localPeer = this.components.peerId;\n        if (localPeer === undefined) {\n            throw new Error('Need a local peerid');\n        }\n        options = options ?? {};\n        const { url, certhashes, remotePeer } = parseMultiaddr(ma);\n        if (remotePeer == null) {\n            throw new Error('Need a target peerid');\n        }\n        if (certhashes.length === 0) {\n            throw new Error('Expected multiaddr to contain certhashes');\n        }\n        let abortListener;\n        let maConn;\n        let cleanUpWTSession = () => { };\n        let closed = false;\n        let ready = false;\n        let authenticated = false;\n        try {\n            this.metrics?.dialerEvents.increment({ pending: true });\n            const wt = new WebTransport(`${url}/.well-known/libp2p-webtransport?type=noise`, {\n                serverCertificateHashes: certhashes.map(certhash => ({\n                    algorithm: 'sha-256',\n                    value: certhash.digest\n                }))\n            });\n            cleanUpWTSession = (metric) => {\n                if (closed) {\n                    // already closed session\n                    return;\n                }\n                try {\n                    this.metrics?.dialerEvents.increment({ [metric]: true });\n                    wt.close();\n                }\n                catch (err) {\n                    log.error('error closing wt session', err);\n                }\n                finally {\n                    // This is how we specify the connection is closed and shouldn't be used.\n                    if (maConn != null) {\n                        maConn.timeline.close = Date.now();\n                    }\n                    closed = true;\n                }\n            };\n            // if the dial is aborted before we are ready, close the WebTransport session\n            abortListener = () => {\n                if (ready) {\n                    cleanUpWTSession('noise_timeout');\n                }\n                else {\n                    cleanUpWTSession('ready_timeout');\n                }\n            };\n            options.signal?.addEventListener('abort', abortListener, {\n                once: true\n            });\n            await Promise.race([\n                wt.closed,\n                wt.ready\n            ]);\n            ready = true;\n            this.metrics?.dialerEvents.increment({ ready: true });\n            // this promise resolves/throws when the session is closed\n            wt.closed.catch((err) => {\n                log.error('error on remote wt session close', err);\n            })\n                .finally(() => {\n                cleanUpWTSession('remote_close');\n            });\n            if (!await this.authenticateWebTransport(wt, localPeer, remotePeer, certhashes)) {\n                throw new Error('Failed to authenticate webtransport');\n            }\n            this.metrics?.dialerEvents.increment({ open: true });\n            maConn = {\n                close: async () => {\n                    log('Closing webtransport');\n                    cleanUpWTSession('close');\n                },\n                abort: (err) => {\n                    log('aborting webtransport due to passed err', err);\n                    cleanUpWTSession('abort');\n                },\n                remoteAddr: ma,\n                timeline: {\n                    open: Date.now()\n                },\n                // This connection is never used directly since webtransport supports native streams.\n                ...inertDuplex()\n            };\n            authenticated = true;\n            return await options.upgrader.upgradeOutbound(maConn, { skipEncryption: true, muxerFactory: this.webtransportMuxer(wt), skipProtection: true });\n        }\n        catch (err) {\n            log.error('caught wt session err', err);\n            if (authenticated) {\n                cleanUpWTSession('upgrade_error');\n            }\n            else if (ready) {\n                cleanUpWTSession('noise_error');\n            }\n            else {\n                cleanUpWTSession('ready_error');\n            }\n            throw err;\n        }\n        finally {\n            if (abortListener != null) {\n                options.signal?.removeEventListener('abort', abortListener);\n            }\n        }\n    }\n    async authenticateWebTransport(wt, localPeer, remotePeer, certhashes) {\n        const stream = await wt.createBidirectionalStream();\n        const writer = stream.writable.getWriter();\n        const reader = stream.readable.getReader();\n        await writer.ready;\n        const duplex = {\n            source: (async function* () {\n                while (true) {\n                    const val = await reader.read();\n                    if (val.value != null) {\n                        yield val.value;\n                    }\n                    if (val.done) {\n                        break;\n                    }\n                }\n            })(),\n            sink: async function (source) {\n                for await (const chunk of source) {\n                    await writer.write(chunk);\n                }\n            }\n        };\n        const n = noise()();\n        const { remoteExtensions } = await n.secureOutbound(localPeer, duplex, remotePeer);\n        // We're done with this authentication stream\n        writer.close().catch((err) => {\n            log.error(`Failed to close authentication stream writer: ${err.message}`);\n        });\n        reader.cancel().catch((err) => {\n            log.error(`Failed to close authentication stream reader: ${err.message}`);\n        });\n        // Verify the certhashes we used when dialing are a subset of the certhashes relayed by the remote peer\n        if (!isSubset(remoteExtensions?.webtransportCerthashes ?? [], certhashes.map(ch => ch.bytes))) {\n            throw new Error(\"Our certhashes are not a subset of the remote's reported certhashes\");\n        }\n        return true;\n    }\n    webtransportMuxer(wt) {\n        let streamIDCounter = 0;\n        const config = this.config;\n        return {\n            protocol: 'webtransport',\n            createStreamMuxer: (init) => {\n                // !TODO handle abort signal when WebTransport supports this.\n                if (typeof init === 'function') {\n                    // The api docs say that init may be a function\n                    init = { onIncomingStream: init };\n                }\n                const activeStreams = [];\n                (async function () {\n                    //! TODO unclear how to add backpressure here?\n                    const reader = wt.incomingBidirectionalStreams.getReader();\n                    while (true) {\n                        const { done, value: wtStream } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        if (activeStreams.length >= config.maxInboundStreams) {\n                            // We've reached our limit, close this stream.\n                            wtStream.writable.close().catch((err) => {\n                                log.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);\n                            });\n                            wtStream.readable.cancel().catch((err) => {\n                                log.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);\n                            });\n                        }\n                        else {\n                            const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), 'inbound', activeStreams, init?.onStreamEnd);\n                            activeStreams.push(stream);\n                            init?.onIncomingStream?.(stream);\n                        }\n                    }\n                })().catch(() => {\n                    log.error('WebTransport failed to receive incoming stream');\n                });\n                const muxer = {\n                    protocol: 'webtransport',\n                    streams: activeStreams,\n                    newStream: async (name) => {\n                        const wtStream = await wt.createBidirectionalStream();\n                        const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), init?.direction ?? 'outbound', activeStreams, init?.onStreamEnd);\n                        activeStreams.push(stream);\n                        return stream;\n                    },\n                    /**\n                     * Close or abort all tracked streams and stop the muxer\n                     */\n                    close: async (options) => {\n                        log('Closing webtransport muxer');\n                        await Promise.all(activeStreams.map(async (s) => s.close(options)));\n                    },\n                    abort: (err) => {\n                        log('Aborting webtransport muxer with err:', err);\n                        for (const stream of activeStreams) {\n                            stream.abort(err);\n                        }\n                    },\n                    // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.\n                    ...inertDuplex()\n                };\n                return muxer;\n            }\n        };\n    }\n    createListener(options) {\n        throw new Error('Webtransport servers are not supported in Node or the browser');\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid webtransport addresses.\n     */\n    filter(multiaddrs) {\n        return multiaddrs.filter(WebTransportMatcher.exactMatch);\n    }\n}\nexport function webTransport(init = {}) {\n    return (components) => new WebTransportTransport(components, init);\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","// @ts-check\n\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { multiaddr } from '@multiformats/multiaddr';\n/*\n * Valid combinations\n */\nexport const DNS4 = base('dns4');\nexport const DNS6 = base('dns6');\nexport const DNSADDR = base('dnsaddr');\nexport const DNS = or(base('dns'), DNSADDR, DNS4, DNS6);\nexport const IP = or(base('ip4'), base('ip6'));\nexport const TCP = or(and(IP, base('tcp')), and(DNS, base('tcp')));\nexport const UDP = and(IP, base('udp'));\nexport const UTP = and(UDP, base('utp'));\nexport const QUIC = and(UDP, base('quic'));\nexport const QUICV1 = and(UDP, base('quic-v1'));\nconst _WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));\nexport const WebSockets = or(and(_WebSockets, base('p2p')), _WebSockets);\nconst _WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')), and(TCP, base('tls'), base('ws')), and(DNS, base('tls'), base('ws')));\nexport const WebSocketsSecure = or(and(_WebSocketsSecure, base('p2p')), _WebSocketsSecure);\nexport const HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')));\nexport const HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));\nconst _WebRTCDirect = and(UDP, base('webrtc-direct'), base('certhash'));\nexport const WebRTCDirect = or(and(_WebRTCDirect, base('p2p')), _WebRTCDirect);\nconst _WebTransport = and(QUICV1, base('webtransport'), base('certhash'), base('certhash'));\nexport const WebTransport = or(and(_WebTransport, base('p2p')), _WebTransport);\n/**\n * @deprecated\n */\nexport const P2PWebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('p2p')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')), and(WebSockets, base('p2p-webrtc-star')), and(WebSocketsSecure, base('p2p-webrtc-star')));\nexport const WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('p2p')), and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));\n/**\n * @deprecated\n */\nexport const P2PWebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct'), base('p2p')), and(HTTPS, base('p2p-webrtc-direct'), base('p2p')), and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));\nexport const Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);\n// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\nexport const Stardust = or(and(Reliable, base('p2p-stardust'), base('p2p')), and(Reliable, base('p2p-stardust')));\nconst _P2P = or(and(Reliable, base('p2p')), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base('p2p'));\nconst _Circuit = or(and(_P2P, base('p2p-circuit'), _P2P), and(_P2P, base('p2p-circuit')), and(base('p2p-circuit'), _P2P), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));\nconst CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);\nexport const Circuit = CircuitRecursive();\nexport const P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);\nexport const IPFS = P2P;\nexport const WebRTC = or(and(Circuit, base('webrtc'), base('p2p')), and(Circuit, base('webrtc')), and(Reliable, base('webrtc'), base('p2p')), and(Reliable, base('webrtc')), base('webrtc'));\n/*\n * Validation funcs\n */\nfunction makeMatchesFunction(partialMatch) {\n    function matches(a) {\n        let ma;\n        try {\n            ma = multiaddr(a);\n        }\n        catch (err) { // catch error\n            return false; // also if it's invalid it's probably not matching as well so return false\n        }\n        const out = partialMatch(ma.protoNames());\n        if (out === null) {\n            return false;\n        }\n        if (out === true || out === false) {\n            return out;\n        }\n        return out.length === 0;\n    }\n    return matches;\n}\nfunction and(...args) {\n    function partialMatch(a) {\n        if (a.length < args.length) {\n            return null;\n        }\n        let out = a;\n        args.some((arg) => {\n            out = typeof arg === 'function'\n                ? arg().partialMatch(a)\n                : arg.partialMatch(a);\n            if (Array.isArray(out)) {\n                a = out;\n            }\n            if (out === null) {\n                return true;\n            }\n            return false;\n        });\n        return out;\n    }\n    return {\n        toString: function () { return '{ ' + args.join(' ') + ' }'; },\n        input: args,\n        matches: makeMatchesFunction(partialMatch),\n        partialMatch\n    };\n}\nfunction or(...args) {\n    function partialMatch(a) {\n        let out = null;\n        args.some((arg) => {\n            const res = typeof arg === 'function'\n                ? arg().partialMatch(a)\n                : arg.partialMatch(a);\n            if (res != null) {\n                out = res;\n                return true;\n            }\n            return false;\n        });\n        return out;\n    }\n    const result = {\n        toString: function () { return '{ ' + args.join(' ') + ' }'; },\n        input: args,\n        matches: makeMatchesFunction(partialMatch),\n        partialMatch\n    };\n    return result;\n}\nfunction base(n) {\n    const name = n;\n    function matches(a) {\n        let ma;\n        try {\n            ma = multiaddr(a);\n        }\n        catch (err) { // catch error\n            return false; // also if it's invalid it's probably not matching as well so return false\n        }\n        const pnames = ma.protoNames();\n        if (pnames.length === 1 && pnames[0] === name) {\n            return true;\n        }\n        return false;\n    }\n    function partialMatch(protos) {\n        if (protos.length === 0) {\n            return null;\n        }\n        if (protos[0] === name) {\n            return protos.slice(1);\n        }\n        return null;\n    }\n    return {\n        toString: function () { return name; },\n        matches,\n        partialMatch\n    };\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * This module exports various matchers that can be used to infer the type of a\n * passed multiaddr.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org')\n *\n * DNS.matches(ma) // true - this is a multiaddr with a DNS address at the start\n * ```\n *\n * @example\n *\n * The default matching behaviour ignores any subsequent tuples in the multiaddr.\n * If you want stricter matching you can use `.exactMatch`:\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS, Circuit } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org/p2p/QmFoo/p2p-circuit/p2p/QmBar')\n *\n * DNS.exactMatch(ma) // false - this address has extra tuples after the DNS component\n * Circuit.matches(ma) // true\n * Circuit.exactMatch(ma) // true - the extra tuples are circuit relay related\n * ```\n */\nimport { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport {} from '@multiformats/multiaddr';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64url } from 'multiformats/bases/base64';\n/**\n * Split a multiaddr into path components\n */\nconst toParts = (ma) => {\n    return ma.toString().split('/').slice(1);\n};\nconst func = (fn) => {\n    return {\n        match: (vals) => {\n            if (vals.length < 1) {\n                return false;\n            }\n            if (fn(vals[0])) {\n                return vals.slice(1);\n            }\n            return false;\n        },\n        pattern: 'fn'\n    };\n};\nconst literal = (str) => {\n    return {\n        match: (vals) => func((val) => val === str).match(vals),\n        pattern: str\n    };\n};\nconst string = () => {\n    return {\n        match: (vals) => func((val) => typeof val === 'string').match(vals),\n        pattern: '{string}'\n    };\n};\nconst number = () => {\n    return {\n        match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),\n        pattern: '{number}'\n    };\n};\nconst peerId = () => {\n    return {\n        match: (vals) => {\n            if (vals.length < 2) {\n                return false;\n            }\n            if (vals[0] !== 'p2p' && vals[0] !== 'ipfs') {\n                return false;\n            }\n            // Q is RSA, 1 is Ed25519 or Secp256k1\n            if (vals[1].startsWith('Q') || vals[1].startsWith('1')) {\n                try {\n                    base58btc.decode(`z${vals[1]}`);\n                }\n                catch (err) {\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n            return vals.slice(2);\n        },\n        pattern: '/p2p/{peerid}'\n    };\n};\nconst certhash = () => {\n    return {\n        match: (vals) => {\n            if (vals.length < 2) {\n                return false;\n            }\n            if (vals[0] !== 'certhash') {\n                return false;\n            }\n            try {\n                base64url.decode(vals[1]);\n            }\n            catch {\n                return false;\n            }\n            return vals.slice(2);\n        },\n        pattern: '/certhash/{certhash}'\n    };\n};\nconst optional = (matcher) => {\n    return {\n        match: (vals) => {\n            const result = matcher.match(vals);\n            if (result === false) {\n                return vals;\n            }\n            return result;\n        },\n        pattern: `optional(${matcher.pattern})`\n    };\n};\nconst or = (...matchers) => {\n    return {\n        match: (vals) => {\n            let matches;\n            for (const matcher of matchers) {\n                const result = matcher.match(vals);\n                // no match\n                if (result === false) {\n                    continue;\n                }\n                // choose greediest matcher\n                if (matches == null || result.length < matches.length) {\n                    matches = result;\n                }\n            }\n            if (matches == null) {\n                return false;\n            }\n            return matches;\n        },\n        pattern: `or(${matchers.map(m => m.pattern).join(', ')})`\n    };\n};\nconst and = (...matchers) => {\n    return {\n        match: (vals) => {\n            for (const matcher of matchers) {\n                // pass what's left of the array\n                const result = matcher.match(vals);\n                // no match\n                if (result === false) {\n                    return false;\n                }\n                vals = result;\n            }\n            return vals;\n        },\n        pattern: `and(${matchers.map(m => m.pattern).join(', ')})`\n    };\n};\nfunction fmt(...matchers) {\n    function match(ma) {\n        let parts = toParts(ma);\n        for (const matcher of matchers) {\n            const result = matcher.match(parts);\n            if (result === false) {\n                return false;\n            }\n            parts = result;\n        }\n        return parts;\n    }\n    function matches(ma) {\n        const result = match(ma);\n        return result !== false;\n    }\n    function exactMatch(ma) {\n        const result = match(ma);\n        if (result === false) {\n            return false;\n        }\n        return result.length === 0;\n    }\n    return {\n        matches,\n        exactMatch\n    };\n}\n/**\n * DNS matchers\n */\nconst _DNS4 = and(literal('dns4'), string());\nconst _DNS6 = and(literal('dns6'), string());\nconst _DNSADDR = and(literal('dnsaddr'), string());\nconst _DNS = and(literal('dns'), string());\n/**\n * Matches dns4 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS4 } from '@multiformats/multiaddr-matcher'\n *\n * DNS4.matches(multiaddr('/dns4/example.org')) // true\n * ```\n */\nexport const DNS4 = fmt(_DNS4);\n/**\n * Matches dns6 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS6 } from '@multiformats/multiaddr-matcher'\n *\n * DNS6.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS6 = fmt(_DNS6);\n/**\n * Matches dnsaddr addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNSADDR } from '@multiformats/multiaddr-matcher'\n *\n * DNSADDR.matches(multiaddr('/dnsaddr/example.org')) // true\n * ```\n */\nexport const DNSADDR = fmt(_DNSADDR);\n/**\n * Matches any dns address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * DNS.matches(multiaddr('/dnsaddr/example.org')) // true\n * DNS.matches(multiaddr('/dns4/example.org')) // true\n * DNS.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS = fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6));\nconst _IP4 = and(literal('ip4'), func(isIPv4));\nconst _IP6 = and(literal('ip6'), func(isIPv6));\nconst _IP = or(_IP4, _IP6);\nconst IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);\n/**\n * Matches ip4 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP4 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip4/123.123.123.123')\n *\n * IP4.matches(ma) // true\n * ```\n */\nexport const IP4 = fmt(_IP4);\n/**\n * Matches ip6 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP6 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')\n *\n * IP6.matches(ma) // true\n * ```\n */\nexport const IP6 = fmt(_IP6);\n/**\n * Matches ip4 or ip6 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP } from '@multiformats/multiaddr-matcher'\n *\n * IP.matches(multiaddr('/ip4/123.123.123.123')) // true\n * IP.matches(multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')) // true\n * ```\n */\nexport const IP = fmt(_IP);\nconst _TCP = and(IP_OR_DOMAIN, literal('tcp'), number());\nconst _UDP = and(IP_OR_DOMAIN, literal('udp'), number());\nconst TCP_OR_UDP = or(_TCP, _UDP);\n/**\n * Matches TCP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { TCP } from '@multiformats/multiaddr-matcher'\n *\n * TCP.matches(multiaddr('/ip4/123.123.123.123/tcp/1234')) // true\n * ```\n */\nexport const TCP = fmt(_TCP);\n/**\n * Matches UDP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { UDP } from '@multiformats/multiaddr-matcher'\n *\n * UDP.matches(multiaddr('/ip4/123.123.123.123/udp/1234')) // true\n * ```\n */\nexport const UDP = fmt(_UDP);\nconst _QUIC = and(_UDP, literal('quic'));\nconst _QUICV1 = and(_UDP, literal('quic-v1'));\nconst QUIC_V0_OR_V1 = or(_QUIC, _QUICV1);\n/**\n * Matches QUIC addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUIC } from '@multiformats/multiaddr-matcher'\n *\n * QUIC.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic')) // true\n * ```\n */\nexport const QUIC = fmt(_QUIC);\n/**\n * Matches QUICv1 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUICV1 } from '@multiformats/multiaddr-matcher'\n *\n * QUICV1.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1')) // true\n * ```\n */\nexport const QUICV1 = fmt(_QUICV1);\nconst _WEB = or(IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);\nconst _WebSockets = or(and(_WEB, literal('ws'), optional(peerId())));\n/**\n * Matches WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSockets } from '@multiformats/multiaddr-matcher'\n *\n * WebSockets.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/ws')) // true\n * ```\n */\nexport const WebSockets = fmt(_WebSockets);\nconst _WebSocketsSecure = or(and(_WEB, literal('wss'), optional(peerId())), and(_WEB, literal('tls'), literal('ws'), optional(peerId())));\n/**\n * Matches secure WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSocketsSecure } from '@multiformats/multiaddr-matcher'\n *\n * WebSocketsSecure.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/wss')) // true\n * ```\n */\nexport const WebSocketsSecure = fmt(_WebSocketsSecure);\nconst _WebRTCDirect = and(TCP_OR_UDP, literal('webrtc-direct'), certhash(), optional(certhash()), optional(peerId()));\n/**\n * Matches WebRTC-direct addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo/webrtc-direct/certhash/u....')) // true\n * ```\n */\nexport const WebRTCDirect = fmt(_WebRTCDirect);\nconst _WebTransport = and(_QUICV1, literal('webtransport'), certhash(), certhash(), optional(peerId()));\n/**\n * Matches WebTransport addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1/webtransport/certhash/u..../certhash/u..../p2p/QmFoo')) // true\n * ```\n */\nexport const WebTransport = fmt(_WebTransport);\nconst _P2P = or(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());\n/**\n * Matches peer addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { P2P } from '@multiformats/multiaddr-matcher'\n *\n * P2P.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo')) // true\n * ```\n */\nexport const P2P = fmt(_P2P);\nconst _Circuit = and(_P2P, literal('p2p-circuit'), peerId());\n/**\n * Matches circuit relay addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { Circuit } from '@multiformats/multiaddr-matcher'\n *\n * Circuit.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/p2p/QmTarget')) // true\n * ```\n */\nexport const Circuit = fmt(_Circuit);\nconst _WebRTC = or(and(_P2P, literal('p2p-circuit'), literal('webrtc'), peerId()), and(_P2P, literal('webrtc'), optional(peerId())), literal('webrtc'));\n/**\n * Matches WebRTC addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTC } from '@multiformats/multiaddr-matcher'\n *\n * WebRTC.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/webrtc/p2p/QmTarget')) // true\n * ```\n */\nexport const WebRTC = fmt(_WebRTC);\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nimport { CID } from 'multiformats/cid';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport * as Digest from 'multiformats/hashes/digest';\nimport varint from 'varint';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { IpNet } from '@chainsafe/netmask';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.decode.bytes);\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.decode.bytes);\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.decode.bytes);\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _DefaultMultiaddr_string, _DefaultMultiaddr_tuples, _DefaultMultiaddr_stringTuples, _a;\nimport * as codec from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nimport varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport { base58btc } from 'multiformats/bases/base58';\nimport errCode from 'err-code';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    constructor(addr) {\n        _DefaultMultiaddr_string.set(this, void 0);\n        _DefaultMultiaddr_tuples.set(this, void 0);\n        _DefaultMultiaddr_stringTuples.set(this, void 0);\n        this[_a] = true;\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        if (addr instanceof Uint8Array) {\n            this.bytes = codec.fromBytes(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            this.bytes = codec.fromString(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            this.bytes = codec.fromBytes(addr.bytes); // validate + copy buffer\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n    }\n    toString() {\n        if (__classPrivateFieldGet(this, _DefaultMultiaddr_string, \"f\") == null) {\n            __classPrivateFieldSet(this, _DefaultMultiaddr_string, codec.bytesToString(this.bytes), \"f\");\n        }\n        return __classPrivateFieldGet(this, _DefaultMultiaddr_string, \"f\");\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.protoCodes().map(code => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        const codes = [];\n        const buf = this.bytes;\n        let i = 0;\n        while (i < buf.length) {\n            const code = varint.decode(buf, i);\n            const n = varint.decode.bytes ?? 0;\n            const p = getProtocol(code);\n            const size = codec.sizeForAddr(p, buf.slice(i + n));\n            i += (size + n);\n            codes.push(code);\n        }\n        return codes;\n    }\n    protoNames() {\n        return this.protos().map(proto => proto.name);\n    }\n    tuples() {\n        if (__classPrivateFieldGet(this, _DefaultMultiaddr_tuples, \"f\") == null) {\n            __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, codec.bytesToTuples(this.bytes), \"f\");\n        }\n        return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, \"f\");\n    }\n    stringTuples() {\n        if (__classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, \"f\") == null) {\n            __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, codec.tuplesToStringTuples(this.tuples()), \"f\");\n        }\n        return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, \"f\");\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(codec.tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            const tuples = this.stringTuples().filter((tuple) => {\n                if (tuple[0] === names.ipfs.code) {\n                    return true;\n                }\n                return false;\n            });\n            // Get the last ipfs tuple ['ipfs', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        let path = null;\n        try {\n            path = this.stringTuples().filter((tuple) => {\n                const proto = getProtocol(tuple[0]);\n                if (proto.path === true) {\n                    return true;\n                }\n                return false;\n            })[0][1];\n            if (path == null) {\n                path = null;\n            }\n        }\n        catch {\n            path = null;\n        }\n        return path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [(_DefaultMultiaddr_string = new WeakMap(), _DefaultMultiaddr_tuples = new WeakMap(), _DefaultMultiaddr_stringTuples = new WeakMap(), _a = symbol, inspect)]() {\n        return `Multiaddr(${codec.bytesToString(this.bytes)})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import errCode from 'err-code';\nexport function openFailedError(err) {\n    err = err ?? new Error('Open failed');\n    return errCode(err, 'ERR_OPEN_FAILED');\n}\nexport function closeFailedError(err) {\n    err = err ?? new Error('Close failed');\n    return errCode(err, 'ERR_CLOSE_FAILED');\n}\nexport function putFailedError(err) {\n    err = err ?? new Error('Put failed');\n    return errCode(err, 'ERR_PUT_FAILED');\n}\nexport function getFailedError(err) {\n    err = err ?? new Error('Get failed');\n    return errCode(err, 'ERR_GET_FAILED');\n}\nexport function deleteFailedError(err) {\n    err = err ?? new Error('Delete failed');\n    return errCode(err, 'ERR_DELETE_FAILED');\n}\nexport function hasFailedError(err) {\n    err = err ?? new Error('Has failed');\n    return errCode(err, 'ERR_HAS_FAILED');\n}\nexport function notFoundError(err) {\n    err = err ?? new Error('Not Found');\n    return errCode(err, 'ERR_NOT_FOUND');\n}\nexport function abortedError(err) {\n    err = err ?? new Error('Aborted');\n    return errCode(err, 'ERR_ABORTED');\n}\n//# sourceMappingURL=errors.js.map","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}","const decodeErrPrefix = 'CBOR decode error:';\nconst encodeErrPrefix = 'CBOR encode error:';\nconst uintMinorPrefixBytes = [];\nuintMinorPrefixBytes[23] = 1;\nuintMinorPrefixBytes[24] = 2;\nuintMinorPrefixBytes[25] = 3;\nuintMinorPrefixBytes[26] = 5;\nuintMinorPrefixBytes[27] = 9;\nfunction assertEnoughData(data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${ decodeErrPrefix } not enough data for type`);\n  }\n}\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n};","import { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport {\n  jump,\n  quick\n} from './jump.js';\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      if (!decoder) {\n        throw new Error(`${ decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      if (useMaps && m.has(key) || !useMaps && key in obj) {\n        throw new Error(`${ decodeErrPrefix } found repeat map key \"${ key }\"`);\n      }\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${ decodeErrPrefix } tag not supported (${ token.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport {\n  Tokeniser,\n  tokensToObject,\n  decode\n};","import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};","import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${ decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);\n}\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${ decodeErrPrefix } ${ msg }`);\n  };\n}\nexport const jump = [];\nfor (let i = 0; i <= 23; i++) {\n  jump[i] = invalidMinor;\n}\njump[24] = uint.decodeUint8;\njump[25] = uint.decodeUint16;\njump[26] = uint.decodeUint32;\njump[27] = uint.decodeUint64;\njump[28] = invalidMinor;\njump[29] = invalidMinor;\njump[30] = invalidMinor;\njump[31] = invalidMinor;\nfor (let i = 32; i <= 55; i++) {\n  jump[i] = invalidMinor;\n}\njump[56] = negint.decodeNegint8;\njump[57] = negint.decodeNegint16;\njump[58] = negint.decodeNegint32;\njump[59] = negint.decodeNegint64;\njump[60] = invalidMinor;\njump[61] = invalidMinor;\njump[62] = invalidMinor;\njump[63] = invalidMinor;\nfor (let i = 64; i <= 87; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[88] = bytes.decodeBytes8;\njump[89] = bytes.decodeBytes16;\njump[90] = bytes.decodeBytes32;\njump[91] = bytes.decodeBytes64;\njump[92] = invalidMinor;\njump[93] = invalidMinor;\njump[94] = invalidMinor;\njump[95] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 96; i <= 119; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[120] = string.decodeString8;\njump[121] = string.decodeString16;\njump[122] = string.decodeString32;\njump[123] = string.decodeString64;\njump[124] = invalidMinor;\njump[125] = invalidMinor;\njump[126] = invalidMinor;\njump[127] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 128; i <= 151; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[152] = array.decodeArray8;\njump[153] = array.decodeArray16;\njump[154] = array.decodeArray32;\njump[155] = array.decodeArray64;\njump[156] = invalidMinor;\njump[157] = invalidMinor;\njump[158] = invalidMinor;\njump[159] = array.decodeArrayIndefinite;\nfor (let i = 160; i <= 183; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[184] = map.decodeMap8;\njump[185] = map.decodeMap16;\njump[186] = map.decodeMap32;\njump[187] = map.decodeMap64;\njump[188] = invalidMinor;\njump[189] = invalidMinor;\njump[190] = invalidMinor;\njump[191] = map.decodeMapIndefinite;\nfor (let i = 192; i <= 215; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[216] = tag.decodeTag8;\njump[217] = tag.decodeTag16;\njump[218] = tag.decodeTag32;\njump[219] = tag.decodeTag64;\njump[220] = invalidMinor;\njump[221] = invalidMinor;\njump[222] = invalidMinor;\njump[223] = invalidMinor;\nfor (let i = 224; i <= 243; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[244] = invalidMinor;\njump[245] = invalidMinor;\njump[246] = invalidMinor;\njump[247] = float.decodeUndefined;\njump[248] = errorer('simple values are not supported');\njump[249] = float.decodeFloat16;\njump[250] = float.decodeFloat32;\njump[251] = float.decodeFloat64;\njump[252] = invalidMinor;\njump[253] = invalidMinor;\njump[254] = invalidMinor;\njump[255] = float.decodeBreak;\nexport const quick = [];\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\nquick[64] = new Token(Type.bytes, new Uint8Array(0), 1);\nquick[96] = new Token(Type.string, '', 1);\nquick[128] = new Token(Type.array, 0, 1);\nquick[160] = new Token(Type.map, 0, 1);\nquick[244] = new Token(Type.false, false, 1);\nquick[245] = new Token(Type.true, true, 1);\nquick[246] = new Token(Type.null, null, 1);\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n  case Type.false:\n    return fromArray([244]);\n  case Type.true:\n    return fromArray([245]);\n  case Type.null:\n    return fromArray([246]);\n  case Type.bytes:\n    if (!token.value.length) {\n      return fromArray([64]);\n    }\n    return;\n  case Type.string:\n    if (token.value === '') {\n      return fromArray([96]);\n    }\n    return;\n  case Type.array:\n    if (token.value === 0) {\n      return fromArray([128]);\n    }\n    return;\n  case Type.map:\n    if (token.value === 0) {\n      return fromArray([160]);\n    }\n    return;\n  case Type.uint:\n    if (token.value < 24) {\n      return fromArray([Number(token.value)]);\n    }\n    return;\n  case Type.negint:\n    if (token.value >= -24) {\n      return fromArray([31 - Number(token.value)]);\n    }\n  }\n}","class Type {\n  constructor(major, name, terminal) {\n    this.major = major;\n    this.majorEncoded = major << 5;\n    this.name = name;\n    this.terminal = terminal;\n  }\n  toString() {\n    return `Type[${ this.major }].${ this.name }`;\n  }\n  compare(typ) {\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, 'uint', true);\nType.negint = new Type(1, 'negint', true);\nType.bytes = new Type(2, 'bytes', true);\nType.string = new Type(3, 'string', true);\nType.array = new Type(4, 'array', false);\nType.map = new Type(5, 'map', false);\nType.tag = new Type(6, 'tag', false);\nType.float = new Type(7, 'float', true);\nType.false = new Type(7, 'false', true);\nType.true = new Type(7, 'true', true);\nType.null = new Type(7, 'null', true);\nType.undefined = new Type(7, 'undefined', true);\nType.break = new Type(7, 'break', true);\nclass Token {\n  constructor(type, value, encodedLength) {\n    this.type = type;\n    this.value = value;\n    this.encodedLength = encodedLength;\n    this.encodedBytes = undefined;\n    this.byteValue = undefined;\n  }\n  toString() {\n    return `Token[${ this.type }].${ this.value }`;\n  }\n}\nexport {\n  Type,\n  Token\n};","import debug from 'debug';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64 } from 'multiformats/bases/base64';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n//# sourceMappingURL=index.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import debug from 'debug';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64 } from 'multiformats/bases/base64';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { sha256 } from 'multiformats/hashes/sha2';\n// @ts-expect-error no types\nimport vd from 'varint-decoder';\nimport { isMapEqual } from '../utils/index.js';\nimport ve from '../utils/varint-encoder.js';\nimport { BitswapMessageEntry as Entry } from './entry.js';\nimport { Message } from './message.js';\nexport class BitswapMessage {\n    static Entry = Entry;\n    static WantType = {\n        Block: Message.Wantlist.WantType.Block,\n        Have: Message.Wantlist.WantType.Have\n    };\n    static BlockPresenceType = {\n        Have: Message.BlockPresenceType.Have,\n        DontHave: Message.BlockPresenceType.DontHave\n    };\n    static deserialize = async (raw, hashLoader) => {\n        const decoded = Message.decode(raw);\n        const isFull = decoded.wantlist?.full === true;\n        const msg = new BitswapMessage(isFull);\n        decoded.wantlist?.entries.forEach((entry) => {\n            if (entry.block == null) {\n                return;\n            }\n            // note: entry.block is the CID here\n            const cid = CID.decode(entry.block);\n            msg.addEntry(cid, entry.priority ?? 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n        });\n        decoded.blockPresences.forEach((blockPresence) => {\n            if (blockPresence.cid == null) {\n                return;\n            }\n            const cid = CID.decode(blockPresence.cid);\n            if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n                msg.addHave(cid);\n            }\n            else {\n                msg.addDontHave(cid);\n            }\n        });\n        // Bitswap 1.0.0\n        // decoded.blocks are just the byte arrays\n        if (decoded.blocks.length > 0) {\n            await Promise.all(decoded.blocks.map(async (b) => {\n                const hash = await sha256.digest(b);\n                const cid = CID.createV0(hash);\n                msg.addBlock(cid, b);\n            }));\n            return msg;\n        }\n        // Bitswap 1.1.0\n        if (decoded.payload.length > 0) {\n            await Promise.all(decoded.payload.map(async (p) => {\n                if (p.prefix == null || p.data == null) {\n                    return;\n                }\n                const values = vd(p.prefix);\n                const cidVersion = values[0];\n                const multicodec = values[1];\n                const hashAlg = values[2];\n                const hasher = hashAlg === sha256.code ? sha256 : await hashLoader?.getHasher(hashAlg);\n                if (hasher == null) {\n                    throw new CodeError('Unknown hash algorithm', 'ERR_UNKNOWN_HASH_ALG');\n                }\n                // const hashLen = values[3] // We haven't need to use this so far\n                const hash = await hasher.digest(p.data);\n                const cid = CID.create(cidVersion, multicodec, hash);\n                msg.addBlock(cid, p.data);\n            }));\n            msg.setPendingBytes(decoded.pendingBytes);\n            return msg;\n        }\n        return msg;\n    };\n    static blockPresenceSize = (cid) => {\n        // It's ok if this is not exactly right: it's used to estimate the size of\n        // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n        // plenty of padding under the maximum message size.\n        // (It's more important for this to be fast).\n        return cid.bytes.length + 1;\n    };\n    full;\n    wantlist;\n    blocks;\n    blockPresences;\n    pendingBytes;\n    constructor(full) {\n        this.full = full;\n        this.wantlist = new Map();\n        this.blocks = new Map();\n        this.blockPresences = new Map();\n        this.pendingBytes = 0;\n    }\n    get empty() {\n        return this.blocks.size === 0 &&\n            this.wantlist.size === 0 &&\n            this.blockPresences.size === 0;\n    }\n    addEntry(cid, priority, wantType, cancel, sendDontHave) {\n        if (wantType == null) {\n            wantType = BitswapMessage.WantType.Block;\n        }\n        const cidStr = cid.toString(base58btc);\n        const entry = this.wantlist.get(cidStr);\n        if (entry != null) {\n            // Only change priority if want is of the same type\n            if (entry.wantType === wantType) {\n                entry.priority = priority;\n            }\n            // Only change from \"dont cancel\" to \"do cancel\"\n            if (cancel === true) {\n                entry.cancel = Boolean(cancel);\n            }\n            // Only change from \"dont send\" to \"do send\" DONT_HAVE\n            if (sendDontHave === true) {\n                entry.sendDontHave = Boolean(sendDontHave);\n            }\n            // want-block overrides existing want-have\n            if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n                entry.wantType = wantType;\n            }\n        }\n        else {\n            this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n        }\n    }\n    addBlock(cid, block) {\n        const cidStr = cid.toString(base58btc);\n        this.blocks.set(cidStr, block);\n    }\n    addHave(cid) {\n        const cidStr = cid.toString(base58btc);\n        if (!this.blockPresences.has(cidStr)) {\n            this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n        }\n    }\n    addDontHave(cid) {\n        const cidStr = cid.toString(base58btc);\n        if (!this.blockPresences.has(cidStr)) {\n            this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n        }\n    }\n    cancel(cid) {\n        const cidStr = cid.toString(base58btc);\n        this.wantlist.delete(cidStr);\n        this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n    }\n    setPendingBytes(size) {\n        this.pendingBytes = size;\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     */\n    serializeToBitswap100() {\n        return Message.encode({\n            wantlist: {\n                entries: Array.from(this.wantlist.values()).map((entry) => {\n                    return {\n                        block: entry.cid.bytes,\n                        priority: Number(entry.priority),\n                        cancel: Boolean(entry.cancel),\n                        wantType: Message.Wantlist.WantType.Block,\n                        sendDontHave: false\n                    };\n                }),\n                full: Boolean(this.full)\n            },\n            blocks: Array.from(this.blocks.values())\n        });\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     */\n    serializeToBitswap110() {\n        const msg = {\n            wantlist: {\n                entries: Array.from(this.wantlist.values()).map((entry) => {\n                    return {\n                        block: entry.cid.bytes,\n                        priority: Number(entry.priority),\n                        wantType: entry.wantType,\n                        cancel: Boolean(entry.cancel),\n                        sendDontHave: Boolean(entry.sendDontHave)\n                    };\n                }),\n                full: Boolean(this.full)\n            },\n            blockPresences: [],\n            payload: [],\n            pendingBytes: this.pendingBytes,\n            blocks: []\n        };\n        for (const [cidStr, data] of this.blocks.entries()) {\n            const cid = CID.parse(cidStr);\n            const version = cid.version;\n            const codec = cid.code;\n            const multihash = cid.multihash.code;\n            const digestLength = cid.multihash.digest.length;\n            const prefix = ve([\n                version, codec, multihash, digestLength\n            ]);\n            msg.payload.push({\n                prefix,\n                data\n            });\n        }\n        for (const [cidStr, bpType] of this.blockPresences) {\n            msg.blockPresences.push({\n                cid: CID.parse(cidStr).bytes,\n                type: bpType\n            });\n        }\n        if (this.pendingBytes > 0) {\n            msg.pendingBytes = this.pendingBytes;\n        }\n        return Message.encode(msg);\n    }\n    equals(other) {\n        if (this.full !== other.full ||\n            this.pendingBytes !== other.pendingBytes ||\n            !isMapEqual(this.wantlist, other.wantlist) ||\n            !isMapEqual(this.blocks, other.blocks) ||\n            // @TODO - Is this a bug ?\n            // @ts-expect-error - isMap equals map values to be objects not numbers\n            !isMapEqual(this.blockPresences, other.blockPresences)) {\n            return false;\n        }\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        const list = Array.from(this.wantlist.keys());\n        const blocks = Array.from(this.blocks.keys());\n        return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n    }\n}\n//# sourceMappingURL=index.js.map","import { trackedMap } from '@libp2p/interface/metrics/tracked-map';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { Message } from '../message/message.js';\nimport { WantListEntry as Entry } from './entry.js';\nconst WantType = {\n    Block: Message.Wantlist.WantType.Block,\n    Have: Message.Wantlist.WantType.Have\n};\nconst sortBy = (fn, list) => {\n    return Array.prototype.slice.call(list, 0).sort((a, b) => {\n        const aa = fn(a);\n        const bb = fn(b);\n        return aa < bb ? -1 : aa > bb ? 1 : 0;\n    });\n};\nexport class Wantlist {\n    static Entry = Entry;\n    set;\n    _stats;\n    constructor(stats, libp2p) {\n        this.set = (libp2p != null)\n            ? trackedMap({\n                name: 'ipfs_bitswap_wantlist',\n                metrics: libp2p.metrics\n            })\n            : new Map();\n        this._stats = stats;\n    }\n    get length() {\n        return this.set.size;\n    }\n    add(cid, priority, wantType) {\n        const cidStr = cid.toString(base58btc);\n        const entry = this.set.get(cidStr);\n        if (entry != null) {\n            entry.inc();\n            entry.priority = priority;\n            // We can only overwrite want-have with want-block\n            if (entry.wantType === WantType.Have && wantType === WantType.Block) {\n                entry.wantType = wantType;\n            }\n        }\n        else {\n            this.set.set(cidStr, new Entry(cid, priority, wantType));\n            if (this._stats != null) {\n                this._stats.push(undefined, 'wantListSize', 1);\n            }\n        }\n    }\n    remove(cid) {\n        const cidStr = cid.toString(base58btc);\n        const entry = this.set.get(cidStr);\n        if (entry == null) {\n            return;\n        }\n        entry.dec();\n        // only delete when no refs are held\n        if (entry.hasRefs()) {\n            return;\n        }\n        this.set.delete(cidStr);\n        if (this._stats != null) {\n            this._stats.push(undefined, 'wantListSize', -1);\n        }\n    }\n    removeForce(cidStr) {\n        if (this.set.has(cidStr)) {\n            this.set.delete(cidStr);\n        }\n    }\n    forEach(fn) {\n        this.set.forEach(fn);\n    }\n    entries() {\n        return this.set.entries();\n    }\n    sortedEntries() {\n        // TODO: Figure out if this is an actual bug.\n        // @ts-expect-error - Property 'key' does not exist on type 'WantListEntry'\n        return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())));\n    }\n    contains(cid) {\n        const cidStr = cid.toString(base58btc);\n        return this.set.has(cidStr);\n    }\n    get(cid) {\n        const cidStr = cid.toString(base58btc);\n        return this.set.get(cidStr);\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * SortedMap is a Map whose iterator order can be defined by the user\n */\nexport class SortedMap extends Map {\n    _cmp;\n    _keys;\n    constructor(entries, cmp) {\n        super();\n        this._cmp = cmp ?? this._defaultSort;\n        this._keys = [];\n        for (const [k, v] of entries ?? []) {\n            this.set(k, v);\n        }\n    }\n    /**\n     * Call update to update the position of the key when it should change.\n     * For example if the compare function sorts by the priority field, and the\n     * priority changes, call update.\n     * Call indexOf() to get the index _before_ the change happens.\n     */\n    update(i) {\n        if (i < 0 || i >= this._keys.length) {\n            return;\n        }\n        const k = this._keys[i];\n        this._keys.splice(i, 1);\n        const newIdx = this._find(k);\n        this._keys.splice(newIdx, 0, k);\n    }\n    set(k, v) {\n        // If the key is already in the map, remove it from the ordering and\n        // re-insert it below\n        if (this.has(k)) {\n            const i = this.indexOf(k);\n            this._keys.splice(i, 1);\n        }\n        // Update / insert the k/v into the map\n        super.set(k, v);\n        // Find the correct position of the newly inserted k/v in the order\n        const i = this._find(k);\n        this._keys.splice(i, 0, k);\n        return this;\n    }\n    clear() {\n        super.clear();\n        this._keys = [];\n    }\n    delete(k) {\n        if (!this.has(k)) {\n            return false;\n        }\n        const i = this.indexOf(k);\n        this._keys.splice(i, 1);\n        return super.delete(k);\n    }\n    indexOf(k) {\n        if (!this.has(k)) {\n            return -1;\n        }\n        const i = this._find(k);\n        if (this._keys[i] === k) {\n            return i;\n        }\n        // There may be more than one key with the same ordering\n        // eg { k1: <priority 5>, k2: <priority 5> }\n        // so scan outwards until the key matches\n        for (let j = 1; j < this._keys.length; j++) {\n            if (this._keys[i + j] === k)\n                return i + j;\n            if (this._keys[i - j] === k)\n                return i - j;\n        }\n        return -1; // should never happen for existing key\n    }\n    _find(k) {\n        let lower = 0;\n        let upper = this._keys.length;\n        while (lower < upper) {\n            const pivot = (lower + upper) >>> 1; // lower + (upper - lower) / 2\n            const cmp = this._kCmp(this._keys[pivot], k);\n            // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n            if (cmp < 0) { // pivot < k\n                lower = pivot + 1;\n            }\n            else if (cmp > 0) { // pivot > k\n                upper = pivot;\n            }\n            else { // pivot == k\n                return pivot;\n            }\n        }\n        return lower;\n    }\n    *keys() {\n        for (const k of this._keys) {\n            yield k;\n        }\n        return undefined;\n    }\n    *values() {\n        for (const k of this._keys) {\n            // @ts-expect-error - return of `this.get(k)` is `Value|undefined` which is\n            // incompatible with `Value`. Typechecker can't that this contains values\n            // for all the `_keys`. ts(2322)\n            yield this.get(k);\n        }\n        return undefined;\n    }\n    *entries() {\n        for (const k of this._keys) {\n            // @ts-expect-error - return of `this.get(k)` is `Value|undefined` which is\n            // incompatible with `Value`. Typechecker can't that this contains values\n            // for all the `_keys`. ts(2322)\n            yield [k, this.get(k)];\n        }\n        return undefined;\n    }\n    *[Symbol.iterator]() {\n        yield* this.entries();\n    }\n    // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void\n    forEach(cb, thisArg = this) {\n        if (cb == null) {\n            return;\n        }\n        for (const k of this._keys) {\n            const val = this.get(k);\n            if (val == null) {\n                throw new Error('Value cannot be undefined');\n            }\n            cb.apply(thisArg, [[k, val]]);\n        }\n    }\n    _defaultSort(a, b) {\n        if (a[0] < b[0])\n            return -1;\n        if (b[0] < a[0])\n            return 1;\n        return 0;\n    }\n    _kCmp(a, b) {\n        return this._cmp(\n        // @ts-expect-error - get may return undefined\n        [a, this.get(a)], [b, this.get(b)]);\n    }\n}\n//# sourceMappingURL=sorted-map.js.map","const SECOND = 1000;\nexport const maxProvidersPerRequest = 3;\nexport const providerRequestTimeout = 10 * SECOND;\nexport const hasBlockTimeout = 15 * SECOND;\nexport const provideTimeout = 15 * SECOND;\nexport const kMaxPriority = Math.pow(2, 31) - 1;\nexport const maxListeners = 1000;\nexport const wantlistSendDebounceMs = 1;\n//# sourceMappingURL=constants.js.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_queue;\nimport lowerBound from './lower-bound.js';\nclass PriorityQueue {\n    constructor() {\n        _PriorityQueue_queue.set(this, []);\n    }\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\")[this.size - 1].priority >= options.priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").push(element);\n            return;\n        }\n        const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, \"f\"), element, (a, b) => b.priority - a.priority);\n        __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").splice(index, 0, element);\n    }\n    dequeue() {\n        const item = __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").length;\n    }\n}\n_PriorityQueue_queue = new WeakMap();\nexport default PriorityQueue;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\nexport default PQueue;\n","import * as cborg from 'cborg';\nimport { Key } from 'interface-datastore';\nimport { base36 } from 'multiformats/bases/base36';\nimport { CID } from 'multiformats/cid';\nimport defer from 'p-defer';\nimport PQueue from 'p-queue';\nimport { CustomProgressEvent } from 'progress-events';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { dagCborWalker, dagJsonWalker, dagPbWalker, jsonWalker, rawWalker } from './utils/dag-walkers.js';\nconst DEFAULT_DAG_WALKERS = [\n    rawWalker,\n    dagPbWalker,\n    dagCborWalker,\n    dagJsonWalker,\n    jsonWalker\n];\nconst DATASTORE_PIN_PREFIX = '/pin/';\nconst DATASTORE_BLOCK_PREFIX = '/pinned-block/';\nconst DATASTORE_ENCODING = base36;\n// const DAG_WALK_MAX_QUEUE_LENGTH = 10\nconst DAG_WALK_QUEUE_CONCURRENCY = 1;\nfunction toDSKey(cid) {\n    if (cid.version === 0) {\n        cid = cid.toV1();\n    }\n    return new Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);\n}\nexport class PinsImpl {\n    datastore;\n    blockstore;\n    dagWalkers;\n    constructor(datastore, blockstore, dagWalkers) {\n        this.datastore = datastore;\n        this.blockstore = blockstore;\n        this.dagWalkers = {};\n        [...DEFAULT_DAG_WALKERS, ...dagWalkers].forEach(dagWalker => {\n            this.dagWalkers[dagWalker.codec] = dagWalker;\n        });\n    }\n    async add(cid, options = {}) {\n        const pinKey = toDSKey(cid);\n        if (await this.datastore.has(pinKey)) {\n            throw new Error('Already pinned');\n        }\n        const depth = Math.round(options.depth ?? Infinity);\n        if (depth < 0) {\n            throw new Error('Depth must be greater than or equal to 0');\n        }\n        // use a queue to walk the DAG instead of recursion so we can traverse very large DAGs\n        const queue = new PQueue({\n            concurrency: DAG_WALK_QUEUE_CONCURRENCY\n        });\n        void queue.add(async () => {\n            await this.#walkDag(cid, queue, (pinnedBlock) => {\n                // do not update pinned block if this block is already pinned by this CID\n                if (pinnedBlock.pinnedBy.find(c => uint8ArrayEquals(c, cid.bytes)) != null) {\n                    return;\n                }\n                pinnedBlock.pinCount++;\n                pinnedBlock.pinnedBy.push(cid.bytes);\n            }, {\n                ...options,\n                depth\n            });\n        });\n        // if a job in the queue errors, throw that error\n        const deferred = defer();\n        queue.on('error', (err) => {\n            queue.clear();\n            deferred.reject(err);\n        });\n        // wait for the queue to complete or error\n        await Promise.race([\n            queue.onIdle(),\n            deferred.promise\n        ]);\n        const pin = {\n            depth,\n            metadata: options.metadata ?? {}\n        };\n        await this.datastore.put(pinKey, cborg.encode(pin), options);\n        return {\n            cid,\n            ...pin\n        };\n    }\n    /**\n     * Walk the DAG behind the passed CID, ensure all blocks are present in the blockstore\n     * and update the pin count for them\n     */\n    async #walkDag(cid, queue, withPinnedBlock, options) {\n        if (options.depth === -1) {\n            return;\n        }\n        const dagWalker = this.dagWalkers[cid.code];\n        if (dagWalker == null) {\n            throw new Error(`No dag walker found for cid codec ${cid.code}`);\n        }\n        const block = await this.blockstore.get(cid, options);\n        await this.#updatePinnedBlock(cid, withPinnedBlock, options);\n        // walk dag, ensure all blocks are present\n        for await (const cid of dagWalker.walk(block)) {\n            void queue.add(async () => {\n                await this.#walkDag(cid, queue, withPinnedBlock, {\n                    ...options,\n                    depth: options.depth - 1\n                });\n            });\n        }\n    }\n    /**\n     * Update the pin count for the CID\n     */\n    async #updatePinnedBlock(cid, withPinnedBlock, options) {\n        const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);\n        let pinnedBlock = {\n            pinCount: 0,\n            pinnedBy: []\n        };\n        try {\n            pinnedBlock = cborg.decode(await this.datastore.get(blockKey, options));\n        }\n        catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n                throw err;\n            }\n        }\n        withPinnedBlock(pinnedBlock);\n        if (pinnedBlock.pinCount === 0) {\n            if (await this.datastore.has(blockKey)) {\n                await this.datastore.delete(blockKey);\n                return;\n            }\n        }\n        await this.datastore.put(blockKey, cborg.encode(pinnedBlock), options);\n        options.onProgress?.(new CustomProgressEvent('helia:pin:add', { detail: cid }));\n    }\n    async rm(cid, options = {}) {\n        const pinKey = toDSKey(cid);\n        const buf = await this.datastore.get(pinKey, options);\n        const pin = cborg.decode(buf);\n        await this.datastore.delete(pinKey, options);\n        // use a queue to walk the DAG instead of recursion so we can traverse very large DAGs\n        const queue = new PQueue({\n            concurrency: DAG_WALK_QUEUE_CONCURRENCY\n        });\n        void queue.add(async () => {\n            await this.#walkDag(cid, queue, (pinnedBlock) => {\n                pinnedBlock.pinCount--;\n                pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter(c => uint8ArrayEquals(c, cid.bytes));\n            }, {\n                ...options,\n                depth: pin.depth\n            });\n        });\n        await queue.onIdle();\n        return {\n            cid,\n            ...pin\n        };\n    }\n    async *ls(options = {}) {\n        for await (const { key, value } of this.datastore.query({\n            prefix: DATASTORE_PIN_PREFIX + (options.cid != null ? `${options.cid.toString(base36)}` : '')\n        }, options)) {\n            const cid = CID.parse(key.toString().substring(5), base36);\n            const pin = cborg.decode(value);\n            yield {\n                cid,\n                ...pin\n            };\n        }\n    }\n    async isPinned(cid, options = {}) {\n        const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);\n        return this.datastore.has(blockKey, options);\n    }\n}\n//# sourceMappingURL=pins.js.map","import { Key } from 'interface-datastore';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst DS_VERSION_KEY = new Key('/version');\nconst CURRENT_VERSION = 1;\nexport async function assertDatastoreVersionIsCurrent(datastore) {\n    if (!(await datastore.has(DS_VERSION_KEY))) {\n        await datastore.put(DS_VERSION_KEY, uint8ArrayFromString(`${CURRENT_VERSION}`));\n        return;\n    }\n    const buf = await datastore.get(DS_VERSION_KEY);\n    const str = uint8ArrayToString(buf);\n    const version = parseInt(str, 10);\n    if (version !== CURRENT_VERSION) {\n        // TODO: write migrations when we break compatibility - for an example, see https://github.com/ipfs/js-ipfs-repo/tree/master/packages/ipfs-repo-migrations\n        throw new Error('Unknown datastore version, a datastore migration may be required');\n    }\n}\n//# sourceMappingURL=datastore-version.js.map","import { logger } from '@libp2p/logger';\nimport { createBitswap } from 'ipfs-bitswap';\nimport drain from 'it-drain';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256, sha512 } from 'multiformats/hashes/sha2';\nimport { CustomProgressEvent } from 'progress-events';\nimport { PinsImpl } from './pins.js';\nimport { BlockStorage } from './storage.js';\nimport { assertDatastoreVersionIsCurrent } from './utils/datastore-version.js';\nimport { NetworkedStorage } from './utils/networked-storage.js';\nconst log = logger('helia');\nexport class HeliaImpl {\n    libp2p;\n    blockstore;\n    datastore;\n    pins;\n    #bitswap;\n    constructor(init) {\n        const hashers = [\n            sha256,\n            sha512,\n            identity,\n            ...(init.hashers ?? [])\n        ];\n        this.#bitswap = createBitswap(init.libp2p, init.blockstore, {\n            hashLoader: {\n                getHasher: async (codecOrName) => {\n                    const hasher = hashers.find(hasher => {\n                        return hasher.code === codecOrName || hasher.name === codecOrName;\n                    });\n                    if (hasher != null) {\n                        return hasher;\n                    }\n                    throw new Error(`Could not load hasher for code/name \"${codecOrName}\"`);\n                }\n            }\n        });\n        const networkedStorage = new NetworkedStorage(init.blockstore, {\n            bitswap: this.#bitswap\n        });\n        this.pins = new PinsImpl(init.datastore, networkedStorage, init.dagWalkers ?? []);\n        this.libp2p = init.libp2p;\n        this.blockstore = new BlockStorage(networkedStorage, this.pins, {\n            holdGcLock: init.holdGcLock\n        });\n        this.datastore = init.datastore;\n    }\n    async start() {\n        await assertDatastoreVersionIsCurrent(this.datastore);\n        await this.#bitswap?.start();\n        await this.libp2p.start();\n    }\n    async stop() {\n        await this.libp2p.stop();\n        await this.#bitswap?.stop();\n    }\n    async gc(options = {}) {\n        const releaseLock = await this.blockstore.lock.writeLock();\n        try {\n            const helia = this;\n            const blockstore = this.blockstore.unwrap();\n            log('gc start');\n            await drain(blockstore.deleteMany((async function* () {\n                for await (const { cid } of blockstore.getAll()) {\n                    try {\n                        if (await helia.pins.isPinned(cid, options)) {\n                            continue;\n                        }\n                        yield cid;\n                        options.onProgress?.(new CustomProgressEvent('helia:gc:deleted', cid));\n                    }\n                    catch (err) {\n                        log.error('Error during gc', err);\n                        options.onProgress?.(new CustomProgressEvent('helia:gc:error', err));\n                    }\n                }\n            }())));\n        }\n        finally {\n            releaseLock();\n        }\n        log('gc finished');\n    }\n}\n//# sourceMappingURL=helia.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","import debug from 'debug';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64 } from 'multiformats/bases/base64';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n//# sourceMappingURL=index.js.map","import cjs from \"./rpc.cjs\"\n\nexport const {RPC} = cjs\n","import { TopicValidatorResult } from '@libp2p/interface/pubsub';\nexport var SignaturePolicy;\n(function (SignaturePolicy) {\n    /**\n     * On the producing side:\n     * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n     *\n     * On the consuming side:\n     * - Enforce the fields to be present, reject otherwise.\n     * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n     */\n    SignaturePolicy[\"StrictSign\"] = \"StrictSign\";\n    /**\n     * On the producing side:\n     * - Build messages without the signature, key, from and seqno fields.\n     * - The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n     *\n     * On the consuming side:\n     * - Enforce the fields to be absent, reject otherwise.\n     * - Propagate only if the fields are absent, reject otherwise.\n     * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n     */\n    SignaturePolicy[\"StrictNoSign\"] = \"StrictNoSign\";\n})(SignaturePolicy || (SignaturePolicy = {}));\nexport var PublishConfigType;\n(function (PublishConfigType) {\n    PublishConfigType[PublishConfigType[\"Signing\"] = 0] = \"Signing\";\n    PublishConfigType[PublishConfigType[\"Anonymous\"] = 1] = \"Anonymous\";\n})(PublishConfigType || (PublishConfigType = {}));\nexport var RejectReason;\n(function (RejectReason) {\n    /**\n     * The message failed the configured validation during decoding.\n     * SelfOrigin is considered a ValidationError\n     */\n    RejectReason[\"Error\"] = \"error\";\n    /**\n     * Custom validator fn reported status IGNORE.\n     */\n    RejectReason[\"Ignore\"] = \"ignore\";\n    /**\n     * Custom validator fn reported status REJECT.\n     */\n    RejectReason[\"Reject\"] = \"reject\";\n    /**\n     * The peer that sent the message OR the source from field is blacklisted.\n     * Causes messages to be ignored, not penalized, neither do score record creation.\n     */\n    RejectReason[\"Blacklisted\"] = \"blacklisted\";\n})(RejectReason || (RejectReason = {}));\nexport var ValidateError;\n(function (ValidateError) {\n    /// The message has an invalid signature,\n    ValidateError[\"InvalidSignature\"] = \"invalid_signature\";\n    /// The sequence number was the incorrect size\n    ValidateError[\"InvalidSeqno\"] = \"invalid_seqno\";\n    /// The PeerId was invalid\n    ValidateError[\"InvalidPeerId\"] = \"invalid_peerid\";\n    /// Signature existed when validation has been sent to\n    /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n    ValidateError[\"SignaturePresent\"] = \"signature_present\";\n    /// Sequence number existed when validation has been sent to\n    /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n    ValidateError[\"SeqnoPresent\"] = \"seqno_present\";\n    /// Message source existed when validation has been sent to\n    /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n    ValidateError[\"FromPresent\"] = \"from_present\";\n    /// The data transformation failed.\n    ValidateError[\"TransformFailed\"] = \"transform_failed\";\n})(ValidateError || (ValidateError = {}));\nexport var MessageStatus;\n(function (MessageStatus) {\n    MessageStatus[\"duplicate\"] = \"duplicate\";\n    MessageStatus[\"invalid\"] = \"invalid\";\n    MessageStatus[\"valid\"] = \"valid\";\n})(MessageStatus || (MessageStatus = {}));\n/**\n * Typesafe conversion of MessageAcceptance -> RejectReason. TS ensures all values covered\n */\nexport function rejectReasonFromAcceptance(acceptance) {\n    switch (acceptance) {\n        case TopicValidatorResult.Ignore:\n            return RejectReason.Ignore;\n        case TopicValidatorResult.Reject:\n            return RejectReason.Reject;\n    }\n}\n//# sourceMappingURL=types.js.map","import { ERR_INVALID_PEER_SCORE_PARAMS } from './constants.js';\nimport { CodeError } from '@libp2p/interface/errors';\nexport const defaultPeerScoreParams = {\n    topics: {},\n    topicScoreCap: 10.0,\n    appSpecificScore: () => 0.0,\n    appSpecificWeight: 10.0,\n    IPColocationFactorWeight: -5.0,\n    IPColocationFactorThreshold: 10.0,\n    IPColocationFactorWhitelist: new Set(),\n    behaviourPenaltyWeight: -10.0,\n    behaviourPenaltyThreshold: 0.0,\n    behaviourPenaltyDecay: 0.2,\n    decayInterval: 1000.0,\n    decayToZero: 0.1,\n    retainScore: 3600 * 1000\n};\nexport const defaultTopicScoreParams = {\n    topicWeight: 0.5,\n    timeInMeshWeight: 1,\n    timeInMeshQuantum: 1,\n    timeInMeshCap: 3600,\n    firstMessageDeliveriesWeight: 1,\n    firstMessageDeliveriesDecay: 0.5,\n    firstMessageDeliveriesCap: 2000,\n    meshMessageDeliveriesWeight: -1,\n    meshMessageDeliveriesDecay: 0.5,\n    meshMessageDeliveriesCap: 100,\n    meshMessageDeliveriesThreshold: 20,\n    meshMessageDeliveriesWindow: 10,\n    meshMessageDeliveriesActivation: 5000,\n    meshFailurePenaltyWeight: -1,\n    meshFailurePenaltyDecay: 0.5,\n    invalidMessageDeliveriesWeight: -1,\n    invalidMessageDeliveriesDecay: 0.3\n};\nexport function createPeerScoreParams(p = {}) {\n    return {\n        ...defaultPeerScoreParams,\n        ...p,\n        topics: p.topics\n            ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {\n                topics[topic] = createTopicScoreParams(topicScoreParams);\n                return topics;\n            }, {})\n            : {}\n    };\n}\nexport function createTopicScoreParams(p = {}) {\n    return {\n        ...defaultTopicScoreParams,\n        ...p\n    };\n}\n// peer score parameter validation\nexport function validatePeerScoreParams(p) {\n    for (const [topic, params] of Object.entries(p.topics)) {\n        try {\n            validateTopicScoreParams(params);\n        }\n        catch (e) {\n            throw new CodeError(`invalid score parameters for topic ${topic}: ${e.message}`, ERR_INVALID_PEER_SCORE_PARAMS);\n        }\n    }\n    // check that the topic score is 0 or something positive\n    if (p.topicScoreCap < 0) {\n        throw new CodeError('invalid topic score cap; must be positive (or 0 for no cap)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check that we have an app specific score; the weight can be anything (but expected positive)\n    if (p.appSpecificScore === null || p.appSpecificScore === undefined) {\n        throw new CodeError('missing application specific score function', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check the IP colocation factor\n    if (p.IPColocationFactorWeight > 0) {\n        throw new CodeError('invalid IPColocationFactorWeight; must be negative (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {\n        throw new CodeError('invalid IPColocationFactorThreshold; must be at least 1', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check the behaviour penalty\n    if (p.behaviourPenaltyWeight > 0) {\n        throw new CodeError('invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {\n        throw new CodeError('invalid BehaviourPenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check the decay parameters\n    if (p.decayInterval < 1000) {\n        throw new CodeError('invalid DecayInterval; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.decayToZero <= 0 || p.decayToZero >= 1) {\n        throw new CodeError('invalid DecayToZero; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // no need to check the score retention; a value of 0 means that we don't retain scores\n}\nexport function validateTopicScoreParams(p) {\n    // make sure we have a sane topic weight\n    if (p.topicWeight < 0) {\n        throw new CodeError('invalid topic weight; must be >= 0', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check P1\n    if (p.timeInMeshQuantum === 0) {\n        throw new CodeError('invalid TimeInMeshQuantum; must be non zero', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.timeInMeshWeight < 0) {\n        throw new CodeError('invalid TimeInMeshWeight; must be positive (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {\n        throw new CodeError('invalid TimeInMeshQuantum; must be positive', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {\n        throw new CodeError('invalid TimeInMeshCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check P2\n    if (p.firstMessageDeliveriesWeight < 0) {\n        throw new CodeError('invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.firstMessageDeliveriesWeight !== 0 &&\n        (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {\n        throw new CodeError('invalid FirstMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {\n        throw new CodeError('invalid FirstMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check P3\n    if (p.meshMessageDeliveriesWeight > 0) {\n        throw new CodeError('invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {\n        throw new CodeError('invalid MeshMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {\n        throw new CodeError('invalid MeshMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {\n        throw new CodeError('invalid MeshMessageDeliveriesThreshold; must be positive', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.meshMessageDeliveriesWindow < 0) {\n        throw new CodeError('invalid MeshMessageDeliveriesWindow; must be non-negative', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1000) {\n        throw new CodeError('invalid MeshMessageDeliveriesActivation; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check P3b\n    if (p.meshFailurePenaltyWeight > 0) {\n        throw new CodeError('invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {\n        throw new CodeError('invalid MeshFailurePenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    // check P4\n    if (p.invalidMessageDeliveriesWeight > 0) {\n        throw new CodeError('invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n    if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {\n        throw new CodeError('invalid InvalidMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS);\n    }\n}\n//# sourceMappingURL=peer-score-params.js.map","import { TimeCacheDuration } from '../constants.js';\nimport Denque from 'denque';\nexport var DeliveryRecordStatus;\n(function (DeliveryRecordStatus) {\n    /**\n     * we don't know (yet) if the message is valid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"unknown\"] = 0] = \"unknown\";\n    /**\n     * we know the message is valid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"valid\"] = 1] = \"valid\";\n    /**\n     * we know the message is invalid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"invalid\"] = 2] = \"invalid\";\n    /**\n     * we were instructed by the validator to ignore the message\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"ignored\"] = 3] = \"ignored\";\n})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));\n/**\n * Map of canonical message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nexport class MessageDeliveries {\n    records;\n    queue;\n    constructor() {\n        this.records = new Map();\n        this.queue = new Denque();\n    }\n    getRecord(msgIdStr) {\n        return this.records.get(msgIdStr);\n    }\n    ensureRecord(msgIdStr) {\n        let drec = this.records.get(msgIdStr);\n        if (drec) {\n            return drec;\n        }\n        // record doesn't exist yet\n        // create record\n        drec = {\n            status: DeliveryRecordStatus.unknown,\n            firstSeenTsMs: Date.now(),\n            validated: 0,\n            peers: new Set()\n        };\n        this.records.set(msgIdStr, drec);\n        // and add msgId to the queue\n        const entry = {\n            msgId: msgIdStr,\n            expire: Date.now() + TimeCacheDuration\n        };\n        this.queue.push(entry);\n        return drec;\n    }\n    gc() {\n        const now = Date.now();\n        // queue is sorted by expiry time\n        // remove expired messages, remove from queue until first un-expired message found\n        let head = this.queue.peekFront();\n        while (head && head.expire < now) {\n            this.records.delete(head.msgId);\n            this.queue.shift();\n            head = this.queue.peekFront();\n        }\n    }\n    clear() {\n        this.records.clear();\n        this.queue.clear();\n    }\n}\n//# sourceMappingURL=message-deliveries.js.map","/**\n * Exclude up to `ineed` items from a set if item meets condition `cond`\n */\nexport function removeItemsFromSet(superSet, ineed, cond = () => true) {\n    const subset = new Set();\n    if (ineed <= 0)\n        return subset;\n    for (const id of superSet) {\n        if (subset.size >= ineed)\n            break;\n        if (cond(id)) {\n            subset.add(id);\n            superSet.delete(id);\n        }\n    }\n    return subset;\n}\n/**\n * Exclude up to `ineed` items from a set\n */\nexport function removeFirstNItemsFromSet(superSet, ineed) {\n    return removeItemsFromSet(superSet, ineed, () => true);\n}\nexport class MapDef extends Map {\n    getDefault;\n    constructor(getDefault) {\n        super();\n        this.getDefault = getDefault;\n    }\n    getOrDefault(key) {\n        let value = super.get(key);\n        if (value === undefined) {\n            value = this.getDefault();\n            this.set(key, value);\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=set.js.map","import { validatePeerScoreParams } from './peer-score-params.js';\nimport { computeScore } from './compute-score.js';\nimport { MessageDeliveries, DeliveryRecordStatus } from './message-deliveries.js';\nimport { logger } from '@libp2p/logger';\nimport { RejectReason } from '../types.js';\nimport { MapDef } from '../utils/set.js';\nconst log = logger('libp2p:gossipsub:score');\nexport class PeerScore {\n    params;\n    metrics;\n    /**\n     * Per-peer stats for score calculation\n     */\n    peerStats = new Map();\n    /**\n     * IP colocation tracking; maps IP => set of peers.\n     */\n    peerIPs = new MapDef(() => new Set());\n    /**\n     * Cache score up to decayInterval if topic stats are unchanged.\n     */\n    scoreCache = new Map();\n    /**\n     * Recent message delivery timing/participants\n     */\n    deliveryRecords = new MessageDeliveries();\n    _backgroundInterval;\n    scoreCacheValidityMs;\n    computeScore;\n    constructor(params, metrics, opts) {\n        this.params = params;\n        this.metrics = metrics;\n        validatePeerScoreParams(params);\n        this.scoreCacheValidityMs = opts.scoreCacheValidityMs;\n        this.computeScore = opts.computeScore ?? computeScore;\n    }\n    get size() {\n        return this.peerStats.size;\n    }\n    /**\n     * Start PeerScore instance\n     */\n    start() {\n        if (this._backgroundInterval) {\n            log('Peer score already running');\n            return;\n        }\n        this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n        log('started');\n    }\n    /**\n     * Stop PeerScore instance\n     */\n    stop() {\n        if (!this._backgroundInterval) {\n            log('Peer score already stopped');\n            return;\n        }\n        clearInterval(this._backgroundInterval);\n        delete this._backgroundInterval;\n        this.peerIPs.clear();\n        this.peerStats.clear();\n        this.deliveryRecords.clear();\n        log('stopped');\n    }\n    /**\n     * Periodic maintenance\n     */\n    background() {\n        this.refreshScores();\n        this.deliveryRecords.gc();\n    }\n    dumpPeerScoreStats() {\n        return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));\n    }\n    messageFirstSeenTimestampMs(msgIdStr) {\n        const drec = this.deliveryRecords.getRecord(msgIdStr);\n        return drec ? drec.firstSeenTsMs : null;\n    }\n    /**\n     * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n     */\n    refreshScores() {\n        const now = Date.now();\n        const decayToZero = this.params.decayToZero;\n        this.peerStats.forEach((pstats, id) => {\n            if (!pstats.connected) {\n                // has the retention period expired?\n                if (now > pstats.expire) {\n                    // yes, throw it away (but clean up the IP tracking first)\n                    this.removeIPsForPeer(id, pstats.knownIPs);\n                    this.peerStats.delete(id);\n                    this.scoreCache.delete(id);\n                }\n                // we don't decay retained scores, as the peer is not active.\n                // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n                // unless the retention period has elapsed.\n                // similarly, a well behaved peer does not lose its score by getting disconnected.\n                return;\n            }\n            Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n                const tparams = this.params.topics[topic];\n                if (tparams === undefined) {\n                    // we are not scoring this topic\n                    // should be unreachable, we only add scored topics to pstats\n                    return;\n                }\n                // decay counters\n                tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n                if (tstats.firstMessageDeliveries < decayToZero) {\n                    tstats.firstMessageDeliveries = 0;\n                }\n                tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n                if (tstats.meshMessageDeliveries < decayToZero) {\n                    tstats.meshMessageDeliveries = 0;\n                }\n                tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n                if (tstats.meshFailurePenalty < decayToZero) {\n                    tstats.meshFailurePenalty = 0;\n                }\n                tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n                if (tstats.invalidMessageDeliveries < decayToZero) {\n                    tstats.invalidMessageDeliveries = 0;\n                }\n                // update mesh time and activate mesh message delivery parameter if need be\n                if (tstats.inMesh) {\n                    tstats.meshTime = now - tstats.graftTime;\n                    if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n                        tstats.meshMessageDeliveriesActive = true;\n                    }\n                }\n            });\n            // decay P7 counter\n            pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n            if (pstats.behaviourPenalty < decayToZero) {\n                pstats.behaviourPenalty = 0;\n            }\n        });\n    }\n    /**\n     * Return the score for a peer\n     */\n    score(id) {\n        this.metrics?.scoreFnCalls.inc();\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return 0;\n        }\n        const now = Date.now();\n        const cacheEntry = this.scoreCache.get(id);\n        // Found cached score within validity period\n        if (cacheEntry && cacheEntry.cacheUntil > now) {\n            return cacheEntry.score;\n        }\n        this.metrics?.scoreFnRuns.inc();\n        const score = this.computeScore(id, pstats, this.params, this.peerIPs);\n        const cacheUntil = now + this.scoreCacheValidityMs;\n        if (cacheEntry) {\n            this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));\n            cacheEntry.score = score;\n            cacheEntry.cacheUntil = cacheUntil;\n        }\n        else {\n            this.scoreCache.set(id, { score, cacheUntil });\n        }\n        return score;\n    }\n    /**\n     * Apply a behavioural penalty to a peer\n     */\n    addPenalty(id, penalty, penaltyLabel) {\n        const pstats = this.peerStats.get(id);\n        if (pstats) {\n            pstats.behaviourPenalty += penalty;\n            this.metrics?.onScorePenalty(penaltyLabel);\n        }\n    }\n    addPeer(id) {\n        // create peer stats (not including topic stats for each topic to be scored)\n        // topic stats will be added as needed\n        const pstats = {\n            connected: true,\n            expire: 0,\n            topics: {},\n            knownIPs: new Set(),\n            behaviourPenalty: 0\n        };\n        this.peerStats.set(id, pstats);\n    }\n    /** Adds a new IP to a peer, if the peer is not known the update is ignored */\n    addIP(id, ip) {\n        const pstats = this.peerStats.get(id);\n        if (pstats) {\n            pstats.knownIPs.add(ip);\n        }\n        this.peerIPs.getOrDefault(ip).add(id);\n    }\n    /** Remove peer association with IP */\n    removeIP(id, ip) {\n        const pstats = this.peerStats.get(id);\n        if (pstats) {\n            pstats.knownIPs.delete(ip);\n        }\n        const peersWithIP = this.peerIPs.get(ip);\n        if (peersWithIP) {\n            peersWithIP.delete(id);\n            if (peersWithIP.size === 0) {\n                this.peerIPs.delete(ip);\n            }\n        }\n    }\n    removePeer(id) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        // decide whether to retain the score; this currently only retains non-positive scores\n        // to dissuade attacks on the score function.\n        if (this.score(id) > 0) {\n            this.removeIPsForPeer(id, pstats.knownIPs);\n            this.peerStats.delete(id);\n            return;\n        }\n        // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n        // reset to 0 and mesh delivery penalties applied.\n        Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n            tstats.firstMessageDeliveries = 0;\n            const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n            if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n                const deficit = threshold - tstats.meshMessageDeliveries;\n                tstats.meshFailurePenalty += deficit * deficit;\n            }\n            tstats.inMesh = false;\n            tstats.meshMessageDeliveriesActive = false;\n        });\n        pstats.connected = false;\n        pstats.expire = Date.now() + this.params.retainScore;\n    }\n    /** Handles scoring functionality as a peer GRAFTs to a topic. */\n    graft(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (pstats) {\n            const tstats = this.getPtopicStats(pstats, topic);\n            if (tstats) {\n                // if we are scoring the topic, update the mesh status.\n                tstats.inMesh = true;\n                tstats.graftTime = Date.now();\n                tstats.meshTime = 0;\n                tstats.meshMessageDeliveriesActive = false;\n            }\n        }\n    }\n    /** Handles scoring functionality as a peer PRUNEs from a topic. */\n    prune(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (pstats) {\n            const tstats = this.getPtopicStats(pstats, topic);\n            if (tstats) {\n                // sticky mesh delivery rate failure penalty\n                const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n                if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n                    const deficit = threshold - tstats.meshMessageDeliveries;\n                    tstats.meshFailurePenalty += deficit * deficit;\n                }\n                tstats.meshMessageDeliveriesActive = false;\n                tstats.inMesh = false;\n                // TODO: Consider clearing score cache on important penalties\n                // this.scoreCache.delete(id)\n            }\n        }\n    }\n    validateMessage(msgIdStr) {\n        this.deliveryRecords.ensureRecord(msgIdStr);\n    }\n    deliverMessage(from, msgIdStr, topic) {\n        this.markFirstMessageDelivery(from, topic);\n        const drec = this.deliveryRecords.ensureRecord(msgIdStr);\n        const now = Date.now();\n        // defensive check that this is the first delivery trace -- delivery status should be unknown\n        if (drec.status !== DeliveryRecordStatus.unknown) {\n            log('unexpected delivery: message from %s was first seen %s ago and has delivery status %s', from, now - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);\n            return;\n        }\n        // mark the message as valid and reward mesh peers that have already forwarded it to us\n        drec.status = DeliveryRecordStatus.valid;\n        drec.validated = now;\n        drec.peers.forEach((p) => {\n            // this check is to make sure a peer can't send us a message twice and get a double count\n            // if it is a first delivery.\n            if (p !== from.toString()) {\n                this.markDuplicateMessageDelivery(p, topic);\n            }\n        });\n    }\n    /**\n     * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.\n     */\n    rejectInvalidMessage(from, topic) {\n        this.markInvalidMessageDelivery(from, topic);\n    }\n    rejectMessage(from, msgIdStr, topic, reason) {\n        switch (reason) {\n            // these messages are not tracked, but the peer is penalized as they are invalid\n            case RejectReason.Error:\n                this.markInvalidMessageDelivery(from, topic);\n                return;\n            // we ignore those messages, so do nothing.\n            case RejectReason.Blacklisted:\n                return;\n            // the rest are handled after record creation\n        }\n        const drec = this.deliveryRecords.ensureRecord(msgIdStr);\n        // defensive check that this is the first rejection -- delivery status should be unknown\n        if (drec.status !== DeliveryRecordStatus.unknown) {\n            log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', from, Date.now() - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);\n            return;\n        }\n        if (reason === RejectReason.Ignore) {\n            // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n            drec.status = DeliveryRecordStatus.ignored;\n            drec.peers.clear();\n            return;\n        }\n        // mark the message as invalid and penalize peers that have already forwarded it.\n        drec.status = DeliveryRecordStatus.invalid;\n        this.markInvalidMessageDelivery(from, topic);\n        drec.peers.forEach((p) => {\n            this.markInvalidMessageDelivery(p, topic);\n        });\n        // release the delivery time tracking map to free some memory early\n        drec.peers.clear();\n    }\n    duplicateMessage(from, msgIdStr, topic) {\n        const drec = this.deliveryRecords.ensureRecord(msgIdStr);\n        if (drec.peers.has(from)) {\n            // we have already seen this duplicate\n            return;\n        }\n        switch (drec.status) {\n            case DeliveryRecordStatus.unknown:\n                // the message is being validated; track the peer delivery and wait for\n                // the Deliver/Reject/Ignore notification.\n                drec.peers.add(from);\n                break;\n            case DeliveryRecordStatus.valid:\n                // mark the peer delivery time to only count a duplicate delivery once.\n                drec.peers.add(from);\n                this.markDuplicateMessageDelivery(from, topic, drec.validated);\n                break;\n            case DeliveryRecordStatus.invalid:\n                // we no longer track delivery time\n                this.markInvalidMessageDelivery(from, topic);\n                break;\n            case DeliveryRecordStatus.ignored:\n                // the message was ignored; do nothing (we don't know if it was valid)\n                break;\n        }\n    }\n    /**\n     * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n     */\n    markInvalidMessageDelivery(from, topic) {\n        const pstats = this.peerStats.get(from);\n        if (pstats) {\n            const tstats = this.getPtopicStats(pstats, topic);\n            if (tstats) {\n                tstats.invalidMessageDeliveries += 1;\n            }\n        }\n    }\n    /**\n     * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n     * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n     * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()\n     */\n    markFirstMessageDelivery(from, topic) {\n        const pstats = this.peerStats.get(from);\n        if (pstats) {\n            const tstats = this.getPtopicStats(pstats, topic);\n            if (tstats) {\n                let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n                tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);\n                if (tstats.inMesh) {\n                    cap = this.params.topics[topic].meshMessageDeliveriesCap;\n                    tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);\n                }\n            }\n        }\n    }\n    /**\n     * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n     * as long the message was received within the P3 window.\n     */\n    markDuplicateMessageDelivery(from, topic, validatedTime) {\n        const pstats = this.peerStats.get(from);\n        if (pstats) {\n            const now = validatedTime !== undefined ? Date.now() : 0;\n            const tstats = this.getPtopicStats(pstats, topic);\n            if (tstats && tstats.inMesh) {\n                const tparams = this.params.topics[topic];\n                // check against the mesh delivery window -- if the validated time is passed as 0, then\n                // the message was received before we finished validation and thus falls within the mesh\n                // delivery window.\n                if (validatedTime !== undefined) {\n                    const deliveryDelayMs = now - validatedTime;\n                    const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;\n                    this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);\n                    if (isLateDelivery) {\n                        return;\n                    }\n                }\n                const cap = tparams.meshMessageDeliveriesCap;\n                tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);\n            }\n        }\n    }\n    /**\n     * Removes an IP list from the tracking list for a peer.\n     */\n    removeIPsForPeer(id, ipsToRemove) {\n        for (const ipToRemove of ipsToRemove) {\n            const peerSet = this.peerIPs.get(ipToRemove);\n            if (peerSet) {\n                peerSet.delete(id);\n                if (peerSet.size === 0) {\n                    this.peerIPs.delete(ipToRemove);\n                }\n            }\n        }\n    }\n    /**\n     * Returns topic stats if they exist, otherwise if the supplied parameters score the\n     * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.\n     */\n    getPtopicStats(pstats, topic) {\n        let topicStats = pstats.topics[topic];\n        if (topicStats !== undefined) {\n            return topicStats;\n        }\n        if (this.params.topics[topic] !== undefined) {\n            topicStats = {\n                inMesh: false,\n                graftTime: 0,\n                meshTime: 0,\n                firstMessageDeliveries: 0,\n                meshMessageDeliveries: 0,\n                meshMessageDeliveriesActive: false,\n                meshFailurePenalty: 0,\n                invalidMessageDeliveries: 0\n            };\n            pstats.topics[topic] = topicStats;\n            return topicStats;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=peer-score.js.map","import { TopicValidatorResult } from '@libp2p/interface/pubsub';\nimport { MessageStatus, RejectReason, ValidateError } from './types.js';\nexport var MessageSource;\n(function (MessageSource) {\n    MessageSource[\"forward\"] = \"forward\";\n    MessageSource[\"publish\"] = \"publish\";\n})(MessageSource || (MessageSource = {}));\nexport var InclusionReason;\n(function (InclusionReason) {\n    /** Peer was a fanaout peer. */\n    InclusionReason[\"Fanout\"] = \"fanout\";\n    /** Included from random selection. */\n    InclusionReason[\"Random\"] = \"random\";\n    /** Peer subscribed. */\n    InclusionReason[\"Subscribed\"] = \"subscribed\";\n    /** On heartbeat, peer was included to fill the outbound quota. */\n    InclusionReason[\"Outbound\"] = \"outbound\";\n    /** On heartbeat, not enough peers in mesh */\n    InclusionReason[\"NotEnough\"] = \"not_enough\";\n    /** On heartbeat opportunistic grafting due to low mesh score */\n    InclusionReason[\"Opportunistic\"] = \"opportunistic\";\n})(InclusionReason || (InclusionReason = {}));\n/// Reasons why a peer was removed from the mesh.\nexport var ChurnReason;\n(function (ChurnReason) {\n    /// Peer disconnected.\n    ChurnReason[\"Dc\"] = \"disconnected\";\n    /// Peer had a bad score.\n    ChurnReason[\"BadScore\"] = \"bad_score\";\n    /// Peer sent a PRUNE.\n    ChurnReason[\"Prune\"] = \"prune\";\n    /// Too many peers.\n    ChurnReason[\"Excess\"] = \"excess\";\n})(ChurnReason || (ChurnReason = {}));\n/// Kinds of reasons a peer's score has been penalized\nexport var ScorePenalty;\n(function (ScorePenalty) {\n    /// A peer grafted before waiting the back-off time.\n    ScorePenalty[\"GraftBackoff\"] = \"graft_backoff\";\n    /// A Peer did not respond to an IWANT request in time.\n    ScorePenalty[\"BrokenPromise\"] = \"broken_promise\";\n    /// A Peer did not send enough messages as expected.\n    ScorePenalty[\"MessageDeficit\"] = \"message_deficit\";\n    /// Too many peers under one IP address.\n    ScorePenalty[\"IPColocation\"] = \"IP_colocation\";\n})(ScorePenalty || (ScorePenalty = {}));\nexport var IHaveIgnoreReason;\n(function (IHaveIgnoreReason) {\n    IHaveIgnoreReason[\"LowScore\"] = \"low_score\";\n    IHaveIgnoreReason[\"MaxIhave\"] = \"max_ihave\";\n    IHaveIgnoreReason[\"MaxIasked\"] = \"max_iasked\";\n})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));\nexport var ScoreThreshold;\n(function (ScoreThreshold) {\n    ScoreThreshold[\"graylist\"] = \"graylist\";\n    ScoreThreshold[\"publish\"] = \"publish\";\n    ScoreThreshold[\"gossip\"] = \"gossip\";\n    ScoreThreshold[\"mesh\"] = \"mesh\";\n})(ScoreThreshold || (ScoreThreshold = {}));\n/**\n * A collection of metrics used throughout the Gossipsub behaviour.\n * NOTE: except for special reasons, do not add more than 1 label for frequent metrics,\n * there's a performance penalty as of June 2023.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getMetrics(register, topicStrToLabel, opts) {\n    // Using function style instead of class to prevent having to re-declare all MetricsPrometheus types.\n    return {\n        /* Metrics for static config */\n        protocolsEnabled: register.gauge({\n            name: 'gossipsub_protocol',\n            help: 'Status of enabled protocols',\n            labelNames: ['protocol']\n        }),\n        /* Metrics per known topic */\n        /** Status of our subscription to this topic. This metric allows analyzing other topic metrics\n         *  filtered by our current subscription status.\n         *  = rust-libp2p `topic_subscription_status` */\n        topicSubscriptionStatus: register.gauge({\n            name: 'gossipsub_topic_subscription_status',\n            help: 'Status of our subscription to this topic',\n            labelNames: ['topicStr']\n        }),\n        /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour\n         * regardless of our subscription status. */\n        topicPeersCount: register.gauge({\n            name: 'gossipsub_topic_peer_count',\n            help: 'Number of peers subscribed to each topic',\n            labelNames: ['topicStr']\n        }),\n        /* Metrics regarding mesh state */\n        /** Number of peers in our mesh. This metric should be updated with the count of peers for a\n         *  topic in the mesh regardless of inclusion and churn events.\n         *  = rust-libp2p `mesh_peer_counts` */\n        meshPeerCounts: register.gauge({\n            name: 'gossipsub_mesh_peer_count',\n            help: 'Number of peers in our mesh',\n            labelNames: ['topicStr']\n        }),\n        /** Number of times we include peers in a topic mesh for different reasons.\n         *  = rust-libp2p `mesh_peer_inclusion_events` */\n        meshPeerInclusionEventsFanout: register.gauge({\n            name: 'gossipsub_mesh_peer_inclusion_events_fanout_total',\n            help: 'Number of times we include peers in a topic mesh for fanout reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerInclusionEventsRandom: register.gauge({\n            name: 'gossipsub_mesh_peer_inclusion_events_random_total',\n            help: 'Number of times we include peers in a topic mesh for random reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerInclusionEventsSubscribed: register.gauge({\n            name: 'gossipsub_mesh_peer_inclusion_events_subscribed_total',\n            help: 'Number of times we include peers in a topic mesh for subscribed reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerInclusionEventsOutbound: register.gauge({\n            name: 'gossipsub_mesh_peer_inclusion_events_outbound_total',\n            help: 'Number of times we include peers in a topic mesh for outbound reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerInclusionEventsNotEnough: register.gauge({\n            name: 'gossipsub_mesh_peer_inclusion_events_not_enough_total',\n            help: 'Number of times we include peers in a topic mesh for not_enough reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerInclusionEventsOpportunistic: register.gauge({\n            name: 'gossipsub_mesh_peer_inclusion_events_opportunistic_total',\n            help: 'Number of times we include peers in a topic mesh for opportunistic reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerInclusionEventsUnknown: register.gauge({\n            name: 'gossipsub_mesh_peer_inclusion_events_unknown_total',\n            help: 'Number of times we include peers in a topic mesh for unknown reasons',\n            labelNames: ['topic']\n        }),\n        /** Number of times we remove peers in a topic mesh for different reasons.\n         *  = rust-libp2p `mesh_peer_churn_events` */\n        meshPeerChurnEventsDisconnected: register.gauge({\n            name: 'gossipsub_peer_churn_events_disconnected_total',\n            help: 'Number of times we remove peers in a topic mesh for disconnected reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerChurnEventsBadScore: register.gauge({\n            name: 'gossipsub_peer_churn_events_bad_score_total',\n            help: 'Number of times we remove peers in a topic mesh for bad_score reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerChurnEventsPrune: register.gauge({\n            name: 'gossipsub_peer_churn_events_prune_total',\n            help: 'Number of times we remove peers in a topic mesh for prune reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerChurnEventsExcess: register.gauge({\n            name: 'gossipsub_peer_churn_events_excess_total',\n            help: 'Number of times we remove peers in a topic mesh for excess reasons',\n            labelNames: ['topic']\n        }),\n        meshPeerChurnEventsUnknown: register.gauge({\n            name: 'gossipsub_peer_churn_events_unknown_total',\n            help: 'Number of times we remove peers in a topic mesh for unknown reasons',\n            labelNames: ['topic']\n        }),\n        /* General Metrics */\n        /** Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based\n         *  on which protocol they support. This metric keeps track of the number of peers that are\n         *  connected of each type. */\n        peersPerProtocol: register.gauge({\n            name: 'gossipsub_peers_per_protocol_count',\n            help: 'Peers connected for each topic',\n            labelNames: ['protocol']\n        }),\n        /** The time it takes to complete one iteration of the heartbeat. */\n        heartbeatDuration: register.histogram({\n            name: 'gossipsub_heartbeat_duration_seconds',\n            help: 'The time it takes to complete one iteration of the heartbeat',\n            // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled\n            buckets: [0.01, 0.1, 1]\n        }),\n        /** Heartbeat run took longer than heartbeat interval so next is skipped */\n        heartbeatSkipped: register.gauge({\n            name: 'gossipsub_heartbeat_skipped',\n            help: 'Heartbeat run took longer than heartbeat interval so next is skipped'\n        }),\n        /** Message validation results for each topic.\n         *  Invalid == Reject?\n         *  = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */\n        acceptedMessagesTotal: register.gauge({\n            name: 'gossipsub_accepted_messages_total',\n            help: 'Total accepted messages for each topic',\n            labelNames: ['topic']\n        }),\n        ignoredMessagesTotal: register.gauge({\n            name: 'gossipsub_ignored_messages_total',\n            help: 'Total ignored messages for each topic',\n            labelNames: ['topic']\n        }),\n        rejectedMessagesTotal: register.gauge({\n            name: 'gossipsub_rejected_messages_total',\n            help: 'Total rejected messages for each topic',\n            labelNames: ['topic']\n        }),\n        unknownValidationResultsTotal: register.gauge({\n            name: 'gossipsub_unknown_validation_results_total',\n            help: 'Total unknown validation results for each topic',\n            labelNames: ['topic']\n        }),\n        /** When the user validates a message, it tries to re propagate it to its mesh peers. If the\n         *  message expires from the memcache before it can be validated, we count this a cache miss\n         *  and it is an indicator that the memcache size should be increased.\n         *  = rust-libp2p `mcache_misses` */\n        asyncValidationMcacheHit: register.gauge({\n            name: 'gossipsub_async_validation_mcache_hit_total',\n            help: 'Async validation result reported by the user layer',\n            labelNames: ['hit']\n        }),\n        asyncValidationDelayFromFirstSeenSec: register.histogram({\n            name: 'gossipsub_async_validation_delay_from_first_seen',\n            help: 'Async validation report delay from first seen in second',\n            labelNames: ['topic'],\n            buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]\n        }),\n        asyncValidationUnknownFirstSeen: register.gauge({\n            name: 'gossipsub_async_validation_unknown_first_seen_count_total',\n            help: 'Async validation report unknown first seen value for message'\n        }),\n        // peer stream\n        peerReadStreamError: register.gauge({\n            name: 'gossipsub_peer_read_stream_err_count_total',\n            help: 'Peer read stream error'\n        }),\n        // RPC outgoing. Track byte length + data structure sizes\n        rpcRecvBytes: register.gauge({ name: 'gossipsub_rpc_recv_bytes_total', help: 'RPC recv' }),\n        rpcRecvCount: register.gauge({ name: 'gossipsub_rpc_recv_count_total', help: 'RPC recv' }),\n        rpcRecvSubscription: register.gauge({ name: 'gossipsub_rpc_recv_subscription_total', help: 'RPC recv' }),\n        rpcRecvMessage: register.gauge({ name: 'gossipsub_rpc_recv_message_total', help: 'RPC recv' }),\n        rpcRecvControl: register.gauge({ name: 'gossipsub_rpc_recv_control_total', help: 'RPC recv' }),\n        rpcRecvIHave: register.gauge({ name: 'gossipsub_rpc_recv_ihave_total', help: 'RPC recv' }),\n        rpcRecvIWant: register.gauge({ name: 'gossipsub_rpc_recv_iwant_total', help: 'RPC recv' }),\n        rpcRecvGraft: register.gauge({ name: 'gossipsub_rpc_recv_graft_total', help: 'RPC recv' }),\n        rpcRecvPrune: register.gauge({ name: 'gossipsub_rpc_recv_prune_total', help: 'RPC recv' }),\n        rpcDataError: register.gauge({ name: 'gossipsub_rpc_data_err_count_total', help: 'RPC data error' }),\n        rpcRecvError: register.gauge({ name: 'gossipsub_rpc_recv_err_count_total', help: 'RPC recv error' }),\n        /** Total count of RPC dropped because acceptFrom() == false */\n        rpcRecvNotAccepted: register.gauge({\n            name: 'gossipsub_rpc_rcv_not_accepted_total',\n            help: 'Total count of RPC dropped because acceptFrom() == false'\n        }),\n        // RPC incoming. Track byte length + data structure sizes\n        rpcSentBytes: register.gauge({ name: 'gossipsub_rpc_sent_bytes_total', help: 'RPC sent' }),\n        rpcSentCount: register.gauge({ name: 'gossipsub_rpc_sent_count_total', help: 'RPC sent' }),\n        rpcSentSubscription: register.gauge({ name: 'gossipsub_rpc_sent_subscription_total', help: 'RPC sent' }),\n        rpcSentMessage: register.gauge({ name: 'gossipsub_rpc_sent_message_total', help: 'RPC sent' }),\n        rpcSentControl: register.gauge({ name: 'gossipsub_rpc_sent_control_total', help: 'RPC sent' }),\n        rpcSentIHave: register.gauge({ name: 'gossipsub_rpc_sent_ihave_total', help: 'RPC sent' }),\n        rpcSentIWant: register.gauge({ name: 'gossipsub_rpc_sent_iwant_total', help: 'RPC sent' }),\n        rpcSentGraft: register.gauge({ name: 'gossipsub_rpc_sent_graft_total', help: 'RPC sent' }),\n        rpcSentPrune: register.gauge({ name: 'gossipsub_rpc_sent_prune_total', help: 'RPC sent' }),\n        // publish message. Track peers sent to and bytes\n        /** Total count of msg published by topic */\n        msgPublishCount: register.gauge({\n            name: 'gossipsub_msg_publish_count_total',\n            help: 'Total count of msg published by topic',\n            labelNames: ['topic']\n        }),\n        /** Total count of peers that we publish a msg to */\n        msgPublishPeersByTopic: register.gauge({\n            name: 'gossipsub_msg_publish_peers_total',\n            help: 'Total count of peers that we publish a msg to',\n            labelNames: ['topic']\n        }),\n        /** Total count of peers (by group) that we publish a msg to */\n        directPeersPublishedTotal: register.gauge({\n            name: 'gossipsub_direct_peers_published_total',\n            help: 'Total direct peers that we publish a msg to',\n            labelNames: ['topic']\n        }),\n        floodsubPeersPublishedTotal: register.gauge({\n            name: 'gossipsub_floodsub_peers_published_total',\n            help: 'Total floodsub peers that we publish a msg to',\n            labelNames: ['topic']\n        }),\n        meshPeersPublishedTotal: register.gauge({\n            name: 'gossipsub_mesh_peers_published_total',\n            help: 'Total mesh peers that we publish a msg to',\n            labelNames: ['topic']\n        }),\n        fanoutPeersPublishedTotal: register.gauge({\n            name: 'gossipsub_fanout_peers_published_total',\n            help: 'Total fanout peers that we publish a msg to',\n            labelNames: ['topic']\n        }),\n        /** Total count of msg publish data.length bytes */\n        msgPublishBytes: register.gauge({\n            name: 'gossipsub_msg_publish_bytes_total',\n            help: 'Total count of msg publish data.length bytes',\n            labelNames: ['topic']\n        }),\n        /** Total time in seconds to publish a message */\n        msgPublishTime: register.histogram({\n            name: 'gossipsub_msg_publish_seconds',\n            help: 'Total time in seconds to publish a message',\n            buckets: [0.001, 0.002, 0.005, 0.01, 0.1, 0.5, 1],\n            labelNames: ['topic']\n        }),\n        /** Total count of msg forwarded by topic */\n        msgForwardCount: register.gauge({\n            name: 'gossipsub_msg_forward_count_total',\n            help: 'Total count of msg forwarded by topic',\n            labelNames: ['topic']\n        }),\n        /** Total count of peers that we forward a msg to */\n        msgForwardPeers: register.gauge({\n            name: 'gossipsub_msg_forward_peers_total',\n            help: 'Total count of peers that we forward a msg to',\n            labelNames: ['topic']\n        }),\n        /** Total count of recv msgs before any validation */\n        msgReceivedPreValidation: register.gauge({\n            name: 'gossipsub_msg_received_prevalidation_total',\n            help: 'Total count of recv msgs before any validation',\n            labelNames: ['topic']\n        }),\n        /** Total count of recv msgs error */\n        msgReceivedError: register.gauge({\n            name: 'gossipsub_msg_received_error_total',\n            help: 'Total count of recv msgs error',\n            labelNames: ['topic']\n        }),\n        /** Tracks distribution of recv msgs by duplicate, invalid, valid */\n        prevalidationInvalidTotal: register.gauge({\n            name: 'gossipsub_pre_validation_invalid_total',\n            help: 'Total count of invalid messages received',\n            labelNames: ['topic']\n        }),\n        prevalidationValidTotal: register.gauge({\n            name: 'gossipsub_pre_validation_valid_total',\n            help: 'Total count of valid messages received',\n            labelNames: ['topic']\n        }),\n        prevalidationDuplicateTotal: register.gauge({\n            name: 'gossipsub_pre_validation_duplicate_total',\n            help: 'Total count of duplicate messages received',\n            labelNames: ['topic']\n        }),\n        prevalidationUnknownTotal: register.gauge({\n            name: 'gossipsub_pre_validation_unknown_status_total',\n            help: 'Total count of unknown_status messages received',\n            labelNames: ['topic']\n        }),\n        /** Tracks specific reason of invalid */\n        msgReceivedInvalid: register.gauge({\n            name: 'gossipsub_msg_received_invalid_total',\n            help: 'Tracks specific reason of invalid',\n            labelNames: ['error']\n        }),\n        msgReceivedInvalidByTopic: register.gauge({\n            name: 'gossipsub_msg_received_invalid_by_topic_total',\n            help: 'Tracks specific invalid message by topic',\n            labelNames: ['topic']\n        }),\n        /** Track duplicate message delivery time */\n        duplicateMsgDeliveryDelay: register.histogram({\n            name: 'gossisub_duplicate_msg_delivery_delay_seconds',\n            help: 'Time since the 1st duplicated message validated',\n            labelNames: ['topic'],\n            buckets: [\n                0.25 * opts.maxMeshMessageDeliveriesWindowSec,\n                0.5 * opts.maxMeshMessageDeliveriesWindowSec,\n                1 * opts.maxMeshMessageDeliveriesWindowSec,\n                2 * opts.maxMeshMessageDeliveriesWindowSec,\n                4 * opts.maxMeshMessageDeliveriesWindowSec\n            ]\n        }),\n        /** Total count of late msg delivery total by topic */\n        duplicateMsgLateDelivery: register.gauge({\n            name: 'gossisub_duplicate_msg_late_delivery_total',\n            help: 'Total count of late duplicate message delivery by topic, which triggers P3 penalty',\n            labelNames: ['topic']\n        }),\n        duplicateMsgIgnored: register.gauge({\n            name: 'gossisub_ignored_published_duplicate_msgs_total',\n            help: 'Total count of published duplicate message ignored by topic',\n            labelNames: ['topic']\n        }),\n        /* Metrics related to scoring */\n        /** Total times score() is called */\n        scoreFnCalls: register.gauge({\n            name: 'gossipsub_score_fn_calls_total',\n            help: 'Total times score() is called'\n        }),\n        /** Total times score() call actually computed computeScore(), no cache */\n        scoreFnRuns: register.gauge({\n            name: 'gossipsub_score_fn_runs_total',\n            help: 'Total times score() call actually computed computeScore(), no cache'\n        }),\n        scoreCachedDelta: register.histogram({\n            name: 'gossipsub_score_cache_delta',\n            help: 'Delta of score between cached values that expired',\n            buckets: [10, 100, 1000]\n        }),\n        /** Current count of peers by score threshold */\n        peersByScoreThreshold: register.gauge({\n            name: 'gossipsub_peers_by_score_threshold_count',\n            help: 'Current count of peers by score threshold',\n            labelNames: ['threshold']\n        }),\n        score: register.avgMinMax({\n            name: 'gossipsub_score',\n            help: 'Avg min max of gossip scores'\n        }),\n        /**\n         * Separate score weights\n         * Need to use 2-label metrics in this case to debug the score weights\n         **/\n        scoreWeights: register.avgMinMax({\n            name: 'gossipsub_score_weights',\n            help: 'Separate score weights',\n            labelNames: ['topic', 'p']\n        }),\n        /** Histogram of the scores for each mesh topic. */\n        // TODO: Not implemented\n        scorePerMesh: register.avgMinMax({\n            name: 'gossipsub_score_per_mesh',\n            help: 'Histogram of the scores for each mesh topic',\n            labelNames: ['topic']\n        }),\n        /** A counter of the kind of penalties being applied to peers. */\n        // TODO: Not fully implemented\n        scoringPenalties: register.gauge({\n            name: 'gossipsub_scoring_penalties_total',\n            help: 'A counter of the kind of penalties being applied to peers',\n            labelNames: ['penalty']\n        }),\n        behaviourPenalty: register.histogram({\n            name: 'gossipsub_peer_stat_behaviour_penalty',\n            help: 'Current peer stat behaviour_penalty at each scrape',\n            buckets: [\n                0.25 * opts.behaviourPenaltyThreshold,\n                0.5 * opts.behaviourPenaltyThreshold,\n                1 * opts.behaviourPenaltyThreshold,\n                2 * opts.behaviourPenaltyThreshold,\n                4 * opts.behaviourPenaltyThreshold\n            ]\n        }),\n        // TODO:\n        // - iasked per peer (on heartbeat)\n        // - when promise is resolved, track messages from promises\n        /** Total received IHAVE messages that we ignore for some reason */\n        ihaveRcvIgnored: register.gauge({\n            name: 'gossipsub_ihave_rcv_ignored_total',\n            help: 'Total received IHAVE messages that we ignore for some reason',\n            labelNames: ['reason']\n        }),\n        /** Total received IHAVE messages by topic */\n        ihaveRcvMsgids: register.gauge({\n            name: 'gossipsub_ihave_rcv_msgids_total',\n            help: 'Total received IHAVE messages by topic',\n            labelNames: ['topic']\n        }),\n        /** Total messages per topic we don't have. Not actual requests.\n         *  The number of times we have decided that an IWANT control message is required for this\n         *  topic. A very high metric might indicate an underperforming network.\n         *  = rust-libp2p `topic_iwant_msgs` */\n        ihaveRcvNotSeenMsgids: register.gauge({\n            name: 'gossipsub_ihave_rcv_not_seen_msgids_total',\n            help: 'Total messages per topic we do not have, not actual requests',\n            labelNames: ['topic']\n        }),\n        /** Total received IWANT messages by topic */\n        iwantRcvMsgids: register.gauge({\n            name: 'gossipsub_iwant_rcv_msgids_total',\n            help: 'Total received IWANT messages by topic',\n            labelNames: ['topic']\n        }),\n        /** Total requested messageIDs that we don't have */\n        iwantRcvDonthaveMsgids: register.gauge({\n            name: 'gossipsub_iwant_rcv_dont_have_msgids_total',\n            help: 'Total requested messageIDs that we do not have'\n        }),\n        iwantPromiseStarted: register.gauge({\n            name: 'gossipsub_iwant_promise_sent_total',\n            help: 'Total count of started IWANT promises'\n        }),\n        /** Total count of resolved IWANT promises */\n        iwantPromiseResolved: register.gauge({\n            name: 'gossipsub_iwant_promise_resolved_total',\n            help: 'Total count of resolved IWANT promises'\n        }),\n        /** Total count of resolved IWANT promises from duplicate messages */\n        iwantPromiseResolvedFromDuplicate: register.gauge({\n            name: 'gossipsub_iwant_promise_resolved_from_duplicate_total',\n            help: 'Total count of resolved IWANT promises from duplicate messages'\n        }),\n        /** Total count of peers we have asked IWANT promises that are resolved */\n        iwantPromiseResolvedPeers: register.gauge({\n            name: 'gossipsub_iwant_promise_resolved_peers',\n            help: 'Total count of peers we have asked IWANT promises that are resolved'\n        }),\n        iwantPromiseBroken: register.gauge({\n            name: 'gossipsub_iwant_promise_broken',\n            help: 'Total count of broken IWANT promises'\n        }),\n        iwantMessagePruned: register.gauge({\n            name: 'gossipsub_iwant_message_pruned',\n            help: 'Total count of pruned IWANT messages'\n        }),\n        /** Histogram of delivery time of resolved IWANT promises */\n        iwantPromiseDeliveryTime: register.histogram({\n            name: 'gossipsub_iwant_promise_delivery_seconds',\n            help: 'Histogram of delivery time of resolved IWANT promises',\n            buckets: [\n                0.5 * opts.gossipPromiseExpireSec,\n                1 * opts.gossipPromiseExpireSec,\n                2 * opts.gossipPromiseExpireSec,\n                4 * opts.gossipPromiseExpireSec\n            ]\n        }),\n        iwantPromiseUntracked: register.gauge({\n            name: 'gossip_iwant_promise_untracked',\n            help: 'Total count of untracked IWANT promise'\n        }),\n        /** Backoff time */\n        connectedPeersBackoffSec: register.histogram({\n            name: 'gossipsub_connected_peers_backoff_seconds',\n            help: 'Backoff time in seconds',\n            // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.\n            // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.\n            // Higher values of 60 seconds should not occur, but we add 120 seconds just in case\n            // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters\n            buckets: [1, 2, 4, 10, 20, 60, 120]\n        }),\n        /* Data structure sizes */\n        /** Unbounded cache sizes */\n        cacheSize: register.gauge({\n            name: 'gossipsub_cache_size',\n            help: 'Unbounded cache sizes',\n            labelNames: ['cache']\n        }),\n        /** Current mcache msg count */\n        mcacheSize: register.gauge({\n            name: 'gossipsub_mcache_size',\n            help: 'Current mcache msg count'\n        }),\n        mcacheNotValidatedCount: register.gauge({\n            name: 'gossipsub_mcache_not_validated_count',\n            help: 'Current mcache msg count not validated'\n        }),\n        fastMsgIdCacheCollision: register.gauge({\n            name: 'gossipsub_fastmsgid_cache_collision_total',\n            help: 'Total count of key collisions on fastmsgid cache put'\n        }),\n        newConnectionCount: register.gauge({\n            name: 'gossipsub_new_connection_total',\n            help: 'Total new connection by status',\n            labelNames: ['status']\n        }),\n        topicStrToLabel: topicStrToLabel,\n        toTopic(topicStr) {\n            return this.topicStrToLabel.get(topicStr) ?? topicStr;\n        },\n        /** We joined a topic */\n        onJoin(topicStr) {\n            this.topicSubscriptionStatus.set({ topicStr }, 1);\n            this.meshPeerCounts.set({ topicStr }, 0); // Reset count\n        },\n        /** We left a topic */\n        onLeave(topicStr) {\n            this.topicSubscriptionStatus.set({ topicStr }, 0);\n            this.meshPeerCounts.set({ topicStr }, 0); // Reset count\n        },\n        /** Register the inclusion of peers in our mesh due to some reason. */\n        onAddToMesh(topicStr, reason, count) {\n            const topic = this.toTopic(topicStr);\n            switch (reason) {\n                case InclusionReason.Fanout:\n                    this.meshPeerInclusionEventsFanout.inc({ topic }, count);\n                    break;\n                case InclusionReason.Random:\n                    this.meshPeerInclusionEventsRandom.inc({ topic }, count);\n                    break;\n                case InclusionReason.Subscribed:\n                    this.meshPeerInclusionEventsSubscribed.inc({ topic }, count);\n                    break;\n                case InclusionReason.Outbound:\n                    this.meshPeerInclusionEventsOutbound.inc({ topic }, count);\n                    break;\n                case InclusionReason.NotEnough:\n                    this.meshPeerInclusionEventsNotEnough.inc({ topic }, count);\n                    break;\n                case InclusionReason.Opportunistic:\n                    this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count);\n                    break;\n                default:\n                    this.meshPeerInclusionEventsUnknown.inc({ topic }, count);\n                    break;\n            }\n        },\n        /** Register the removal of peers in our mesh due to some reason */\n        // - remove_peer_from_mesh()\n        // - heartbeat() Churn::BadScore\n        // - heartbeat() Churn::Excess\n        // - on_disconnect() Churn::Ds\n        onRemoveFromMesh(topicStr, reason, count) {\n            const topic = this.toTopic(topicStr);\n            switch (reason) {\n                case ChurnReason.Dc:\n                    this.meshPeerChurnEventsDisconnected.inc({ topic }, count);\n                    break;\n                case ChurnReason.BadScore:\n                    this.meshPeerChurnEventsBadScore.inc({ topic }, count);\n                    break;\n                case ChurnReason.Prune:\n                    this.meshPeerChurnEventsPrune.inc({ topic }, count);\n                    break;\n                case ChurnReason.Excess:\n                    this.meshPeerChurnEventsExcess.inc({ topic }, count);\n                    break;\n                default:\n                    this.meshPeerChurnEventsUnknown.inc({ topic }, count);\n                    break;\n            }\n        },\n        /**\n         * Update validation result to metrics\n         * @param messageRecord null means the message's mcache record was not known at the time of acceptance report\n         */\n        onReportValidation(messageRecord, acceptance, firstSeenTimestampMs) {\n            this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? 'hit' : 'miss' });\n            if (messageRecord != null) {\n                const topic = this.toTopic(messageRecord.message.topic);\n                switch (acceptance) {\n                    case TopicValidatorResult.Accept:\n                        this.acceptedMessagesTotal.inc({ topic });\n                        break;\n                    case TopicValidatorResult.Ignore:\n                        this.ignoredMessagesTotal.inc({ topic });\n                        break;\n                    case TopicValidatorResult.Reject:\n                        this.rejectedMessagesTotal.inc({ topic });\n                        break;\n                    default:\n                        this.unknownValidationResultsTotal.inc({ topic });\n                        break;\n                }\n            }\n            if (firstSeenTimestampMs != null) {\n                this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1000);\n            }\n            else {\n                this.asyncValidationUnknownFirstSeen.inc();\n            }\n        },\n        /**\n         * - in handle_graft() Penalty::GraftBackoff\n         * - in apply_iwant_penalties() Penalty::BrokenPromise\n         * - in metric_score() P3 Penalty::MessageDeficit\n         * - in metric_score() P6 Penalty::IPColocation\n         */\n        onScorePenalty(penalty) {\n            // Can this be labeled by topic too?\n            this.scoringPenalties.inc({ penalty }, 1);\n        },\n        onIhaveRcv(topicStr, ihave, idonthave) {\n            const topic = this.toTopic(topicStr);\n            this.ihaveRcvMsgids.inc({ topic }, ihave);\n            this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);\n        },\n        onIwantRcv(iwantByTopic, iwantDonthave) {\n            for (const [topicStr, iwant] of iwantByTopic) {\n                const topic = this.toTopic(topicStr);\n                this.iwantRcvMsgids.inc({ topic }, iwant);\n            }\n            this.iwantRcvDonthaveMsgids.inc(iwantDonthave);\n        },\n        onForwardMsg(topicStr, tosendCount) {\n            const topic = this.toTopic(topicStr);\n            this.msgForwardCount.inc({ topic }, 1);\n            this.msgForwardPeers.inc({ topic }, tosendCount);\n        },\n        onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen, ms) {\n            const topic = this.toTopic(topicStr);\n            this.msgPublishCount.inc({ topic }, 1);\n            this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);\n            this.msgPublishPeersByTopic.inc({ topic }, tosendCount);\n            this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct);\n            this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub);\n            this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh);\n            this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout);\n            this.msgPublishTime.observe({ topic }, ms / 1000);\n        },\n        onMsgRecvPreValidation(topicStr) {\n            const topic = this.toTopic(topicStr);\n            this.msgReceivedPreValidation.inc({ topic }, 1);\n        },\n        onMsgRecvError(topicStr) {\n            const topic = this.toTopic(topicStr);\n            this.msgReceivedError.inc({ topic }, 1);\n        },\n        onPrevalidationResult(topicStr, status) {\n            const topic = this.toTopic(topicStr);\n            switch (status) {\n                case MessageStatus.duplicate:\n                    this.prevalidationDuplicateTotal.inc({ topic });\n                    break;\n                case MessageStatus.invalid:\n                    this.prevalidationInvalidTotal.inc({ topic });\n                    break;\n                case MessageStatus.valid:\n                    this.prevalidationValidTotal.inc({ topic });\n                    break;\n                default:\n                    this.prevalidationUnknownTotal.inc({ topic });\n                    break;\n            }\n        },\n        onMsgRecvInvalid(topicStr, reason) {\n            const topic = this.toTopic(topicStr);\n            const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;\n            this.msgReceivedInvalid.inc({ error }, 1);\n            this.msgReceivedInvalidByTopic.inc({ topic }, 1);\n        },\n        onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {\n            this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1000);\n            if (isLateDelivery) {\n                const topic = this.toTopic(topicStr);\n                this.duplicateMsgLateDelivery.inc({ topic }, 1);\n            }\n        },\n        onPublishDuplicateMsg(topicStr) {\n            const topic = this.toTopic(topicStr);\n            this.duplicateMsgIgnored.inc({ topic }, 1);\n        },\n        onPeerReadStreamError() {\n            this.peerReadStreamError.inc(1);\n        },\n        onRpcRecvError() {\n            this.rpcRecvError.inc(1);\n        },\n        onRpcDataError() {\n            this.rpcDataError.inc(1);\n        },\n        onRpcRecv(rpc, rpcBytes) {\n            this.rpcRecvBytes.inc(rpcBytes);\n            this.rpcRecvCount.inc(1);\n            if (rpc.subscriptions)\n                this.rpcRecvSubscription.inc(rpc.subscriptions.length);\n            if (rpc.messages)\n                this.rpcRecvMessage.inc(rpc.messages.length);\n            if (rpc.control) {\n                this.rpcRecvControl.inc(1);\n                if (rpc.control.ihave)\n                    this.rpcRecvIHave.inc(rpc.control.ihave.length);\n                if (rpc.control.iwant)\n                    this.rpcRecvIWant.inc(rpc.control.iwant.length);\n                if (rpc.control.graft)\n                    this.rpcRecvGraft.inc(rpc.control.graft.length);\n                if (rpc.control.prune)\n                    this.rpcRecvPrune.inc(rpc.control.prune.length);\n            }\n        },\n        onRpcSent(rpc, rpcBytes) {\n            this.rpcSentBytes.inc(rpcBytes);\n            this.rpcSentCount.inc(1);\n            if (rpc.subscriptions)\n                this.rpcSentSubscription.inc(rpc.subscriptions.length);\n            if (rpc.messages)\n                this.rpcSentMessage.inc(rpc.messages.length);\n            if (rpc.control) {\n                const ihave = rpc.control.ihave?.length ?? 0;\n                const iwant = rpc.control.iwant?.length ?? 0;\n                const graft = rpc.control.graft?.length ?? 0;\n                const prune = rpc.control.prune?.length ?? 0;\n                if (ihave > 0)\n                    this.rpcSentIHave.inc(ihave);\n                if (iwant > 0)\n                    this.rpcSentIWant.inc(iwant);\n                if (graft > 0)\n                    this.rpcSentGraft.inc(graft);\n                if (prune > 0)\n                    this.rpcSentPrune.inc(prune);\n                if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)\n                    this.rpcSentControl.inc(1);\n            }\n        },\n        registerScores(scores, scoreThresholds) {\n            let graylist = 0;\n            let publish = 0;\n            let gossip = 0;\n            let mesh = 0;\n            for (const score of scores) {\n                if (score >= scoreThresholds.graylistThreshold)\n                    graylist++;\n                if (score >= scoreThresholds.publishThreshold)\n                    publish++;\n                if (score >= scoreThresholds.gossipThreshold)\n                    gossip++;\n                if (score >= 0)\n                    mesh++;\n            }\n            this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);\n            this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);\n            this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);\n            this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);\n            // Register full score too\n            this.score.set(scores);\n        },\n        registerScoreWeights(sw) {\n            for (const [topic, wsTopic] of sw.byTopic) {\n                this.scoreWeights.set({ topic, p: 'p1' }, wsTopic.p1w);\n                this.scoreWeights.set({ topic, p: 'p2' }, wsTopic.p2w);\n                this.scoreWeights.set({ topic, p: 'p3' }, wsTopic.p3w);\n                this.scoreWeights.set({ topic, p: 'p3b' }, wsTopic.p3bw);\n                this.scoreWeights.set({ topic, p: 'p4' }, wsTopic.p4w);\n            }\n            this.scoreWeights.set({ p: 'p5' }, sw.p5w);\n            this.scoreWeights.set({ p: 'p6' }, sw.p6w);\n            this.scoreWeights.set({ p: 'p7' }, sw.p7w);\n        },\n        registerScorePerMesh(mesh, scoreByPeer) {\n            const peersPerTopicLabel = new Map();\n            mesh.forEach((peers, topicStr) => {\n                // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n                const topicLabel = this.topicStrToLabel.get(topicStr) ?? 'unknown';\n                let peersInMesh = peersPerTopicLabel.get(topicLabel);\n                if (!peersInMesh) {\n                    peersInMesh = new Set();\n                    peersPerTopicLabel.set(topicLabel, peersInMesh);\n                }\n                peers.forEach((p) => peersInMesh?.add(p));\n            });\n            for (const [topic, peers] of peersPerTopicLabel) {\n                const meshScores = [];\n                peers.forEach((peer) => {\n                    meshScores.push(scoreByPeer.get(peer) ?? 0);\n                });\n                this.scorePerMesh.set({ topic }, meshScores);\n            }\n        }\n    };\n}\n//# sourceMappingURL=metrics.js.map","import { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { randomBytes } from '@libp2p/crypto';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { RPC } from '../message/rpc.js';\nimport { PublishConfigType, ValidateError } from '../types.js';\nimport { StrictSign, StrictNoSign } from '@libp2p/interface/pubsub';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:');\nexport async function buildRawMessage(publishConfig, topic, originalData, transformedData) {\n    switch (publishConfig.type) {\n        case PublishConfigType.Signing: {\n            const rpcMsg = {\n                from: publishConfig.author.toBytes(),\n                data: transformedData,\n                seqno: randomBytes(8),\n                topic,\n                signature: undefined,\n                key: undefined // Exclude key field for signing\n            };\n            // Get the message in bytes, and prepend with the pubsub prefix\n            // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n            const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);\n            rpcMsg.signature = await publishConfig.privateKey.sign(bytes);\n            rpcMsg.key = publishConfig.key;\n            const msg = {\n                type: 'signed',\n                from: publishConfig.author,\n                data: originalData,\n                sequenceNumber: BigInt(`0x${uint8ArrayToString(rpcMsg.seqno, 'base16')}`),\n                topic,\n                signature: rpcMsg.signature,\n                key: rpcMsg.key\n            };\n            return {\n                raw: rpcMsg,\n                msg: msg\n            };\n        }\n        case PublishConfigType.Anonymous: {\n            return {\n                raw: {\n                    from: undefined,\n                    data: transformedData,\n                    seqno: undefined,\n                    topic,\n                    signature: undefined,\n                    key: undefined\n                },\n                msg: {\n                    type: 'unsigned',\n                    data: originalData,\n                    topic\n                }\n            };\n        }\n    }\n}\nexport async function validateToRawMessage(signaturePolicy, msg) {\n    // If strict-sign, verify all\n    // If anonymous (no-sign), ensure no preven\n    switch (signaturePolicy) {\n        case StrictNoSign:\n            if (msg.signature != null)\n                return { valid: false, error: ValidateError.SignaturePresent };\n            if (msg.seqno != null)\n                return { valid: false, error: ValidateError.SeqnoPresent };\n            if (msg.key != null)\n                return { valid: false, error: ValidateError.FromPresent };\n            return { valid: true, message: { type: 'unsigned', topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };\n        case StrictSign: {\n            // Verify seqno\n            if (msg.seqno == null)\n                return { valid: false, error: ValidateError.InvalidSeqno };\n            if (msg.seqno.length !== 8) {\n                return { valid: false, error: ValidateError.InvalidSeqno };\n            }\n            if (msg.signature == null)\n                return { valid: false, error: ValidateError.InvalidSignature };\n            if (msg.from == null)\n                return { valid: false, error: ValidateError.InvalidPeerId };\n            let fromPeerId;\n            try {\n                // TODO: Fix PeerId types\n                fromPeerId = peerIdFromBytes(msg.from);\n            }\n            catch (e) {\n                return { valid: false, error: ValidateError.InvalidPeerId };\n            }\n            // - check from defined\n            // - transform source to PeerId\n            // - parse signature\n            // - get .key, else from source\n            // - check key == source if present\n            // - verify sig\n            let publicKey;\n            if (msg.key) {\n                publicKey = unmarshalPublicKey(msg.key);\n                // TODO: Should `fromPeerId.pubKey` be optional?\n                if (fromPeerId.publicKey !== undefined && !uint8ArrayEquals(publicKey.bytes, fromPeerId.publicKey)) {\n                    return { valid: false, error: ValidateError.InvalidPeerId };\n                }\n            }\n            else {\n                if (fromPeerId.publicKey == null) {\n                    return { valid: false, error: ValidateError.InvalidPeerId };\n                }\n                publicKey = unmarshalPublicKey(fromPeerId.publicKey);\n            }\n            const rpcMsgPreSign = {\n                from: msg.from,\n                data: msg.data,\n                seqno: msg.seqno,\n                topic: msg.topic,\n                signature: undefined,\n                key: undefined // Exclude key field for signing\n            };\n            // Get the message in bytes, and prepend with the pubsub prefix\n            // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n            const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);\n            if (!(await publicKey.verify(bytes, msg.signature))) {\n                return { valid: false, error: ValidateError.InvalidSignature };\n            }\n            return {\n                valid: true,\n                message: {\n                    type: 'signed',\n                    from: fromPeerId,\n                    data: msg.data ?? new Uint8Array(0),\n                    sequenceNumber: BigInt(`0x${uint8ArrayToString(msg.seqno, 'base16')}`),\n                    topic: msg.topic,\n                    signature: msg.signature,\n                    key: msg.key ?? marshalPublicKey(publicKey)\n                }\n            };\n        }\n    }\n}\n//# sourceMappingURL=buildRawMessage.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","import { convertToString } from '@multiformats/multiaddr/convert';\n// Protocols https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n// code  size  name\n// 4     32    ip4\n// 41    128   ip6\nvar Protocol;\n(function (Protocol) {\n    Protocol[Protocol[\"ip4\"] = 4] = \"ip4\";\n    Protocol[Protocol[\"ip6\"] = 41] = \"ip6\";\n})(Protocol || (Protocol = {}));\nexport function multiaddrToIPStr(multiaddr) {\n    for (const tuple of multiaddr.tuples()) {\n        switch (tuple[0]) {\n            case Protocol.ip4:\n            case Protocol.ip6:\n                return convertToString(tuple[0], tuple[1]);\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=multiaddr.js.map","import { pipe } from 'it-pipe';\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id';\nimport { logger } from '@libp2p/logger';\nimport { CustomEvent, EventEmitter } from '@libp2p/interface/events';\nimport { MessageCache } from './message-cache.js';\nimport { RPC } from './message/rpc.js';\nimport * as constants from './constants.js';\nimport { shuffle, messageIdToString } from './utils/index.js';\nimport { PeerScore, createPeerScoreParams, createPeerScoreThresholds } from './score/index.js';\nimport { IWantTracer } from './tracer.js';\nimport { SimpleTimeCache } from './utils/time-cache.js';\nimport { ACCEPT_FROM_WHITELIST_DURATION_MS, ACCEPT_FROM_WHITELIST_MAX_MESSAGES, ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, BACKOFF_SLACK } from './constants.js';\nimport { ChurnReason, getMetrics, IHaveIgnoreReason, InclusionReason, ScorePenalty } from './metrics.js';\nimport { ValidateError, MessageStatus, RejectReason, rejectReasonFromAcceptance } from './types.js';\nimport { buildRawMessage, validateToRawMessage } from './utils/buildRawMessage.js';\nimport { msgIdFnStrictNoSign, msgIdFnStrictSign } from './utils/msgIdFn.js';\nimport { computeAllPeersScoreWeights } from './score/scoreMetrics.js';\nimport { getPublishConfigFromPeerId } from './utils/publishConfig.js';\nimport { StrictSign, StrictNoSign, TopicValidatorResult } from '@libp2p/interface/pubsub';\nimport { removeFirstNItemsFromSet, removeItemsFromSet } from './utils/set.js';\nimport { pushable } from 'it-pushable';\nimport { InboundStream, OutboundStream } from './stream.js';\nimport { decodeRpc, defaultDecodeRpcLimits } from './message/decodeRpc.js';\nimport { multiaddrToIPStr } from './utils/multiaddr.js';\nexport const multicodec = constants.GossipsubIDv11;\nvar GossipStatusCode;\n(function (GossipStatusCode) {\n    GossipStatusCode[GossipStatusCode[\"started\"] = 0] = \"started\";\n    GossipStatusCode[GossipStatusCode[\"stopped\"] = 1] = \"stopped\";\n})(GossipStatusCode || (GossipStatusCode = {}));\nexport class GossipSub extends EventEmitter {\n    /**\n     * The signature policy to follow by default\n     */\n    globalSignaturePolicy;\n    multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n    publishConfig;\n    dataTransform;\n    // State\n    peers = new Set();\n    streamsInbound = new Map();\n    streamsOutbound = new Map();\n    /** Ensures outbound streams are created sequentially */\n    outboundInflightQueue = pushable({ objectMode: true });\n    /** Direct peers */\n    direct = new Set();\n    /** Floodsub peers */\n    floodsubPeers = new Set();\n    /** Cache of seen messages */\n    seenCache;\n    /**\n     * Map of peer id and AcceptRequestWhileListEntry\n     */\n    acceptFromWhitelist = new Map();\n    /**\n     * Map of topics to which peers are subscribed to\n     */\n    topics = new Map();\n    /**\n     * List of our subscriptions\n     */\n    subscriptions = new Set();\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     */\n    mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     */\n    fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     */\n    fanoutLastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     */\n    gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     */\n    control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     */\n    peerhave = new Map();\n    /** Number of messages we have asked from peer in the last heartbeat */\n    iasked = new Map();\n    /** Prune backoff map */\n    backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     */\n    outbound = new Map();\n    msgIdFn;\n    /**\n     * A fast message id function used for internal message de-duplication\n     */\n    fastMsgIdFn;\n    msgIdToStrFn;\n    /** Maps fast message-id to canonical message-id */\n    fastMsgIdCache;\n    /**\n     * Short term cache for published message ids. This is used for penalizing peers sending\n     * our own messages back if the messages are anonymous or use a random author.\n     */\n    publishedMessageIds;\n    /**\n     * A message cache that contains the messages for last few heartbeat ticks\n     */\n    mcache;\n    /** Peer score tracking */\n    score;\n    /**\n     * Custom validator function per topic.\n     * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.\n     * If you need to apply validation that may require longer times use `asyncValidation` option and callback the\n     * validation result through `Gossipsub.reportValidationResult`\n     */\n    topicValidators = new Map();\n    /**\n     * Make this protected so child class may want to redirect to its own log.\n     */\n    log;\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n    heartbeatTicks = 0;\n    /**\n     * Tracks IHAVE/IWANT promises broken by peers\n     */\n    gossipTracer;\n    components;\n    directPeerInitial = null;\n    static multicodec = constants.GossipsubIDv11;\n    // Options\n    opts;\n    decodeRpcLimits;\n    metrics;\n    status = { code: GossipStatusCode.stopped };\n    maxInboundStreams;\n    maxOutboundStreams;\n    allowedTopics;\n    heartbeatTimer = null;\n    constructor(components, options = {}) {\n        super();\n        const opts = {\n            fallbackToFloodsub: true,\n            floodPublish: true,\n            doPX: false,\n            directPeers: [],\n            D: constants.GossipsubD,\n            Dlo: constants.GossipsubDlo,\n            Dhi: constants.GossipsubDhi,\n            Dscore: constants.GossipsubDscore,\n            Dout: constants.GossipsubDout,\n            Dlazy: constants.GossipsubDlazy,\n            heartbeatInterval: constants.GossipsubHeartbeatInterval,\n            fanoutTTL: constants.GossipsubFanoutTTL,\n            mcacheLength: constants.GossipsubHistoryLength,\n            mcacheGossip: constants.GossipsubHistoryGossip,\n            seenTTL: constants.GossipsubSeenTTL,\n            gossipsubIWantFollowupMs: constants.GossipsubIWantFollowupTime,\n            prunePeers: constants.GossipsubPrunePeers,\n            pruneBackoff: constants.GossipsubPruneBackoff,\n            unsubcribeBackoff: constants.GossipsubUnsubscribeBackoff,\n            graftFloodThreshold: constants.GossipsubGraftFloodThreshold,\n            opportunisticGraftPeers: constants.GossipsubOpportunisticGraftPeers,\n            opportunisticGraftTicks: constants.GossipsubOpportunisticGraftTicks,\n            directConnectTicks: constants.GossipsubDirectConnectTicks,\n            ...options,\n            scoreParams: createPeerScoreParams(options.scoreParams),\n            scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)\n        };\n        this.components = components;\n        this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;\n        this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;\n        // Also wants to get notified of peers connected using floodsub\n        if (opts.fallbackToFloodsub) {\n            this.multicodecs.push(constants.FloodsubID);\n        }\n        // From pubsub\n        this.log = logger(opts.debugName ?? 'libp2p:gossipsub');\n        // Gossipsub\n        this.opts = opts;\n        this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));\n        this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });\n        this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });\n        if (options.msgIdFn) {\n            // Use custom function\n            this.msgIdFn = options.msgIdFn;\n        }\n        else {\n            switch (this.globalSignaturePolicy) {\n                case StrictSign:\n                    this.msgIdFn = msgIdFnStrictSign;\n                    break;\n                case StrictNoSign:\n                    this.msgIdFn = msgIdFnStrictNoSign;\n                    break;\n            }\n        }\n        if (options.fastMsgIdFn) {\n            this.fastMsgIdFn = options.fastMsgIdFn;\n            this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });\n        }\n        // By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n        this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;\n        this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);\n        if (options.dataTransform) {\n            this.dataTransform = options.dataTransform;\n        }\n        if (options.metricsRegister) {\n            if (!options.metricsTopicStrToLabel) {\n                throw Error('Must set metricsTopicStrToLabel with metrics');\n            }\n            // in theory, each topic has its own meshMessageDeliveriesWindow param\n            // however in lodestar, we configure it mostly the same so just pick the max of positive ones\n            // (some topics have meshMessageDeliveriesWindow as 0)\n            const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), constants.DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);\n            const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {\n                gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,\n                behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,\n                maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000\n            });\n            metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));\n            for (const protocol of this.multicodecs) {\n                metrics.protocolsEnabled.set({ protocol }, 1);\n            }\n            this.metrics = metrics;\n        }\n        else {\n            this.metrics = null;\n        }\n        this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);\n        /**\n         * libp2p\n         */\n        this.score = new PeerScore(this.opts.scoreParams, this.metrics, {\n            scoreCacheValidityMs: opts.heartbeatInterval\n        });\n        this.maxInboundStreams = options.maxInboundStreams;\n        this.maxOutboundStreams = options.maxOutboundStreams;\n        this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null;\n    }\n    getPeers() {\n        return [...this.peers.keys()].map((str) => peerIdFromString(str));\n    }\n    isStarted() {\n        return this.status.code === GossipStatusCode.started;\n    }\n    // LIFECYCLE METHODS\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     */\n    async start() {\n        // From pubsub\n        if (this.isStarted()) {\n            return;\n        }\n        this.log('starting');\n        this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId);\n        // Create the outbound inflight queue\n        // This ensures that outbound stream creation happens sequentially\n        this.outboundInflightQueue = pushable({ objectMode: true });\n        pipe(this.outboundInflightQueue, async (source) => {\n            for await (const { peerId, connection } of source) {\n                await this.createOutboundStream(peerId, connection);\n            }\n        }).catch((e) => this.log.error('outbound inflight queue error', e));\n        // set direct peer addresses in the address book\n        await Promise.all(this.opts.directPeers.map(async (p) => {\n            await this.components.peerStore.merge(p.id, {\n                multiaddrs: p.addrs\n            });\n        }));\n        const registrar = this.components.registrar;\n        // Incoming streams\n        // Called after a peer dials us\n        await Promise.all(this.multicodecs.map((multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {\n            maxInboundStreams: this.maxInboundStreams,\n            maxOutboundStreams: this.maxOutboundStreams\n        })));\n        // # How does Gossipsub interact with libp2p? Rough guide from Mar 2022\n        //\n        // ## Setup:\n        // Gossipsub requests libp2p to callback, TBD\n        //\n        // `this.libp2p.handle()` registers a handler for `/meshsub/1.1.0` and other Gossipsub protocols\n        // The handler callback is registered in libp2p Upgrader.protocols map.\n        //\n        // Upgrader receives an inbound connection from some transport and (`Upgrader.upgradeInbound`):\n        // - Adds encryption (NOISE in our case)\n        // - Multiplex stream\n        // - Create a muxer and register that for each new stream call Upgrader.protocols handler\n        //\n        // ## Topology\n        // - new instance of Topology (unlinked to libp2p) with handlers\n        // - registar.register(topology)\n        // register protocol with topology\n        // Topology callbacks called on connection manager changes\n        const topology = {\n            onConnect: this.onPeerConnected.bind(this),\n            onDisconnect: this.onPeerDisconnected.bind(this)\n        };\n        const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec) => registrar.register(multicodec, topology)));\n        // Schedule to start heartbeat after `GossipsubHeartbeatInitialDelay`\n        const heartbeatTimeout = setTimeout(this.runHeartbeat, constants.GossipsubHeartbeatInitialDelay);\n        // Then, run heartbeat every `heartbeatInterval` offset by `GossipsubHeartbeatInitialDelay`\n        this.status = {\n            code: GossipStatusCode.started,\n            registrarTopologyIds,\n            heartbeatTimeout: heartbeatTimeout,\n            hearbeatStartMs: Date.now() + constants.GossipsubHeartbeatInitialDelay\n        };\n        this.score.start();\n        // connect to direct peers\n        this.directPeerInitial = setTimeout(() => {\n            Promise.resolve()\n                .then(async () => {\n                await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));\n            })\n                .catch((err) => {\n                this.log(err);\n            });\n        }, constants.GossipsubDirectConnectInitialDelay);\n        this.log('started');\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     */\n    async stop() {\n        this.log('stopping');\n        // From pubsub\n        if (this.status.code !== GossipStatusCode.started) {\n            return;\n        }\n        const { registrarTopologyIds } = this.status;\n        this.status = { code: GossipStatusCode.stopped };\n        // unregister protocol and handlers\n        const registrar = this.components.registrar;\n        await Promise.all(this.multicodecs.map((multicodec) => registrar.unhandle(multicodec)));\n        registrarTopologyIds.forEach((id) => registrar.unregister(id));\n        this.outboundInflightQueue.end();\n        for (const outboundStream of this.streamsOutbound.values()) {\n            outboundStream.close();\n        }\n        this.streamsOutbound.clear();\n        for (const inboundStream of this.streamsInbound.values()) {\n            inboundStream.close();\n        }\n        this.streamsInbound.clear();\n        this.peers.clear();\n        this.subscriptions.clear();\n        // Gossipsub\n        if (this.heartbeatTimer) {\n            this.heartbeatTimer.cancel();\n            this.heartbeatTimer = null;\n        }\n        this.score.stop();\n        this.mesh.clear();\n        this.fanout.clear();\n        this.fanoutLastpub.clear();\n        this.gossip.clear();\n        this.control.clear();\n        this.peerhave.clear();\n        this.iasked.clear();\n        this.backoff.clear();\n        this.outbound.clear();\n        this.gossipTracer.clear();\n        this.seenCache.clear();\n        if (this.fastMsgIdCache)\n            this.fastMsgIdCache.clear();\n        if (this.directPeerInitial)\n            clearTimeout(this.directPeerInitial);\n        this.log('stopped');\n    }\n    /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */\n    dumpPeerScoreStats() {\n        return this.score.dumpPeerScoreStats();\n    }\n    /**\n     * On an inbound stream opened\n     */\n    onIncomingStream({ stream, connection }) {\n        if (!this.isStarted()) {\n            return;\n        }\n        const peerId = connection.remotePeer;\n        // add peer to router\n        this.addPeer(peerId, connection.direction, connection.remoteAddr);\n        // create inbound stream\n        this.createInboundStream(peerId, stream);\n        // attempt to create outbound stream\n        this.outboundInflightQueue.push({ peerId, connection });\n    }\n    /**\n     * Registrar notifies an established connection with pubsub protocol\n     */\n    onPeerConnected(peerId, connection) {\n        this.metrics?.newConnectionCount.inc({ status: connection.status });\n        // libp2p may emit a closed connection and never issue peer:disconnect event\n        // see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/398\n        if (!this.isStarted() || connection.status !== 'open') {\n            return;\n        }\n        this.addPeer(peerId, connection.direction, connection.remoteAddr);\n        this.outboundInflightQueue.push({ peerId, connection });\n    }\n    /**\n     * Registrar notifies a closing connection with pubsub protocol\n     */\n    onPeerDisconnected(peerId) {\n        this.log('connection ended %p', peerId);\n        this.removePeer(peerId);\n    }\n    async createOutboundStream(peerId, connection) {\n        if (!this.isStarted()) {\n            return;\n        }\n        const id = peerId.toString();\n        if (!this.peers.has(id)) {\n            return;\n        }\n        // TODO make this behavior more robust\n        // This behavior is different than for inbound streams\n        // If an outbound stream already exists, don't create a new stream\n        if (this.streamsOutbound.has(id)) {\n            return;\n        }\n        try {\n            const stream = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error('outbound pipe error', e), { maxBufferSize: this.opts.maxOutboundBufferSize });\n            this.log('create outbound stream %p', peerId);\n            this.streamsOutbound.set(id, stream);\n            const protocol = stream.protocol;\n            if (protocol === constants.FloodsubID) {\n                this.floodsubPeers.add(id);\n            }\n            this.metrics?.peersPerProtocol.inc({ protocol }, 1);\n            // Immediately send own subscriptions via the newly attached stream\n            if (this.subscriptions.size > 0) {\n                this.log('send subscriptions to', id);\n                this.sendSubscriptions(id, Array.from(this.subscriptions), true);\n            }\n        }\n        catch (e) {\n            this.log.error('createOutboundStream error', e);\n        }\n    }\n    async createInboundStream(peerId, stream) {\n        if (!this.isStarted()) {\n            return;\n        }\n        const id = peerId.toString();\n        if (!this.peers.has(id)) {\n            return;\n        }\n        // TODO make this behavior more robust\n        // This behavior is different than for outbound streams\n        // If a peer initiates a new inbound connection\n        // we assume that one is the new canonical inbound stream\n        const priorInboundStream = this.streamsInbound.get(id);\n        if (priorInboundStream !== undefined) {\n            this.log('replacing existing inbound steam %s', id);\n            priorInboundStream.close();\n        }\n        this.log('create inbound stream %s', id);\n        const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });\n        this.streamsInbound.set(id, inboundStream);\n        this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => this.log(err));\n    }\n    /**\n     * Add a peer to the router\n     */\n    addPeer(peerId, direction, addr) {\n        const id = peerId.toString();\n        if (!this.peers.has(id)) {\n            this.log('new peer %p', peerId);\n            this.peers.add(id);\n            // Add to peer scoring\n            this.score.addPeer(id);\n            const currentIP = multiaddrToIPStr(addr);\n            if (currentIP !== null) {\n                this.score.addIP(id, currentIP);\n            }\n            else {\n                this.log('Added peer has no IP in current address %s %s', id, addr.toString());\n            }\n            // track the connection direction. Don't allow to unset outbound\n            if (!this.outbound.has(id)) {\n                this.outbound.set(id, direction === 'outbound');\n            }\n        }\n    }\n    /**\n     * Removes a peer from the router\n     */\n    removePeer(peerId) {\n        const id = peerId.toString();\n        if (!this.peers.has(id)) {\n            return;\n        }\n        // delete peer\n        this.log('delete peer %p', peerId);\n        this.peers.delete(id);\n        const outboundStream = this.streamsOutbound.get(id);\n        const inboundStream = this.streamsInbound.get(id);\n        if (outboundStream) {\n            this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);\n        }\n        // close streams\n        outboundStream?.close();\n        inboundStream?.close();\n        // remove streams\n        this.streamsOutbound.delete(id);\n        this.streamsInbound.delete(id);\n        // remove peer from topics map\n        for (const peers of this.topics.values()) {\n            peers.delete(id);\n        }\n        // Remove this peer from the mesh\n        for (const [topicStr, peers] of this.mesh) {\n            if (peers.delete(id) === true) {\n                this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);\n            }\n        }\n        // Remove this peer from the fanout\n        for (const peers of this.fanout.values()) {\n            peers.delete(id);\n        }\n        // Remove from floodsubPeers\n        this.floodsubPeers.delete(id);\n        // Remove from gossip mapping\n        this.gossip.delete(id);\n        // Remove from control mapping\n        this.control.delete(id);\n        // Remove from backoff mapping\n        this.outbound.delete(id);\n        // Remove from peer scoring\n        this.score.removePeer(id);\n        this.acceptFromWhitelist.delete(id);\n    }\n    // API METHODS\n    get started() {\n        return this.status.code === GossipStatusCode.started;\n    }\n    /**\n     * Get a the peer-ids in a topic mesh\n     */\n    getMeshPeers(topic) {\n        const peersInTopic = this.mesh.get(topic);\n        return peersInTopic ? Array.from(peersInTopic) : [];\n    }\n    /**\n     * Get a list of the peer-ids that are subscribed to one topic.\n     */\n    getSubscribers(topic) {\n        const peersInTopic = this.topics.get(topic);\n        return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));\n    }\n    /**\n     * Get the list of topics which the peer is subscribed to.\n     */\n    getTopics() {\n        return Array.from(this.subscriptions);\n    }\n    // TODO: Reviewing Pubsub API\n    // MESSAGE METHODS\n    /**\n     * Responsible for processing each RPC message received by other peers.\n     */\n    async pipePeerReadStream(peerId, stream) {\n        try {\n            await pipe(stream, async (source) => {\n                for await (const data of source) {\n                    try {\n                        // TODO: Check max gossip message size, before decodeRpc()\n                        const rpcBytes = data.subarray();\n                        // Note: This function may throw, it must be wrapped in a try {} catch {} to prevent closing the stream.\n                        // TODO: What should we do if the entire RPC is invalid?\n                        const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits);\n                        this.metrics?.onRpcRecv(rpc, rpcBytes.length);\n                        // Since processRpc may be overridden entirely in unsafe ways,\n                        // the simplest/safest option here is to wrap in a function and capture all errors\n                        // to prevent a top-level unhandled exception\n                        // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n                        if (this.opts.awaitRpcHandler) {\n                            try {\n                                await this.handleReceivedRpc(peerId, rpc);\n                            }\n                            catch (err) {\n                                this.metrics?.onRpcRecvError();\n                                this.log(err);\n                            }\n                        }\n                        else {\n                            this.handleReceivedRpc(peerId, rpc).catch((err) => {\n                                this.metrics?.onRpcRecvError();\n                                this.log(err);\n                            });\n                        }\n                    }\n                    catch (e) {\n                        this.metrics?.onRpcDataError();\n                        this.log(e);\n                    }\n                }\n            });\n        }\n        catch (err) {\n            this.metrics?.onPeerReadStreamError();\n            this.handlePeerReadStreamError(err, peerId);\n        }\n    }\n    /**\n     * Handle error when read stream pipe throws, less of the functional use but more\n     * to for testing purposes to spy on the error handling\n     * */\n    handlePeerReadStreamError(err, peerId) {\n        this.log.error(err);\n        this.onPeerDisconnected(peerId);\n    }\n    /**\n     * Handles an rpc request from a peer\n     */\n    async handleReceivedRpc(from, rpc) {\n        // Check if peer is graylisted in which case we ignore the event\n        if (!this.acceptFrom(from.toString())) {\n            this.log('received message from unacceptable peer %p', from);\n            this.metrics?.rpcRecvNotAccepted.inc();\n            return;\n        }\n        const subscriptions = rpc.subscriptions ? rpc.subscriptions.length : 0;\n        const messages = rpc.messages ? rpc.messages.length : 0;\n        let ihave = 0;\n        let iwant = 0;\n        let graft = 0;\n        let prune = 0;\n        if (rpc.control) {\n            if (rpc.control.ihave)\n                ihave = rpc.control.ihave.length;\n            if (rpc.control.iwant)\n                iwant = rpc.control.iwant.length;\n            if (rpc.control.graft)\n                graft = rpc.control.graft.length;\n            if (rpc.control.prune)\n                prune = rpc.control.prune.length;\n        }\n        this.log(`rpc.from ${from.toString()} subscriptions ${subscriptions} messages ${messages} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`);\n        // Handle received subscriptions\n        if (rpc.subscriptions && rpc.subscriptions.length > 0) {\n            // update peer subscriptions\n            const subscriptions = [];\n            rpc.subscriptions.forEach((subOpt) => {\n                const topic = subOpt.topic;\n                const subscribe = subOpt.subscribe === true;\n                if (topic != null) {\n                    if (this.allowedTopics && !this.allowedTopics.has(topic)) {\n                        // Not allowed: subscription data-structures are not bounded by topic count\n                        // TODO: Should apply behaviour penalties?\n                        return;\n                    }\n                    this.handleReceivedSubscription(from, topic, subscribe);\n                    subscriptions.push({ topic, subscribe });\n                }\n            });\n            this.dispatchEvent(new CustomEvent('subscription-change', {\n                detail: { peerId: from, subscriptions }\n            }));\n        }\n        // Handle messages\n        // TODO: (up to limit)\n        if (rpc.messages) {\n            for (const message of rpc.messages) {\n                if (this.allowedTopics && !this.allowedTopics.has(message.topic)) {\n                    // Not allowed: message cache data-structures are not bounded by topic count\n                    // TODO: Should apply behaviour penalties?\n                    continue;\n                }\n                const handleReceivedMessagePromise = this.handleReceivedMessage(from, message)\n                    // Should never throw, but handle just in case\n                    .catch((err) => {\n                    this.metrics?.onMsgRecvError(message.topic);\n                    this.log(err);\n                });\n                if (this.opts.awaitRpcMessageHandler) {\n                    await handleReceivedMessagePromise;\n                }\n            }\n        }\n        // Handle control messages\n        if (rpc.control) {\n            await this.handleControlMessage(from.toString(), rpc.control);\n        }\n    }\n    /**\n     * Handles a subscription change from a peer\n     */\n    handleReceivedSubscription(from, topic, subscribe) {\n        this.log('subscription update from %p topic %s', from, topic);\n        let topicSet = this.topics.get(topic);\n        if (topicSet == null) {\n            topicSet = new Set();\n            this.topics.set(topic, topicSet);\n        }\n        if (subscribe) {\n            // subscribe peer to new topic\n            topicSet.add(from.toString());\n        }\n        else {\n            // unsubscribe from existing topic\n            topicSet.delete(from.toString());\n        }\n        // TODO: rust-libp2p has A LOT more logic here\n    }\n    /**\n     * Handles a newly received message from an RPC.\n     * May forward to all peers in the mesh.\n     */\n    async handleReceivedMessage(from, rpcMsg) {\n        this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);\n        const validationResult = await this.validateReceivedMessage(from, rpcMsg);\n        this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code);\n        switch (validationResult.code) {\n            case MessageStatus.duplicate:\n                // Report the duplicate\n                this.score.duplicateMessage(from.toString(), validationResult.msgIdStr, rpcMsg.topic);\n                // due to the collision of fastMsgIdFn, 2 different messages may end up the same fastMsgId\n                // so we need to also mark the duplicate message as delivered or the promise is not resolved\n                // and peer gets penalized. See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/385\n                this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);\n                this.mcache.observeDuplicate(validationResult.msgIdStr, from.toString());\n                return;\n            case MessageStatus.invalid:\n                // invalid messages received\n                // metrics.register_invalid_message(&raw_message.topic)\n                // Tell peer_score about reject\n                // Reject the original source, and any duplicates we've seen from other peers.\n                if (validationResult.msgIdStr) {\n                    const msgIdStr = validationResult.msgIdStr;\n                    this.score.rejectMessage(from.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);\n                    this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);\n                }\n                else {\n                    this.score.rejectInvalidMessage(from.toString(), rpcMsg.topic);\n                }\n                this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);\n                return;\n            case MessageStatus.valid:\n                // Tells score that message arrived (but is maybe not fully validated yet).\n                // Consider the message as delivered for gossip promises.\n                this.score.validateMessage(validationResult.messageId.msgIdStr);\n                this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);\n                // Add the message to our memcache\n                // if no validation is required, mark the message as validated\n                this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);\n                // Dispatch the message to the user if we are subscribed to the topic\n                if (this.subscriptions.has(rpcMsg.topic)) {\n                    const isFromSelf = this.components.peerId.equals(from);\n                    if (!isFromSelf || this.opts.emitSelf) {\n                        super.dispatchEvent(new CustomEvent('gossipsub:message', {\n                            detail: {\n                                propagationSource: from,\n                                msgId: validationResult.messageId.msgIdStr,\n                                msg: validationResult.msg\n                            }\n                        }));\n                        // TODO: Add option to switch between emit per topic or all messages in one\n                        super.dispatchEvent(new CustomEvent('message', { detail: validationResult.msg }));\n                    }\n                }\n                // Forward the message to mesh peers, if no validation is required\n                // If asyncValidation is ON, expect the app layer to call reportMessageValidationResult(), then forward\n                if (!this.opts.asyncValidation) {\n                    // TODO: in rust-libp2p\n                    // .forward_msg(&msg_id, raw_message, Some(propagation_source))\n                    this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from.toString());\n                }\n        }\n    }\n    /**\n     * Handles a newly received message from an RPC.\n     * May forward to all peers in the mesh.\n     */\n    async validateReceivedMessage(propagationSource, rpcMsg) {\n        // Fast message ID stuff\n        const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);\n        const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined;\n        if (msgIdCached) {\n            // This message has been seen previously. Ignore it\n            return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };\n        }\n        // Perform basic validation on message and convert to RawGossipsubMessage for fastMsgIdFn()\n        const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);\n        if (!validationResult.valid) {\n            return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };\n        }\n        const msg = validationResult.message;\n        // Try and perform the data transform to the message. If it fails, consider it invalid.\n        try {\n            if (this.dataTransform) {\n                msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);\n            }\n        }\n        catch (e) {\n            this.log('Invalid message, transform failed', e);\n            return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };\n        }\n        // TODO: Check if message is from a blacklisted source or propagation origin\n        // - Reject any message from a blacklisted peer\n        // - Also reject any message that originated from a blacklisted peer\n        // - reject messages claiming to be from ourselves but not locally published\n        // Calculate the message id on the transformed data.\n        const msgId = await this.msgIdFn(msg);\n        const msgIdStr = this.msgIdToStrFn(msgId);\n        const messageId = { msgId, msgIdStr };\n        // Add the message to the duplicate caches\n        if (fastMsgIdStr !== undefined && this.fastMsgIdCache) {\n            const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);\n            if (collision) {\n                this.metrics?.fastMsgIdCacheCollision.inc();\n            }\n        }\n        if (this.seenCache.has(msgIdStr)) {\n            return { code: MessageStatus.duplicate, msgIdStr };\n        }\n        else {\n            this.seenCache.put(msgIdStr);\n        }\n        // (Optional) Provide custom validation here with dynamic validators per topic\n        // NOTE: This custom topicValidator() must resolve fast (< 100ms) to allow scores\n        // to not penalize peers for long validation times.\n        const topicValidator = this.topicValidators.get(rpcMsg.topic);\n        if (topicValidator != null) {\n            let acceptance;\n            // Use try {} catch {} in case topicValidator() is synchronous\n            try {\n                acceptance = await topicValidator(propagationSource, msg);\n            }\n            catch (e) {\n                const errCode = e.code;\n                if (errCode === constants.ERR_TOPIC_VALIDATOR_IGNORE)\n                    acceptance = TopicValidatorResult.Ignore;\n                if (errCode === constants.ERR_TOPIC_VALIDATOR_REJECT)\n                    acceptance = TopicValidatorResult.Reject;\n                else\n                    acceptance = TopicValidatorResult.Ignore;\n            }\n            if (acceptance !== TopicValidatorResult.Accept) {\n                return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };\n            }\n        }\n        return { code: MessageStatus.valid, messageId, msg };\n    }\n    /**\n     * Return score of a peer.\n     */\n    getScore(peerId) {\n        return this.score.score(peerId);\n    }\n    /**\n     * Send an rpc object to a peer with subscriptions\n     */\n    sendSubscriptions(toPeer, topics, subscribe) {\n        this.sendRpc(toPeer, {\n            subscriptions: topics.map((topic) => ({ topic, subscribe }))\n        });\n    }\n    /**\n     * Handles an rpc control message from a peer\n     */\n    async handleControlMessage(id, controlMsg) {\n        if (controlMsg === undefined) {\n            return;\n        }\n        const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];\n        const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];\n        const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];\n        controlMsg.prune && (await this.handlePrune(id, controlMsg.prune));\n        if (!iwant.length && !ihave.length && !prune.length) {\n            return;\n        }\n        const sent = this.sendRpc(id, { messages: ihave, control: { iwant, prune } });\n        const iwantMessageIds = iwant[0]?.messageIDs;\n        if (iwantMessageIds) {\n            if (sent) {\n                this.gossipTracer.addPromise(id, iwantMessageIds);\n            }\n            else {\n                this.metrics?.iwantPromiseUntracked.inc(1);\n            }\n        }\n    }\n    /**\n     * Whether to accept a message from a peer\n     */\n    acceptFrom(id) {\n        if (this.direct.has(id)) {\n            return true;\n        }\n        const now = Date.now();\n        const entry = this.acceptFromWhitelist.get(id);\n        if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n            entry.messagesAccepted += 1;\n            return true;\n        }\n        const score = this.score.score(id);\n        if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n            // peer is unlikely to be able to drop its score to `graylistThreshold`\n            // after 128 messages or 1s\n            this.acceptFromWhitelist.set(id, {\n                messagesAccepted: 0,\n                acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS\n            });\n        }\n        else {\n            this.acceptFromWhitelist.delete(id);\n        }\n        return score >= this.opts.scoreThresholds.graylistThreshold;\n    }\n    /**\n     * Handles IHAVE messages\n     */\n    handleIHave(id, ihave) {\n        if (!ihave.length) {\n            return [];\n        }\n        // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n        const score = this.score.score(id);\n        if (score < this.opts.scoreThresholds.gossipThreshold) {\n            this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n            this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });\n            return [];\n        }\n        // IHAVE flood protection\n        const peerhave = (this.peerhave.get(id) ?? 0) + 1;\n        this.peerhave.set(id, peerhave);\n        if (peerhave > constants.GossipsubMaxIHaveMessages) {\n            this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n            this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });\n            return [];\n        }\n        const iasked = this.iasked.get(id) ?? 0;\n        if (iasked >= constants.GossipsubMaxIHaveLength) {\n            this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n            this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });\n            return [];\n        }\n        // string msgId => msgId\n        const iwant = new Map();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n                return;\n            }\n            let idonthave = 0;\n            messageIDs.forEach((msgId) => {\n                const msgIdStr = this.msgIdToStrFn(msgId);\n                if (!this.seenCache.has(msgIdStr)) {\n                    iwant.set(msgIdStr, msgId);\n                    idonthave++;\n                }\n            });\n            this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);\n        });\n        if (!iwant.size) {\n            return [];\n        }\n        let iask = iwant.size;\n        if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n            iask = constants.GossipsubMaxIHaveLength - iasked;\n        }\n        this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n        let iwantList = Array.from(iwant.values());\n        // ask in random order\n        shuffle(iwantList);\n        // truncate to the messages we are actually asking for and update the iasked counter\n        iwantList = iwantList.slice(0, iask);\n        this.iasked.set(id, iasked + iask);\n        // do not add gossipTracer promise here until a successful sendRpc()\n        return [\n            {\n                messageIDs: iwantList\n            }\n        ];\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     */\n    handleIWant(id, iwant) {\n        if (!iwant.length) {\n            return [];\n        }\n        // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n        const score = this.score.score(id);\n        if (score < this.opts.scoreThresholds.gossipThreshold) {\n            this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n            return [];\n        }\n        const ihave = new Map();\n        const iwantByTopic = new Map();\n        let iwantDonthave = 0;\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs &&\n                messageIDs.forEach((msgId) => {\n                    const msgIdStr = this.msgIdToStrFn(msgId);\n                    const entry = this.mcache.getWithIWantCount(msgIdStr, id);\n                    if (entry == null) {\n                        iwantDonthave++;\n                        return;\n                    }\n                    iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));\n                    if (entry.count > constants.GossipsubGossipRetransmission) {\n                        this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId);\n                        return;\n                    }\n                    ihave.set(msgIdStr, entry.msg);\n                });\n        });\n        this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);\n        if (!ihave.size) {\n            this.log('IWANT: Could not provide any wanted messages to %s', id);\n            return [];\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n        return Array.from(ihave.values());\n    }\n    /**\n     * Handles Graft messages\n     */\n    async handleGraft(id, graft) {\n        const prune = [];\n        const score = this.score.score(id);\n        const now = Date.now();\n        let doPX = this.opts.doPX;\n        graft.forEach(({ topicID }) => {\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                // don't do PX when there is an unknown topic to avoid leaking our peers\n                doPX = false;\n                // spam hardening: ignore GRAFTs for unknown topics\n                return;\n            }\n            // check if peer is already in the mesh; if so do nothing\n            if (peersInMesh.has(id)) {\n                return;\n            }\n            // we don't GRAFT to/from direct peers; complain loudly if this happens\n            if (this.direct.has(id)) {\n                this.log('GRAFT: ignoring request from direct peer %s', id);\n                // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n                prune.push(topicID);\n                // but don't px\n                doPX = false;\n                return;\n            }\n            // make sure we are not backing off that peer\n            const expire = this.backoff.get(topicID)?.get(id);\n            if (typeof expire === 'number' && now < expire) {\n                this.log('GRAFT: ignoring backed off peer %s', id);\n                // add behavioral penalty\n                this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);\n                // no PX\n                doPX = false;\n                // check the flood cutoff -- is the GRAFT coming too fast?\n                const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;\n                if (now < floodCutoff) {\n                    // extra penalty\n                    this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);\n                }\n                // refresh the backoff\n                this.addBackoff(id, topicID);\n                prune.push(topicID);\n                return;\n            }\n            // check the score\n            if (score < 0) {\n                // we don't GRAFT peers with negative score\n                this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID);\n                // we do send them PRUNE however, because it's a matter of protocol correctness\n                prune.push(topicID);\n                // but we won't PX to them\n                doPX = false;\n                // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n                this.addBackoff(id, topicID);\n                return;\n            }\n            // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n            // from peers with outbound connections; this is a defensive check to restrict potential\n            // mesh takeover attacks combined with love bombing\n            if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {\n                prune.push(topicID);\n                this.addBackoff(id, topicID);\n                return;\n            }\n            this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n            this.score.graft(id, topicID);\n            peersInMesh.add(id);\n            this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);\n        });\n        if (!prune.length) {\n            return [];\n        }\n        const onUnsubscribe = false;\n        return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX, onUnsubscribe)));\n    }\n    /**\n     * Handles Prune messages\n     */\n    async handlePrune(id, prune) {\n        const score = this.score.score(id);\n        for (const { topicID, backoff, peers } of prune) {\n            if (topicID == null) {\n                continue;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                return;\n            }\n            this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n            this.score.prune(id, topicID);\n            if (peersInMesh.has(id)) {\n                peersInMesh.delete(id);\n                this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1);\n            }\n            // is there a backoff specified by the peer? if so obey it\n            if (typeof backoff === 'number' && backoff > 0) {\n                this.doAddBackoff(id, topicID, backoff * 1000);\n            }\n            else {\n                this.addBackoff(id, topicID);\n            }\n            // PX\n            if (peers && peers.length) {\n                // we ignore PX from peers with insufficient scores\n                if (score < this.opts.scoreThresholds.acceptPXThreshold) {\n                    this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n                    continue;\n                }\n                await this.pxConnect(peers);\n            }\n        }\n    }\n    /**\n     * Add standard backoff log for a peer in a topic\n     */\n    addBackoff(id, topic) {\n        this.doAddBackoff(id, topic, this.opts.pruneBackoff);\n    }\n    /**\n     * Add backoff expiry interval for a peer in a topic\n     *\n     * @param id\n     * @param topic\n     * @param intervalMs - backoff duration in milliseconds\n     */\n    doAddBackoff(id, topic, intervalMs) {\n        let backoff = this.backoff.get(topic);\n        if (!backoff) {\n            backoff = new Map();\n            this.backoff.set(topic, backoff);\n        }\n        const expire = Date.now() + intervalMs;\n        const existingExpire = backoff.get(id) ?? 0;\n        if (existingExpire < expire) {\n            backoff.set(id, expire);\n        }\n    }\n    /**\n     * Apply penalties from broken IHAVE/IWANT promises\n     */\n    applyIwantPenalties() {\n        this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n            this.log(\"peer %s didn't follow up in %d IWANT requests; adding penalty\", p, count);\n            this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);\n        });\n    }\n    /**\n     * Clear expired backoff expiries\n     */\n    clearBackoff() {\n        // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n            return;\n        }\n        const now = Date.now();\n        this.backoff.forEach((backoff, topic) => {\n            backoff.forEach((expire, id) => {\n                // add some slack time to the expiration, see https://github.com/libp2p/specs/pull/289\n                if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {\n                    backoff.delete(id);\n                }\n            });\n            if (backoff.size === 0) {\n                this.backoff.delete(topic);\n            }\n        });\n    }\n    /**\n     * Maybe reconnect to direct peers\n     */\n    async directConnect() {\n        const toconnect = [];\n        this.direct.forEach((id) => {\n            if (!this.streamsOutbound.has(id)) {\n                toconnect.push(id);\n            }\n        });\n        await Promise.all(toconnect.map(async (id) => await this.connect(id)));\n    }\n    /**\n     * Maybe attempt connection given signed peer records\n     */\n    async pxConnect(peers) {\n        if (peers.length > this.opts.prunePeers) {\n            shuffle(peers);\n            peers = peers.slice(0, this.opts.prunePeers);\n        }\n        const toconnect = [];\n        await Promise.all(peers.map(async (pi) => {\n            if (!pi.peerID) {\n                return;\n            }\n            const peer = peerIdFromBytes(pi.peerID);\n            const p = peer.toString();\n            if (this.peers.has(p)) {\n                return;\n            }\n            if (!pi.signedPeerRecord) {\n                toconnect.push(p);\n                return;\n            }\n            // The peer sent us a signed record\n            // This is not a record from the peer who sent the record, but another peer who is connected with it\n            // Ensure that it is valid\n            try {\n                if (!(await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer))) {\n                    this.log('bogus peer record obtained through px: could not add peer record to address book');\n                    return;\n                }\n                toconnect.push(p);\n            }\n            catch (e) {\n                this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n            }\n        }));\n        if (!toconnect.length) {\n            return;\n        }\n        await Promise.all(toconnect.map(async (id) => await this.connect(id)));\n    }\n    /**\n     * Connect to a peer using the gossipsub protocol\n     */\n    async connect(id) {\n        this.log('Initiating connection with %s', id);\n        const peerId = peerIdFromString(id);\n        const connection = await this.components.connectionManager.openConnection(peerId);\n        for (const multicodec of this.multicodecs) {\n            for (const topology of this.components.registrar.getTopologies(multicodec)) {\n                topology.onConnect?.(peerId, connection);\n            }\n        }\n    }\n    /**\n     * Subscribes to a topic\n     */\n    subscribe(topic) {\n        if (this.status.code !== GossipStatusCode.started) {\n            throw new Error('Pubsub has not started');\n        }\n        if (!this.subscriptions.has(topic)) {\n            this.subscriptions.add(topic);\n            for (const peerId of this.peers.keys()) {\n                this.sendSubscriptions(peerId, [topic], true);\n            }\n        }\n        this.join(topic);\n    }\n    /**\n     * Unsubscribe to a topic\n     */\n    unsubscribe(topic) {\n        if (this.status.code !== GossipStatusCode.started) {\n            throw new Error('Pubsub is not started');\n        }\n        const wasSubscribed = this.subscriptions.delete(topic);\n        this.log('unsubscribe from %s - am subscribed %s', topic, wasSubscribed);\n        if (wasSubscribed) {\n            for (const peerId of this.peers.keys()) {\n                this.sendSubscriptions(peerId, [topic], false);\n            }\n        }\n        this.leave(topic);\n    }\n    /**\n     * Join topic\n     */\n    join(topic) {\n        if (this.status.code !== GossipStatusCode.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        // if we are already in the mesh, return\n        if (this.mesh.has(topic)) {\n            return;\n        }\n        this.log('JOIN %s', topic);\n        this.metrics?.onJoin(topic);\n        const toAdd = new Set();\n        const backoff = this.backoff.get(topic);\n        // check if we have mesh_n peers in fanout[topic] and add them to the mesh if we do,\n        // removing the fanout entry.\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // Remove fanout entry and the last published time\n            this.fanout.delete(topic);\n            this.fanoutLastpub.delete(topic);\n            // remove explicit peers, peers with negative scores, and backoffed peers\n            fanoutPeers.forEach((id) => {\n                if (!this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id))) {\n                    toAdd.add(id);\n                }\n            });\n            this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);\n        }\n        // check if we need to get more peers, which we randomly select\n        if (toAdd.size < this.opts.D) {\n            const fanoutCount = toAdd.size;\n            const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => \n            // filter direct peers and peers with negative score\n            !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id)));\n            newPeers.forEach((peer) => {\n                toAdd.add(peer);\n            });\n            this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);\n        }\n        this.mesh.set(topic, toAdd);\n        toAdd.forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this.sendGraft(id, topic);\n            // rust-libp2p\n            // - peer_score.graft()\n            // - Self::control_pool_add()\n            // - peer_added_to_mesh()\n        });\n    }\n    /**\n     * Leave topic\n     */\n    leave(topic) {\n        if (this.status.code !== GossipStatusCode.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('LEAVE %s', topic);\n        this.metrics?.onLeave(topic);\n        // Send PRUNE to mesh peers\n        const meshPeers = this.mesh.get(topic);\n        if (meshPeers) {\n            Promise.all(Array.from(meshPeers).map(async (id) => {\n                this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n                return await this.sendPrune(id, topic);\n            })).catch((err) => {\n                this.log('Error sending prunes to mesh peers', err);\n            });\n            this.mesh.delete(topic);\n        }\n    }\n    selectPeersToForward(topic, propagationSource, excludePeers) {\n        const tosend = new Set();\n        // Add explicit peers\n        const peersInTopic = this.topics.get(topic);\n        if (peersInTopic) {\n            this.direct.forEach((peer) => {\n                if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {\n                    tosend.add(peer);\n                }\n            });\n            // As of Mar 2022, spec + golang-libp2p include this while rust-libp2p does not\n            // rust-libp2p: https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/protocols/gossipsub/src/behaviour.rs#L2693\n            // spec: https://github.com/libp2p/specs/blob/10712c55ab309086a52eec7d25f294df4fa96528/pubsub/gossipsub/gossipsub-v1.0.md?plain=1#L361\n            this.floodsubPeers.forEach((peer) => {\n                if (peersInTopic.has(peer) &&\n                    propagationSource !== peer &&\n                    !excludePeers?.has(peer) &&\n                    this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {\n                    tosend.add(peer);\n                }\n            });\n        }\n        // add mesh peers\n        const meshPeers = this.mesh.get(topic);\n        if (meshPeers && meshPeers.size > 0) {\n            meshPeers.forEach((peer) => {\n                if (propagationSource !== peer && !excludePeers?.has(peer)) {\n                    tosend.add(peer);\n                }\n            });\n        }\n        return tosend;\n    }\n    selectPeersToPublish(topic) {\n        const tosend = new Set();\n        const tosendCount = {\n            direct: 0,\n            floodsub: 0,\n            mesh: 0,\n            fanout: 0\n        };\n        const peersInTopic = this.topics.get(topic);\n        if (peersInTopic) {\n            // flood-publish behavior\n            // send to direct peers and _all_ peers meeting the publishThreshold\n            if (this.opts.floodPublish) {\n                peersInTopic.forEach((id) => {\n                    if (this.direct.has(id)) {\n                        tosend.add(id);\n                        tosendCount.direct++;\n                    }\n                    else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n                        tosend.add(id);\n                        tosendCount.floodsub++;\n                    }\n                });\n            }\n            else {\n                // non-flood-publish behavior\n                // send to direct peers, subscribed floodsub peers\n                // and some mesh peers above publishThreshold\n                // direct peers (if subscribed)\n                this.direct.forEach((id) => {\n                    if (peersInTopic.has(id)) {\n                        tosend.add(id);\n                        tosendCount.direct++;\n                    }\n                });\n                // floodsub peers\n                // Note: if there are no floodsub peers, we save a loop through peersInTopic Map\n                this.floodsubPeers.forEach((id) => {\n                    if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n                        tosend.add(id);\n                        tosendCount.floodsub++;\n                    }\n                });\n                // Gossipsub peers handling\n                const meshPeers = this.mesh.get(topic);\n                if (meshPeers && meshPeers.size > 0) {\n                    meshPeers.forEach((peer) => {\n                        tosend.add(peer);\n                        tosendCount.mesh++;\n                    });\n                }\n                // We are not in the mesh for topic, use fanout peers\n                else {\n                    const fanoutPeers = this.fanout.get(topic);\n                    if (fanoutPeers && fanoutPeers.size > 0) {\n                        fanoutPeers.forEach((peer) => {\n                            tosend.add(peer);\n                            tosendCount.fanout++;\n                        });\n                    }\n                    // We have no fanout peers, select mesh_n of them and add them to the fanout\n                    else {\n                        // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                        const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {\n                            return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;\n                        });\n                        if (newFanoutPeers.size > 0) {\n                            // eslint-disable-line max-depth\n                            this.fanout.set(topic, newFanoutPeers);\n                            newFanoutPeers.forEach((peer) => {\n                                // eslint-disable-line max-depth\n                                tosend.add(peer);\n                                tosendCount.fanout++;\n                            });\n                        }\n                    }\n                    // We are publishing to fanout peers - update the time we published\n                    this.fanoutLastpub.set(topic, Date.now());\n                }\n            }\n        }\n        return { tosend, tosendCount };\n    }\n    /**\n     * Forwards a message from our peers.\n     *\n     * For messages published by us (the app layer), this class uses `publish`\n     */\n    forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {\n        // message is fully validated inform peer_score\n        if (propagationSource) {\n            this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);\n        }\n        const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);\n        // Note: Don't throw if tosend is empty, we can have a mesh with a single peer\n        // forward the message to peers\n        tosend.forEach((id) => {\n            // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n            this.sendRpc(id, { messages: [rawMsg] });\n        });\n        this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);\n    }\n    /**\n     * App layer publishes a message to peers, return number of peers this message is published to\n     * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.\n     *\n     * For messages not from us, this class uses `forwardMessage`.\n     */\n    async publish(topic, data, opts) {\n        const startMs = Date.now();\n        const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;\n        if (this.publishConfig == null) {\n            throw Error('PublishError.Uninitialized');\n        }\n        // Prepare raw message with user's publishConfig\n        const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);\n        // calculate the message id from the un-transformed data\n        const msgId = await this.msgIdFn(msg);\n        const msgIdStr = this.msgIdToStrFn(msgId);\n        // Current publish opt takes precedence global opts, while preserving false value\n        const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError;\n        if (this.seenCache.has(msgIdStr)) {\n            // This message has already been seen. We don't re-publish messages that have already\n            // been published on the network.\n            if (ignoreDuplicatePublishError) {\n                this.metrics?.onPublishDuplicateMsg(topic);\n                return { recipients: [] };\n            }\n            throw Error('PublishError.Duplicate');\n        }\n        const { tosend, tosendCount } = this.selectPeersToPublish(topic);\n        const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);\n        // Current publish opt takes precedence global opts, while preserving false value\n        const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers;\n        if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {\n            throw Error('PublishError.InsufficientPeers');\n        }\n        // If the message isn't a duplicate and we have sent it to some peers add it to the\n        // duplicate cache and memcache.\n        this.seenCache.put(msgIdStr);\n        // all published messages are valid\n        this.mcache.put({ msgId, msgIdStr }, rawMsg, true);\n        // If the message is anonymous or has a random author add it to the published message ids cache.\n        this.publishedMessageIds.put(msgIdStr);\n        // Send to set of peers aggregated from direct, mesh, fanout\n        for (const id of tosend) {\n            // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n            const sent = this.sendRpc(id, { messages: [rawMsg] });\n            // did not actually send the message\n            if (!sent) {\n                tosend.delete(id);\n            }\n        }\n        const durationMs = Date.now() - startMs;\n        this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0, durationMs);\n        // Dispatch the message to the user if we are subscribed to the topic\n        if (willSendToSelf) {\n            tosend.add(this.components.peerId.toString());\n            super.dispatchEvent(new CustomEvent('gossipsub:message', {\n                detail: {\n                    propagationSource: this.components.peerId,\n                    msgId: msgIdStr,\n                    msg\n                }\n            }));\n            // TODO: Add option to switch between emit per topic or all messages in one\n            super.dispatchEvent(new CustomEvent('message', { detail: msg }));\n        }\n        return {\n            recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))\n        };\n    }\n    /**\n     * This function should be called when `asyncValidation` is `true` after\n     * the message got validated by the caller. Messages are stored in the `mcache` and\n     * validation is expected to be fast enough that the messages should still exist in the cache.\n     * There are three possible validation outcomes and the outcome is given in acceptance.\n     *\n     * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the\n     * network. The `propagation_source` parameter indicates who the message was received by and\n     * will not be forwarded back to that peer.\n     *\n     * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache\n     * and the P penalty will be applied to the `propagationSource`.\n     *\n     * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache\n     * but no P penalty will be applied.\n     *\n     * This function will return true if the message was found in the cache and false if was not\n     * in the cache anymore.\n     *\n     * This should only be called once per message.\n     */\n    reportMessageValidationResult(msgId, propagationSource, acceptance) {\n        let cacheEntry;\n        if (acceptance === TopicValidatorResult.Accept) {\n            cacheEntry = this.mcache.validate(msgId);\n            if (cacheEntry != null) {\n                const { message: rawMsg, originatingPeers } = cacheEntry;\n                // message is fully validated inform peer_score\n                this.score.deliverMessage(propagationSource, msgId, rawMsg.topic);\n                this.forwardMessage(msgId, cacheEntry.message, propagationSource, originatingPeers);\n            }\n            // else, Message not in cache. Ignoring forwarding\n        }\n        // Not valid\n        else {\n            cacheEntry = this.mcache.remove(msgId);\n            if (cacheEntry) {\n                const rejectReason = rejectReasonFromAcceptance(acceptance);\n                const { message: rawMsg, originatingPeers } = cacheEntry;\n                // Tell peer_score about reject\n                // Reject the original source, and any duplicates we've seen from other peers.\n                this.score.rejectMessage(propagationSource, msgId, rawMsg.topic, rejectReason);\n                for (const peer of originatingPeers) {\n                    this.score.rejectMessage(peer, msgId, rawMsg.topic, rejectReason);\n                }\n            }\n            // else, Message not in cache. Ignoring forwarding\n        }\n        const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId);\n        this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs);\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     */\n    sendGraft(id, topic) {\n        const graft = [\n            {\n                topicID: topic\n            }\n        ];\n        this.sendRpc(id, { control: { graft } });\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     */\n    async sendPrune(id, topic) {\n        // this is only called from leave() function\n        const onUnsubscribe = true;\n        const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)];\n        this.sendRpc(id, { control: { prune } });\n    }\n    /**\n     * Send an rpc object to a peer\n     */\n    sendRpc(id, rpc) {\n        const outboundStream = this.streamsOutbound.get(id);\n        if (!outboundStream) {\n            this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);\n            return false;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(id);\n        if (ctrl) {\n            this.piggybackControl(id, rpc, ctrl);\n            this.control.delete(id);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(id);\n        if (ihave) {\n            this.piggybackGossip(id, rpc, ihave);\n            this.gossip.delete(id);\n        }\n        const rpcBytes = RPC.encode(rpc).finish();\n        try {\n            outboundStream.push(rpcBytes);\n        }\n        catch (e) {\n            this.log.error(`Cannot send rpc to ${id}`, e);\n            // if the peer had control messages or gossip, re-attach\n            if (ctrl) {\n                this.control.set(id, ctrl);\n            }\n            if (ihave) {\n                this.gossip.set(id, ihave);\n            }\n            return false;\n        }\n        this.metrics?.onRpcSent(rpc, rpcBytes.length);\n        return true;\n    }\n    /** Mutates `outRpc` adding graft and prune control messages */\n    piggybackControl(id, outRpc, ctrl) {\n        if (ctrl.graft) {\n            if (!outRpc.control)\n                outRpc.control = {};\n            if (!outRpc.control.graft)\n                outRpc.control.graft = [];\n            for (const graft of ctrl.graft) {\n                if (graft.topicID && this.mesh.get(graft.topicID)?.has(id)) {\n                    outRpc.control.graft.push(graft);\n                }\n            }\n        }\n        if (ctrl.prune) {\n            if (!outRpc.control)\n                outRpc.control = {};\n            if (!outRpc.control.prune)\n                outRpc.control.prune = [];\n            for (const prune of ctrl.prune) {\n                if (prune.topicID && !this.mesh.get(prune.topicID)?.has(id)) {\n                    outRpc.control.prune.push(prune);\n                }\n            }\n        }\n    }\n    /** Mutates `outRpc` adding ihave control messages */\n    piggybackGossip(id, outRpc, ihave) {\n        if (!outRpc.control)\n            outRpc.control = {};\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     *\n     * @param tograft - peer id => topic[]\n     * @param toprune - peer id => topic[]\n     */\n    async sendGraftPrune(tograft, toprune, noPX) {\n        const doPX = this.opts.doPX;\n        const onUnsubscribe = false;\n        for (const [id, topics] of tograft) {\n            const graft = topics.map((topicID) => ({ topicID }));\n            let prune = [];\n            // If a peer also has prunes, process them now\n            const pruning = toprune.get(id);\n            if (pruning) {\n                prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));\n                toprune.delete(id);\n            }\n            this.sendRpc(id, { control: { graft, prune } });\n        }\n        for (const [id, topics] of toprune) {\n            const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));\n            this.sendRpc(id, { control: { prune } });\n        }\n    }\n    /**\n     * Emits gossip - Send IHAVE messages to a random set of gossip peers\n     */\n    emitGossip(peersToGossipByTopic) {\n        const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));\n        for (const [topic, peersToGossip] of peersToGossipByTopic) {\n            this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);\n        }\n    }\n    /**\n     * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy\n     * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers\n     * We also exclude direct peers, as there is no reason to emit gossip to them\n     * @param topic\n     * @param candidateToGossip - peers to gossip\n     * @param messageIDs - message ids to gossip\n     */\n    doEmitGossip(topic, candidateToGossip, messageIDs) {\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        if (!candidateToGossip.size)\n            return;\n        let target = this.opts.Dlazy;\n        const factor = constants.GossipsubGossipFactor * candidateToGossip.size;\n        let peersToGossip = candidateToGossip;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.size) {\n            target = peersToGossip.size;\n        }\n        else {\n            // only shuffle if needed\n            peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.forEach((id) => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough reduncancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n            }\n            this.pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs\n            });\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            this.sendRpc(peer, { control: { ihave } });\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } });\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     */\n    pushGossip(id, controlIHaveMsgs) {\n        this.log('Add gossip to %s', id);\n        const gossip = this.gossip.get(id) || [];\n        this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic\n     */\n    async makePrune(id, topic, doPX, onUnsubscribe) {\n        this.score.prune(id, topic);\n        if (this.streamsOutbound.get(id).protocol === constants.GossipsubIDv10) {\n            // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n            return {\n                topicID: topic,\n                peers: []\n            };\n        }\n        // backoff is measured in seconds\n        // GossipsubPruneBackoff and GossipsubUnsubscribeBackoff are measured in milliseconds\n        // The protobuf has it as a uint64\n        const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff;\n        const backoff = backoffMs / 1000;\n        this.doAddBackoff(id, topic, backoffMs);\n        if (!doPX) {\n            return {\n                topicID: topic,\n                peers: [],\n                backoff: backoff\n            };\n        }\n        // select peers for Peer eXchange\n        const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {\n            return xid !== id && this.score.score(xid) >= 0;\n        });\n        const px = await Promise.all(Array.from(peers).map(async (peerId) => {\n            // see if we have a signed record to send back; if we don't, just send\n            // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n            // unsigned address records through PX anyways\n            // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n            const id = peerIdFromString(peerId);\n            let peerInfo;\n            try {\n                peerInfo = await this.components.peerStore.get(id);\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n            return {\n                peerID: id.toBytes(),\n                signedPeerRecord: peerInfo?.peerRecordEnvelope\n            };\n        }));\n        return {\n            topicID: topic,\n            peers: px,\n            backoff: backoff\n        };\n    }\n    runHeartbeat = () => {\n        const timer = this.metrics?.heartbeatDuration.startTimer();\n        this.heartbeat()\n            .catch((err) => {\n            this.log('Error running heartbeat', err);\n        })\n            .finally(() => {\n            if (timer != null) {\n                timer();\n            }\n            // Schedule the next run if still in started status\n            if (this.status.code === GossipStatusCode.started) {\n                // Clear previous timeout before overwriting `status.heartbeatTimeout`, it should be completed tho.\n                clearTimeout(this.status.heartbeatTimeout);\n                // NodeJS setInterval function is innexact, calls drift by a few miliseconds on each call.\n                // To run the heartbeat precisely setTimeout() must be used recomputing the delay on every loop.\n                let msToNextHeartbeat = this.opts.heartbeatInterval - ((Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval);\n                // If too close to next heartbeat, skip one\n                if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {\n                    msToNextHeartbeat += this.opts.heartbeatInterval;\n                    this.metrics?.heartbeatSkipped.inc();\n                }\n                this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);\n            }\n        });\n    };\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     */\n    async heartbeat() {\n        const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;\n        this.heartbeatTicks++;\n        // cache scores throught the heartbeat\n        const scores = new Map();\n        const getScore = (id) => {\n            let s = scores.get(id);\n            if (s === undefined) {\n                s = this.score.score(id);\n                scores.set(id, s);\n            }\n            return s;\n        };\n        // peer id => topic[]\n        const tograft = new Map();\n        // peer id => topic[]\n        const toprune = new Map();\n        // peer id => don't px\n        const noPX = new Map();\n        // clean up expired backoffs\n        this.clearBackoff();\n        // clean up peerhave/iasked counters\n        this.peerhave.clear();\n        this.metrics?.cacheSize.set({ cache: 'iasked' }, this.iasked.size);\n        this.iasked.clear();\n        // apply IWANT request penalties\n        this.applyIwantPenalties();\n        // ensure direct peers are connected\n        if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {\n            // we only do this every few ticks to allow pending connections to complete and account for restarts/downtime\n            await this.directConnect();\n        }\n        // EXTRA: Prune caches\n        this.fastMsgIdCache?.prune();\n        this.seenCache.prune();\n        this.gossipTracer.prune();\n        this.publishedMessageIds.prune();\n        /**\n         * Instead of calling getRandomGossipPeers multiple times to:\n         *   + get more mesh peers\n         *   + more outbound peers\n         *   + oppportunistic grafting\n         *   + emitGossip\n         *\n         * We want to loop through the topic peers only a single time and prepare gossip peers for all topics to improve the performance\n         */\n        const peersToGossipByTopic = new Map();\n        // maintain the mesh for topics we have joined\n        this.mesh.forEach((peers, topic) => {\n            const peersInTopic = this.topics.get(topic);\n            const candidateMeshPeers = new Set();\n            const peersToGossip = new Set();\n            peersToGossipByTopic.set(topic, peersToGossip);\n            if (peersInTopic) {\n                const shuffledPeers = shuffle(Array.from(peersInTopic));\n                const backoff = this.backoff.get(topic);\n                for (const id of shuffledPeers) {\n                    const peerStreams = this.streamsOutbound.get(id);\n                    if (peerStreams &&\n                        this.multicodecs.includes(peerStreams.protocol) &&\n                        !peers.has(id) &&\n                        !this.direct.has(id)) {\n                        const score = getScore(id);\n                        if ((!backoff || !backoff.has(id)) && score >= 0)\n                            candidateMeshPeers.add(id);\n                        // instead of having to find gossip peers after heartbeat which require another loop\n                        // we prepare peers to gossip in a topic within heartbeat to improve performance\n                        if (score >= this.opts.scoreThresholds.gossipThreshold)\n                            peersToGossip.add(id);\n                    }\n                }\n            }\n            // prune/graft helper functions (defined per topic)\n            const prunePeer = (id, reason) => {\n                this.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);\n                // no need to update peer score here as we do it in makePrune\n                // add prune backoff record\n                this.addBackoff(id, topic);\n                // remove peer from mesh\n                peers.delete(id);\n                // after pruning a peer from mesh, we want to gossip topic to it if its score meet the gossip threshold\n                if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)\n                    peersToGossip.add(id);\n                this.metrics?.onRemoveFromMesh(topic, reason, 1);\n                // add to toprune\n                const topics = toprune.get(id);\n                if (!topics) {\n                    toprune.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            const graftPeer = (id, reason) => {\n                this.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);\n                // update peer score\n                this.score.graft(id, topic);\n                // add peer to mesh\n                peers.add(id);\n                // when we add a new mesh peer, we don't want to gossip messages to it\n                peersToGossip.delete(id);\n                this.metrics?.onAddToMesh(topic, reason, 1);\n                // add to tograft\n                const topics = tograft.get(id);\n                if (!topics) {\n                    tograft.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            // drop all peers with negative score, without PX\n            peers.forEach((id) => {\n                const score = getScore(id);\n                // Record the score\n                if (score < 0) {\n                    this.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n                    prunePeer(id, ChurnReason.BadScore);\n                    noPX.set(id, true);\n                }\n            });\n            // do we have enough peers?\n            if (peers.size < Dlo) {\n                const ineed = D - peers.size;\n                // slice up to first `ineed` items and remove them from candidateMeshPeers\n                // same to `const newMeshPeers = candidateMeshPeers.slice(0, ineed)`\n                const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);\n                newMeshPeers.forEach((p) => {\n                    graftPeer(p, InclusionReason.NotEnough);\n                });\n            }\n            // do we have to many peers?\n            if (peers.size > Dhi) {\n                let peersArray = Array.from(peers);\n                // sort by score\n                peersArray.sort((a, b) => getScore(b) - getScore(a));\n                // We keep the first D_score peers by score and the remaining up to D randomly\n                // under the constraint that we keep D_out peers in the mesh (if we have that many)\n                peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));\n                // count the outbound peers we are keeping\n                let outbound = 0;\n                peersArray.slice(0, D).forEach((p) => {\n                    if (this.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, bubble up some outbound peers from the random selection\n                if (outbound < Dout) {\n                    const rotate = (i) => {\n                        // rotate the peersArray to the right and put the ith peer in the front\n                        const p = peersArray[i];\n                        for (let j = i; j > 0; j--) {\n                            peersArray[j] = peersArray[j - 1];\n                        }\n                        peersArray[0] = p;\n                    };\n                    // first bubble up all outbound peers already in the selection to the front\n                    if (outbound > 0) {\n                        let ihave = outbound;\n                        for (let i = 1; i < D && ihave > 0; i++) {\n                            if (this.outbound.get(peersArray[i])) {\n                                rotate(i);\n                                ihave--;\n                            }\n                        }\n                    }\n                    // now bubble up enough outbound peers outside the selection to the front\n                    let ineed = D - outbound;\n                    for (let i = D; i < peersArray.length && ineed > 0; i++) {\n                        if (this.outbound.get(peersArray[i])) {\n                            rotate(i);\n                            ineed--;\n                        }\n                    }\n                }\n                // prune the excess peers\n                peersArray.slice(D).forEach((p) => {\n                    prunePeer(p, ChurnReason.Excess);\n                });\n            }\n            // do we have enough outbound peers?\n            if (peers.size >= Dlo) {\n                // count the outbound peers we have\n                let outbound = 0;\n                peers.forEach((p) => {\n                    if (this.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, select some peers with outbound connections and graft them\n                if (outbound < Dout) {\n                    const ineed = Dout - outbound;\n                    const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);\n                    newMeshPeers.forEach((p) => {\n                        graftPeer(p, InclusionReason.Outbound);\n                    });\n                }\n            }\n            // should we try to improve the mesh with opportunistic grafting?\n            if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {\n                // Opportunistic grafting works as follows: we check the median score of peers in the\n                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n                // random with score over the median.\n                // The intention is to (slowly) improve an underperforming mesh by introducing good\n                // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n                // situations where we are stuck with poor peers and also recover from churn of good peers.\n                // now compute the median peer score in the mesh\n                const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));\n                const medianIndex = Math.floor(peers.size / 2);\n                const medianScore = getScore(peersList[medianIndex]);\n                // if the median score is below the threshold, select a better peer (if any) and GRAFT\n                if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {\n                    const ineed = this.opts.opportunisticGraftPeers;\n                    const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);\n                    for (const id of newMeshPeers) {\n                        this.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n                        graftPeer(id, InclusionReason.Opportunistic);\n                    }\n                }\n            }\n        });\n        // expire fanout for topics we haven't published to in a while\n        const now = Date.now();\n        this.fanoutLastpub.forEach((lastpb, topic) => {\n            if (lastpb + fanoutTTL < now) {\n                this.fanout.delete(topic);\n                this.fanoutLastpub.delete(topic);\n            }\n        });\n        // maintain our fanout for topics we are publishing but we have not joined\n        this.fanout.forEach((fanoutPeers, topic) => {\n            // checks whether our peers are still in the topic and have a score above the publish threshold\n            const topicPeers = this.topics.get(topic);\n            fanoutPeers.forEach((id) => {\n                if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            const peersInTopic = this.topics.get(topic);\n            const candidateFanoutPeers = [];\n            // the fanout map contains topics to which we are not subscribed.\n            const peersToGossip = new Set();\n            peersToGossipByTopic.set(topic, peersToGossip);\n            if (peersInTopic) {\n                const shuffledPeers = shuffle(Array.from(peersInTopic));\n                for (const id of shuffledPeers) {\n                    const peerStreams = this.streamsOutbound.get(id);\n                    if (peerStreams &&\n                        this.multicodecs.includes(peerStreams.protocol) &&\n                        !fanoutPeers.has(id) &&\n                        !this.direct.has(id)) {\n                        const score = getScore(id);\n                        if (score >= this.opts.scoreThresholds.publishThreshold)\n                            candidateFanoutPeers.push(id);\n                        // instead of having to find gossip peers after heartbeat which require another loop\n                        // we prepare peers to gossip in a topic within heartbeat to improve performance\n                        if (score >= this.opts.scoreThresholds.gossipThreshold)\n                            peersToGossip.add(id);\n                    }\n                }\n            }\n            // do we need more peers?\n            if (fanoutPeers.size < D) {\n                const ineed = D - fanoutPeers.size;\n                candidateFanoutPeers.slice(0, ineed).forEach((id) => {\n                    fanoutPeers.add(id);\n                    peersToGossip?.delete(id);\n                });\n            }\n        });\n        this.emitGossip(peersToGossipByTopic);\n        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n        await this.sendGraftPrune(tograft, toprune, noPX);\n        // flush pending gossip that wasn't piggybacked above\n        this.flush();\n        // advance the message history window\n        this.mcache.shift();\n        this.dispatchEvent(new CustomEvent('gossipsub:heartbeat'));\n    }\n    /**\n     * Given a topic, returns up to count peers subscribed to that topic\n     * that pass an optional filter function\n     *\n     * @param topic\n     * @param count\n     * @param filter - a function to filter acceptable peers\n     */\n    getRandomGossipPeers(topic, count, filter = () => true) {\n        const peersInTopic = this.topics.get(topic);\n        if (!peersInTopic) {\n            return new Set();\n        }\n        // Adds all peers using our protocol\n        // that also pass the filter function\n        let peers = [];\n        peersInTopic.forEach((id) => {\n            const peerStreams = this.streamsOutbound.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (this.multicodecs.includes(peerStreams.protocol) && filter(id)) {\n                peers.push(id);\n            }\n        });\n        // Pseudo-randomly shuffles peers\n        peers = shuffle(peers);\n        if (count > 0 && peers.length > count) {\n            peers = peers.slice(0, count);\n        }\n        return new Set(peers);\n    }\n    onScrapeMetrics(metrics) {\n        /* Data structure sizes */\n        metrics.mcacheSize.set(this.mcache.size);\n        metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);\n        // Arbitrary size\n        metrics.cacheSize.set({ cache: 'direct' }, this.direct.size);\n        metrics.cacheSize.set({ cache: 'seenCache' }, this.seenCache.size);\n        metrics.cacheSize.set({ cache: 'fastMsgIdCache' }, this.fastMsgIdCache?.size ?? 0);\n        metrics.cacheSize.set({ cache: 'publishedMessageIds' }, this.publishedMessageIds.size);\n        metrics.cacheSize.set({ cache: 'mcache' }, this.mcache.size);\n        metrics.cacheSize.set({ cache: 'score' }, this.score.size);\n        metrics.cacheSize.set({ cache: 'gossipTracer.promises' }, this.gossipTracer.size);\n        metrics.cacheSize.set({ cache: 'gossipTracer.requests' }, this.gossipTracer.requestMsByMsgSize);\n        // Bounded by topic\n        metrics.cacheSize.set({ cache: 'topics' }, this.topics.size);\n        metrics.cacheSize.set({ cache: 'subscriptions' }, this.subscriptions.size);\n        metrics.cacheSize.set({ cache: 'mesh' }, this.mesh.size);\n        metrics.cacheSize.set({ cache: 'fanout' }, this.fanout.size);\n        // Bounded by peer\n        metrics.cacheSize.set({ cache: 'peers' }, this.peers.size);\n        metrics.cacheSize.set({ cache: 'streamsOutbound' }, this.streamsOutbound.size);\n        metrics.cacheSize.set({ cache: 'streamsInbound' }, this.streamsInbound.size);\n        metrics.cacheSize.set({ cache: 'acceptFromWhitelist' }, this.acceptFromWhitelist.size);\n        metrics.cacheSize.set({ cache: 'gossip' }, this.gossip.size);\n        metrics.cacheSize.set({ cache: 'control' }, this.control.size);\n        metrics.cacheSize.set({ cache: 'peerhave' }, this.peerhave.size);\n        metrics.cacheSize.set({ cache: 'outbound' }, this.outbound.size);\n        // 2D nested data structure\n        let backoffSize = 0;\n        const now = Date.now();\n        metrics.connectedPeersBackoffSec.reset();\n        for (const backoff of this.backoff.values()) {\n            backoffSize += backoff.size;\n            for (const [peer, expiredMs] of backoff.entries()) {\n                if (this.peers.has(peer)) {\n                    metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1000);\n                }\n            }\n        }\n        metrics.cacheSize.set({ cache: 'backoff' }, backoffSize);\n        // Peer counts\n        for (const [topicStr, peers] of this.topics) {\n            metrics.topicPeersCount.set({ topicStr }, peers.size);\n        }\n        for (const [topicStr, peers] of this.mesh) {\n            metrics.meshPeerCounts.set({ topicStr }, peers.size);\n        }\n        // Peer scores\n        const scores = [];\n        const scoreByPeer = new Map();\n        metrics.behaviourPenalty.reset();\n        for (const peerIdStr of this.peers.keys()) {\n            const score = this.score.score(peerIdStr);\n            scores.push(score);\n            scoreByPeer.set(peerIdStr, score);\n            metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);\n        }\n        metrics.registerScores(scores, this.opts.scoreThresholds);\n        // Breakdown score per mesh topicLabel\n        metrics.registerScorePerMesh(this.mesh, scoreByPeer);\n        // Breakdown on each score weight\n        const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);\n        metrics.registerScoreWeights(sw);\n    }\n}\nexport function gossipsub(init = {}) {\n    return (components) => new GossipSub(components, init);\n}\n//# sourceMappingURL=index.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","export var MessageTypes;\n(function (MessageTypes) {\n    MessageTypes[MessageTypes[\"NEW_STREAM\"] = 0] = \"NEW_STREAM\";\n    MessageTypes[MessageTypes[\"MESSAGE_RECEIVER\"] = 1] = \"MESSAGE_RECEIVER\";\n    MessageTypes[MessageTypes[\"MESSAGE_INITIATOR\"] = 2] = \"MESSAGE_INITIATOR\";\n    MessageTypes[MessageTypes[\"CLOSE_RECEIVER\"] = 3] = \"CLOSE_RECEIVER\";\n    MessageTypes[MessageTypes[\"CLOSE_INITIATOR\"] = 4] = \"CLOSE_INITIATOR\";\n    MessageTypes[MessageTypes[\"RESET_RECEIVER\"] = 5] = \"RESET_RECEIVER\";\n    MessageTypes[MessageTypes[\"RESET_INITIATOR\"] = 6] = \"RESET_INITIATOR\";\n})(MessageTypes || (MessageTypes = {}));\nexport const MessageTypeNames = Object.freeze({\n    0: 'NEW_STREAM',\n    1: 'MESSAGE_RECEIVER',\n    2: 'MESSAGE_INITIATOR',\n    3: 'CLOSE_RECEIVER',\n    4: 'CLOSE_INITIATOR',\n    5: 'RESET_RECEIVER',\n    6: 'RESET_INITIATOR'\n});\nexport const InitiatorMessageTypes = Object.freeze({\n    NEW_STREAM: MessageTypes.NEW_STREAM,\n    MESSAGE: MessageTypes.MESSAGE_INITIATOR,\n    CLOSE: MessageTypes.CLOSE_INITIATOR,\n    RESET: MessageTypes.RESET_INITIATOR\n});\nexport const ReceiverMessageTypes = Object.freeze({\n    MESSAGE: MessageTypes.MESSAGE_RECEIVER,\n    CLOSE: MessageTypes.CLOSE_RECEIVER,\n    RESET: MessageTypes.RESET_RECEIVER\n});\n//# sourceMappingURL=message-types.js.map","import defer from 'p-defer';\nimport { Uint8ArrayList } from 'uint8arraylist';\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nconst DEFAULT_BATCH_SIZE = 1024 * 1024;\nconst DEFAULT_SERIALIZE = (buf, list) => { list.append(buf); };\nfunction batchedBytes(source, options) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            let buffer = new Uint8ArrayList();\n            let ended = false;\n            let deferred = defer();\n            let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);\n            if (isNaN(size) || size === 0 || size < 0) {\n                size = DEFAULT_BATCH_SIZE;\n            }\n            if (size !== Math.round(size)) {\n                throw new Error('Batch size must be an integer');\n            }\n            const yieldAfter = options?.yieldAfter ?? 0;\n            const serialize = options?.serialize ?? DEFAULT_SERIALIZE;\n            void Promise.resolve().then(async () => {\n                try {\n                    let timeout;\n                    for await (const buf of source) {\n                        // @ts-expect-error - if buf is not `Uint8Array | Uint8ArrayList` we cannot use the default serializer\n                        serialize(buf, buffer);\n                        if (buffer.byteLength >= size) {\n                            clearTimeout(timeout);\n                            deferred.resolve();\n                            continue;\n                        }\n                        timeout = setTimeout(() => {\n                            deferred.resolve();\n                        }, yieldAfter);\n                    }\n                    clearTimeout(timeout);\n                    deferred.resolve();\n                }\n                catch (err) {\n                    deferred.reject(err);\n                }\n                finally {\n                    ended = true;\n                }\n            });\n            while (!ended) { // eslint-disable-line no-unmodified-loop-condition\n                await deferred.promise;\n                deferred = defer();\n                if (buffer.byteLength > 0) {\n                    const b = buffer;\n                    buffer = new Uint8ArrayList();\n                    yield b.subarray();\n                }\n            }\n        })();\n    }\n    return (function* () {\n        const buffer = new Uint8ArrayList();\n        let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);\n        if (isNaN(size) || size === 0 || size < 0) {\n            size = DEFAULT_BATCH_SIZE;\n        }\n        if (size !== Math.round(size)) {\n            throw new Error('Batch size must be an integer');\n        }\n        const serialize = options?.serialize ?? DEFAULT_SERIALIZE;\n        for (const buf of source) {\n            // @ts-expect-error - if buf is not `Uint8Array | Uint8ArrayList` we cannot use the default serializer\n            serialize(buf, buffer);\n            if (buffer.byteLength >= size) {\n                yield buffer.subarray(0, size);\n                buffer.consume(size);\n            }\n        }\n        if (buffer.byteLength > 0) {\n            yield buffer.subarray();\n        }\n    })();\n}\nexport default batchedBytes;\n//# sourceMappingURL=index.js.map","import batchedBytes from 'it-batched-bytes';\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { allocUnsafe } from './alloc-unsafe.js';\nimport { MessageTypes } from './message-types.js';\nconst POOL_SIZE = 10 * 1024;\nclass Encoder {\n    _pool;\n    _poolOffset;\n    constructor() {\n        this._pool = allocUnsafe(POOL_SIZE);\n        this._poolOffset = 0;\n    }\n    /**\n     * Encodes the given message and adds it to the passed list\n     */\n    write(msg, list) {\n        const pool = this._pool;\n        let offset = this._poolOffset;\n        varint.encode(msg.id << 3 | msg.type, pool, offset);\n        offset += varint.encodingLength(msg.id << 3 | msg.type);\n        if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n            varint.encode(msg.data.length, pool, offset);\n            offset += varint.encodingLength(msg.data.length);\n        }\n        else {\n            varint.encode(0, pool, offset);\n            offset += varint.encodingLength(0);\n        }\n        const header = pool.subarray(this._poolOffset, offset);\n        if (POOL_SIZE - offset < 100) {\n            this._pool = allocUnsafe(POOL_SIZE);\n            this._poolOffset = 0;\n        }\n        else {\n            this._poolOffset = offset;\n        }\n        list.append(header);\n        if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n            list.append(msg.data);\n        }\n    }\n}\nconst encoder = new Encoder();\n/**\n * Encode and yield one or more messages\n */\nexport async function* encode(source, minSendBytes = 0) {\n    if (minSendBytes == null || minSendBytes === 0) {\n        // just send the messages\n        for await (const messages of source) {\n            const list = new Uint8ArrayList();\n            for (const msg of messages) {\n                encoder.write(msg, list);\n            }\n            yield list.subarray();\n        }\n        return;\n    }\n    // batch messages up for sending\n    yield* batchedBytes(source, {\n        size: minSendBytes,\n        serialize: (obj, list) => {\n            for (const m of obj) {\n                encoder.write(m, list);\n            }\n        }\n    });\n}\n//# sourceMappingURL=encode.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { abortableSource } from 'abortable-iterator';\nimport { pipe } from 'it-pipe';\nimport { pushableV } from 'it-pushable';\nimport { RateLimiterMemory } from 'rate-limiter-flexible';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { Decoder } from './decode.js';\nimport { encode } from './encode.js';\nimport { MessageTypes, MessageTypeNames } from './message-types.js';\nimport { createStream } from './stream.js';\nconst log = logger('libp2p:mplex');\nconst MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4; // 4MB\nconst DISCONNECT_THRESHOLD = 5;\nconst CLOSE_TIMEOUT = 500;\nfunction printMessage(msg) {\n    const output = {\n        ...msg,\n        type: `${MessageTypeNames[msg.type]} (${msg.type})`\n    };\n    if (msg.type === MessageTypes.NEW_STREAM) {\n        output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());\n    }\n    if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n        output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16');\n    }\n    return output;\n}\nexport class MplexStreamMuxer {\n    protocol = '/mplex/6.7.0';\n    sink;\n    source;\n    _streamId;\n    _streams;\n    _init;\n    _source;\n    closeController;\n    rateLimiter;\n    closeTimeout;\n    constructor(init) {\n        init = init ?? {};\n        this._streamId = 0;\n        this._streams = {\n            /**\n             * Stream to ids map\n             */\n            initiators: new Map(),\n            /**\n             * Stream to ids map\n             */\n            receivers: new Map()\n        };\n        this._init = init;\n        this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT;\n        /**\n         * An iterable sink\n         */\n        this.sink = this._createSink();\n        /**\n         * An iterable source\n         */\n        this._source = pushableV({\n            objectMode: true,\n            onEnd: () => {\n                // the source has ended, we can't write any more messages to gracefully\n                // close streams so all we can do is destroy them\n                for (const stream of this._streams.initiators.values()) {\n                    stream.destroy();\n                }\n                for (const stream of this._streams.receivers.values()) {\n                    stream.destroy();\n                }\n            }\n        });\n        this.source = pipe(this._source, source => encode(source, this._init.minSendBytes));\n        /**\n         * Close controller\n         */\n        this.closeController = new AbortController();\n        this.rateLimiter = new RateLimiterMemory({\n            points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,\n            duration: 1\n        });\n    }\n    /**\n     * Returns a Map of streams and their ids\n     */\n    get streams() {\n        // Inbound and Outbound streams may have the same ids, so we need to make those unique\n        const streams = [];\n        for (const stream of this._streams.initiators.values()) {\n            streams.push(stream);\n        }\n        for (const stream of this._streams.receivers.values()) {\n            streams.push(stream);\n        }\n        return streams;\n    }\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of the stream will be used.\n     */\n    newStream(name) {\n        if (this.closeController.signal.aborted) {\n            throw new Error('Muxer already closed');\n        }\n        const id = this._streamId++;\n        name = name == null ? id.toString() : name.toString();\n        const registry = this._streams.initiators;\n        return this._newStream({ id, name, type: 'initiator', registry });\n    }\n    /**\n     * Close or abort all tracked streams and stop the muxer\n     */\n    async close(options) {\n        if (this.closeController.signal.aborted) {\n            return;\n        }\n        const signal = options?.signal ?? AbortSignal.timeout(this.closeTimeout);\n        try {\n            // try to gracefully close all streams\n            await Promise.all(this.streams.map(async (s) => s.close({\n                signal\n            })));\n            this._source.end();\n            // try to gracefully close the muxer\n            await this._source.onEmpty({\n                signal\n            });\n            this.closeController.abort();\n        }\n        catch (err) {\n            this.abort(err);\n        }\n    }\n    abort(err) {\n        if (this.closeController.signal.aborted) {\n            return;\n        }\n        this.streams.forEach(s => { s.abort(err); });\n        this.closeController.abort(err);\n    }\n    /**\n     * Called whenever an inbound stream is created\n     */\n    _newReceiverStream(options) {\n        const { id, name } = options;\n        const registry = this._streams.receivers;\n        return this._newStream({ id, name, type: 'receiver', registry });\n    }\n    _newStream(options) {\n        const { id, name, type, registry } = options;\n        log('new %s stream %s', type, id);\n        if (type === 'initiator' && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n            throw new CodeError('Too many outbound streams open', 'ERR_TOO_MANY_OUTBOUND_STREAMS');\n        }\n        if (registry.has(id)) {\n            throw new Error(`${type} stream ${id} already exists!`);\n        }\n        const send = async (msg) => {\n            if (log.enabled) {\n                log.trace('%s stream %s send', type, id, printMessage(msg));\n            }\n            this._source.push(msg);\n        };\n        const onEnd = () => {\n            log('%s stream with id %s and protocol %s ended', type, id, stream.protocol);\n            registry.delete(id);\n            if (this._init.onStreamEnd != null) {\n                this._init.onStreamEnd(stream);\n            }\n        };\n        const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });\n        registry.set(id, stream);\n        return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     */\n    _createSink() {\n        const sink = async (source) => {\n            try {\n                source = abortableSource(source, this.closeController.signal, {\n                    returnOnAbort: true\n                });\n                const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);\n                for await (const chunk of source) {\n                    for (const msg of decoder.write(chunk)) {\n                        await this._handleIncoming(msg);\n                    }\n                }\n                this._source.end();\n            }\n            catch (err) {\n                log('error in sink', err);\n                this._source.end(err); // End the source with an error\n            }\n        };\n        return sink;\n    }\n    async _handleIncoming(message) {\n        const { id, type } = message;\n        if (log.enabled) {\n            log.trace('incoming message', printMessage(message));\n        }\n        // Create a new stream?\n        if (message.type === MessageTypes.NEW_STREAM) {\n            if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {\n                log('too many inbound streams open');\n                // not going to allow this stream, send the reset message manually\n                // instead of setting it up just to tear it down\n                this._source.push({\n                    id,\n                    type: MessageTypes.RESET_RECEIVER\n                });\n                // if we've hit our stream limit, and the remote keeps trying to open\n                // more new streams, if they are doing this very quickly maybe they\n                // are attacking us and we should close the connection\n                try {\n                    await this.rateLimiter.consume('new-stream', 1);\n                }\n                catch {\n                    log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection');\n                    // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n                    this.abort(new Error('Too many open streams'));\n                    return;\n                }\n                return;\n            }\n            const stream = this._newReceiverStream({ id, name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray()) });\n            if (this._init.onIncomingStream != null) {\n                this._init.onIncomingStream(stream);\n            }\n            return;\n        }\n        const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;\n        const stream = list.get(id);\n        if (stream == null) {\n            log('missing stream %s for message type %s', id, MessageTypeNames[type]);\n            // if the remote keeps sending us messages for streams that have been\n            // closed or were never opened they may be attacking us so if they do\n            // this very quickly all we can do is close the connection\n            try {\n                await this.rateLimiter.consume('missing-stream', 1);\n            }\n            catch {\n                log('rate limit hit when receiving messages for streams that do not exist - closing remote connection');\n                // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n                this.abort(new Error('Too many messages for missing streams'));\n                return;\n            }\n            return;\n        }\n        const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;\n        try {\n            switch (type) {\n                case MessageTypes.MESSAGE_INITIATOR:\n                case MessageTypes.MESSAGE_RECEIVER:\n                    if (stream.sourceReadableLength() > maxBufferSize) {\n                        // Stream buffer has got too large, reset the stream\n                        this._source.push({\n                            id: message.id,\n                            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n                        });\n                        // Inform the stream consumer they are not fast enough\n                        throw new CodeError('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers', 'ERR_STREAM_INPUT_BUFFER_FULL');\n                    }\n                    // We got data from the remote, push it into our local stream\n                    stream.sourcePush(message.data);\n                    break;\n                case MessageTypes.CLOSE_INITIATOR:\n                case MessageTypes.CLOSE_RECEIVER:\n                    // The remote has stopped writing, so we can stop reading\n                    stream.remoteCloseWrite();\n                    break;\n                case MessageTypes.RESET_INITIATOR:\n                case MessageTypes.RESET_RECEIVER:\n                    // The remote has errored, stop reading and writing to the stream immediately\n                    stream.reset();\n                    break;\n                default:\n                    log('unknown message type %s', type);\n            }\n        }\n        catch (err) {\n            log.error('error while processing message', err);\n            stream.abort(err);\n        }\n    }\n}\n//# sourceMappingURL=mplex.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var IpnsEntry;\n(function (IpnsEntry) {\n    let ValidityType;\n    (function (ValidityType) {\n        ValidityType[\"EOL\"] = \"EOL\";\n    })(ValidityType = IpnsEntry.ValidityType || (IpnsEntry.ValidityType = {}));\n    let __ValidityTypeValues;\n    (function (__ValidityTypeValues) {\n        __ValidityTypeValues[__ValidityTypeValues[\"EOL\"] = 0] = \"EOL\";\n    })(__ValidityTypeValues || (__ValidityTypeValues = {}));\n    (function (ValidityType) {\n        ValidityType.codec = () => {\n            return enumeration(__ValidityTypeValues);\n        };\n    })(ValidityType = IpnsEntry.ValidityType || (IpnsEntry.ValidityType = {}));\n    let _codec;\n    IpnsEntry.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.value != null) {\n                    w.uint32(10);\n                    w.bytes(obj.value);\n                }\n                if (obj.signatureV1 != null) {\n                    w.uint32(18);\n                    w.bytes(obj.signatureV1);\n                }\n                if (obj.validityType != null) {\n                    w.uint32(24);\n                    IpnsEntry.ValidityType.codec().encode(obj.validityType, w);\n                }\n                if (obj.validity != null) {\n                    w.uint32(34);\n                    w.bytes(obj.validity);\n                }\n                if (obj.sequence != null) {\n                    w.uint32(40);\n                    w.uint64(obj.sequence);\n                }\n                if (obj.ttl != null) {\n                    w.uint32(48);\n                    w.uint64(obj.ttl);\n                }\n                if (obj.pubKey != null) {\n                    w.uint32(58);\n                    w.bytes(obj.pubKey);\n                }\n                if (obj.signatureV2 != null) {\n                    w.uint32(66);\n                    w.bytes(obj.signatureV2);\n                }\n                if (obj.data != null) {\n                    w.uint32(74);\n                    w.bytes(obj.data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.value = reader.bytes();\n                            break;\n                        case 2:\n                            obj.signatureV1 = reader.bytes();\n                            break;\n                        case 3:\n                            obj.validityType = IpnsEntry.ValidityType.codec().decode(reader);\n                            break;\n                        case 4:\n                            obj.validity = reader.bytes();\n                            break;\n                        case 5:\n                            obj.sequence = reader.uint64();\n                            break;\n                        case 6:\n                            obj.ttl = reader.uint64();\n                            break;\n                        case 7:\n                            obj.pubKey = reader.bytes();\n                            break;\n                        case 8:\n                            obj.signatureV2 = reader.bytes();\n                            break;\n                        case 9:\n                            obj.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    IpnsEntry.encode = (obj) => {\n        return encodeMessage(obj, IpnsEntry.codec());\n    };\n    IpnsEntry.decode = (buf) => {\n        return decodeMessage(buf, IpnsEntry.codec());\n    };\n})(IpnsEntry || (IpnsEntry = {}));\n//# sourceMappingURL=ipns.js.map","import { unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { isPeerId } from '@libp2p/interface/peer-id';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id';\nimport * as cborg from 'cborg';\nimport errCode from 'err-code';\nimport { base36 } from 'multiformats/bases/base36';\nimport { CID } from 'multiformats/cid';\nimport NanoDate from 'timestamp-nano';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ERRORS from './errors.js';\nimport { IpnsEntry } from './pb/ipns.js';\nconst log = logger('ipns:utils');\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/');\nconst LIBP2P_CID_CODEC = 114;\n/**\n * Convert a JavaScript date into an `RFC3339Nano` formatted\n * string\n */\nexport function toRFC3339(time) {\n    const year = time.getUTCFullYear();\n    const month = String(time.getUTCMonth() + 1).padStart(2, '0');\n    const day = String(time.getUTCDate()).padStart(2, '0');\n    const hour = String(time.getUTCHours()).padStart(2, '0');\n    const minute = String(time.getUTCMinutes()).padStart(2, '0');\n    const seconds = String(time.getUTCSeconds()).padStart(2, '0');\n    const milliseconds = time.getUTCMilliseconds();\n    const nanoseconds = milliseconds * 1000 * 1000;\n    return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`;\n}\n/**\n * Parses a date string formatted as `RFC3339Nano` into a\n * JavaScript Date object\n */\nexport function parseRFC3339(time) {\n    const rfc3339Matcher = new RegExp(\n    // 2006-01-02T\n    '(\\\\d{4})-(\\\\d{2})-(\\\\d{2})T' +\n        // 15:04:05\n        '(\\\\d{2}):(\\\\d{2}):(\\\\d{2})' +\n        // .999999999Z\n        '\\\\.(\\\\d+)Z');\n    const m = String(time).trim().match(rfc3339Matcher);\n    if (m == null) {\n        throw new Error('Invalid format');\n    }\n    const year = parseInt(m[1], 10);\n    const month = parseInt(m[2], 10) - 1;\n    const date = parseInt(m[3], 10);\n    const hour = parseInt(m[4], 10);\n    const minute = parseInt(m[5], 10);\n    const second = parseInt(m[6], 10);\n    const millisecond = parseInt(m[7].padEnd(6, '0').slice(0, 3), 10);\n    return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));\n}\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record\n */\nexport const extractPublicKey = async (peerId, record) => {\n    if (record == null || peerId == null) {\n        const error = new Error('one or more of the provided parameters are not defined');\n        log.error(error);\n        throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n    }\n    let pubKey;\n    if (record.pubKey != null) {\n        try {\n            pubKey = unmarshalPublicKey(record.pubKey);\n        }\n        catch (err) {\n            log.error(err);\n            throw err;\n        }\n        const otherId = await peerIdFromKeys(record.pubKey);\n        if (!otherId.equals(peerId)) {\n            throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY);\n        }\n    }\n    else if (peerId.publicKey != null) {\n        pubKey = unmarshalPublicKey(peerId.publicKey);\n    }\n    if (pubKey != null) {\n        return pubKey;\n    }\n    throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER);\n};\n/**\n * Utility for creating the record data for being signed\n */\nexport const ipnsRecordDataForV1Sig = (value, validityType, validity) => {\n    const validityTypeBuffer = uint8ArrayFromString(validityType);\n    return uint8ArrayConcat([value, validity, validityTypeBuffer]);\n};\n/**\n * Utility for creating the record data for being signed\n */\nexport const ipnsRecordDataForV2Sig = (data) => {\n    const entryData = uint8ArrayFromString('ipns-signature:');\n    return uint8ArrayConcat([entryData, data]);\n};\nexport const marshal = (obj) => {\n    if ('signatureV1' in obj) {\n        return IpnsEntry.encode({\n            value: uint8ArrayFromString(obj.value),\n            signatureV1: obj.signatureV1,\n            validityType: obj.validityType,\n            validity: uint8ArrayFromString(obj.validity.toString()),\n            sequence: obj.sequence,\n            ttl: obj.ttl,\n            pubKey: obj.pubKey,\n            signatureV2: obj.signatureV2,\n            data: obj.data\n        });\n    }\n    else {\n        return IpnsEntry.encode({\n            pubKey: obj.pubKey,\n            signatureV2: obj.signatureV2,\n            data: obj.data\n        });\n    }\n};\nexport function unmarshal(buf) {\n    const message = IpnsEntry.decode(buf);\n    // protobufjs returns bigints as numbers\n    if (message.sequence != null) {\n        message.sequence = BigInt(message.sequence);\n    }\n    // protobufjs returns bigints as numbers\n    if (message.ttl != null) {\n        message.ttl = BigInt(message.ttl);\n    }\n    // Check if we have the data field. If we don't, we fail. We've been producing\n    // V1+V2 records for quite a while and we don't support V1-only records during\n    // validation any more\n    if (message.signatureV2 == null || message.data == null) {\n        throw errCode(new Error('missing data or signatureV2'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    }\n    const data = parseCborData(message.data);\n    const value = normalizeValue(data.Value);\n    let validity;\n    try {\n        validity = NanoDate.fromDate(parseRFC3339(uint8ArrayToString(data.Validity)));\n    }\n    catch (e) {\n        log.error('unrecognized validity format (not an rfc3339 format)');\n        throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n    }\n    if (message.value != null && message.signatureV1 != null) {\n        // V1+V2\n        validateCborDataMatchesPbData(message);\n        return {\n            value,\n            validityType: IpnsEntry.ValidityType.EOL,\n            validity,\n            sequence: data.Sequence,\n            ttl: data.TTL,\n            pubKey: message.pubKey,\n            signatureV1: message.signatureV1,\n            signatureV2: message.signatureV2,\n            data: message.data\n        };\n    }\n    else if (message.signatureV2 != null) {\n        // V2-only\n        return {\n            value,\n            validityType: IpnsEntry.ValidityType.EOL,\n            validity,\n            sequence: data.Sequence,\n            ttl: data.TTL,\n            pubKey: message.pubKey,\n            signatureV2: message.signatureV2,\n            data: message.data\n        };\n    }\n    else {\n        throw new Error('invalid record: does not include signatureV1 or signatureV2');\n    }\n}\nexport const peerIdToRoutingKey = (peerId) => {\n    return uint8ArrayConcat([\n        IPNS_PREFIX,\n        peerId.toBytes()\n    ]);\n};\nexport const peerIdFromRoutingKey = (key) => {\n    return peerIdFromBytes(key.slice(IPNS_PREFIX.length));\n};\nexport const createCborData = (value, validity, validityType, sequence, ttl) => {\n    let ValidityType;\n    if (validityType === IpnsEntry.ValidityType.EOL) {\n        ValidityType = 0;\n    }\n    else {\n        throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n    }\n    const data = {\n        Value: value,\n        Validity: validity,\n        ValidityType,\n        Sequence: sequence,\n        TTL: ttl\n    };\n    return cborg.encode(data);\n};\nexport const parseCborData = (buf) => {\n    const data = cborg.decode(buf);\n    if (data.ValidityType === 0) {\n        data.ValidityType = IpnsEntry.ValidityType.EOL;\n    }\n    else {\n        throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n    }\n    if (Number.isInteger(data.Sequence)) {\n        // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n        data.Sequence = BigInt(data.Sequence);\n    }\n    if (Number.isInteger(data.TTL)) {\n        // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n        data.TTL = BigInt(data.TTL);\n    }\n    return data;\n};\n/**\n * Normalizes the given record value. It ensures it is a PeerID, a CID or a\n * string starting with '/'. PeerIDs become `/ipns/${cidV1Libp2pKey}`,\n * CIDs become `/ipfs/${cidAsV1}`.\n */\nexport const normalizeValue = (value) => {\n    if (value != null) {\n        // if we have a PeerId, turn it into an ipns path\n        if (isPeerId(value)) {\n            return `/ipns/${value.toCID().toString(base36)}`;\n        }\n        // if the value is bytes, stringify it and see if we have a path\n        if (value instanceof Uint8Array) {\n            const string = uint8ArrayToString(value);\n            if (string.startsWith('/')) {\n                value = string;\n            }\n        }\n        // if we have a path, check it is a valid path\n        const string = value.toString().trim();\n        if (string.startsWith('/') && string.length > 1) {\n            return string;\n        }\n        // if we have a CID, turn it into an ipfs path\n        const cid = CID.asCID(value);\n        if (cid != null) {\n            // PeerID encoded as a CID\n            if (cid.code === LIBP2P_CID_CODEC) {\n                return `/ipns/${cid.toString(base36)}`;\n            }\n            return `/ipfs/${cid.toV1().toString()}`;\n        }\n        // try parsing what we have as CID bytes or a CID string\n        try {\n            if (value instanceof Uint8Array) {\n                return `/ipfs/${CID.decode(value).toV1().toString()}`;\n            }\n            return `/ipfs/${CID.parse(string).toV1().toString()}`;\n        }\n        catch {\n            // fall through\n        }\n    }\n    throw errCode(new Error('Value must be a valid content path starting with /'), ERRORS.ERR_INVALID_VALUE);\n};\nconst validateCborDataMatchesPbData = (entry) => {\n    if (entry.data == null) {\n        throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);\n    }\n    const data = parseCborData(entry.data);\n    if (!uint8ArrayEquals(data.Value, entry.value ?? new Uint8Array(0))) {\n        throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (!uint8ArrayEquals(data.Validity, entry.validity ?? new Uint8Array(0))) {\n        throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (data.ValidityType !== entry.validityType) {\n        throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (data.Sequence !== entry.sequence) {\n        throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (data.TTL !== entry.ttl) {\n        throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    }\n};\n//# sourceMappingURL=utils.js.map","import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as ERRORS from './errors.js';\nimport { IpnsEntry } from './pb/ipns.js';\nimport { extractPublicKey, ipnsRecordDataForV2Sig, unmarshal, peerIdFromRoutingKey } from './utils.js';\nconst log = logger('ipns:validator');\n/**\n * Limit valid IPNS record sizes to 10kb\n */\nconst MAX_RECORD_SIZE = 1024 * 10;\n/**\n * Validates the given IPNS Record against the given public key. We need a \"raw\"\n * record in order to be able to access to all of its fields.\n */\nexport const validate = async (publicKey, buf) => {\n    // unmarshal ensures that (1) SignatureV2 and Data are present, (2) that ValidityType\n    // and Validity are of valid types and have a value, (3) that CBOR data matches protobuf\n    // if it's a V1+V2 record.\n    const record = unmarshal(buf);\n    // Validate Signature V2\n    let isValid;\n    try {\n        const dataForSignature = ipnsRecordDataForV2Sig(record.data);\n        isValid = await publicKey.verify(dataForSignature, record.signatureV2);\n    }\n    catch (err) {\n        isValid = false;\n    }\n    if (!isValid) {\n        log.error('record signature verification failed');\n        throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    }\n    // Validate according to the validity type\n    if (record.validityType === IpnsEntry.ValidityType.EOL) {\n        if (record.validity.toDate().getTime() < Date.now()) {\n            log.error('record has expired');\n            throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n        }\n    }\n    else if (record.validityType != null) {\n        log.error('unrecognized validity type');\n        throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n    }\n    log('ipns record for %b is valid', record.value);\n};\nexport async function ipnsValidator(key, marshalledData) {\n    if (marshalledData.byteLength > MAX_RECORD_SIZE) {\n        throw errCode(new Error('record too large'), ERRORS.ERR_RECORD_TOO_LARGE);\n    }\n    const peerId = peerIdFromRoutingKey(key);\n    const receivedRecord = unmarshal(marshalledData);\n    // extract public key\n    const pubKey = await extractPublicKey(peerId, receivedRecord);\n    // Record validation\n    await validate(pubKey, marshalledData);\n}\n//# sourceMappingURL=validator.js.map","/**\n * @packageDocumentation\n *\n * Create a Helia node.\n *\n * @example\n *\n * ```typescript\n * import { MemoryDatastore } from 'datastore-core'\n * import { MemoryBlockstore } from 'blockstore-core'\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n * import { CID } from 'multiformats/cid'\n *\n * const node = await createHelia({\n *   blockstore: new MemoryBlockstore(),\n *   datastore: new MemoryDatastore()\n * })\n * const fs = unixfs(node)\n * fs.cat(CID.parse('bafyFoo'))\n * ```\n */\nimport { logger } from '@libp2p/logger';\nimport { MemoryBlockstore } from 'blockstore-core';\nimport { MemoryDatastore } from 'datastore-core';\nimport { HeliaImpl } from './helia.js';\nimport { createLibp2p } from './utils/libp2p.js';\nimport { name, version } from './version.js';\n// re-export interface types so people don't have to depend on @helia/interface\n// if they don't want to\nexport * from '@helia/interface';\nexport * from '@helia/interface/blocks';\nexport * from '@helia/interface/pins';\nconst log = logger('helia');\nexport async function createHelia(init = {}) {\n    const datastore = init.datastore ?? new MemoryDatastore();\n    const blockstore = init.blockstore ?? new MemoryBlockstore();\n    let libp2p;\n    if (isLibp2p(init.libp2p)) {\n        libp2p = init.libp2p;\n    }\n    else {\n        libp2p = await createLibp2p(datastore, init.libp2p);\n    }\n    const helia = new HeliaImpl({\n        ...init,\n        datastore,\n        blockstore,\n        libp2p\n    });\n    if (init.start !== false) {\n        await helia.start();\n    }\n    // add helia to agent version\n    addHeliaToAgentVersion(helia);\n    return helia;\n}\nfunction isLibp2p(obj) {\n    if (obj == null) {\n        return false;\n    }\n    // a non-exhaustive list of methods found on the libp2p object\n    const funcs = ['dial', 'dialProtocol', 'hangUp', 'handle', 'unhandle', 'getMultiaddrs', 'getProtocols'];\n    // if these are all functions it's probably a libp2p object\n    return funcs.every(m => typeof obj[m] === 'function');\n}\nfunction addHeliaToAgentVersion(helia) {\n    // add helia to agent version\n    try {\n        const existingAgentVersion = helia.libp2p.services.identify.host.agentVersion;\n        if (existingAgentVersion.match(/js-libp2p\\/\\d+\\.\\d+\\.\\d+\\sUserAgent=/) == null) {\n            // the user changed the agent version\n            return;\n        }\n        helia.libp2p.services.identify.host.agentVersion = `${name}/${version} ${helia.libp2p.services.identify.host.agentVersion}`;\n    }\n    catch (err) {\n        log.error('could not add Helia to agent version', err);\n    }\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n","const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n","import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n","import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","const word = '[a-fA-F\\\\d:]';\n\nconst boundry = options => options && options.includeBoundaries\n\t? `(?:(?<=\\\\s|^)(?=${word})|(?<=${word})(?=\\\\s|$))`\n\t: '';\n\nconst v4 = '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n\nconst v6segment = '[a-fA-F\\\\d]{1,4}';\n\nconst v6 = `\n(?:\n(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n`.replace(/\\s*\\/\\/.*$/gm, '').replace(/\\n/g, '').trim();\n\n// Pre-compile only the exact regexes because adding a global flag make regexes stateful\nconst v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);\nconst v4exact = new RegExp(`^${v4}$`);\nconst v6exact = new RegExp(`^${v6}$`);\n\nconst ipRegex = options => options && options.exact\n\t? v46Exact\n\t: new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, 'g');\n\nipRegex.v4 = options => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, 'g');\nipRegex.v6 = options => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, 'g');\n\nexport default ipRegex;\n","import { base58btc } from 'multiformats/bases/base58';\nexport class WantListEntry {\n    _refCounter;\n    cid;\n    priority;\n    wantType;\n    constructor(cid, priority, wantType) {\n        // Keep track of how many requests we have for this key\n        this._refCounter = 1;\n        this.cid = cid;\n        this.priority = priority ?? 1;\n        this.wantType = wantType;\n    }\n    inc() {\n        this._refCounter += 1;\n    }\n    dec() {\n        this._refCounter = Math.max(0, this._refCounter - 1);\n    }\n    hasRefs() {\n        return this._refCounter > 0;\n    }\n    // So that console.log prints a nice description of this object\n    get [Symbol.toStringTag]() {\n        const cidStr = this.cid.toString(base58btc);\n        return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;\n    }\n    equals(other) {\n        return (this._refCounter === other._refCounter) &&\n            this.cid.equals(other.cid) &&\n            this.priority === other.priority &&\n            this.wantType === other.wantType;\n    }\n}\n//# sourceMappingURL=entry.js.map","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive bytes over streams.\n *\n * @example\n *\n * ```typescript\n * import { byteStream } from 'it-byte-stream'\n *\n * const stream = byteStream(duplex)\n *\n * // read the next chunk\n * const bytes = await stream.read()\n *\n * // read the next five bytes\n * const fiveBytes = await stream.read(5)\n *\n * // write bytes into the stream\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n * ```\n */\nimport { pushable } from 'it-pushable';\nimport { Uint8ArrayList } from 'uint8arraylist';\nexport class CodeError extends Error {\n    code;\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nexport class AbortError extends CodeError {\n    type;\n    constructor(message) {\n        super(message, 'ABORT_ERR');\n        this.type = 'aborted';\n    }\n}\nexport function byteStream(duplex) {\n    const write = pushable();\n    duplex.sink(write).catch((err) => {\n        write.end(err);\n    });\n    duplex.sink = async (source) => {\n        for await (const buf of source) {\n            write.push(buf);\n        }\n        write.end();\n    };\n    let source = duplex.source;\n    if (duplex.source[Symbol.iterator] != null) {\n        source = duplex.source[Symbol.iterator]();\n    }\n    else if (duplex.source[Symbol.asyncIterator] != null) {\n        source = duplex.source[Symbol.asyncIterator]();\n    }\n    const readBuffer = new Uint8ArrayList();\n    const W = {\n        read: async (bytes, options) => {\n            options?.signal?.throwIfAborted();\n            let listener;\n            const abortPromise = new Promise((resolve, reject) => {\n                listener = () => {\n                    reject(new AbortError('Read aborted'));\n                };\n                options?.signal?.addEventListener('abort', listener);\n            });\n            try {\n                if (bytes == null) {\n                    // just read whatever arrives\n                    const { done, value } = await Promise.race([\n                        source.next(),\n                        abortPromise\n                    ]);\n                    if (done === true) {\n                        return new Uint8ArrayList();\n                    }\n                    return value;\n                }\n                while (readBuffer.byteLength < bytes) {\n                    const { value, done } = await Promise.race([\n                        source.next(),\n                        abortPromise\n                    ]);\n                    if (done === true) {\n                        throw new CodeError('unexpected end of input', 'ERR_UNEXPECTED_EOF');\n                    }\n                    readBuffer.append(value);\n                }\n                const buf = readBuffer.sublist(0, bytes);\n                readBuffer.consume(bytes);\n                return buf;\n            }\n            finally {\n                if (listener != null) {\n                    options?.signal?.removeEventListener('abort', listener);\n                }\n            }\n        },\n        write: async (data, options) => {\n            options?.signal?.throwIfAborted();\n            // just write\n            if (data instanceof Uint8Array) {\n                write.push(data);\n            }\n            else {\n                write.push(data.subarray());\n            }\n            await write.onEmpty(options);\n        },\n        unwrap: () => {\n            const originalStream = duplex.source;\n            duplex.source = (async function* () {\n                yield* readBuffer;\n                yield* originalStream;\n            }());\n            return duplex;\n        }\n    };\n    return W;\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed byte arrays over\n * streams.\n *\n * @example\n *\n * ```typescript\n * import { lpStream } from 'it-length-prefixed-stream'\n *\n * const stream = lpStream(duplex)\n *\n * // read the next length-prefixed chunk\n * const bytes = await stream.read()\n *\n * // write a length-prefixed chunk\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n * ```\n */\nimport { byteStream } from 'it-byte-stream';\nimport * as lp from 'it-length-prefixed';\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nclass CodeError extends Error {\n    code;\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nconst defaultLengthDecoder = (buf) => {\n    return varint.decode(buf);\n};\ndefaultLengthDecoder.bytes = 0;\nexport function lpStream(duplex, opts) {\n    const bytes = byteStream(duplex);\n    const W = {\n        read: async (options) => {\n            let dataLength = -1;\n            const lengthBuffer = new Uint8ArrayList();\n            const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder;\n            while (true) {\n                // read one byte at a time until we can decode a varint\n                lengthBuffer.append(await bytes.read(1, options));\n                try {\n                    dataLength = decodeLength(lengthBuffer);\n                }\n                catch (err) {\n                    if (err instanceof RangeError) {\n                        continue;\n                    }\n                    throw err;\n                }\n                if (dataLength > -1) {\n                    break;\n                }\n                if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n                    throw new CodeError('message length length too long', 'ERR_MSG_LENGTH_TOO_LONG');\n                }\n            }\n            if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n                throw new CodeError('message length too long', 'ERR_MSG_DATA_TOO_LONG');\n            }\n            return bytes.read(dataLength, options);\n        },\n        write: async (data, options) => {\n            // encode, write\n            await bytes.write(lp.encode.single(data, opts), options);\n        },\n        unwrap: () => {\n            return bytes.unwrap();\n        }\n    };\n    return W;\n}\n//# sourceMappingURL=index.js.map","import * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nimport { isAsyncIterable } from './utils.js';\nconst defaultEncoder = (length) => {\n    const lengthLength = varint.encodingLength(length);\n    const lengthBuf = allocUnsafe(lengthLength);\n    varint.encode(length, lengthBuf);\n    defaultEncoder.bytes = lengthLength;\n    return lengthBuf;\n};\ndefaultEncoder.bytes = 0;\nexport function encode(source, options) {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    function* maybeYield(chunk) {\n        // length + data\n        const length = encodeLength(chunk.byteLength);\n        // yield only Uint8Arrays\n        if (length instanceof Uint8Array) {\n            yield length;\n        }\n        else {\n            yield* length;\n        }\n        // yield only Uint8Arrays\n        if (chunk instanceof Uint8Array) {\n            yield chunk;\n        }\n        else {\n            yield* chunk;\n        }\n    }\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const chunk of source) {\n                yield* maybeYield(chunk);\n            }\n        })();\n    }\n    return (function* () {\n        for (const chunk of source) {\n            yield* maybeYield(chunk);\n        }\n    })();\n}\nencode.single = (chunk, options) => {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);\n};\n//# sourceMappingURL=encode.js.map","/* eslint max-depth: [\"error\", 6] */\nimport errCode from 'err-code';\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { isAsyncIterable } from './utils.js';\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n    ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n    ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nconst defaultDecoder = (buf) => {\n    const length = varint.decode(buf);\n    defaultDecoder.bytes = varint.encodingLength(length);\n    return length;\n};\ndefaultDecoder.bytes = 0;\nexport function decode(source, options) {\n    const buffer = new Uint8ArrayList();\n    let mode = ReadMode.LENGTH;\n    let dataLength = -1;\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n    function* maybeYield() {\n        while (buffer.byteLength > 0) {\n            if (mode === ReadMode.LENGTH) {\n                // read length, ignore errors for short reads\n                try {\n                    dataLength = lengthDecoder(buffer);\n                    if (dataLength < 0) {\n                        throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n                    }\n                    if (dataLength > maxDataLength) {\n                        throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n                    }\n                    const dataLengthLength = lengthDecoder.bytes;\n                    buffer.consume(dataLengthLength);\n                    if (options?.onLength != null) {\n                        options.onLength(dataLength);\n                    }\n                    mode = ReadMode.DATA;\n                }\n                catch (err) {\n                    if (err instanceof RangeError) {\n                        if (buffer.byteLength > maxLengthLength) {\n                            throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n                        }\n                        break;\n                    }\n                    throw err;\n                }\n            }\n            if (mode === ReadMode.DATA) {\n                if (buffer.byteLength < dataLength) {\n                    // not enough data, wait for more\n                    break;\n                }\n                const data = buffer.sublist(0, dataLength);\n                buffer.consume(dataLength);\n                if (options?.onData != null) {\n                    options.onData(data);\n                }\n                yield data;\n                mode = ReadMode.LENGTH;\n            }\n        }\n    }\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const buf of source) {\n                buffer.append(buf);\n                yield* maybeYield();\n            }\n            if (buffer.byteLength > 0) {\n                throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n            }\n        })();\n    }\n    return (function* () {\n        for (const buf of source) {\n            buffer.append(buf);\n            yield* maybeYield();\n        }\n        if (buffer.byteLength > 0) {\n            throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n        }\n    })();\n}\ndecode.fromReader = (reader, options) => {\n    let byteLength = 1; // Read single byte chunks until the length is known\n    const varByteSource = (async function* () {\n        while (true) {\n            try {\n                const { done, value } = await reader.next(byteLength);\n                if (done === true) {\n                    return;\n                }\n                if (value != null) {\n                    yield value;\n                }\n            }\n            catch (err) {\n                if (err.code === 'ERR_UNDER_READ') {\n                    return { done: true, value: null };\n                }\n                throw err;\n            }\n            finally {\n                // Reset the byteLength so we continue to check for varints\n                byteLength = 1;\n            }\n        }\n    }());\n    /**\n     * Once the length has been parsed, read chunk for that length\n     */\n    const onLength = (l) => { byteLength = l; };\n    return decode(varByteSource, {\n        ...(options ?? {}),\n        onLength\n    });\n};\n//# sourceMappingURL=decode.js.map","/* global EventTarget Event */\nimport defer from 'p-defer';\nconst CustomEvent = globalThis.CustomEvent ?? Event;\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function* parallel(source, options = {}) {\n    let concurrency = options.concurrency ?? Infinity;\n    if (concurrency < 1) {\n        concurrency = Infinity;\n    }\n    const ordered = options.ordered == null ? false : options.ordered;\n    const emitter = new EventTarget();\n    const ops = [];\n    let slotAvailable = defer();\n    let resultAvailable = defer();\n    let sourceFinished = false;\n    let sourceErr;\n    let opErred = false;\n    emitter.addEventListener('task-complete', () => {\n        resultAvailable.resolve();\n    });\n    void Promise.resolve().then(async () => {\n        try {\n            for await (const task of source) {\n                if (ops.length === concurrency) {\n                    slotAvailable = defer();\n                    await slotAvailable.promise;\n                }\n                if (opErred) {\n                    break;\n                }\n                const op = {\n                    done: false\n                };\n                ops.push(op);\n                task()\n                    .then(result => {\n                    op.done = true;\n                    op.ok = true;\n                    op.value = result;\n                    emitter.dispatchEvent(new CustomEvent('task-complete'));\n                }, err => {\n                    op.done = true;\n                    op.err = err;\n                    emitter.dispatchEvent(new CustomEvent('task-complete'));\n                });\n            }\n            sourceFinished = true;\n            emitter.dispatchEvent(new CustomEvent('task-complete'));\n        }\n        catch (err) {\n            sourceErr = err;\n            emitter.dispatchEvent(new CustomEvent('task-complete'));\n        }\n    });\n    function valuesAvailable() {\n        if (ordered) {\n            return ops[0]?.done;\n        }\n        return Boolean(ops.find(op => op.done));\n    }\n    function* yieldOrderedValues() {\n        while ((ops.length > 0) && ops[0].done) {\n            const op = ops[0];\n            ops.shift();\n            if (op.ok) {\n                yield op.value;\n            }\n            else {\n                // allow the source to exit\n                opErred = true;\n                slotAvailable.resolve();\n                throw op.err;\n            }\n            slotAvailable.resolve();\n        }\n    }\n    function* yieldUnOrderedValues() {\n        // more values can become available while we wait for `yield`\n        // to return control to this function\n        while (valuesAvailable()) {\n            for (let i = 0; i < ops.length; i++) {\n                if (ops[i].done) {\n                    const op = ops[i];\n                    ops.splice(i, 1);\n                    i--;\n                    if (op.ok) {\n                        yield op.value;\n                    }\n                    else {\n                        opErred = true;\n                        slotAvailable.resolve();\n                        throw op.err;\n                    }\n                    slotAvailable.resolve();\n                }\n            }\n        }\n    }\n    while (true) {\n        if (!valuesAvailable()) {\n            resultAvailable = defer();\n            await resultAvailable.promise;\n        }\n        if (sourceErr != null) {\n            // the source threw an error, propagate it\n            throw sourceErr;\n        }\n        if (ordered) {\n            yield* yieldOrderedValues();\n        }\n        else {\n            yield* yieldUnOrderedValues();\n        }\n        if (sourceFinished && ops.length === 0) {\n            // not waiting for any results and no more tasks so we are done\n            break;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Message;\n(function (Message) {\n    let MessageType;\n    (function (MessageType) {\n        MessageType[\"DIAL\"] = \"DIAL\";\n        MessageType[\"DIAL_RESPONSE\"] = \"DIAL_RESPONSE\";\n    })(MessageType = Message.MessageType || (Message.MessageType = {}));\n    let __MessageTypeValues;\n    (function (__MessageTypeValues) {\n        __MessageTypeValues[__MessageTypeValues[\"DIAL\"] = 0] = \"DIAL\";\n        __MessageTypeValues[__MessageTypeValues[\"DIAL_RESPONSE\"] = 1] = \"DIAL_RESPONSE\";\n    })(__MessageTypeValues || (__MessageTypeValues = {}));\n    (function (MessageType) {\n        MessageType.codec = () => {\n            return enumeration(__MessageTypeValues);\n        };\n    })(MessageType = Message.MessageType || (Message.MessageType = {}));\n    let ResponseStatus;\n    (function (ResponseStatus) {\n        ResponseStatus[\"OK\"] = \"OK\";\n        ResponseStatus[\"E_DIAL_ERROR\"] = \"E_DIAL_ERROR\";\n        ResponseStatus[\"E_DIAL_REFUSED\"] = \"E_DIAL_REFUSED\";\n        ResponseStatus[\"E_BAD_REQUEST\"] = \"E_BAD_REQUEST\";\n        ResponseStatus[\"E_INTERNAL_ERROR\"] = \"E_INTERNAL_ERROR\";\n    })(ResponseStatus = Message.ResponseStatus || (Message.ResponseStatus = {}));\n    let __ResponseStatusValues;\n    (function (__ResponseStatusValues) {\n        __ResponseStatusValues[__ResponseStatusValues[\"OK\"] = 0] = \"OK\";\n        __ResponseStatusValues[__ResponseStatusValues[\"E_DIAL_ERROR\"] = 100] = \"E_DIAL_ERROR\";\n        __ResponseStatusValues[__ResponseStatusValues[\"E_DIAL_REFUSED\"] = 101] = \"E_DIAL_REFUSED\";\n        __ResponseStatusValues[__ResponseStatusValues[\"E_BAD_REQUEST\"] = 200] = \"E_BAD_REQUEST\";\n        __ResponseStatusValues[__ResponseStatusValues[\"E_INTERNAL_ERROR\"] = 300] = \"E_INTERNAL_ERROR\";\n    })(__ResponseStatusValues || (__ResponseStatusValues = {}));\n    (function (ResponseStatus) {\n        ResponseStatus.codec = () => {\n            return enumeration(__ResponseStatusValues);\n        };\n    })(ResponseStatus = Message.ResponseStatus || (Message.ResponseStatus = {}));\n    let PeerInfo;\n    (function (PeerInfo) {\n        let _codec;\n        PeerInfo.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if (obj.id != null) {\n                        w.uint32(10);\n                        w.bytes(obj.id);\n                    }\n                    if (obj.addrs != null) {\n                        for (const value of obj.addrs) {\n                            w.uint32(18);\n                            w.bytes(value);\n                        }\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        addrs: []\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.id = reader.bytes();\n                                break;\n                            case 2:\n                                obj.addrs.push(reader.bytes());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        PeerInfo.encode = (obj) => {\n            return encodeMessage(obj, PeerInfo.codec());\n        };\n        PeerInfo.decode = (buf) => {\n            return decodeMessage(buf, PeerInfo.codec());\n        };\n    })(PeerInfo = Message.PeerInfo || (Message.PeerInfo = {}));\n    let Dial;\n    (function (Dial) {\n        let _codec;\n        Dial.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if (obj.peer != null) {\n                        w.uint32(10);\n                        Message.PeerInfo.codec().encode(obj.peer, w);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {};\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.peer = Message.PeerInfo.codec().decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Dial.encode = (obj) => {\n            return encodeMessage(obj, Dial.codec());\n        };\n        Dial.decode = (buf) => {\n            return decodeMessage(buf, Dial.codec());\n        };\n    })(Dial = Message.Dial || (Message.Dial = {}));\n    let DialResponse;\n    (function (DialResponse) {\n        let _codec;\n        DialResponse.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if (obj.status != null) {\n                        w.uint32(8);\n                        Message.ResponseStatus.codec().encode(obj.status, w);\n                    }\n                    if (obj.statusText != null) {\n                        w.uint32(18);\n                        w.string(obj.statusText);\n                    }\n                    if (obj.addr != null) {\n                        w.uint32(26);\n                        w.bytes(obj.addr);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {};\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.status = Message.ResponseStatus.codec().decode(reader);\n                                break;\n                            case 2:\n                                obj.statusText = reader.string();\n                                break;\n                            case 3:\n                                obj.addr = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        DialResponse.encode = (obj) => {\n            return encodeMessage(obj, DialResponse.codec());\n        };\n        DialResponse.decode = (buf) => {\n            return decodeMessage(buf, DialResponse.codec());\n        };\n    })(DialResponse = Message.DialResponse || (Message.DialResponse = {}));\n    let _codec;\n    Message.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.type != null) {\n                    w.uint32(8);\n                    Message.MessageType.codec().encode(obj.type, w);\n                }\n                if (obj.dial != null) {\n                    w.uint32(18);\n                    Message.Dial.codec().encode(obj.dial, w);\n                }\n                if (obj.dialResponse != null) {\n                    w.uint32(26);\n                    Message.DialResponse.codec().encode(obj.dialResponse, w);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.type = Message.MessageType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.dial = Message.Dial.codec().decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            obj.dialResponse = Message.DialResponse.codec().decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Message.encode = (obj) => {\n        return encodeMessage(obj, Message.codec());\n    };\n    Message.decode = (buf) => {\n        return decodeMessage(buf, Message.codec());\n    };\n})(Message || (Message = {}));\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Use the `autoNATService` function to add support for the [AutoNAT protocol](https://docs.libp2p.io/concepts/nat/autonat/)\n * to libp2p.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { autoNATService } from 'libp2p/autonat'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     autoNAT: autoNATService()\n *   }\n * })\n * ```\n */\nimport { setMaxListeners } from 'events';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { createEd25519PeerId } from '@libp2p/peer-id-factory';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport first from 'it-first';\nimport * as lp from 'it-length-prefixed';\nimport map from 'it-map';\nimport parallel from 'it-parallel';\nimport { pipe } from 'it-pipe';\nimport isPrivateIp from 'private-ip';\nimport { codes } from '../errors.js';\nimport { MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS, PROTOCOL_NAME, PROTOCOL_PREFIX, PROTOCOL_VERSION, REFRESH_INTERVAL, STARTUP_DELAY, TIMEOUT } from './constants.js';\nimport { Message } from './pb/index.js';\nconst log = logger('libp2p:autonat');\n// if more than 3 peers manage to dial us on what we believe to be our external\n// IP then we are convinced that it is, in fact, our external IP\n// https://github.com/libp2p/specs/blob/master/autonat/README.md#autonat-protocol\nconst REQUIRED_SUCCESSFUL_DIALS = 4;\nclass DefaultAutoNATService {\n    components;\n    startupDelay;\n    refreshInterval;\n    protocol;\n    timeout;\n    maxInboundStreams;\n    maxOutboundStreams;\n    verifyAddressTimeout;\n    started;\n    constructor(components, init) {\n        this.components = components;\n        this.started = false;\n        this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;\n        this.timeout = init.timeout ?? TIMEOUT;\n        this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;\n        this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;\n        this.startupDelay = init.startupDelay ?? STARTUP_DELAY;\n        this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;\n        this._verifyExternalAddresses = this._verifyExternalAddresses.bind(this);\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        if (this.started) {\n            return;\n        }\n        await this.components.registrar.handle(this.protocol, (data) => {\n            void this.handleIncomingAutonatStream(data)\n                .catch(err => {\n                log.error('error handling incoming autonat stream', err);\n            });\n        }, {\n            maxInboundStreams: this.maxInboundStreams,\n            maxOutboundStreams: this.maxOutboundStreams\n        });\n        this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.startupDelay);\n        this.started = true;\n    }\n    async stop() {\n        await this.components.registrar.unhandle(this.protocol);\n        clearTimeout(this.verifyAddressTimeout);\n        this.started = false;\n    }\n    /**\n     * Handle an incoming AutoNAT request\n     */\n    async handleIncomingAutonatStream(data) {\n        const signal = AbortSignal.timeout(this.timeout);\n        const onAbort = () => {\n            data.stream.abort(new CodeError('handleIncomingAutonatStream timeout', codes.ERR_TIMEOUT));\n        };\n        signal.addEventListener('abort', onAbort, { once: true });\n        // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning\n        // appearing in the console\n        try {\n            // fails on node < 15.4\n            setMaxListeners?.(Infinity, signal);\n        }\n        catch { }\n        const ourHosts = this.components.addressManager.getAddresses()\n            .map(ma => ma.toOptions().host);\n        try {\n            const self = this;\n            await pipe(data.stream, (source) => lp.decode(source), async function* (stream) {\n                const buf = await first(stream);\n                if (buf == null) {\n                    log('no message received');\n                    yield Message.encode({\n                        type: Message.MessageType.DIAL_RESPONSE,\n                        dialResponse: {\n                            status: Message.ResponseStatus.E_BAD_REQUEST,\n                            statusText: 'No message was sent'\n                        }\n                    });\n                    return;\n                }\n                let request;\n                try {\n                    request = Message.decode(buf);\n                }\n                catch (err) {\n                    log.error('could not decode message', err);\n                    yield Message.encode({\n                        type: Message.MessageType.DIAL_RESPONSE,\n                        dialResponse: {\n                            status: Message.ResponseStatus.E_BAD_REQUEST,\n                            statusText: 'Could not decode message'\n                        }\n                    });\n                    return;\n                }\n                const dialRequest = request.dial;\n                if (dialRequest == null) {\n                    log.error('dial was missing from message');\n                    yield Message.encode({\n                        type: Message.MessageType.DIAL_RESPONSE,\n                        dialResponse: {\n                            status: Message.ResponseStatus.E_BAD_REQUEST,\n                            statusText: 'No Dial message found in message'\n                        }\n                    });\n                    return;\n                }\n                let peerId;\n                const peer = dialRequest.peer;\n                if (peer == null || peer.id == null) {\n                    log.error('PeerId missing from message');\n                    yield Message.encode({\n                        type: Message.MessageType.DIAL_RESPONSE,\n                        dialResponse: {\n                            status: Message.ResponseStatus.E_BAD_REQUEST,\n                            statusText: 'missing peer info'\n                        }\n                    });\n                    return;\n                }\n                try {\n                    peerId = peerIdFromBytes(peer.id);\n                }\n                catch (err) {\n                    log.error('invalid PeerId', err);\n                    yield Message.encode({\n                        type: Message.MessageType.DIAL_RESPONSE,\n                        dialResponse: {\n                            status: Message.ResponseStatus.E_BAD_REQUEST,\n                            statusText: 'bad peer id'\n                        }\n                    });\n                    return;\n                }\n                log('incoming request from %p', peerId);\n                // reject any dial requests that arrive via relays\n                if (!data.connection.remotePeer.equals(peerId)) {\n                    log('target peer %p did not equal sending peer %p', peerId, data.connection.remotePeer);\n                    yield Message.encode({\n                        type: Message.MessageType.DIAL_RESPONSE,\n                        dialResponse: {\n                            status: Message.ResponseStatus.E_BAD_REQUEST,\n                            statusText: 'peer id mismatch'\n                        }\n                    });\n                    return;\n                }\n                // get a list of multiaddrs to dial\n                const multiaddrs = peer.addrs\n                    .map(buf => multiaddr(buf))\n                    .filter(ma => {\n                    const isFromSameHost = ma.toOptions().host === data.connection.remoteAddr.toOptions().host;\n                    log.trace('request to dial %a was sent from %a is same host %s', ma, data.connection.remoteAddr, isFromSameHost);\n                    // skip any Multiaddrs where the target node's IP does not match the sending node's IP\n                    return isFromSameHost;\n                })\n                    .filter(ma => {\n                    const host = ma.toOptions().host;\n                    const isPublicIp = !(isPrivateIp(host) ?? false);\n                    log.trace('host %s was public %s', host, isPublicIp);\n                    // don't try to dial private addresses\n                    return isPublicIp;\n                })\n                    .filter(ma => {\n                    const host = ma.toOptions().host;\n                    const isNotOurHost = !ourHosts.includes(host);\n                    log.trace('host %s was not our host %s', host, isNotOurHost);\n                    // don't try to dial nodes on the same host as us\n                    return isNotOurHost;\n                })\n                    .filter(ma => {\n                    const isSupportedTransport = Boolean(self.components.transportManager.transportForMultiaddr(ma));\n                    log.trace('transport for %a is supported %s', ma, isSupportedTransport);\n                    // skip any Multiaddrs that have transports we do not support\n                    return isSupportedTransport;\n                })\n                    .map(ma => {\n                    if (ma.getPeerId() == null) {\n                        // make sure we have the PeerId as part of the Multiaddr\n                        ma = ma.encapsulate(`/p2p/${peerId.toString()}`);\n                    }\n                    return ma;\n                });\n                // make sure we have something to dial\n                if (multiaddrs.length === 0) {\n                    log('no valid multiaddrs for %p in message', peerId);\n                    yield Message.encode({\n                        type: Message.MessageType.DIAL_RESPONSE,\n                        dialResponse: {\n                            status: Message.ResponseStatus.E_DIAL_REFUSED,\n                            statusText: 'no dialable addresses'\n                        }\n                    });\n                    return;\n                }\n                log('dial multiaddrs %s for peer %p', multiaddrs.map(ma => ma.toString()).join(', '), peerId);\n                let errorMessage = '';\n                let lastMultiaddr = multiaddrs[0];\n                for await (const multiaddr of multiaddrs) {\n                    let connection;\n                    lastMultiaddr = multiaddr;\n                    try {\n                        connection = await self.components.connectionManager.openConnection(multiaddr, {\n                            signal\n                        });\n                        if (!connection.remoteAddr.equals(multiaddr)) {\n                            log.error('tried to dial %a but dialed %a', multiaddr, connection.remoteAddr);\n                            throw new Error('Unexpected remote address');\n                        }\n                        log('Success %p', peerId);\n                        yield Message.encode({\n                            type: Message.MessageType.DIAL_RESPONSE,\n                            dialResponse: {\n                                status: Message.ResponseStatus.OK,\n                                addr: connection.remoteAddr.decapsulateCode(protocols('p2p').code).bytes\n                            }\n                        });\n                        return;\n                    }\n                    catch (err) {\n                        log('could not dial %p', peerId, err);\n                        errorMessage = err.message;\n                    }\n                    finally {\n                        if (connection != null) {\n                            await connection.close();\n                        }\n                    }\n                }\n                yield Message.encode({\n                    type: Message.MessageType.DIAL_RESPONSE,\n                    dialResponse: {\n                        status: Message.ResponseStatus.E_DIAL_ERROR,\n                        statusText: errorMessage,\n                        addr: lastMultiaddr.bytes\n                    }\n                });\n            }, (source) => lp.encode(source), data.stream);\n        }\n        catch (err) {\n            log.error('error handling incoming autonat stream', err);\n        }\n        finally {\n            signal.removeEventListener('abort', onAbort);\n        }\n    }\n    _verifyExternalAddresses() {\n        void this.verifyExternalAddresses()\n            .catch(err => {\n            log.error('error verifying external address', err);\n        });\n    }\n    /**\n     * Our multicodec topology noticed a new peer that supports autonat\n     */\n    async verifyExternalAddresses() {\n        clearTimeout(this.verifyAddressTimeout);\n        // Do not try to push if we are not running\n        if (!this.isStarted()) {\n            return;\n        }\n        const addressManager = this.components.addressManager;\n        const multiaddrs = addressManager.getObservedAddrs()\n            .filter(ma => {\n            const options = ma.toOptions();\n            return !(isPrivateIp(options.host) ?? false);\n        });\n        if (multiaddrs.length === 0) {\n            log('no public addresses found, not requesting verification');\n            this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);\n            return;\n        }\n        const signal = AbortSignal.timeout(this.timeout);\n        // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning\n        // appearing in the console\n        try {\n            // fails on node < 15.4\n            setMaxListeners?.(Infinity, signal);\n        }\n        catch { }\n        const self = this;\n        try {\n            log('verify multiaddrs %s', multiaddrs.map(ma => ma.toString()).join(', '));\n            const request = Message.encode({\n                type: Message.MessageType.DIAL,\n                dial: {\n                    peer: {\n                        id: this.components.peerId.toBytes(),\n                        addrs: multiaddrs.map(map => map.bytes)\n                    }\n                }\n            });\n            // find some random peers\n            const randomPeer = await createEd25519PeerId();\n            const randomCid = randomPeer.toBytes();\n            const results = {};\n            const networkSegments = [];\n            const verifyAddress = async (peer) => {\n                let onAbort = () => { };\n                try {\n                    log('asking %p to verify multiaddr', peer.id);\n                    const connection = await self.components.connectionManager.openConnection(peer.id, {\n                        signal\n                    });\n                    const stream = await connection.newStream(this.protocol, {\n                        signal\n                    });\n                    onAbort = () => { stream.abort(new CodeError('verifyAddress timeout', codes.ERR_TIMEOUT)); };\n                    signal.addEventListener('abort', onAbort, { once: true });\n                    const buf = await pipe([request], (source) => lp.encode(source), stream, (source) => lp.decode(source), async (stream) => first(stream));\n                    if (buf == null) {\n                        log('no response received from %p', connection.remotePeer);\n                        return undefined;\n                    }\n                    const response = Message.decode(buf);\n                    if (response.type !== Message.MessageType.DIAL_RESPONSE || response.dialResponse == null) {\n                        log('invalid autonat response from %p', connection.remotePeer);\n                        return undefined;\n                    }\n                    if (response.dialResponse.status === Message.ResponseStatus.OK) {\n                        // make sure we use different network segments\n                        const options = connection.remoteAddr.toOptions();\n                        let segment;\n                        if (options.family === 4) {\n                            const octets = options.host.split('.');\n                            segment = octets[0];\n                        }\n                        else if (options.family === 6) {\n                            const octets = options.host.split(':');\n                            segment = octets[0];\n                        }\n                        else {\n                            log('remote address \"%s\" was not IP4 or IP6?', options.host);\n                            return undefined;\n                        }\n                        if (networkSegments.includes(segment)) {\n                            log('already have response from network segment %d - %s', segment, options.host);\n                            return undefined;\n                        }\n                        networkSegments.push(segment);\n                    }\n                    return response.dialResponse;\n                }\n                catch (err) {\n                    log.error('error asking remote to verify multiaddr', err);\n                }\n                finally {\n                    signal.removeEventListener('abort', onAbort);\n                }\n            };\n            for await (const dialResponse of parallel(map(this.components.peerRouting.getClosestPeers(randomCid, {\n                signal\n            }), (peer) => async () => verifyAddress(peer)), {\n                concurrency: REQUIRED_SUCCESSFUL_DIALS\n            })) {\n                try {\n                    if (dialResponse == null) {\n                        continue;\n                    }\n                    // they either told us which address worked/didn't work, or we only sent them one address\n                    const addr = dialResponse.addr == null ? multiaddrs[0] : multiaddr(dialResponse.addr);\n                    log('autonat response for %a is %s', addr, dialResponse.status);\n                    if (dialResponse.status === Message.ResponseStatus.E_BAD_REQUEST) {\n                        // the remote could not parse our request\n                        continue;\n                    }\n                    if (dialResponse.status === Message.ResponseStatus.E_DIAL_REFUSED) {\n                        // the remote could not honour our request\n                        continue;\n                    }\n                    if (dialResponse.addr == null && multiaddrs.length > 1) {\n                        // we sent the remote multiple addrs but they didn't tell us which ones worked/didn't work\n                        continue;\n                    }\n                    if (!multiaddrs.some(ma => ma.equals(addr))) {\n                        log('peer reported %a as %s but it was not in our observed address list', addr, dialResponse.status);\n                        continue;\n                    }\n                    const addrStr = addr.toString();\n                    if (results[addrStr] == null) {\n                        results[addrStr] = { success: 0, failure: 0 };\n                    }\n                    if (dialResponse.status === Message.ResponseStatus.OK) {\n                        results[addrStr].success++;\n                    }\n                    else if (dialResponse.status === Message.ResponseStatus.E_DIAL_ERROR) {\n                        results[addrStr].failure++;\n                    }\n                    if (results[addrStr].success === REQUIRED_SUCCESSFUL_DIALS) {\n                        // we are now convinced\n                        log('%a is externally dialable', addr);\n                        addressManager.confirmObservedAddr(addr);\n                        return;\n                    }\n                    if (results[addrStr].failure === REQUIRED_SUCCESSFUL_DIALS) {\n                        // we are now unconvinced\n                        log('%a is not externally dialable', addr);\n                        addressManager.removeObservedAddr(addr);\n                        return;\n                    }\n                }\n                catch (err) {\n                    log.error('could not verify external address', err);\n                }\n            }\n        }\n        finally {\n            this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);\n        }\n    }\n}\nexport function autoNATService(init = {}) {\n    return (components) => {\n        return new DefaultAutoNATService(components, init);\n    };\n}\n//# sourceMappingURL=index.js.map","const second = 1000;\nconst minute = 60 * second;\n/**\n * Delay before HOP relay service is advertised on the network\n */\nexport const ADVERTISE_BOOT_DELAY = 15 * minute;\n/**\n * Delay Between HOP relay service advertisements on the network\n */\nexport const ADVERTISE_TTL = 30 * minute;\n/**\n * Multicodec code\n */\nexport const CIRCUIT_PROTO_CODE = 290;\n/**\n * Relay HOP relay service namespace for discovery\n */\nexport const RELAY_RENDEZVOUS_NS = '/libp2p/relay';\n/**\n * The maximum number of relay reservations the relay server will accept\n */\nexport const DEFAULT_MAX_RESERVATION_STORE_SIZE = 15;\n/**\n * How often to check for reservation expiry\n */\nexport const DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second;\n/**\n * How often to check for reservation expiry\n */\nexport const DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;\nexport const DEFAULT_RESERVATION_CONCURRENCY = 1;\nexport const RELAY_SOURCE_TAG = 'circuit-relay-source';\nexport const RELAY_TAG = 'circuit-relay-relay';\n// circuit v2 connection limits\n// https://github.com/libp2p/go-libp2p/blob/master/p2p/protocol/circuitv2/relay/resources.go#L61-L66\n// 2 min is the default connection duration\nexport const DEFAULT_DURATION_LIMIT = 2 * minute;\n// 128k is the default data limit\nexport const DEFAULT_DATA_LIMIT = BigInt(1 << 17);\n/**\n * The hop protocol\n */\nexport const RELAY_V2_HOP_CODEC = '/libp2p/circuit/relay/0.2.0/hop';\n/**\n * the stop protocol\n */\nexport const RELAY_V2_STOP_CODEC = '/libp2p/circuit/relay/0.2.0/stop';\n/**\n * Hop messages must be exchanged inside this timeout\n */\nexport const DEFAULT_HOP_TIMEOUT = 30 * second;\n/**\n * How long to wait before starting to advertise the relay service\n */\nexport const DEFAULT_ADVERT_BOOT_DELAY = 30 * second;\n//# sourceMappingURL=constants.js.map","import { logger } from '@libp2p/logger';\nconst log = logger('libp2p:stream:converter');\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\nexport function streamToMaConnection(props) {\n    const { stream, remoteAddr } = props;\n    const { sink, source } = stream;\n    const mapSource = (async function* () {\n        for await (const list of source) {\n            if (list instanceof Uint8Array) {\n                yield list;\n            }\n            else {\n                yield* list;\n            }\n        }\n    }());\n    const maConn = {\n        async sink(source) {\n            try {\n                await sink(source);\n                close();\n            }\n            catch (err) {\n                // If aborted we can safely ignore\n                if (err.type !== 'aborted') {\n                    // If the source errored the socket will already have been destroyed by\n                    // toIterable.duplex(). If the socket errored it will already be\n                    // destroyed. There's nothing to do here except log the error & return.\n                    log(err);\n                }\n            }\n        },\n        source: mapSource,\n        remoteAddr,\n        timeline: { open: Date.now(), close: undefined },\n        async close(options) {\n            close();\n            await stream.close(options);\n        },\n        abort(err) {\n            close();\n            stream.abort(err);\n        }\n    };\n    function close() {\n        if (maConn.timeline.close == null) {\n            maConn.timeline.close = Date.now();\n        }\n    }\n    return maConn;\n}\n//# sourceMappingURL=stream-to-ma-conn.js.map","import { EventEmitter } from '@libp2p/interface/events';\nimport { logger } from '@libp2p/logger';\nimport { RELAY_RENDEZVOUS_NS, RELAY_V2_HOP_CODEC } from '../constants.js';\nimport { namespaceToCid } from '../utils.js';\nconst log = logger('libp2p:circuit-relay:discover-relays');\n/**\n * ReservationManager automatically makes a circuit v2 reservation on any connected\n * peers that support the circuit v2 HOP protocol.\n */\nexport class RelayDiscovery extends EventEmitter {\n    peerId;\n    peerStore;\n    contentRouting;\n    registrar;\n    started;\n    topologyId;\n    constructor(components) {\n        super();\n        this.started = false;\n        this.peerId = components.peerId;\n        this.peerStore = components.peerStore;\n        this.contentRouting = components.contentRouting;\n        this.registrar = components.registrar;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        // register a topology listener for when new peers are encountered\n        // that support the hop protocol\n        this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {\n            onConnect: (peerId) => {\n                this.safeDispatchEvent('relay:discover', { detail: peerId });\n            }\n        });\n        void this.discover()\n            .catch(err => {\n            log.error('error listening on relays', err);\n        });\n        this.started = true;\n    }\n    stop() {\n        if (this.topologyId != null) {\n            this.registrar.unregister(this.topologyId);\n        }\n        this.started = false;\n    }\n    /**\n     * Try to listen on available hop relay connections.\n     * The following order will happen while we do not have enough relays:\n     *\n     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected\n     * 2. Dial and try to listen on the peers we know that support hop but are not connected\n     * 3. Search the network\n     */\n    async discover() {\n        log('searching peer store for relays');\n        const peers = (await this.peerStore.all({\n            filters: [\n                // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on\n                (peer) => {\n                    return peer.protocols.includes(RELAY_V2_HOP_CODEC);\n                }\n            ],\n            orders: [\n                () => Math.random() < 0.5 ? 1 : -1\n            ]\n        }));\n        for (const peer of peers) {\n            log('found relay peer %p in content peer store', peer.id);\n            this.safeDispatchEvent('relay:discover', { detail: peer.id });\n        }\n        log('found %d relay peers in peer store', peers.length);\n        try {\n            log('searching content routing for relays');\n            const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);\n            let found = 0;\n            for await (const provider of this.contentRouting.findProviders(cid)) {\n                if (provider.multiaddrs.length > 0 && !provider.id.equals(this.peerId)) {\n                    const peerId = provider.id;\n                    found++;\n                    await this.peerStore.merge(peerId, {\n                        multiaddrs: provider.multiaddrs\n                    });\n                    log('found relay peer %p in content routing', peerId);\n                    this.safeDispatchEvent('relay:discover', { detail: peerId });\n                }\n            }\n            log('found %d relay peers in content routing', found);\n        }\n        catch (err) {\n            log.error('failed when finding relays on the network', err);\n        }\n    }\n}\n//# sourceMappingURL=discovery.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { EventEmitter } from '@libp2p/interface/events';\nimport { logger } from '@libp2p/logger';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nconst log = logger('libp2p:circuit-relay:transport:listener');\nclass CircuitRelayTransportListener extends EventEmitter {\n    connectionManager;\n    relayStore;\n    listeningAddrs;\n    constructor(components) {\n        super();\n        this.connectionManager = components.connectionManager;\n        this.relayStore = components.relayStore;\n        this.listeningAddrs = new PeerMap();\n        // remove listening addrs when a relay is removed\n        this.relayStore.addEventListener('relay:removed', (evt) => {\n            this.#removeRelayPeer(evt.detail);\n        });\n    }\n    async listen(addr) {\n        log('listen on %a', addr);\n        const relayPeerStr = addr.getPeerId();\n        let relayConn;\n        // check if we already have a connection to the relay\n        if (relayPeerStr != null) {\n            const relayPeer = peerIdFromString(relayPeerStr);\n            const connections = this.connectionManager.getConnectionsMap().get(relayPeer) ?? [];\n            if (connections.length > 0) {\n                relayConn = connections[0];\n            }\n        }\n        // open a new connection as we don't already have one\n        if (relayConn == null) {\n            const addrString = addr.toString().split('/p2p-circuit').find(a => a !== '');\n            const ma = multiaddr(addrString);\n            relayConn = await this.connectionManager.openConnection(ma);\n        }\n        if (!this.relayStore.hasReservation(relayConn.remotePeer)) {\n            // addRelay calls transportManager.listen which calls this listen method\n            await this.relayStore.addRelay(relayConn.remotePeer, 'configured');\n            return;\n        }\n        const reservation = this.relayStore.getReservation(relayConn.remotePeer);\n        if (reservation == null) {\n            throw new CodeError('Did not have reservation after making reservation', 'ERR_NO_RESERVATION');\n        }\n        if (this.listeningAddrs.has(relayConn.remotePeer)) {\n            log('already listening on relay %p', relayConn.remotePeer);\n            return;\n        }\n        // add all addresses from the relay reservation\n        this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map(buf => {\n            return multiaddr(buf).encapsulate('/p2p-circuit');\n        }));\n        this.safeDispatchEvent('listening', {});\n    }\n    getAddrs() {\n        return [...this.listeningAddrs.values()].flat();\n    }\n    async close() {\n    }\n    #removeRelayPeer(peerId) {\n        const had = this.listeningAddrs.has(peerId);\n        log('relay peer removed %p - had reservation', peerId, had);\n        this.listeningAddrs.delete(peerId);\n        if (had) {\n            // Announce listen addresses change\n            this.safeDispatchEvent('close', {});\n        }\n    }\n}\nexport function createListener(options) {\n    return new CircuitRelayTransportListener(options);\n}\n//# sourceMappingURL=listener.js.map","import { EventEmitter } from '@libp2p/interface/events';\nimport { logger } from '@libp2p/logger';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { pbStream } from 'it-protobuf-stream';\nimport { PeerJobQueue } from '../../utils/peer-job-queue.js';\nimport { DEFAULT_RESERVATION_CONCURRENCY, RELAY_TAG, RELAY_V2_HOP_CODEC } from '../constants.js';\nimport { HopMessage, Status } from '../pb/index.js';\nimport { getExpirationMilliseconds } from '../utils.js';\nconst log = logger('libp2p:circuit-relay:transport:reservation-store');\n// allow refreshing a relay reservation if it will expire in the next 10 minutes\nconst REFRESH_WINDOW = (60 * 1000) * 10;\n// try to refresh relay reservations 5 minutes before expiry\nconst REFRESH_TIMEOUT = (60 * 1000) * 5;\n// minimum duration before which a reservation must not be refreshed\nconst REFRESH_TIMEOUT_MIN = 30 * 1000;\nexport class ReservationStore extends EventEmitter {\n    peerId;\n    connectionManager;\n    transportManager;\n    peerStore;\n    events;\n    reserveQueue;\n    reservations;\n    maxDiscoveredRelays;\n    maxReservationQueueLength;\n    reservationCompletionTimeout;\n    started;\n    constructor(components, init) {\n        super();\n        this.peerId = components.peerId;\n        this.connectionManager = components.connectionManager;\n        this.transportManager = components.transportManager;\n        this.peerStore = components.peerStore;\n        this.events = components.events;\n        this.reservations = new PeerMap();\n        this.maxDiscoveredRelays = init?.discoverRelays ?? 0;\n        this.maxReservationQueueLength = init?.maxReservationQueueLength ?? 100;\n        this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? 10000;\n        this.started = false;\n        // ensure we don't listen on multiple relays simultaneously\n        this.reserveQueue = new PeerJobQueue({\n            concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY\n        });\n        // When a peer disconnects, if we had a reservation on that peer\n        // remove the reservation and multiaddr and maybe trigger search\n        // for new relays\n        this.events.addEventListener('peer:disconnect', (evt) => {\n            this.#removeRelay(evt.detail);\n        });\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        this.started = true;\n    }\n    async stop() {\n        this.reserveQueue.clear();\n        this.reservations.forEach(({ timeout }) => {\n            clearTimeout(timeout);\n        });\n        this.reservations.clear();\n        this.started = false;\n    }\n    /**\n     * If the number of current relays is beneath the configured `maxReservations`\n     * value, and the passed peer id is not our own, and we have a non-relayed connection\n     * to the remote, and the remote peer speaks the hop protocol, try to reserve a slot\n     * on the remote peer\n     */\n    async addRelay(peerId, type) {\n        if (this.peerId.equals(peerId)) {\n            log('not trying to use self as relay');\n            return;\n        }\n        if (this.reserveQueue.size > this.maxReservationQueueLength) {\n            log('not adding relay as the queue is full');\n            return;\n        }\n        if (this.reserveQueue.hasJob(peerId)) {\n            log('relay peer is already in the reservation queue');\n            return;\n        }\n        log('add relay %p', peerId);\n        await this.reserveQueue.add(async () => {\n            try {\n                // allow refresh of an existing reservation if it is about to expire\n                const existingReservation = this.reservations.get(peerId);\n                if (existingReservation != null) {\n                    if (getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {\n                        log('already have reservation on relay peer %p and it expires in more than 10 minutes', peerId);\n                        return;\n                    }\n                    clearTimeout(existingReservation.timeout);\n                    this.reservations.delete(peerId);\n                }\n                if (type === 'discovered' && [...this.reservations.values()].reduce((acc, curr) => {\n                    if (curr.type === 'discovered') {\n                        acc++;\n                    }\n                    return acc;\n                }, 0) >= this.maxDiscoveredRelays) {\n                    log('already have enough discovered relays');\n                    return;\n                }\n                const signal = AbortSignal.timeout(this.reservationCompletionTimeout);\n                const connection = await this.connectionManager.openConnection(peerId, {\n                    signal\n                });\n                if (connection.remoteAddr.protoNames().includes('p2p-circuit')) {\n                    log('not creating reservation over relayed connection');\n                    return;\n                }\n                const reservation = await this.#createReservation(connection, {\n                    signal\n                });\n                log('created reservation on relay peer %p', peerId);\n                const expiration = getExpirationMilliseconds(reservation.expire);\n                // sets a lower bound on the timeout, and also don't let it go over\n                // 2^31 - 1 (setTimeout will only accept signed 32 bit integers)\n                const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);\n                const timeout = setTimeout(() => {\n                    this.addRelay(peerId, type).catch(err => {\n                        log.error('could not refresh reservation to relay %p', peerId, err);\n                    });\n                }, timeoutDuration);\n                // we've managed to create a reservation successfully\n                this.reservations.set(peerId, {\n                    timeout,\n                    reservation,\n                    type\n                });\n                // ensure we don't close the connection to the relay\n                await this.peerStore.merge(peerId, {\n                    tags: {\n                        [RELAY_TAG]: {\n                            value: 1,\n                            ttl: expiration\n                        }\n                    }\n                });\n                // listen on multiaddr that only the circuit transport is listening for\n                await this.transportManager.listen([multiaddr(`/p2p/${peerId.toString()}/p2p-circuit`)]);\n            }\n            catch (err) {\n                log.error('could not reserve slot on %p', peerId, err);\n                // cancel the renewal timeout if it's been set\n                const reservation = this.reservations.get(peerId);\n                if (reservation != null) {\n                    clearTimeout(reservation.timeout);\n                }\n                // if listening failed, remove the reservation\n                this.reservations.delete(peerId);\n            }\n        }, {\n            peerId\n        });\n    }\n    hasReservation(peerId) {\n        return this.reservations.has(peerId);\n    }\n    getReservation(peerId) {\n        return this.reservations.get(peerId)?.reservation;\n    }\n    async #createReservation(connection, options) {\n        options.signal?.throwIfAborted();\n        log('requesting reservation from %p', connection.remotePeer);\n        const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options);\n        const pbstr = pbStream(stream);\n        const hopstr = pbstr.pb(HopMessage);\n        await hopstr.write({ type: HopMessage.Type.RESERVE }, options);\n        let response;\n        try {\n            response = await hopstr.read(options);\n        }\n        catch (err) {\n            log.error('error parsing reserve message response from %p because', connection.remotePeer, err);\n            throw err;\n        }\n        finally {\n            await stream.close();\n        }\n        if (response.status === Status.OK && (response.reservation != null)) {\n            return response.reservation;\n        }\n        const errMsg = `reservation failed with status ${response.status ?? 'undefined'}`;\n        log.error(errMsg);\n        throw new Error(errMsg);\n    }\n    /**\n     * Remove listen relay\n     */\n    #removeRelay(peerId) {\n        const existingReservation = this.reservations.get(peerId);\n        if (existingReservation == null) {\n            return;\n        }\n        log('connection to relay %p closed, removing reservation from local store', peerId);\n        clearTimeout(existingReservation.timeout);\n        this.reservations.delete(peerId);\n        this.safeDispatchEvent('relay:removed', { detail: peerId });\n        if (this.reservations.size < this.maxDiscoveredRelays) {\n            log('not enough relays %d/%d', this.reservations.size, this.maxDiscoveredRelays);\n            this.safeDispatchEvent('relay:not-enough-relays', {});\n        }\n    }\n}\n//# sourceMappingURL=reservation-store.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/transport';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id';\nimport { streamToMaConnection } from '@libp2p/utils/stream-to-ma-conn';\nimport * as mafmt from '@multiformats/mafmt';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { pbStream } from 'it-protobuf-stream';\nimport { MAX_CONNECTIONS } from '../../connection-manager/constants.js';\nimport { codes } from '../../errors.js';\nimport { CIRCUIT_PROTO_CODE, RELAY_V2_HOP_CODEC, RELAY_V2_STOP_CODEC } from '../constants.js';\nimport { StopMessage, HopMessage, Status } from '../pb/index.js';\nimport { RelayDiscovery } from './discovery.js';\nimport { createListener } from './listener.js';\nimport { ReservationStore } from './reservation-store.js';\nconst log = logger('libp2p:circuit-relay:transport');\nconst isValidStop = (request) => {\n    if (request.peer == null) {\n        return false;\n    }\n    try {\n        request.peer.addrs.forEach(multiaddr);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\nconst defaults = {\n    maxInboundStopStreams: MAX_CONNECTIONS,\n    maxOutboundStopStreams: MAX_CONNECTIONS,\n    stopTimeout: 30000\n};\nclass CircuitRelayTransport {\n    discovery;\n    registrar;\n    peerStore;\n    connectionManager;\n    peerId;\n    upgrader;\n    addressManager;\n    connectionGater;\n    reservationStore;\n    maxInboundStopStreams;\n    maxOutboundStopStreams;\n    stopTimeout;\n    started;\n    constructor(components, init) {\n        this.registrar = components.registrar;\n        this.peerStore = components.peerStore;\n        this.connectionManager = components.connectionManager;\n        this.peerId = components.peerId;\n        this.upgrader = components.upgrader;\n        this.addressManager = components.addressManager;\n        this.connectionGater = components.connectionGater;\n        this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams;\n        this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;\n        this.stopTimeout = init.stopTimeout ?? defaults.stopTimeout;\n        if (init.discoverRelays != null && init.discoverRelays > 0) {\n            this.discovery = new RelayDiscovery(components);\n            this.discovery.addEventListener('relay:discover', (evt) => {\n                this.reservationStore.addRelay(evt.detail, 'discovered')\n                    .catch(err => {\n                    log.error('could not add discovered relay %p', evt.detail, err);\n                });\n            });\n        }\n        this.reservationStore = new ReservationStore(components, init);\n        this.reservationStore.addEventListener('relay:not-enough-relays', () => {\n            this.discovery?.discover()\n                .catch(err => {\n                log.error('could not discover relays', err);\n            });\n        });\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        await this.reservationStore.start();\n        await this.discovery?.start();\n        await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {\n            void this.onStop(data).catch(err => {\n                log.error('error while handling STOP protocol', err);\n                data.stream.abort(err);\n            });\n        }, {\n            maxInboundStreams: this.maxInboundStopStreams,\n            maxOutboundStreams: this.maxOutboundStopStreams,\n            runOnTransientConnection: true\n        });\n        this.started = true;\n    }\n    async stop() {\n        this.discovery?.stop();\n        await this.reservationStore.stop();\n        await this.registrar.unhandle(RELAY_V2_STOP_CODEC);\n        this.started = false;\n    }\n    [symbol] = true;\n    [Symbol.toStringTag] = 'libp2p/circuit-relay-v2';\n    /**\n     * Dial a peer over a relay\n     */\n    async dial(ma, options = {}) {\n        if (ma.protoCodes().filter(code => code === CIRCUIT_PROTO_CODE).length !== 1) {\n            const errMsg = 'Invalid circuit relay address';\n            log.error(errMsg, ma);\n            throw new CodeError(errMsg, codes.ERR_RELAYED_DIAL);\n        }\n        // Check the multiaddr to see if it contains a relay and a destination peer\n        const addrs = ma.toString().split('/p2p-circuit');\n        const relayAddr = multiaddr(addrs[0]);\n        const destinationAddr = multiaddr(addrs[addrs.length - 1]);\n        const relayId = relayAddr.getPeerId();\n        const destinationId = destinationAddr.getPeerId();\n        if (relayId == null || destinationId == null) {\n            const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`;\n            log.error(errMsg);\n            throw new CodeError(errMsg, codes.ERR_RELAYED_DIAL);\n        }\n        const relayPeer = peerIdFromString(relayId);\n        const destinationPeer = peerIdFromString(destinationId);\n        let disconnectOnFailure = false;\n        const relayConnections = this.connectionManager.getConnections(relayPeer);\n        let relayConnection = relayConnections[0];\n        if (relayConnection == null) {\n            await this.peerStore.merge(relayPeer, {\n                multiaddrs: [relayAddr]\n            });\n            relayConnection = await this.connectionManager.openConnection(relayPeer, options);\n            disconnectOnFailure = true;\n        }\n        let stream;\n        try {\n            stream = await relayConnection.newStream([RELAY_V2_HOP_CODEC]);\n            return await this.connectV2({\n                stream,\n                connection: relayConnection,\n                destinationPeer,\n                destinationAddr,\n                relayAddr,\n                ma,\n                disconnectOnFailure\n            });\n        }\n        catch (err) {\n            log.error('circuit relay dial to destination %p via relay %p failed', destinationPeer, relayPeer, err);\n            if (stream != null) {\n                stream.abort(err);\n            }\n            disconnectOnFailure && await relayConnection.close();\n            throw err;\n        }\n    }\n    async connectV2({ stream, connection, destinationPeer, destinationAddr, relayAddr, ma, disconnectOnFailure }) {\n        try {\n            const pbstr = pbStream(stream);\n            const hopstr = pbstr.pb(HopMessage);\n            await hopstr.write({\n                type: HopMessage.Type.CONNECT,\n                peer: {\n                    id: destinationPeer.toBytes(),\n                    addrs: [multiaddr(destinationAddr).bytes]\n                }\n            });\n            const status = await hopstr.read();\n            if (status.status !== Status.OK) {\n                throw new CodeError(`failed to connect via relay with status ${status?.status?.toString() ?? 'undefined'}`, codes.ERR_HOP_REQUEST_FAILED);\n            }\n            const maConn = streamToMaConnection({\n                stream: pbstr.unwrap(),\n                remoteAddr: ma,\n                localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`)\n            });\n            log('new outbound transient connection %a', maConn.remoteAddr);\n            return await this.upgrader.upgradeOutbound(maConn, {\n                transient: true\n            });\n        }\n        catch (err) {\n            log.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err);\n            disconnectOnFailure && await connection.close();\n            throw err;\n        }\n    }\n    /**\n     * Create a listener\n     */\n    createListener(options) {\n        return createListener({\n            connectionManager: this.connectionManager,\n            relayStore: this.reservationStore\n        });\n    }\n    /**\n     * Filter check for all Multiaddrs that this transport can dial on\n     *\n     * @param {Multiaddr[]} multiaddrs\n     * @returns {Multiaddr[]}\n     */\n    filter(multiaddrs) {\n        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n        return multiaddrs.filter((ma) => {\n            return mafmt.Circuit.matches(ma);\n        });\n    }\n    /**\n     * An incoming STOP request means a remote peer wants to dial us via a relay\n     */\n    async onStop({ connection, stream }) {\n        const signal = AbortSignal.timeout(this.stopTimeout);\n        const pbstr = pbStream(stream).pb(StopMessage);\n        const request = await pbstr.read({\n            signal\n        });\n        log('new circuit relay v2 stop stream from %p with type %s', connection.remotePeer, request.type);\n        if (request?.type === undefined) {\n            log.error('type was missing from circuit v2 stop protocol request from %s', connection.remotePeer);\n            await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n                signal\n            });\n            await stream.close();\n            return;\n        }\n        // Validate the STOP request has the required input\n        if (request.type !== StopMessage.Type.CONNECT) {\n            log.error('invalid stop connect request via peer %p', connection.remotePeer);\n            await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {\n                signal\n            });\n            await stream.close();\n            return;\n        }\n        if (!isValidStop(request)) {\n            log.error('invalid stop connect request via peer %p', connection.remotePeer);\n            await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n                signal\n            });\n            await stream.close();\n            return;\n        }\n        const remotePeerId = peerIdFromBytes(request.peer.id);\n        if ((await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId)) === true) {\n            log.error('connection gater denied inbound relayed connection from %p', connection.remotePeer);\n            await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {\n                signal\n            });\n            await stream.close();\n            return;\n        }\n        log.trace('sending success response to %p', connection.remotePeer);\n        await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {\n            signal\n        });\n        const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);\n        const localAddr = this.addressManager.getAddresses()[0];\n        const maConn = streamToMaConnection({\n            stream: pbstr.unwrap().unwrap(),\n            remoteAddr,\n            localAddr\n        });\n        log('new inbound transient connection %a', maConn.remoteAddr);\n        await this.upgrader.upgradeInbound(maConn, {\n            transient: true\n        });\n        log('%s connection %a upgraded', 'inbound', maConn.remoteAddr);\n    }\n}\nexport function circuitRelayTransport(init = {}) {\n    return (components) => {\n        return new CircuitRelayTransport(components, init);\n    };\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var HopMessage;\n(function (HopMessage) {\n    let Type;\n    (function (Type) {\n        Type[\"RESERVE\"] = \"RESERVE\";\n        Type[\"CONNECT\"] = \"CONNECT\";\n        Type[\"STATUS\"] = \"STATUS\";\n    })(Type = HopMessage.Type || (HopMessage.Type = {}));\n    let __TypeValues;\n    (function (__TypeValues) {\n        __TypeValues[__TypeValues[\"RESERVE\"] = 0] = \"RESERVE\";\n        __TypeValues[__TypeValues[\"CONNECT\"] = 1] = \"CONNECT\";\n        __TypeValues[__TypeValues[\"STATUS\"] = 2] = \"STATUS\";\n    })(__TypeValues || (__TypeValues = {}));\n    (function (Type) {\n        Type.codec = () => {\n            return enumeration(__TypeValues);\n        };\n    })(Type = HopMessage.Type || (HopMessage.Type = {}));\n    let _codec;\n    HopMessage.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.type != null) {\n                    w.uint32(8);\n                    HopMessage.Type.codec().encode(obj.type, w);\n                }\n                if (obj.peer != null) {\n                    w.uint32(18);\n                    Peer.codec().encode(obj.peer, w);\n                }\n                if (obj.reservation != null) {\n                    w.uint32(26);\n                    Reservation.codec().encode(obj.reservation, w);\n                }\n                if (obj.limit != null) {\n                    w.uint32(34);\n                    Limit.codec().encode(obj.limit, w);\n                }\n                if (obj.status != null) {\n                    w.uint32(40);\n                    Status.codec().encode(obj.status, w);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.type = HopMessage.Type.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.peer = Peer.codec().decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            obj.reservation = Reservation.codec().decode(reader, reader.uint32());\n                            break;\n                        case 4:\n                            obj.limit = Limit.codec().decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            obj.status = Status.codec().decode(reader);\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    HopMessage.encode = (obj) => {\n        return encodeMessage(obj, HopMessage.codec());\n    };\n    HopMessage.decode = (buf) => {\n        return decodeMessage(buf, HopMessage.codec());\n    };\n})(HopMessage || (HopMessage = {}));\nexport var StopMessage;\n(function (StopMessage) {\n    let Type;\n    (function (Type) {\n        Type[\"CONNECT\"] = \"CONNECT\";\n        Type[\"STATUS\"] = \"STATUS\";\n    })(Type = StopMessage.Type || (StopMessage.Type = {}));\n    let __TypeValues;\n    (function (__TypeValues) {\n        __TypeValues[__TypeValues[\"CONNECT\"] = 0] = \"CONNECT\";\n        __TypeValues[__TypeValues[\"STATUS\"] = 1] = \"STATUS\";\n    })(__TypeValues || (__TypeValues = {}));\n    (function (Type) {\n        Type.codec = () => {\n            return enumeration(__TypeValues);\n        };\n    })(Type = StopMessage.Type || (StopMessage.Type = {}));\n    let _codec;\n    StopMessage.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.type != null) {\n                    w.uint32(8);\n                    StopMessage.Type.codec().encode(obj.type, w);\n                }\n                if (obj.peer != null) {\n                    w.uint32(18);\n                    Peer.codec().encode(obj.peer, w);\n                }\n                if (obj.limit != null) {\n                    w.uint32(26);\n                    Limit.codec().encode(obj.limit, w);\n                }\n                if (obj.status != null) {\n                    w.uint32(32);\n                    Status.codec().encode(obj.status, w);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.type = StopMessage.Type.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.peer = Peer.codec().decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            obj.limit = Limit.codec().decode(reader, reader.uint32());\n                            break;\n                        case 4:\n                            obj.status = Status.codec().decode(reader);\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    StopMessage.encode = (obj) => {\n        return encodeMessage(obj, StopMessage.codec());\n    };\n    StopMessage.decode = (buf) => {\n        return decodeMessage(buf, StopMessage.codec());\n    };\n})(StopMessage || (StopMessage = {}));\nexport var Peer;\n(function (Peer) {\n    let _codec;\n    Peer.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.id != null && obj.id.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.id);\n                }\n                if (obj.addrs != null) {\n                    for (const value of obj.addrs) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    id: new Uint8Array(0),\n                    addrs: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.id = reader.bytes();\n                            break;\n                        case 2:\n                            obj.addrs.push(reader.bytes());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Peer.encode = (obj) => {\n        return encodeMessage(obj, Peer.codec());\n    };\n    Peer.decode = (buf) => {\n        return decodeMessage(buf, Peer.codec());\n    };\n})(Peer || (Peer = {}));\nexport var Reservation;\n(function (Reservation) {\n    let _codec;\n    Reservation.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.expire != null && obj.expire !== 0n)) {\n                    w.uint32(8);\n                    w.uint64(obj.expire);\n                }\n                if (obj.addrs != null) {\n                    for (const value of obj.addrs) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (obj.voucher != null) {\n                    w.uint32(26);\n                    w.bytes(obj.voucher);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    expire: 0n,\n                    addrs: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.expire = reader.uint64();\n                            break;\n                        case 2:\n                            obj.addrs.push(reader.bytes());\n                            break;\n                        case 3:\n                            obj.voucher = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Reservation.encode = (obj) => {\n        return encodeMessage(obj, Reservation.codec());\n    };\n    Reservation.decode = (buf) => {\n        return decodeMessage(buf, Reservation.codec());\n    };\n})(Reservation || (Reservation = {}));\nexport var Limit;\n(function (Limit) {\n    let _codec;\n    Limit.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.duration != null) {\n                    w.uint32(8);\n                    w.uint32(obj.duration);\n                }\n                if (obj.data != null) {\n                    w.uint32(16);\n                    w.uint64(obj.data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.duration = reader.uint32();\n                            break;\n                        case 2:\n                            obj.data = reader.uint64();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Limit.encode = (obj) => {\n        return encodeMessage(obj, Limit.codec());\n    };\n    Limit.decode = (buf) => {\n        return decodeMessage(buf, Limit.codec());\n    };\n})(Limit || (Limit = {}));\nexport var Status;\n(function (Status) {\n    Status[\"UNUSED\"] = \"UNUSED\";\n    Status[\"OK\"] = \"OK\";\n    Status[\"RESERVATION_REFUSED\"] = \"RESERVATION_REFUSED\";\n    Status[\"RESOURCE_LIMIT_EXCEEDED\"] = \"RESOURCE_LIMIT_EXCEEDED\";\n    Status[\"PERMISSION_DENIED\"] = \"PERMISSION_DENIED\";\n    Status[\"CONNECTION_FAILED\"] = \"CONNECTION_FAILED\";\n    Status[\"NO_RESERVATION\"] = \"NO_RESERVATION\";\n    Status[\"MALFORMED_MESSAGE\"] = \"MALFORMED_MESSAGE\";\n    Status[\"UNEXPECTED_MESSAGE\"] = \"UNEXPECTED_MESSAGE\";\n})(Status || (Status = {}));\nvar __StatusValues;\n(function (__StatusValues) {\n    __StatusValues[__StatusValues[\"UNUSED\"] = 0] = \"UNUSED\";\n    __StatusValues[__StatusValues[\"OK\"] = 100] = \"OK\";\n    __StatusValues[__StatusValues[\"RESERVATION_REFUSED\"] = 200] = \"RESERVATION_REFUSED\";\n    __StatusValues[__StatusValues[\"RESOURCE_LIMIT_EXCEEDED\"] = 201] = \"RESOURCE_LIMIT_EXCEEDED\";\n    __StatusValues[__StatusValues[\"PERMISSION_DENIED\"] = 202] = \"PERMISSION_DENIED\";\n    __StatusValues[__StatusValues[\"CONNECTION_FAILED\"] = 203] = \"CONNECTION_FAILED\";\n    __StatusValues[__StatusValues[\"NO_RESERVATION\"] = 204] = \"NO_RESERVATION\";\n    __StatusValues[__StatusValues[\"MALFORMED_MESSAGE\"] = 400] = \"MALFORMED_MESSAGE\";\n    __StatusValues[__StatusValues[\"UNEXPECTED_MESSAGE\"] = 401] = \"UNEXPECTED_MESSAGE\";\n})(__StatusValues || (__StatusValues = {}));\n(function (Status) {\n    Status.codec = () => {\n        return enumeration(__StatusValues);\n    };\n})(Status || (Status = {}));\nexport var ReservationVoucher;\n(function (ReservationVoucher) {\n    let _codec;\n    ReservationVoucher.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.relay != null && obj.relay.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.relay);\n                }\n                if ((obj.peer != null && obj.peer.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.peer);\n                }\n                if ((obj.expiration != null && obj.expiration !== 0n)) {\n                    w.uint32(24);\n                    w.uint64(obj.expiration);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    relay: new Uint8Array(0),\n                    peer: new Uint8Array(0),\n                    expiration: 0n\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.relay = reader.bytes();\n                            break;\n                        case 2:\n                            obj.peer = reader.bytes();\n                            break;\n                        case 3:\n                            obj.expiration = reader.uint64();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    ReservationVoucher.encode = (obj) => {\n        return encodeMessage(obj, ReservationVoucher.codec());\n    };\n    ReservationVoucher.decode = (buf) => {\n        return decodeMessage(buf, ReservationVoucher.codec());\n    };\n})(ReservationVoucher || (ReservationVoucher = {}));\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { anySignal } from 'any-signal';\nimport { CID } from 'multiformats/cid';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { codes } from '../errors.js';\nimport { DEFAULT_DATA_LIMIT, DEFAULT_DURATION_LIMIT } from './constants.js';\nconst log = logger('libp2p:circuit-relay:utils');\nasync function* countStreamBytes(source, limit) {\n    for await (const buf of source) {\n        const len = BigInt(buf.byteLength);\n        if ((limit.remaining - len) < 0) {\n            // this is a safe downcast since len is guarantee to be in the range for a number\n            const remaining = Number(limit.remaining);\n            limit.remaining = 0n;\n            try {\n                if (remaining !== 0) {\n                    yield buf.subarray(0, remaining);\n                }\n            }\n            catch (err) {\n                log.error(err);\n            }\n            throw new Error('data limit exceeded');\n        }\n        limit.remaining -= len;\n        yield buf;\n    }\n}\nconst doRelay = (src, dst, abortSignal, limit) => {\n    function abortStreams(err) {\n        src.abort(err);\n        dst.abort(err);\n        clearTimeout(timeout);\n    }\n    const abortController = new AbortController();\n    const signal = anySignal([abortSignal, abortController.signal]);\n    const timeout = setTimeout(() => {\n        abortController.abort();\n    }, limit.duration);\n    let srcDstFinished = false;\n    let dstSrcFinished = false;\n    const dataLimit = {\n        remaining: limit.data\n    };\n    queueMicrotask(() => {\n        const onAbort = () => {\n            dst.abort(new CodeError('duration limit exceeded', codes.ERR_TIMEOUT));\n        };\n        signal.addEventListener('abort', onAbort, { once: true });\n        void dst.sink(countStreamBytes(src.source, dataLimit))\n            .catch(err => {\n            log.error('error while relaying streams src -> dst', err);\n            abortStreams(err);\n        })\n            .finally(() => {\n            srcDstFinished = true;\n            if (dstSrcFinished) {\n                signal.removeEventListener('abort', onAbort);\n                signal.clear();\n                clearTimeout(timeout);\n            }\n        });\n    });\n    queueMicrotask(() => {\n        const onAbort = () => {\n            src.abort(new CodeError('duration limit exceeded', codes.ERR_TIMEOUT));\n        };\n        signal.addEventListener('abort', onAbort, { once: true });\n        void src.sink(countStreamBytes(dst.source, dataLimit))\n            .catch(err => {\n            log.error('error while relaying streams dst -> src', err);\n            abortStreams(err);\n        })\n            .finally(() => {\n            dstSrcFinished = true;\n            if (srcDstFinished) {\n                signal.removeEventListener('abort', onAbort);\n                signal.clear();\n                clearTimeout(timeout);\n            }\n        });\n    });\n};\nexport function createLimitedRelay(source, destination, abortSignal, limit) {\n    const dataLimit = limit?.data ?? BigInt(DEFAULT_DATA_LIMIT);\n    const durationLimit = limit?.duration ?? DEFAULT_DURATION_LIMIT;\n    doRelay(source, destination, abortSignal, {\n        data: dataLimit,\n        duration: durationLimit\n    });\n}\n/**\n * Convert a namespace string into a cid\n */\nexport async function namespaceToCid(namespace) {\n    const bytes = new TextEncoder().encode(namespace);\n    const hash = await sha256.digest(bytes);\n    return CID.createV0(hash);\n}\n/**\n * returns number of ms between now and expiration time\n */\nexport function getExpirationMilliseconds(expireTimeSeconds) {\n    const expireTimeMillis = expireTimeSeconds * BigInt(1000);\n    const currentTime = new Date().getTime();\n    // downcast to number to use with setTimeout\n    return Number(expireTimeMillis - BigInt(currentTime));\n}\n//# sourceMappingURL=utils.js.map","/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */\nexport const DIAL_TIMEOUT = 30e3;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundUpgradeTimeout\n */\nexport const INBOUND_UPGRADE_TIMEOUT = 30e3;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */\nexport const MAX_PEER_ADDRS_TO_DIAL = 25;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDialsPerPeer\n */\nexport const MAX_PARALLEL_DIALS_PER_PEER = 1;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialInterval\n */\nexport const AUTO_DIAL_INTERVAL = 5000;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialConcurrency\n */\nexport const AUTO_DIAL_CONCURRENCY = 25;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialPriority\n */\nexport const AUTO_DIAL_PRIORITY = 0;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialMaxQueueLength\n */\nexport const AUTO_DIAL_MAX_QUEUE_LENGTH = 100;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialDiscoveredPeersDebounce\n */\nexport const AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */\nexport const INBOUND_CONNECTION_THRESHOLD = 5;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */\nexport const MAX_INCOMING_PENDING_CONNECTIONS = 10;\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempted failed with the relevant\n * peer stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */\nexport const LAST_DIAL_FAILURE_KEY = 'last-dial-failure';\n//# sourceMappingURL=constants.defaults.js.map","// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst clearMethods = new WeakMap();\n\nexport function createDelay({clearTimeout: defaultClear, setTimeout: defaultSet} = {}) {\n\t// We cannot use `async` here as we need the promise identity.\n\treturn (milliseconds, {value, signal} = {}) => {\n\t\t// TODO: Use `signal?.throwIfAborted()` when targeting Node.js 18.\n\t\tif (signal?.aborted) {\n\t\t\treturn Promise.reject(createAbortError());\n\t\t}\n\n\t\tlet timeoutId;\n\t\tlet settle;\n\t\tlet rejectFunction;\n\t\tconst clear = defaultClear ?? clearTimeout;\n\n\t\tconst signalListener = () => {\n\t\t\tclear(timeoutId);\n\t\t\trejectFunction(createAbortError());\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t\t}\n\t\t};\n\n\t\tconst delayPromise = new Promise((resolve, reject) => {\n\t\t\tsettle = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(value);\n\t\t\t};\n\n\t\t\trejectFunction = reject;\n\t\t\ttimeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);\n\t\t});\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tclearMethods.set(delayPromise, () => {\n\t\t\tclear(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t\tsettle();\n\t\t});\n\n\t\treturn delayPromise;\n\t};\n}\n\nconst delay = createDelay();\n\nexport default delay;\n\nexport async function rangeDelay(minimum, maximum, options = {}) {\n\treturn delay(randomInteger(minimum, maximum), options);\n}\n\nexport function clearDelay(promise) {\n\tclearMethods.get(promise)?.();\n}\n","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var HolePunch;\n(function (HolePunch) {\n    let Type;\n    (function (Type) {\n        Type[\"UNUSED\"] = \"UNUSED\";\n        Type[\"CONNECT\"] = \"CONNECT\";\n        Type[\"SYNC\"] = \"SYNC\";\n    })(Type = HolePunch.Type || (HolePunch.Type = {}));\n    let __TypeValues;\n    (function (__TypeValues) {\n        __TypeValues[__TypeValues[\"UNUSED\"] = 0] = \"UNUSED\";\n        __TypeValues[__TypeValues[\"CONNECT\"] = 100] = \"CONNECT\";\n        __TypeValues[__TypeValues[\"SYNC\"] = 300] = \"SYNC\";\n    })(__TypeValues || (__TypeValues = {}));\n    (function (Type) {\n        Type.codec = () => {\n            return enumeration(__TypeValues);\n        };\n    })(Type = HolePunch.Type || (HolePunch.Type = {}));\n    let _codec;\n    HolePunch.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.type != null) {\n                    w.uint32(8);\n                    HolePunch.Type.codec().encode(obj.type, w);\n                }\n                if (obj.observedAddresses != null) {\n                    for (const value of obj.observedAddresses) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    observedAddresses: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.type = HolePunch.Type.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.observedAddresses.push(reader.bytes());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    HolePunch.encode = (obj) => {\n        return encodeMessage(obj, HolePunch.codec());\n    };\n    HolePunch.decode = (buf) => {\n        return decodeMessage(buf, HolePunch.codec());\n    };\n})(HolePunch || (HolePunch = {}));\n//# sourceMappingURL=message.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { Circuit, IP, DNS } from '@multiformats/multiaddr-matcher';\nimport delay from 'delay';\nimport { pbStream } from 'it-protobuf-stream';\nimport isPrivate from 'private-ip';\nimport { codes } from '../errors.js';\nimport { HolePunch } from './pb/message.js';\nimport { multicodec } from './index.js';\nconst log = logger('libp2p:dcutr');\n// https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#rpc-messages\nconst MAX_DCUTR_MESSAGE_SIZE = 1024 * 4;\n// ensure the dial has a high priority to jump to the head of the dial queue\nconst DCUTR_DIAL_PRIORITY = 100;\nconst defaultValues = {\n    // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L27\n    timeout: 5000,\n    // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L28\n    retries: 3,\n    maxInboundStreams: 1,\n    maxOutboundStreams: 1\n};\nexport class DefaultDCUtRService {\n    started;\n    timeout;\n    retries;\n    maxInboundStreams;\n    maxOutboundStreams;\n    peerStore;\n    registrar;\n    connectionManager;\n    addressManager;\n    transportManager;\n    topologyId;\n    constructor(components, init) {\n        this.started = false;\n        this.peerStore = components.peerStore;\n        this.registrar = components.registrar;\n        this.addressManager = components.addressManager;\n        this.connectionManager = components.connectionManager;\n        this.transportManager = components.transportManager;\n        this.timeout = init.timeout ?? defaultValues.timeout;\n        this.retries = init.retries ?? defaultValues.retries;\n        this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;\n        this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        if (this.started) {\n            return;\n        }\n        // register for notifications of when peers that support DCUtR connect\n        // nb. requires the identify service to be enabled\n        this.topologyId = await this.registrar.register(multicodec, {\n            onConnect: (peerId, connection) => {\n                if (!connection.transient) {\n                    // the connection is already direct, no upgrade is required\n                    return;\n                }\n                // the inbound peer starts the connection upgrade\n                if (connection.direction !== 'inbound') {\n                    return;\n                }\n                this.upgradeInbound(connection)\n                    .catch(err => {\n                    log.error('error during outgoing DCUtR attempt', err);\n                });\n            }\n        });\n        await this.registrar.handle(multicodec, (data) => {\n            void this.handleIncomingUpgrade(data.stream, data.connection).catch(err => {\n                log.error('error during incoming DCUtR attempt', err);\n                data.stream.abort(err);\n            });\n        }, {\n            maxInboundStreams: this.maxInboundStreams,\n            maxOutboundStreams: this.maxOutboundStreams,\n            runOnTransientConnection: true\n        });\n        this.started = true;\n    }\n    async stop() {\n        await this.registrar.unhandle(multicodec);\n        if (this.topologyId != null) {\n            this.registrar.unregister(this.topologyId);\n        }\n        this.started = false;\n    }\n    /**\n     * Perform the inbound connection upgrade as B\n     *\n     * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n     */\n    async upgradeInbound(relayedConnection) {\n        // Upon observing the new connection, the inbound peer (here B) checks the\n        // addresses advertised by A via identify.\n        //\n        // If that set includes public addresses, then A may be reachable by a direct\n        // connection, in which case B attempts a unilateral connection upgrade by\n        // initiating a direct connection to A.\n        if (await this.attemptUnilateralConnectionUpgrade(relayedConnection)) {\n            return;\n        }\n        let stream;\n        for (let i = 0; i < this.retries; i++) {\n            const options = {\n                signal: AbortSignal.timeout(this.timeout)\n            };\n            try {\n                // 1. B opens a stream to A using the /libp2p/dcutr protocol.\n                stream = await relayedConnection.newStream([multicodec], {\n                    signal: options.signal,\n                    runOnTransientConnection: true\n                });\n                const pb = pbStream(stream, {\n                    maxDataLength: MAX_DCUTR_MESSAGE_SIZE\n                }).pb(HolePunch);\n                // 2. B sends to A a Connect message containing its observed (and\n                // possibly predicted) addresses from identify and starts a timer\n                // to measure RTT of the relay connection.\n                log('B sending connect to %p', relayedConnection.remotePeer);\n                const connectTimer = Date.now();\n                await pb.write({\n                    type: HolePunch.Type.CONNECT,\n                    observedAddresses: this.addressManager.getAddresses().map(ma => ma.bytes)\n                }, options);\n                log('B receiving connect from %p', relayedConnection.remotePeer);\n                // 4. Upon receiving the Connect, B sends a Sync message\n                const connect = await pb.read(options);\n                if (connect.type !== HolePunch.Type.CONNECT) {\n                    log('A sent wrong message type');\n                    throw new CodeError('DCUtR message type was incorrect', codes.ERR_INVALID_MESSAGE);\n                }\n                const multiaddrs = this.getDialableMultiaddrs(connect.observedAddresses);\n                if (multiaddrs.length === 0) {\n                    log('A did not have any dialable multiaddrs');\n                    throw new CodeError('DCUtR connect message had no multiaddrs', codes.ERR_INVALID_MESSAGE);\n                }\n                const rtt = Date.now() - connectTimer;\n                log('A sending sync, rtt %dms', rtt);\n                await pb.write({\n                    type: HolePunch.Type.SYNC,\n                    observedAddresses: []\n                }, options);\n                log('A waiting for half RTT');\n                // ..and starts a timer for half the RTT measured from the time between\n                // sending the initial Connect and receiving the response\n                await delay(rtt / 2);\n                // TODO: when we have a QUIC transport, the dial step is different - for\n                // now we only have tcp support\n                // https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n                log('B dialing', multiaddrs);\n                // Upon expiry of the timer, B dials the address to A.\n                const conn = await this.connectionManager.openConnection(multiaddrs, {\n                    signal: options.signal,\n                    priority: DCUTR_DIAL_PRIORITY\n                });\n                log('DCUtR to %p succeeded to address %a, closing relayed connection', relayedConnection.remotePeer, conn.remoteAddr);\n                await relayedConnection.close(options);\n                break;\n            }\n            catch (err) {\n                log.error('error while attempting DCUtR on attempt %d of %d', i + 1, this.retries, err);\n                stream?.abort(err);\n                if (i === this.retries) {\n                    throw err;\n                }\n            }\n            finally {\n                if (stream != null) {\n                    await stream.close(options);\n                }\n            }\n        }\n    }\n    /**\n     * This is performed when A has dialed B via a relay but A also has a public\n     * address that B can dial directly\n     */\n    async attemptUnilateralConnectionUpgrade(relayedConnection) {\n        // Upon observing the new connection, the inbound peer (here B) checks the\n        // addresses advertised by A via identify.\n        const peerInfo = await this.peerStore.get(relayedConnection.remotePeer);\n        // If that set includes public addresses, then A may be reachable by a direct\n        // connection, in which case B attempts a unilateral connection upgrade by\n        // initiating a direct connection to A.\n        const publicAddresses = peerInfo.addresses\n            .map(address => {\n            const ma = address.multiaddr;\n            // ensure all multiaddrs have the peer id\n            if (ma.getPeerId() == null) {\n                return ma.encapsulate(`/p2p/${relayedConnection.remotePeer}`);\n            }\n            return ma;\n        })\n            .filter(ma => {\n            return this.isPublicAndDialable(ma);\n        });\n        if (publicAddresses.length > 0) {\n            const signal = AbortSignal.timeout(this.timeout);\n            try {\n                log('attempting unilateral connection upgrade to %a', publicAddresses);\n                // force-dial the multiaddr(s), otherwise `connectionManager.openConnection`\n                // will return the existing relayed connection\n                const connection = await this.connectionManager.openConnection(publicAddresses, {\n                    signal,\n                    force: true\n                });\n                if (connection.transient) {\n                    throw new Error('Could not open a new, non-transient, connection');\n                }\n                log('unilateral connection upgrade to %p succeeded via %a, closing relayed connection', relayedConnection.remotePeer, connection.remoteAddr);\n                await relayedConnection.close();\n                return true;\n            }\n            catch (err) {\n                log.error('unilateral connection upgrade to %p on addresses %a failed', relayedConnection.remotePeer, publicAddresses, err);\n            }\n        }\n        else {\n            log('peer %p has no public addresses, not attempting unilateral connection upgrade', relayedConnection.remotePeer);\n        }\n        // no public addresses or failed to dial public addresses\n        return false;\n    }\n    /**\n     * Perform the connection upgrade as A\n     *\n     * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n     */\n    async handleIncomingUpgrade(stream, relayedConnection) {\n        const options = {\n            signal: AbortSignal.timeout(this.timeout)\n        };\n        try {\n            const pb = pbStream(stream, {\n                maxDataLength: MAX_DCUTR_MESSAGE_SIZE\n            }).pb(HolePunch);\n            log('A receiving connect');\n            // 3. Upon receiving the Connect, A responds back with a Connect message\n            // containing its observed (and possibly predicted) addresses.\n            const connect = await pb.read(options);\n            if (connect.type !== HolePunch.Type.CONNECT) {\n                log('B sent wrong message type');\n                throw new CodeError('DCUtR message type was incorrect', codes.ERR_INVALID_MESSAGE);\n            }\n            if (connect.observedAddresses.length === 0) {\n                log('B sent no multiaddrs');\n                throw new CodeError('DCUtR connect message had no multiaddrs', codes.ERR_INVALID_MESSAGE);\n            }\n            const multiaddrs = this.getDialableMultiaddrs(connect.observedAddresses);\n            if (multiaddrs.length === 0) {\n                log('B had no dialable multiaddrs');\n                throw new CodeError('DCUtR connect message had no dialable multiaddrs', codes.ERR_INVALID_MESSAGE);\n            }\n            log('A sending connect');\n            await pb.write({\n                type: HolePunch.Type.CONNECT,\n                observedAddresses: this.addressManager.getAddresses().map(ma => ma.bytes)\n            });\n            log('A receiving sync');\n            const sync = await pb.read(options);\n            if (sync.type !== HolePunch.Type.SYNC) {\n                throw new CodeError('DCUtR message type was incorrect', codes.ERR_INVALID_MESSAGE);\n            }\n            // TODO: when we have a QUIC transport, the dial step is different - for\n            // now we only have tcp support\n            // https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n            // Upon receiving the Sync, A immediately dials the address to B\n            log('A dialing', multiaddrs);\n            const connection = await this.connectionManager.openConnection(multiaddrs, {\n                signal: options.signal,\n                priority: DCUTR_DIAL_PRIORITY,\n                force: true\n            });\n            log('DCUtR to %p succeeded via %a, closing relayed connection', relayedConnection.remotePeer, connection.remoteAddr);\n            await relayedConnection.close(options);\n        }\n        catch (err) {\n            log.error('incoming DCUtR from %p failed', relayedConnection.remotePeer, err);\n            stream.abort(err);\n        }\n        finally {\n            await stream.close(options);\n        }\n    }\n    /**\n     * Takes the `addr` and converts it to a Multiaddr if possible\n     */\n    getDialableMultiaddrs(addrs) {\n        const output = [];\n        for (const addr of addrs) {\n            if (addr == null || addr.length === 0) {\n                continue;\n            }\n            try {\n                const ma = multiaddr(addr);\n                if (!this.isPublicAndDialable(ma)) {\n                    continue;\n                }\n                output.push(ma);\n            }\n            catch { }\n        }\n        return output;\n    }\n    /**\n     * Returns true if the passed multiaddr is public, not relayed and we have a\n     * transport that can dial it\n     */\n    isPublicAndDialable(ma) {\n        // ignore circuit relay\n        if (Circuit.matches(ma)) {\n            return false;\n        }\n        // dns addresses are probably public?\n        if (DNS.matches(ma)) {\n            return true;\n        }\n        // ensure we have only IPv4/IPv6 addresses\n        if (!IP.matches(ma)) {\n            return false;\n        }\n        const transport = this.transportManager.transportForMultiaddr(ma);\n        if (transport == null) {\n            return false;\n        }\n        const options = ma.toOptions();\n        return isPrivate(options.host) === false;\n    }\n}\n//# sourceMappingURL=dcutr.js.map","export var messages;\n(function (messages) {\n    messages[\"NOT_STARTED_YET\"] = \"The libp2p node is not started yet\";\n    messages[\"DHT_DISABLED\"] = \"DHT is not available\";\n    messages[\"PUBSUB_DISABLED\"] = \"PubSub is not available\";\n    messages[\"CONN_ENCRYPTION_REQUIRED\"] = \"At least one connection encryption module is required\";\n    messages[\"ERR_TRANSPORTS_REQUIRED\"] = \"At least one transport module is required\";\n    messages[\"ERR_PROTECTOR_REQUIRED\"] = \"Private network is enforced, but no protector was provided\";\n    messages[\"NOT_FOUND\"] = \"Not found\";\n})(messages || (messages = {}));\nexport var codes;\n(function (codes) {\n    codes[\"DHT_DISABLED\"] = \"ERR_DHT_DISABLED\";\n    codes[\"ERR_PUBSUB_DISABLED\"] = \"ERR_PUBSUB_DISABLED\";\n    codes[\"PUBSUB_NOT_STARTED\"] = \"ERR_PUBSUB_NOT_STARTED\";\n    codes[\"DHT_NOT_STARTED\"] = \"ERR_DHT_NOT_STARTED\";\n    codes[\"CONN_ENCRYPTION_REQUIRED\"] = \"ERR_CONN_ENCRYPTION_REQUIRED\";\n    codes[\"ERR_TRANSPORTS_REQUIRED\"] = \"ERR_TRANSPORTS_REQUIRED\";\n    codes[\"ERR_PROTECTOR_REQUIRED\"] = \"ERR_PROTECTOR_REQUIRED\";\n    codes[\"ERR_PEER_DIAL_INTERCEPTED\"] = \"ERR_PEER_DIAL_INTERCEPTED\";\n    codes[\"ERR_CONNECTION_INTERCEPTED\"] = \"ERR_CONNECTION_INTERCEPTED\";\n    codes[\"ERR_INVALID_PROTOCOLS_FOR_STREAM\"] = \"ERR_INVALID_PROTOCOLS_FOR_STREAM\";\n    codes[\"ERR_CONNECTION_ENDED\"] = \"ERR_CONNECTION_ENDED\";\n    codes[\"ERR_CONNECTION_FAILED\"] = \"ERR_CONNECTION_FAILED\";\n    codes[\"ERR_NODE_NOT_STARTED\"] = \"ERR_NODE_NOT_STARTED\";\n    codes[\"ERR_ALREADY_ABORTED\"] = \"ERR_ALREADY_ABORTED\";\n    codes[\"ERR_TOO_MANY_ADDRESSES\"] = \"ERR_TOO_MANY_ADDRESSES\";\n    codes[\"ERR_NO_VALID_ADDRESSES\"] = \"ERR_NO_VALID_ADDRESSES\";\n    codes[\"ERR_RELAYED_DIAL\"] = \"ERR_RELAYED_DIAL\";\n    codes[\"ERR_DIALED_SELF\"] = \"ERR_DIALED_SELF\";\n    codes[\"ERR_DISCOVERED_SELF\"] = \"ERR_DISCOVERED_SELF\";\n    codes[\"ERR_DUPLICATE_TRANSPORT\"] = \"ERR_DUPLICATE_TRANSPORT\";\n    codes[\"ERR_ENCRYPTION_FAILED\"] = \"ERR_ENCRYPTION_FAILED\";\n    codes[\"ERR_HOP_REQUEST_FAILED\"] = \"ERR_HOP_REQUEST_FAILED\";\n    codes[\"ERR_INVALID_KEY\"] = \"ERR_INVALID_KEY\";\n    codes[\"ERR_INVALID_MESSAGE\"] = \"ERR_INVALID_MESSAGE\";\n    codes[\"ERR_INVALID_PARAMETERS\"] = \"ERR_INVALID_PARAMETERS\";\n    codes[\"ERR_INVALID_PEER\"] = \"ERR_INVALID_PEER\";\n    codes[\"ERR_MUXER_UNAVAILABLE\"] = \"ERR_MUXER_UNAVAILABLE\";\n    codes[\"ERR_NOT_FOUND\"] = \"ERR_NOT_FOUND\";\n    codes[\"ERR_TIMEOUT\"] = \"ERR_TIMEOUT\";\n    codes[\"ERR_TRANSPORT_UNAVAILABLE\"] = \"ERR_TRANSPORT_UNAVAILABLE\";\n    codes[\"ERR_TRANSPORT_DIAL_FAILED\"] = \"ERR_TRANSPORT_DIAL_FAILED\";\n    codes[\"ERR_UNSUPPORTED_PROTOCOL\"] = \"ERR_UNSUPPORTED_PROTOCOL\";\n    codes[\"ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED\"] = \"ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED\";\n    codes[\"ERR_INVALID_MULTIADDR\"] = \"ERR_INVALID_MULTIADDR\";\n    codes[\"ERR_SIGNATURE_NOT_VALID\"] = \"ERR_SIGNATURE_NOT_VALID\";\n    codes[\"ERR_FIND_SELF\"] = \"ERR_FIND_SELF\";\n    codes[\"ERR_NO_ROUTERS_AVAILABLE\"] = \"ERR_NO_ROUTERS_AVAILABLE\";\n    codes[\"ERR_CONNECTION_NOT_MULTIPLEXED\"] = \"ERR_CONNECTION_NOT_MULTIPLEXED\";\n    codes[\"ERR_NO_DIAL_TOKENS\"] = \"ERR_NO_DIAL_TOKENS\";\n    codes[\"ERR_KEYCHAIN_REQUIRED\"] = \"ERR_KEYCHAIN_REQUIRED\";\n    codes[\"ERR_INVALID_CMS\"] = \"ERR_INVALID_CMS\";\n    codes[\"ERR_MISSING_KEYS\"] = \"ERR_MISSING_KEYS\";\n    codes[\"ERR_NO_KEY\"] = \"ERR_NO_KEY\";\n    codes[\"ERR_INVALID_KEY_NAME\"] = \"ERR_INVALID_KEY_NAME\";\n    codes[\"ERR_INVALID_KEY_TYPE\"] = \"ERR_INVALID_KEY_TYPE\";\n    codes[\"ERR_KEY_ALREADY_EXISTS\"] = \"ERR_KEY_ALREADY_EXISTS\";\n    codes[\"ERR_INVALID_KEY_SIZE\"] = \"ERR_INVALID_KEY_SIZE\";\n    codes[\"ERR_KEY_NOT_FOUND\"] = \"ERR_KEY_NOT_FOUND\";\n    codes[\"ERR_OLD_KEY_NAME_INVALID\"] = \"ERR_OLD_KEY_NAME_INVALID\";\n    codes[\"ERR_NEW_KEY_NAME_INVALID\"] = \"ERR_NEW_KEY_NAME_INVALID\";\n    codes[\"ERR_PASSWORD_REQUIRED\"] = \"ERR_PASSWORD_REQUIRED\";\n    codes[\"ERR_PEM_REQUIRED\"] = \"ERR_PEM_REQUIRED\";\n    codes[\"ERR_CANNOT_READ_KEY\"] = \"ERR_CANNOT_READ_KEY\";\n    codes[\"ERR_MISSING_PRIVATE_KEY\"] = \"ERR_MISSING_PRIVATE_KEY\";\n    codes[\"ERR_MISSING_PUBLIC_KEY\"] = \"ERR_MISSING_PUBLIC_KEY\";\n    codes[\"ERR_INVALID_OLD_PASS_TYPE\"] = \"ERR_INVALID_OLD_PASS_TYPE\";\n    codes[\"ERR_INVALID_NEW_PASS_TYPE\"] = \"ERR_INVALID_NEW_PASS_TYPE\";\n    codes[\"ERR_INVALID_PASS_LENGTH\"] = \"ERR_INVALID_PASS_LENGTH\";\n    codes[\"ERR_NOT_IMPLEMENTED\"] = \"ERR_NOT_IMPLEMENTED\";\n    codes[\"ERR_WRONG_PING_ACK\"] = \"ERR_WRONG_PING_ACK\";\n    codes[\"ERR_INVALID_RECORD\"] = \"ERR_INVALID_RECORD\";\n    codes[\"ERR_ALREADY_SUCCEEDED\"] = \"ERR_ALREADY_SUCCEEDED\";\n    codes[\"ERR_NO_HANDLER_FOR_PROTOCOL\"] = \"ERR_NO_HANDLER_FOR_PROTOCOL\";\n    codes[\"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\";\n    codes[\"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\";\n    codes[\"ERR_CONNECTION_DENIED\"] = \"ERR_CONNECTION_DENIED\";\n    codes[\"ERR_TRANSFER_LIMIT_EXCEEDED\"] = \"ERR_TRANSFER_LIMIT_EXCEEDED\";\n})(codes || (codes = {}));\n//# sourceMappingURL=errors.js.map","import { version } from '../version.js';\nexport const PROTOCOL_VERSION = 'ipfs/0.1.0'; // deprecated\nexport const AGENT_VERSION = `js-libp2p/${version}`;\nexport const MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0'; // deprecated\nexport const MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0'; // deprecated\nexport const IDENTIFY_PROTOCOL_VERSION = '0.1.0';\nexport const MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id';\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push';\nexport const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0';\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0';\n//# sourceMappingURL=consts.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Identify;\n(function (Identify) {\n    let _codec;\n    Identify.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.protocolVersion != null) {\n                    w.uint32(42);\n                    w.string(obj.protocolVersion);\n                }\n                if (obj.agentVersion != null) {\n                    w.uint32(50);\n                    w.string(obj.agentVersion);\n                }\n                if (obj.publicKey != null) {\n                    w.uint32(10);\n                    w.bytes(obj.publicKey);\n                }\n                if (obj.listenAddrs != null) {\n                    for (const value of obj.listenAddrs) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (obj.observedAddr != null) {\n                    w.uint32(34);\n                    w.bytes(obj.observedAddr);\n                }\n                if (obj.protocols != null) {\n                    for (const value of obj.protocols) {\n                        w.uint32(26);\n                        w.string(value);\n                    }\n                }\n                if (obj.signedPeerRecord != null) {\n                    w.uint32(66);\n                    w.bytes(obj.signedPeerRecord);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    listenAddrs: [],\n                    protocols: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 5:\n                            obj.protocolVersion = reader.string();\n                            break;\n                        case 6:\n                            obj.agentVersion = reader.string();\n                            break;\n                        case 1:\n                            obj.publicKey = reader.bytes();\n                            break;\n                        case 2:\n                            obj.listenAddrs.push(reader.bytes());\n                            break;\n                        case 4:\n                            obj.observedAddr = reader.bytes();\n                            break;\n                        case 3:\n                            obj.protocols.push(reader.string());\n                            break;\n                        case 8:\n                            obj.signedPeerRecord = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Identify.encode = (obj) => {\n        return encodeMessage(obj, Identify.codec());\n    };\n    Identify.decode = (buf) => {\n        return decodeMessage(buf, Identify.codec());\n    };\n})(Identify || (Identify = {}));\n//# sourceMappingURL=message.js.map","import { setMaxListeners } from 'events';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport { pbStream } from 'it-protobuf-stream';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { isNode, isBrowser, isWebWorker, isElectronMain, isElectronRenderer, isReactNative } from 'wherearewe';\nimport { codes } from '../errors.js';\nimport { AGENT_VERSION, IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION } from './consts.js';\nimport { Identify } from './pb/message.js';\nconst log = logger('libp2p:identify');\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nconst MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;\nconst defaultValues = {\n    protocolPrefix: 'ipfs',\n    agentVersion: AGENT_VERSION,\n    // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48\n    timeout: 60000,\n    maxInboundStreams: 1,\n    maxOutboundStreams: 1,\n    maxPushIncomingStreams: 1,\n    maxPushOutgoingStreams: 1,\n    maxObservedAddresses: 10,\n    maxIdentifyMessageSize: 8192,\n    runOnConnectionOpen: true,\n    runOnTransientConnection: true\n};\nexport class DefaultIdentifyService {\n    identifyProtocolStr;\n    identifyPushProtocolStr;\n    host;\n    started;\n    timeout;\n    peerId;\n    peerStore;\n    registrar;\n    connectionManager;\n    addressManager;\n    maxInboundStreams;\n    maxOutboundStreams;\n    maxPushIncomingStreams;\n    maxPushOutgoingStreams;\n    maxIdentifyMessageSize;\n    maxObservedAddresses;\n    events;\n    runOnTransientConnection;\n    constructor(components, init) {\n        this.started = false;\n        this.peerId = components.peerId;\n        this.peerStore = components.peerStore;\n        this.registrar = components.registrar;\n        this.addressManager = components.addressManager;\n        this.connectionManager = components.connectionManager;\n        this.events = components.events;\n        this.identifyProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;\n        this.identifyPushProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;\n        this.timeout = init.timeout ?? defaultValues.timeout;\n        this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;\n        this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;\n        this.maxPushIncomingStreams = init.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams;\n        this.maxPushOutgoingStreams = init.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams;\n        this.maxIdentifyMessageSize = init.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize;\n        this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;\n        this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection;\n        // Store self host metadata\n        this.host = {\n            protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n            agentVersion: init.agentVersion ?? defaultValues.agentVersion\n        };\n        if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {\n            // When a new connection happens, trigger identify\n            components.events.addEventListener('connection:open', (evt) => {\n                const connection = evt.detail;\n                this.identify(connection).catch(err => { log.error('error during identify trigged by connection:open', err); });\n            });\n        }\n        // When self peer record changes, trigger identify-push\n        components.events.addEventListener('self:peer:update', (evt) => {\n            void this.push().catch(err => { log.error(err); });\n        });\n        // Append user agent version to default AGENT_VERSION depending on the environment\n        if (this.host.agentVersion === AGENT_VERSION) {\n            if (isNode || isElectronMain) {\n                this.host.agentVersion += ` UserAgent=${globalThis.process.version}`;\n            }\n            else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {\n                this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;\n            }\n        }\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        if (this.started) {\n            return;\n        }\n        await this.peerStore.merge(this.peerId, {\n            metadata: {\n                AgentVersion: uint8ArrayFromString(this.host.agentVersion),\n                ProtocolVersion: uint8ArrayFromString(this.host.protocolVersion)\n            }\n        });\n        await this.registrar.handle(this.identifyProtocolStr, (data) => {\n            void this._handleIdentify(data).catch(err => {\n                log.error(err);\n            });\n        }, {\n            maxInboundStreams: this.maxInboundStreams,\n            maxOutboundStreams: this.maxOutboundStreams,\n            runOnTransientConnection: this.runOnTransientConnection\n        });\n        await this.registrar.handle(this.identifyPushProtocolStr, (data) => {\n            void this._handlePush(data).catch(err => {\n                log.error(err);\n            });\n        }, {\n            maxInboundStreams: this.maxPushIncomingStreams,\n            maxOutboundStreams: this.maxPushOutgoingStreams,\n            runOnTransientConnection: this.runOnTransientConnection\n        });\n        this.started = true;\n    }\n    async stop() {\n        await this.registrar.unhandle(this.identifyProtocolStr);\n        await this.registrar.unhandle(this.identifyPushProtocolStr);\n        this.started = false;\n    }\n    /**\n     * Send an Identify Push update to the list of connections\n     */\n    async pushToConnections(connections) {\n        const listenAddresses = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code));\n        const peerRecord = new PeerRecord({\n            peerId: this.peerId,\n            multiaddrs: listenAddresses\n        });\n        const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);\n        const supportedProtocols = this.registrar.getProtocols();\n        const peer = await this.peerStore.get(this.peerId);\n        const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') ?? uint8ArrayFromString(this.host.agentVersion));\n        const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') ?? uint8ArrayFromString(this.host.protocolVersion));\n        const pushes = connections.map(async (connection) => {\n            let stream;\n            const signal = AbortSignal.timeout(this.timeout);\n            try {\n                // fails on node < 15.4\n                setMaxListeners?.(Infinity, signal);\n            }\n            catch { }\n            try {\n                stream = await connection.newStream([this.identifyPushProtocolStr], {\n                    signal,\n                    runOnTransientConnection: this.runOnTransientConnection\n                });\n                const pb = pbStream(stream, {\n                    maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n                }).pb(Identify);\n                await pb.write({\n                    listenAddrs: listenAddresses.map(ma => ma.bytes),\n                    signedPeerRecord: signedPeerRecord.marshal(),\n                    protocols: supportedProtocols,\n                    agentVersion,\n                    protocolVersion\n                }, {\n                    signal\n                });\n                await stream.close({\n                    signal\n                });\n            }\n            catch (err) {\n                // Just log errors\n                log.error('could not push identify update to peer', err);\n                stream?.abort(err);\n            }\n        });\n        await Promise.all(pushes);\n    }\n    /**\n     * Calls `push` on all peer connections\n     */\n    async push() {\n        // Do not try to push if we are not running\n        if (!this.isStarted()) {\n            return;\n        }\n        const connections = [];\n        await Promise.all(this.connectionManager.getConnections().map(async (conn) => {\n            try {\n                const peer = await this.peerStore.get(conn.remotePeer);\n                if (!peer.protocols.includes(this.identifyPushProtocolStr)) {\n                    return;\n                }\n                connections.push(conn);\n            }\n            catch (err) {\n                if (err.code !== codes.ERR_NOT_FOUND) {\n                    throw err;\n                }\n            }\n        }));\n        await this.pushToConnections(connections);\n    }\n    async _identify(connection, options = {}) {\n        let stream;\n        options.signal = options.signal ?? AbortSignal.timeout(this.timeout);\n        try {\n            stream = await connection.newStream([this.identifyProtocolStr], {\n                ...options,\n                runOnTransientConnection: this.runOnTransientConnection\n            });\n            const pb = pbStream(stream, {\n                maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n            }).pb(Identify);\n            const message = await pb.read(options);\n            await stream.close(options);\n            return message;\n        }\n        catch (err) {\n            log.error('error while reading identify message', err);\n            stream?.abort(err);\n            throw err;\n        }\n    }\n    async identify(connection, options = {}) {\n        const message = await this._identify(connection, options);\n        const { publicKey, protocols, observedAddr } = message;\n        if (publicKey == null) {\n            throw new CodeError('public key was missing from identify message', codes.ERR_MISSING_PUBLIC_KEY);\n        }\n        const id = await peerIdFromKeys(publicKey);\n        if (!connection.remotePeer.equals(id)) {\n            throw new CodeError('identified peer does not match the expected peer', codes.ERR_INVALID_PEER);\n        }\n        if (this.peerId.equals(id)) {\n            throw new CodeError('identified peer is our own peer id?', codes.ERR_INVALID_PEER);\n        }\n        // Get the observedAddr if there is one\n        const cleanObservedAddr = getCleanMultiaddr(observedAddr);\n        log('identify completed for peer %p and protocols %o', id, protocols);\n        log('our observed address is %a', cleanObservedAddr);\n        if (cleanObservedAddr != null &&\n            this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {\n            log('storing our observed address %a', cleanObservedAddr);\n            this.addressManager.addObservedAddr(cleanObservedAddr);\n        }\n        const signedPeerRecord = await this.#consumeIdentifyMessage(connection.remotePeer, message);\n        const result = {\n            peerId: id,\n            protocolVersion: message.protocolVersion,\n            agentVersion: message.agentVersion,\n            publicKey: message.publicKey,\n            listenAddrs: message.listenAddrs.map(buf => multiaddr(buf)),\n            observedAddr: message.observedAddr == null ? undefined : multiaddr(message.observedAddr),\n            protocols: message.protocols,\n            signedPeerRecord\n        };\n        this.events.safeDispatchEvent('peer:identify', { detail: result });\n        return result;\n    }\n    /**\n     * Sends the `Identify` response with the Signed Peer Record\n     * to the requesting peer over the given `connection`\n     */\n    async _handleIdentify(data) {\n        const { connection, stream } = data;\n        const signal = AbortSignal.timeout(this.timeout);\n        try {\n            // fails on node < 15.4\n            setMaxListeners?.(Infinity, signal);\n        }\n        catch { }\n        try {\n            const publicKey = this.peerId.publicKey ?? new Uint8Array(0);\n            const peerData = await this.peerStore.get(this.peerId);\n            const multiaddrs = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code));\n            let signedPeerRecord = peerData.peerRecordEnvelope;\n            if (multiaddrs.length > 0 && signedPeerRecord == null) {\n                const peerRecord = new PeerRecord({\n                    peerId: this.peerId,\n                    multiaddrs\n                });\n                const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);\n                signedPeerRecord = envelope.marshal().subarray();\n            }\n            const pb = pbStream(stream).pb(Identify);\n            await pb.write({\n                protocolVersion: this.host.protocolVersion,\n                agentVersion: this.host.agentVersion,\n                publicKey,\n                listenAddrs: multiaddrs.map(addr => addr.bytes),\n                signedPeerRecord,\n                observedAddr: connection.remoteAddr.bytes,\n                protocols: peerData.protocols\n            }, {\n                signal\n            });\n            await stream.close({\n                signal\n            });\n        }\n        catch (err) {\n            log.error('could not respond to identify request', err);\n            stream.abort(err);\n        }\n    }\n    /**\n     * Reads the Identify Push message from the given `connection`\n     */\n    async _handlePush(data) {\n        const { connection, stream } = data;\n        try {\n            if (this.peerId.equals(connection.remotePeer)) {\n                throw new Error('received push from ourselves?');\n            }\n            const options = {\n                signal: AbortSignal.timeout(this.timeout)\n            };\n            const pb = pbStream(stream, {\n                maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n            }).pb(Identify);\n            const message = await pb.read(options);\n            await stream.close(options);\n            await this.#consumeIdentifyMessage(connection.remotePeer, message);\n        }\n        catch (err) {\n            log.error('received invalid message', err);\n            stream.abort(err);\n            return;\n        }\n        log('handled push from %p', connection.remotePeer);\n    }\n    async #consumeIdentifyMessage(remotePeer, message) {\n        log('received identify from %p', remotePeer);\n        if (message == null) {\n            throw new Error('Message was null or undefined');\n        }\n        const peer = {\n            addresses: message.listenAddrs.map(buf => ({\n                isCertified: false,\n                multiaddr: multiaddr(buf)\n            })),\n            protocols: message.protocols,\n            metadata: new Map(),\n            peerRecordEnvelope: message.signedPeerRecord\n        };\n        let output;\n        // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer\n        if (message.signedPeerRecord != null) {\n            log('received signedPeerRecord in push from %p', remotePeer);\n            let peerRecordEnvelope = message.signedPeerRecord;\n            const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN);\n            let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n            // Verify peerId\n            if (!peerRecord.peerId.equals(envelope.peerId)) {\n                throw new Error('signing key does not match PeerId in the PeerRecord');\n            }\n            // Make sure remote peer is the one sending the record\n            if (!remotePeer.equals(peerRecord.peerId)) {\n                throw new Error('signing key does not match remote PeerId');\n            }\n            let existingPeer;\n            try {\n                existingPeer = await this.peerStore.get(peerRecord.peerId);\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n            if (existingPeer != null) {\n                // don't lose any existing metadata\n                peer.metadata = existingPeer.metadata;\n                // if we have previously received a signed record for this peer, compare it to the incoming one\n                if (existingPeer.peerRecordEnvelope != null) {\n                    const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);\n                    const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);\n                    // ensure seq is greater than, or equal to, the last received\n                    if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n                        log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber);\n                        peerRecord = storedRecord;\n                        peerRecordEnvelope = existingPeer.peerRecordEnvelope;\n                    }\n                }\n            }\n            // store the signed record for next time\n            peer.peerRecordEnvelope = peerRecordEnvelope;\n            // override the stored addresses with the signed multiaddrs\n            peer.addresses = peerRecord.multiaddrs.map(multiaddr => ({\n                isCertified: true,\n                multiaddr\n            }));\n            output = {\n                seq: peerRecord.seqNumber,\n                addresses: peerRecord.multiaddrs\n            };\n        }\n        else {\n            log('%p did not send a signed peer record', remotePeer);\n        }\n        if (message.agentVersion != null) {\n            peer.metadata.set('AgentVersion', uint8ArrayFromString(message.agentVersion));\n        }\n        if (message.protocolVersion != null) {\n            peer.metadata.set('ProtocolVersion', uint8ArrayFromString(message.protocolVersion));\n        }\n        await this.peerStore.patch(remotePeer, peer);\n        return output;\n    }\n}\n/**\n * Takes the `addr` and converts it to a Multiaddr if possible\n */\nfunction getCleanMultiaddr(addr) {\n    if (addr != null && addr.length > 0) {\n        try {\n            return multiaddr(addr);\n        }\n        catch {\n        }\n    }\n}\n//# sourceMappingURL=identify.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { nanoid } from 'nanoid';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n    _buf;\n    /**\n     * @param {string | Uint8Array} s\n     * @param {boolean} [clean]\n     */\n    constructor(s, clean) {\n        if (typeof s === 'string') {\n            this._buf = uint8ArrayFromString(s);\n        }\n        else if (s instanceof Uint8Array) {\n            this._buf = s;\n        }\n        else {\n            throw new Error('Invalid key, should be String of Uint8Array');\n        }\n        if (clean == null) {\n            clean = true;\n        }\n        if (clean) {\n            this.clean();\n        }\n        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n            throw new Error('Invalid key');\n        }\n    }\n    /**\n     * Convert to the string representation\n     *\n     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n     * @returns {string}\n     */\n    toString(encoding = 'utf8') {\n        return uint8ArrayToString(this._buf, encoding);\n    }\n    /**\n     * Return the Uint8Array representation of the key\n     *\n     * @returns {Uint8Array}\n     */\n    uint8Array() {\n        return this._buf;\n    }\n    /**\n     * Return string representation of the key\n     *\n     * @returns {string}\n     */\n    get [Symbol.toStringTag]() {\n        return `Key(${this.toString()})`;\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list - The array of namespaces\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     * ```\n     */\n    static withNamespaces(list) {\n        return new Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.random()\n     * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n     * ```\n     */\n    static random() {\n        return new Key(nanoid().replace(/-/g, ''));\n    }\n    /**\n     * @param {*} other\n     */\n    static asKey(other) {\n        if (other instanceof Uint8Array || typeof other === 'string') {\n            // we can create a key from this\n            return new Key(other);\n        }\n        if (typeof other.uint8Array === 'function') {\n            // this is an older version or may have crossed the esm/cjs boundary\n            return new Key(other.uint8Array());\n        }\n        return null;\n    }\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    clean() {\n        if (this._buf == null || this._buf.byteLength === 0) {\n            this._buf = pathSepB;\n        }\n        if (this._buf[0] !== pathSep) {\n            const bytes = new Uint8Array(this._buf.byteLength + 1);\n            bytes.fill(pathSep, 0, 1);\n            bytes.set(this._buf, 1);\n            this._buf = bytes;\n        }\n        // normalize does not remove trailing slashes\n        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n            this._buf = this._buf.subarray(0, -1);\n        }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key - The other Key to check against\n     * @returns {boolean}\n     */\n    less(key) {\n        const list1 = this.list();\n        const list2 = key.list();\n        for (let i = 0; i < list1.length; i++) {\n            if (list2.length < i + 1) {\n                return false;\n            }\n            const c1 = list1[i];\n            const c2 = list2[i];\n            if (c1 < c2) {\n                return true;\n            }\n            else if (c1 > c2) {\n                return false;\n            }\n        }\n        return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     * ```\n     */\n    reverse() {\n        return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n    namespaces() {\n        return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     * ```\n     */\n    baseNamespace() {\n        const ns = this.namespaces();\n        return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     * ```\n     */\n    list() {\n        return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     * ```\n     */\n    type() {\n        return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     * ```\n     */\n    name() {\n        return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s - The string to append.\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    instance(s) {\n        return new Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     * ```\n     */\n    path() {\n        let p = this.parent().toString();\n        if (!p.endsWith(pathSepS)) {\n            p += pathSepS;\n        }\n        p += this.type();\n        return new Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     * ```\n     */\n    parent() {\n        const list = this.list();\n        if (list.length === 1) {\n            return new Key(pathSepS);\n        }\n        return new Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key - The child Key to add\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    child(key) {\n        if (this.toString() === pathSepS) {\n            return key;\n        }\n        else if (key.toString() === pathSepS) {\n            return this;\n        }\n        return new Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other - The other key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     * ```\n     */\n    isAncestorOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other - The other Key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     * ```\n     */\n    isDecendantOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Checks if this key has only one namespace.\n     *\n     * @returns {boolean}\n     */\n    isTopLevel() {\n        return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys - The array of keys to concatenate\n     * @returns {Key}\n     */\n    concat(...keys) {\n        return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n    }\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType(ns) {\n    const parts = ns.split(':');\n    if (parts.length < 2) {\n        return '';\n    }\n    return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue(ns) {\n    const parts = ns.split(':');\n    return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten(arr) {\n    return ([]).concat(...arr);\n}\n//# sourceMappingURL=key.js.map","export var codes;\n(function (codes) {\n    codes[\"ERR_INVALID_PARAMETERS\"] = \"ERR_INVALID_PARAMETERS\";\n    codes[\"ERR_INVALID_KEY_NAME\"] = \"ERR_INVALID_KEY_NAME\";\n    codes[\"ERR_INVALID_KEY_TYPE\"] = \"ERR_INVALID_KEY_TYPE\";\n    codes[\"ERR_KEY_ALREADY_EXISTS\"] = \"ERR_KEY_ALREADY_EXISTS\";\n    codes[\"ERR_INVALID_KEY_SIZE\"] = \"ERR_INVALID_KEY_SIZE\";\n    codes[\"ERR_KEY_NOT_FOUND\"] = \"ERR_KEY_NOT_FOUND\";\n    codes[\"ERR_OLD_KEY_NAME_INVALID\"] = \"ERR_OLD_KEY_NAME_INVALID\";\n    codes[\"ERR_NEW_KEY_NAME_INVALID\"] = \"ERR_NEW_KEY_NAME_INVALID\";\n    codes[\"ERR_PASSWORD_REQUIRED\"] = \"ERR_PASSWORD_REQUIRED\";\n    codes[\"ERR_PEM_REQUIRED\"] = \"ERR_PEM_REQUIRED\";\n    codes[\"ERR_CANNOT_READ_KEY\"] = \"ERR_CANNOT_READ_KEY\";\n    codes[\"ERR_MISSING_PRIVATE_KEY\"] = \"ERR_MISSING_PRIVATE_KEY\";\n    codes[\"ERR_INVALID_OLD_PASS_TYPE\"] = \"ERR_INVALID_OLD_PASS_TYPE\";\n    codes[\"ERR_INVALID_NEW_PASS_TYPE\"] = \"ERR_INVALID_NEW_PASS_TYPE\";\n    codes[\"ERR_INVALID_PASS_LENGTH\"] = \"ERR_INVALID_PASS_LENGTH\";\n})(codes || (codes = {}));\n//# sourceMappingURL=errors.js.map","/* eslint max-nested-callbacks: [\"error\", 5] */\nimport { pbkdf2, randomBytes } from '@libp2p/crypto';\nimport { generateKeyPair, importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { Key } from 'interface-datastore/key';\nimport mergeOptions from 'merge-options';\nimport sanitize from 'sanitize-filename';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { codes } from './errors.js';\nconst log = logger('libp2p:keychain');\nconst keyPrefix = '/pkcs8/';\nconst infoPrefix = '/info/';\nconst privates = new WeakMap();\n// NIST SP 800-132\nconst NIST = {\n    minKeyLength: 112 / 8,\n    minSaltLength: 128 / 8,\n    minIterationCount: 1000\n};\nconst defaultOptions = {\n    // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n    dek: {\n        keyLength: 512 / 8,\n        iterationCount: 10000,\n        salt: 'you should override this value with a crypto secure random number',\n        hash: 'sha2-512'\n    }\n};\nfunction validateKeyName(name) {\n    if (name == null) {\n        return false;\n    }\n    if (typeof name !== 'string') {\n        return false;\n    }\n    return name === sanitize(name.trim()) && name.length > 0;\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n */\nasync function randomDelay() {\n    const min = 200;\n    const max = 1000;\n    const delay = Math.random() * (max - min) + min;\n    await new Promise(resolve => setTimeout(resolve, delay));\n}\n/**\n * Converts a key name into a datastore name\n */\nfunction DsName(name) {\n    return new Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name\n */\nfunction DsInfoName(name) {\n    return new Key(infoPrefix + name);\n}\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nexport class DefaultKeyChain {\n    components;\n    init;\n    /**\n     * Creates a new instance of a key chain\n     */\n    constructor(components, init) {\n        this.components = components;\n        this.init = mergeOptions(defaultOptions, init);\n        // Enforce NIST SP 800-132\n        if (this.init.pass != null && this.init.pass?.length < 20) {\n            throw new Error('pass must be least 20 characters');\n        }\n        if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {\n            throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);\n        }\n        if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {\n            throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);\n        }\n        if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {\n            throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);\n        }\n        const dek = this.init.pass != null && this.init.dek?.salt != null\n            ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash)\n            : '';\n        privates.set(this, { dek });\n    }\n    /**\n     * Generates the options for a keychain.  A random salt is produced.\n     *\n     * @returns {object}\n     */\n    static generateOptions() {\n        const options = Object.assign({}, defaultOptions);\n        const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n        options.dek.salt = uint8ArrayToString(randomBytes(saltLength), 'base64');\n        return options;\n    }\n    /**\n     * Gets an object that can encrypt/decrypt protected data.\n     * The default options for a keychain.\n     *\n     * @returns {object}\n     */\n    static get options() {\n        return defaultOptions;\n    }\n    /**\n     * Create a new key.\n     *\n     * @param {string} name - The local key name; cannot already exist.\n     * @param {string} type - One of the key types; 'rsa'.\n     * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only\n     */\n    async createKey(name, type, size = 2048) {\n        if (!validateKeyName(name) || name === 'self') {\n            await randomDelay();\n            throw new CodeError('Invalid key name', codes.ERR_INVALID_KEY_NAME);\n        }\n        if (typeof type !== 'string') {\n            await randomDelay();\n            throw new CodeError('Invalid key type', codes.ERR_INVALID_KEY_TYPE);\n        }\n        const dsname = DsName(name);\n        const exists = await this.components.datastore.has(dsname);\n        if (exists) {\n            await randomDelay();\n            throw new CodeError('Key name already exists', codes.ERR_KEY_ALREADY_EXISTS);\n        }\n        switch (type.toLowerCase()) {\n            case 'rsa':\n                if (!Number.isSafeInteger(size) || size < 2048) {\n                    await randomDelay();\n                    throw new CodeError('Invalid RSA key size', codes.ERR_INVALID_KEY_SIZE);\n                }\n                break;\n            default:\n                break;\n        }\n        let keyInfo;\n        try {\n            const keypair = await generateKeyPair(type, size);\n            const kid = await keypair.id();\n            const cached = privates.get(this);\n            if (cached == null) {\n                throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS);\n            }\n            const dek = cached.dek;\n            const pem = await keypair.export(dek);\n            keyInfo = {\n                name,\n                id: kid\n            };\n            const batch = this.components.datastore.batch();\n            batch.put(dsname, uint8ArrayFromString(pem));\n            batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n            await batch.commit();\n        }\n        catch (err) {\n            await randomDelay();\n            throw err;\n        }\n        return keyInfo;\n    }\n    /**\n     * List all the keys.\n     *\n     * @returns {Promise<KeyInfo[]>}\n     */\n    async listKeys() {\n        const query = {\n            prefix: infoPrefix\n        };\n        const info = [];\n        for await (const value of this.components.datastore.query(query)) {\n            info.push(JSON.parse(uint8ArrayToString(value.value)));\n        }\n        return info;\n    }\n    /**\n     * Find a key by it's id\n     */\n    async findKeyById(id) {\n        try {\n            const keys = await this.listKeys();\n            const key = keys.find((k) => k.id === id);\n            if (key == null) {\n                throw new CodeError(`Key with id '${id}' does not exist.`, codes.ERR_KEY_NOT_FOUND);\n            }\n            return key;\n        }\n        catch (err) {\n            await randomDelay();\n            throw err;\n        }\n    }\n    /**\n     * Find a key by it's name.\n     *\n     * @param {string} name - The local key name.\n     * @returns {Promise<KeyInfo>}\n     */\n    async findKeyByName(name) {\n        if (!validateKeyName(name)) {\n            await randomDelay();\n            throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME);\n        }\n        const dsname = DsInfoName(name);\n        try {\n            const res = await this.components.datastore.get(dsname);\n            return JSON.parse(uint8ArrayToString(res));\n        }\n        catch (err) {\n            await randomDelay();\n            log.error(err);\n            throw new CodeError(`Key '${name}' does not exist.`, codes.ERR_KEY_NOT_FOUND);\n        }\n    }\n    /**\n     * Remove an existing key.\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @returns {Promise<KeyInfo>}\n     */\n    async removeKey(name) {\n        if (!validateKeyName(name) || name === 'self') {\n            await randomDelay();\n            throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME);\n        }\n        const dsname = DsName(name);\n        const keyInfo = await this.findKeyByName(name);\n        const batch = this.components.datastore.batch();\n        batch.delete(dsname);\n        batch.delete(DsInfoName(name));\n        await batch.commit();\n        return keyInfo;\n    }\n    /**\n     * Rename a key\n     *\n     * @param {string} oldName - The old local key name; must already exist.\n     * @param {string} newName - The new local key name; must not already exist.\n     * @returns {Promise<KeyInfo>}\n     */\n    async renameKey(oldName, newName) {\n        if (!validateKeyName(oldName) || oldName === 'self') {\n            await randomDelay();\n            throw new CodeError(`Invalid old key name '${oldName}'`, codes.ERR_OLD_KEY_NAME_INVALID);\n        }\n        if (!validateKeyName(newName) || newName === 'self') {\n            await randomDelay();\n            throw new CodeError(`Invalid new key name '${newName}'`, codes.ERR_NEW_KEY_NAME_INVALID);\n        }\n        const oldDsname = DsName(oldName);\n        const newDsname = DsName(newName);\n        const oldInfoName = DsInfoName(oldName);\n        const newInfoName = DsInfoName(newName);\n        const exists = await this.components.datastore.has(newDsname);\n        if (exists) {\n            await randomDelay();\n            throw new CodeError(`Key '${newName}' already exists`, codes.ERR_KEY_ALREADY_EXISTS);\n        }\n        try {\n            const pem = await this.components.datastore.get(oldDsname);\n            const res = await this.components.datastore.get(oldInfoName);\n            const keyInfo = JSON.parse(uint8ArrayToString(res));\n            keyInfo.name = newName;\n            const batch = this.components.datastore.batch();\n            batch.put(newDsname, pem);\n            batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));\n            batch.delete(oldDsname);\n            batch.delete(oldInfoName);\n            await batch.commit();\n            return keyInfo;\n        }\n        catch (err) {\n            await randomDelay();\n            throw err;\n        }\n    }\n    /**\n     * Export an existing key as a PEM encrypted PKCS #8 string\n     */\n    async exportKey(name, password) {\n        if (!validateKeyName(name)) {\n            await randomDelay();\n            throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME);\n        }\n        if (password == null) {\n            await randomDelay();\n            throw new CodeError('Password is required', codes.ERR_PASSWORD_REQUIRED);\n        }\n        const dsname = DsName(name);\n        try {\n            const res = await this.components.datastore.get(dsname);\n            const pem = uint8ArrayToString(res);\n            const cached = privates.get(this);\n            if (cached == null) {\n                throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS);\n            }\n            const dek = cached.dek;\n            const privateKey = await importKey(pem, dek);\n            const keyString = await privateKey.export(password);\n            return keyString;\n        }\n        catch (err) {\n            await randomDelay();\n            throw err;\n        }\n    }\n    /**\n     * Export an existing key as a PeerId\n     */\n    async exportPeerId(name) {\n        const password = 'temporary-password';\n        const pem = await this.exportKey(name, password);\n        const privateKey = await importKey(pem, password);\n        return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);\n    }\n    /**\n     * Import a new key from a PEM encoded PKCS #8 string\n     *\n     * @param {string} name - The local key name; must not already exist.\n     * @param {string} pem - The PEM encoded PKCS #8 string\n     * @param {string} password - The password.\n     * @returns {Promise<KeyInfo>}\n     */\n    async importKey(name, pem, password) {\n        if (!validateKeyName(name) || name === 'self') {\n            await randomDelay();\n            throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME);\n        }\n        if (pem == null) {\n            await randomDelay();\n            throw new CodeError('PEM encoded key is required', codes.ERR_PEM_REQUIRED);\n        }\n        const dsname = DsName(name);\n        const exists = await this.components.datastore.has(dsname);\n        if (exists) {\n            await randomDelay();\n            throw new CodeError(`Key '${name}' already exists`, codes.ERR_KEY_ALREADY_EXISTS);\n        }\n        let privateKey;\n        try {\n            privateKey = await importKey(pem, password);\n        }\n        catch (err) {\n            await randomDelay();\n            throw new CodeError('Cannot read the key, most likely the password is wrong', codes.ERR_CANNOT_READ_KEY);\n        }\n        let kid;\n        try {\n            kid = await privateKey.id();\n            const cached = privates.get(this);\n            if (cached == null) {\n                throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS);\n            }\n            const dek = cached.dek;\n            pem = await privateKey.export(dek);\n        }\n        catch (err) {\n            await randomDelay();\n            throw err;\n        }\n        const keyInfo = {\n            name,\n            id: kid\n        };\n        const batch = this.components.datastore.batch();\n        batch.put(dsname, uint8ArrayFromString(pem));\n        batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n        await batch.commit();\n        return keyInfo;\n    }\n    /**\n     * Import a peer key\n     */\n    async importPeer(name, peer) {\n        try {\n            if (!validateKeyName(name)) {\n                throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME);\n            }\n            if (peer == null) {\n                throw new CodeError('PeerId is required', codes.ERR_MISSING_PRIVATE_KEY);\n            }\n            if (peer.privateKey == null) {\n                throw new CodeError('PeerId.privKey is required', codes.ERR_MISSING_PRIVATE_KEY);\n            }\n            const privateKey = await unmarshalPrivateKey(peer.privateKey);\n            const dsname = DsName(name);\n            const exists = await this.components.datastore.has(dsname);\n            if (exists) {\n                await randomDelay();\n                throw new CodeError(`Key '${name}' already exists`, codes.ERR_KEY_ALREADY_EXISTS);\n            }\n            const cached = privates.get(this);\n            if (cached == null) {\n                throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS);\n            }\n            const dek = cached.dek;\n            const pem = await privateKey.export(dek);\n            const keyInfo = {\n                name,\n                id: peer.toString()\n            };\n            const batch = this.components.datastore.batch();\n            batch.put(dsname, uint8ArrayFromString(pem));\n            batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n            await batch.commit();\n            return keyInfo;\n        }\n        catch (err) {\n            await randomDelay();\n            throw err;\n        }\n    }\n    /**\n     * Gets the private key as PEM encoded PKCS #8 string\n     */\n    async getPrivateKey(name) {\n        if (!validateKeyName(name)) {\n            await randomDelay();\n            throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME);\n        }\n        try {\n            const dsname = DsName(name);\n            const res = await this.components.datastore.get(dsname);\n            return uint8ArrayToString(res);\n        }\n        catch (err) {\n            await randomDelay();\n            log.error(err);\n            throw new CodeError(`Key '${name}' does not exist.`, codes.ERR_KEY_NOT_FOUND);\n        }\n    }\n    /**\n     * Rotate keychain password and re-encrypt all associated keys\n     */\n    async rotateKeychainPass(oldPass, newPass) {\n        if (typeof oldPass !== 'string') {\n            await randomDelay();\n            throw new CodeError(`Invalid old pass type '${typeof oldPass}'`, codes.ERR_INVALID_OLD_PASS_TYPE);\n        }\n        if (typeof newPass !== 'string') {\n            await randomDelay();\n            throw new CodeError(`Invalid new pass type '${typeof newPass}'`, codes.ERR_INVALID_NEW_PASS_TYPE);\n        }\n        if (newPass.length < 20) {\n            await randomDelay();\n            throw new CodeError(`Invalid pass length ${newPass.length}`, codes.ERR_INVALID_PASS_LENGTH);\n        }\n        log('recreating keychain');\n        const cached = privates.get(this);\n        if (cached == null) {\n            throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS);\n        }\n        const oldDek = cached.dek;\n        this.init.pass = newPass;\n        const newDek = newPass != null && this.init.dek?.salt != null\n            ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash)\n            : '';\n        privates.set(this, { dek: newDek });\n        const keys = await this.listKeys();\n        for (const key of keys) {\n            const res = await this.components.datastore.get(DsName(key.name));\n            const pem = uint8ArrayToString(res);\n            const privateKey = await importKey(pem, oldDek);\n            const password = newDek.toString();\n            const keyAsPEM = await privateKey.export(password);\n            // Update stored key\n            const batch = this.components.datastore.batch();\n            const keyInfo = {\n                name: key.name,\n                id: key.id\n            };\n            batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));\n            batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n            await batch.commit();\n        }\n        log('keychain reconstructed');\n    }\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Envelope;\n(function (Envelope) {\n    let _codec;\n    Envelope.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.publicKey);\n                }\n                if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.payloadType);\n                }\n                if ((obj.payload != null && obj.payload.byteLength > 0)) {\n                    w.uint32(26);\n                    w.bytes(obj.payload);\n                }\n                if ((obj.signature != null && obj.signature.byteLength > 0)) {\n                    w.uint32(42);\n                    w.bytes(obj.signature);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    publicKey: new Uint8Array(0),\n                    payloadType: new Uint8Array(0),\n                    payload: new Uint8Array(0),\n                    signature: new Uint8Array(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.publicKey = reader.bytes();\n                            break;\n                        case 2:\n                            obj.payloadType = reader.bytes();\n                            break;\n                        case 3:\n                            obj.payload = reader.bytes();\n                            break;\n                        case 5:\n                            obj.signature = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Envelope.encode = (obj) => {\n        return encodeMessage(obj, Envelope.codec());\n    };\n    Envelope.decode = (buf) => {\n        return decodeMessage(buf, Envelope.codec());\n    };\n})(Envelope || (Envelope = {}));\n//# sourceMappingURL=envelope.js.map","// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record';\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);\n//# sourceMappingURL=consts.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var PeerRecord;\n(function (PeerRecord) {\n    let AddressInfo;\n    (function (AddressInfo) {\n        let _codec;\n        AddressInfo.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n                        w.uint32(10);\n                        w.bytes(obj.multiaddr);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        multiaddr: new Uint8Array(0)\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.multiaddr = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        AddressInfo.encode = (obj) => {\n            return encodeMessage(obj, AddressInfo.codec());\n        };\n        AddressInfo.decode = (buf) => {\n            return decodeMessage(buf, AddressInfo.codec());\n        };\n    })(AddressInfo = PeerRecord.AddressInfo || (PeerRecord.AddressInfo = {}));\n    let _codec;\n    PeerRecord.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.peerId);\n                }\n                if ((obj.seq != null && obj.seq !== 0n)) {\n                    w.uint32(16);\n                    w.uint64(obj.seq);\n                }\n                if (obj.addresses != null) {\n                    for (const value of obj.addresses) {\n                        w.uint32(26);\n                        PeerRecord.AddressInfo.codec().encode(value, w);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    peerId: new Uint8Array(0),\n                    seq: 0n,\n                    addresses: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.peerId = reader.bytes();\n                            break;\n                        case 2:\n                            obj.seq = reader.uint64();\n                            break;\n                        case 3:\n                            obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PeerRecord.encode = (obj) => {\n        return encodeMessage(obj, PeerRecord.codec());\n    };\n    PeerRecord.decode = (buf) => {\n        return decodeMessage(buf, PeerRecord.codec());\n    };\n})(PeerRecord || (PeerRecord = {}));\n//# sourceMappingURL=peer-record.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Peer;\n(function (Peer) {\n    let Peer$metadataEntry;\n    (function (Peer$metadataEntry) {\n        let _codec;\n        Peer$metadataEntry.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.key != null && obj.key !== '')) {\n                        w.uint32(10);\n                        w.string(obj.key);\n                    }\n                    if ((obj.value != null && obj.value.byteLength > 0)) {\n                        w.uint32(18);\n                        w.bytes(obj.value);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        key: '',\n                        value: new Uint8Array(0)\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.key = reader.string();\n                                break;\n                            case 2:\n                                obj.value = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Peer$metadataEntry.encode = (obj) => {\n            return encodeMessage(obj, Peer$metadataEntry.codec());\n        };\n        Peer$metadataEntry.decode = (buf) => {\n            return decodeMessage(buf, Peer$metadataEntry.codec());\n        };\n    })(Peer$metadataEntry = Peer.Peer$metadataEntry || (Peer.Peer$metadataEntry = {}));\n    let Peer$tagsEntry;\n    (function (Peer$tagsEntry) {\n        let _codec;\n        Peer$tagsEntry.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.key != null && obj.key !== '')) {\n                        w.uint32(10);\n                        w.string(obj.key);\n                    }\n                    if (obj.value != null) {\n                        w.uint32(18);\n                        Tag.codec().encode(obj.value, w);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        key: ''\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.key = reader.string();\n                                break;\n                            case 2:\n                                obj.value = Tag.codec().decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Peer$tagsEntry.encode = (obj) => {\n            return encodeMessage(obj, Peer$tagsEntry.codec());\n        };\n        Peer$tagsEntry.decode = (buf) => {\n            return decodeMessage(buf, Peer$tagsEntry.codec());\n        };\n    })(Peer$tagsEntry = Peer.Peer$tagsEntry || (Peer.Peer$tagsEntry = {}));\n    let _codec;\n    Peer.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.addresses != null) {\n                    for (const value of obj.addresses) {\n                        w.uint32(10);\n                        Address.codec().encode(value, w);\n                    }\n                }\n                if (obj.protocols != null) {\n                    for (const value of obj.protocols) {\n                        w.uint32(18);\n                        w.string(value);\n                    }\n                }\n                if (obj.publicKey != null) {\n                    w.uint32(34);\n                    w.bytes(obj.publicKey);\n                }\n                if (obj.peerRecordEnvelope != null) {\n                    w.uint32(42);\n                    w.bytes(obj.peerRecordEnvelope);\n                }\n                if (obj.metadata != null && obj.metadata.size !== 0) {\n                    for (const [key, value] of obj.metadata.entries()) {\n                        w.uint32(50);\n                        Peer.Peer$metadataEntry.codec().encode({ key, value }, w);\n                    }\n                }\n                if (obj.tags != null && obj.tags.size !== 0) {\n                    for (const [key, value] of obj.tags.entries()) {\n                        w.uint32(58);\n                        Peer.Peer$tagsEntry.codec().encode({ key, value }, w);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    addresses: [],\n                    protocols: [],\n                    metadata: new Map(),\n                    tags: new Map()\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.addresses.push(Address.codec().decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            obj.protocols.push(reader.string());\n                            break;\n                        case 4:\n                            obj.publicKey = reader.bytes();\n                            break;\n                        case 5:\n                            obj.peerRecordEnvelope = reader.bytes();\n                            break;\n                        case 6: {\n                            const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32());\n                            obj.metadata.set(entry.key, entry.value);\n                            break;\n                        }\n                        case 7: {\n                            const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32());\n                            obj.tags.set(entry.key, entry.value);\n                            break;\n                        }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Peer.encode = (obj) => {\n        return encodeMessage(obj, Peer.codec());\n    };\n    Peer.decode = (buf) => {\n        return decodeMessage(buf, Peer.codec());\n    };\n})(Peer || (Peer = {}));\nexport var Address;\n(function (Address) {\n    let _codec;\n    Address.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.multiaddr);\n                }\n                if (obj.isCertified != null) {\n                    w.uint32(16);\n                    w.bool(obj.isCertified);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    multiaddr: new Uint8Array(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.multiaddr = reader.bytes();\n                            break;\n                        case 2:\n                            obj.isCertified = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Address.encode = (obj) => {\n        return encodeMessage(obj, Address.codec());\n    };\n    Address.decode = (buf) => {\n        return decodeMessage(buf, Address.codec());\n    };\n})(Address || (Address = {}));\nexport var Tag;\n(function (Tag) {\n    let _codec;\n    Tag.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.value != null && obj.value !== 0)) {\n                    w.uint32(8);\n                    w.uint32(obj.value);\n                }\n                if (obj.expiry != null) {\n                    w.uint32(16);\n                    w.uint64(obj.expiry);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    value: 0\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.value = reader.uint32();\n                            break;\n                        case 2:\n                            obj.expiry = reader.uint64();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Tag.encode = (obj) => {\n        return encodeMessage(obj, Tag.codec());\n    };\n    Tag.decode = (buf) => {\n        return decodeMessage(buf, Tag.codec());\n    };\n})(Tag || (Tag = {}));\n//# sourceMappingURL=peer.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { nanoid } from 'nanoid';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n    _buf;\n    /**\n     * @param {string | Uint8Array} s\n     * @param {boolean} [clean]\n     */\n    constructor(s, clean) {\n        if (typeof s === 'string') {\n            this._buf = uint8ArrayFromString(s);\n        }\n        else if (s instanceof Uint8Array) {\n            this._buf = s;\n        }\n        else {\n            throw new Error('Invalid key, should be String of Uint8Array');\n        }\n        if (clean == null) {\n            clean = true;\n        }\n        if (clean) {\n            this.clean();\n        }\n        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n            throw new Error('Invalid key');\n        }\n    }\n    /**\n     * Convert to the string representation\n     *\n     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n     * @returns {string}\n     */\n    toString(encoding = 'utf8') {\n        return uint8ArrayToString(this._buf, encoding);\n    }\n    /**\n     * Return the Uint8Array representation of the key\n     *\n     * @returns {Uint8Array}\n     */\n    uint8Array() {\n        return this._buf;\n    }\n    /**\n     * Return string representation of the key\n     *\n     * @returns {string}\n     */\n    get [Symbol.toStringTag]() {\n        return `Key(${this.toString()})`;\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list - The array of namespaces\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     * ```\n     */\n    static withNamespaces(list) {\n        return new Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.random()\n     * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n     * ```\n     */\n    static random() {\n        return new Key(nanoid().replace(/-/g, ''));\n    }\n    /**\n     * @param {*} other\n     */\n    static asKey(other) {\n        if (other instanceof Uint8Array || typeof other === 'string') {\n            // we can create a key from this\n            return new Key(other);\n        }\n        if (typeof other.uint8Array === 'function') {\n            // this is an older version or may have crossed the esm/cjs boundary\n            return new Key(other.uint8Array());\n        }\n        return null;\n    }\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    clean() {\n        if (this._buf == null || this._buf.byteLength === 0) {\n            this._buf = pathSepB;\n        }\n        if (this._buf[0] !== pathSep) {\n            const bytes = new Uint8Array(this._buf.byteLength + 1);\n            bytes.fill(pathSep, 0, 1);\n            bytes.set(this._buf, 1);\n            this._buf = bytes;\n        }\n        // normalize does not remove trailing slashes\n        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n            this._buf = this._buf.subarray(0, -1);\n        }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key - The other Key to check against\n     * @returns {boolean}\n     */\n    less(key) {\n        const list1 = this.list();\n        const list2 = key.list();\n        for (let i = 0; i < list1.length; i++) {\n            if (list2.length < i + 1) {\n                return false;\n            }\n            const c1 = list1[i];\n            const c2 = list2[i];\n            if (c1 < c2) {\n                return true;\n            }\n            else if (c1 > c2) {\n                return false;\n            }\n        }\n        return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     * ```\n     */\n    reverse() {\n        return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n    namespaces() {\n        return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     * ```\n     */\n    baseNamespace() {\n        const ns = this.namespaces();\n        return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     * ```\n     */\n    list() {\n        return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     * ```\n     */\n    type() {\n        return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     * ```\n     */\n    name() {\n        return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s - The string to append.\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    instance(s) {\n        return new Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     * ```\n     */\n    path() {\n        let p = this.parent().toString();\n        if (!p.endsWith(pathSepS)) {\n            p += pathSepS;\n        }\n        p += this.type();\n        return new Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     * ```\n     */\n    parent() {\n        const list = this.list();\n        if (list.length === 1) {\n            return new Key(pathSepS);\n        }\n        return new Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key - The child Key to add\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    child(key) {\n        if (this.toString() === pathSepS) {\n            return key;\n        }\n        else if (key.toString() === pathSepS) {\n            return this;\n        }\n        return new Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other - The other key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     * ```\n     */\n    isAncestorOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other - The other Key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     * ```\n     */\n    isDecendantOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Checks if this key has only one namespace.\n     *\n     * @returns {boolean}\n     */\n    isTopLevel() {\n        return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys - The array of keys to concatenate\n     * @returns {Key}\n     */\n    concat(...keys) {\n        return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n    }\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType(ns) {\n    const parts = ns.split(':');\n    if (parts.length < 2) {\n        return '';\n    }\n    return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue(ns) {\n    const parts = ns.split(':');\n    return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten(arr) {\n    return ([]).concat(...arr);\n}\n//# sourceMappingURL=key.js.map","import { logger } from '@libp2p/logger';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport all from 'it-all';\nimport { PersistentStore } from './store.js';\nconst log = logger('libp2p:peer-store');\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nexport class PersistentPeerStore {\n    store;\n    events;\n    peerId;\n    constructor(components, init = {}) {\n        this.events = components.events;\n        this.peerId = components.peerId;\n        this.store = new PersistentStore(components, init);\n    }\n    async forEach(fn, query) {\n        log.trace('forEach await read lock');\n        const release = await this.store.lock.readLock();\n        log.trace('forEach got read lock');\n        try {\n            for await (const peer of this.store.all(query)) {\n                fn(peer);\n            }\n        }\n        finally {\n            log.trace('forEach release read lock');\n            release();\n        }\n    }\n    async all(query) {\n        log.trace('all await read lock');\n        const release = await this.store.lock.readLock();\n        log.trace('all got read lock');\n        try {\n            return await all(this.store.all(query));\n        }\n        finally {\n            log.trace('all release read lock');\n            release();\n        }\n    }\n    async delete(peerId) {\n        log.trace('delete await write lock');\n        const release = await this.store.lock.writeLock();\n        log.trace('delete got write lock');\n        try {\n            await this.store.delete(peerId);\n        }\n        finally {\n            log.trace('delete release write lock');\n            release();\n        }\n    }\n    async has(peerId) {\n        log.trace('has await read lock');\n        const release = await this.store.lock.readLock();\n        log.trace('has got read lock');\n        try {\n            return await this.store.has(peerId);\n        }\n        finally {\n            log.trace('has release read lock');\n            release();\n        }\n    }\n    async get(peerId) {\n        log.trace('get await read lock');\n        const release = await this.store.lock.readLock();\n        log.trace('get got read lock');\n        try {\n            return await this.store.load(peerId);\n        }\n        finally {\n            log.trace('get release read lock');\n            release();\n        }\n    }\n    async save(id, data) {\n        log.trace('save await write lock');\n        const release = await this.store.lock.writeLock();\n        log.trace('save got write lock');\n        try {\n            const result = await this.store.save(id, data);\n            this.#emitIfUpdated(id, result);\n            return result.peer;\n        }\n        finally {\n            log.trace('save release write lock');\n            release();\n        }\n    }\n    async patch(id, data) {\n        log.trace('patch await write lock');\n        const release = await this.store.lock.writeLock();\n        log.trace('patch got write lock');\n        try {\n            const result = await this.store.patch(id, data);\n            this.#emitIfUpdated(id, result);\n            return result.peer;\n        }\n        finally {\n            log.trace('patch release write lock');\n            release();\n        }\n    }\n    async merge(id, data) {\n        log.trace('merge await write lock');\n        const release = await this.store.lock.writeLock();\n        log.trace('merge got write lock');\n        try {\n            const result = await this.store.merge(id, data);\n            this.#emitIfUpdated(id, result);\n            return result.peer;\n        }\n        finally {\n            log.trace('merge release write lock');\n            release();\n        }\n    }\n    async consumePeerRecord(buf, expectedPeer) {\n        const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN);\n        if (expectedPeer?.equals(envelope.peerId) === false) {\n            log('envelope peer id was not the expected peer id - expected: %p received: %p', expectedPeer, envelope.peerId);\n            return false;\n        }\n        const peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n        let peer;\n        try {\n            peer = await this.get(envelope.peerId);\n        }\n        catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n                throw err;\n            }\n        }\n        // ensure seq is greater than, or equal to, the last received\n        if (peer?.peerRecordEnvelope != null) {\n            const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);\n            const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);\n            if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n                log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber);\n                return false;\n            }\n        }\n        await this.patch(peerRecord.peerId, {\n            peerRecordEnvelope: buf,\n            addresses: peerRecord.multiaddrs.map(multiaddr => ({\n                isCertified: true,\n                multiaddr\n            }))\n        });\n        return true;\n    }\n    #emitIfUpdated(id, result) {\n        if (!result.updated) {\n            return;\n        }\n        if (this.peerId.equals(id)) {\n            this.events.safeDispatchEvent('self:peer:update', { detail: result });\n        }\n        else {\n            this.events.safeDispatchEvent('peer:update', { detail: result });\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { debounce } from './utils.js';\nconst log = logger('libp2p:address-manager');\nconst defaultAddressFilter = (addrs) => addrs;\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */\nfunction stripPeerId(ma, peerId) {\n    const observedPeerIdStr = ma.getPeerId();\n    // strip our peer id if it has been passed\n    if (observedPeerIdStr != null) {\n        const observedPeerId = peerIdFromString(observedPeerIdStr);\n        // use same encoding for comparison\n        if (observedPeerId.equals(peerId)) {\n            ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));\n        }\n    }\n    return ma;\n}\nexport class DefaultAddressManager {\n    components;\n    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`\n    listen;\n    announce;\n    observed;\n    announceFilter;\n    /**\n     * Responsible for managing the peer addresses.\n     * Peers can specify their listen and announce addresses.\n     * The listen addresses will be used by the libp2p transports to listen for new connections,\n     * while the announce addresses will be used for the peer addresses' to other peers in the network.\n     */\n    constructor(components, init = {}) {\n        const { listen = [], announce = [] } = init;\n        this.components = components;\n        this.listen = listen.map(ma => ma.toString());\n        this.announce = new Set(announce.map(ma => ma.toString()));\n        this.observed = new Map();\n        this.announceFilter = init.announceFilter ?? defaultAddressFilter;\n        // this method gets called repeatedly on startup when transports start listening so\n        // debounce it so we don't cause multiple self:peer:update events to be emitted\n        this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000);\n        // update our stored addresses when new transports listen\n        components.events.addEventListener('transport:listening', () => {\n            this._updatePeerStoreAddresses();\n        });\n        // update our stored addresses when existing transports stop listening\n        components.events.addEventListener('transport:close', () => {\n            this._updatePeerStoreAddresses();\n        });\n    }\n    _updatePeerStoreAddresses() {\n        // if announce addresses have been configured, ensure they make it into our peer\n        // record for things like identify\n        const addrs = this.getAnnounceAddrs()\n            .concat(this.components.transportManager.getAddrs())\n            .concat([...this.observed.entries()]\n            .filter(([_, metadata]) => metadata.confident)\n            .map(([str]) => multiaddr(str))).map(ma => {\n            // strip our peer id if it is present\n            if (ma.getPeerId() === this.components.peerId.toString()) {\n                return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);\n            }\n            return ma;\n        });\n        this.components.peerStore.patch(this.components.peerId, {\n            multiaddrs: addrs\n        })\n            .catch(err => { log.error('error updating addresses', err); });\n    }\n    /**\n     * Get peer listen multiaddrs\n     */\n    getListenAddrs() {\n        return Array.from(this.listen).map((a) => multiaddr(a));\n    }\n    /**\n     * Get peer announcing multiaddrs\n     */\n    getAnnounceAddrs() {\n        return Array.from(this.announce).map((a) => multiaddr(a));\n    }\n    /**\n     * Get observed multiaddrs\n     */\n    getObservedAddrs() {\n        return Array.from(this.observed).map(([a]) => multiaddr(a));\n    }\n    /**\n     * Add peer observed addresses\n     */\n    addObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        // do not trigger the change:addresses event if we already know about this address\n        if (this.observed.has(addrString)) {\n            return;\n        }\n        this.observed.set(addrString, {\n            confident: false\n        });\n    }\n    confirmObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        const metadata = this.observed.get(addrString) ?? {\n            confident: false\n        };\n        const startingConfidence = metadata.confident;\n        this.observed.set(addrString, {\n            confident: true\n        });\n        // only trigger the 'self:peer:update' event if our confidence in an address has changed\n        if (!startingConfidence) {\n            this._updatePeerStoreAddresses();\n        }\n    }\n    removeObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        this.observed.delete(addrString);\n    }\n    getAddresses() {\n        let addrs = this.getAnnounceAddrs().map(ma => ma.toString());\n        if (addrs.length === 0) {\n            // no configured announce addrs, add configured listen addresses\n            addrs = this.components.transportManager.getAddrs().map(ma => ma.toString());\n        }\n        // add observed addresses we are confident in\n        addrs = addrs.concat(Array.from(this.observed)\n            .filter(([ma, metadata]) => metadata.confident)\n            .map(([ma]) => ma));\n        // dedupe multiaddrs\n        const addrSet = new Set(addrs);\n        // Create advertising list\n        return this.announceFilter(Array.from(addrSet)\n            .map(str => multiaddr(str)))\n            .map(ma => {\n            // do not append our peer id to a path multiaddr as it will become invalid\n            if (ma.protos().pop()?.path === true) {\n                return ma;\n            }\n            if (ma.getPeerId() === this.components.peerId.toString()) {\n                return ma;\n            }\n            return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);\n        });\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Provides strategies to sort a list of multiaddrs.\n *\n * @example\n *\n * ```typescript\n * import { publicAddressesFirst } from '@libp2p/utils/address-sort'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n *\n * const addresses = [\n *   multiaddr('/ip4/127.0.0.1/tcp/9000'),\n *   multiaddr('/ip4/82.41.53.1/tcp/9000')\n * ].sort(publicAddressesFirst)\n *\n * console.info(addresses)\n * // ['/ip4/82.41.53.1/tcp/9000', '/ip4/127.0.0.1/tcp/9000']\n * ```\n */\nimport { Circuit } from '@multiformats/multiaddr-matcher';\nimport { isPrivate } from './multiaddr/is-private.js';\n/**\n * Compare function for array.sort() that moves public addresses to the start\n * of the array.\n */\nexport function publicAddressesFirst(a, b) {\n    const isAPrivate = isPrivate(a.multiaddr);\n    const isBPrivate = isPrivate(b.multiaddr);\n    if (isAPrivate && !isBPrivate) {\n        return 1;\n    }\n    else if (!isAPrivate && isBPrivate) {\n        return -1;\n    }\n    return 0;\n}\n/**\n * Compare function for array.sort() that moves certified addresses to the start\n * of the array.\n */\nexport function certifiedAddressesFirst(a, b) {\n    if (a.isCertified && !b.isCertified) {\n        return -1;\n    }\n    else if (!a.isCertified && b.isCertified) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Compare function for array.sort() that moves circuit relay addresses to the\n * start of the array.\n */\nexport function circuitRelayAddressesLast(a, b) {\n    const isACircuit = Circuit.exactMatch(a.multiaddr);\n    const isBCircuit = Circuit.exactMatch(b.multiaddr);\n    if (isACircuit && !isBCircuit) {\n        return 1;\n    }\n    else if (!isACircuit && isBCircuit) {\n        return -1;\n    }\n    return 0;\n}\nexport function defaultAddressSort(a, b) {\n    const publicResult = publicAddressesFirst(a, b);\n    if (publicResult !== 0) {\n        return publicResult;\n    }\n    const relayResult = circuitRelayAddressesLast(a, b);\n    if (relayResult !== 0) {\n        return relayResult;\n    }\n    const certifiedResult = certifiedAddressesFirst(a, b);\n    return certifiedResult;\n}\n//# sourceMappingURL=address-sort.js.map","/**\n * @packageDocumentation\n *\n * Provides strategies for resolving multiaddrs.\n */\nimport { getProtocol } from '../protocols-table.js';\nimport Resolver from './dns.js';\nconst { code: dnsaddrCode } = getProtocol('dnsaddr');\n/**\n * Resolver for dnsaddr addresses.\n *\n * @example\n *\n * ```typescript\n * import { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const addresses = await dnsaddrResolver(ma)\n *\n * console.info(addresses)\n * //[\n * //  '/dnsaddr/am6.bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n * //  '/dnsaddr/ny5.bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n * //  '/dnsaddr/sg1.bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n * //  '/dnsaddr/sv15.bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN'\n * //]\n * ```\n */\nexport async function dnsaddrResolver(addr, options = {}) {\n    const resolver = new Resolver();\n    if (options.signal != null) {\n        options.signal.addEventListener('abort', () => {\n            resolver.cancel();\n        });\n    }\n    const peerId = addr.getPeerId();\n    const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];\n    if (hostname == null) {\n        throw new Error('No hostname found in multiaddr');\n    }\n    const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);\n    let addresses = records.flat().map((a) => a.split('=')[1]).filter(Boolean);\n    if (peerId != null) {\n        addresses = addresses.filter((entry) => entry.includes(peerId));\n    }\n    return addresses;\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { FaultTolerance } from '@libp2p/interface/transport';\nimport { defaultAddressSort } from '@libp2p/utils/address-sort';\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers';\nimport mergeOptions from 'merge-options';\nimport { codes, messages } from './errors.js';\nconst DefaultConfig = {\n    addresses: {\n        listen: [],\n        announce: [],\n        noAnnounce: [],\n        announceFilter: (multiaddrs) => multiaddrs\n    },\n    connectionManager: {\n        resolvers: {\n            dnsaddr: dnsaddrResolver\n        },\n        addressSorter: defaultAddressSort\n    },\n    transportManager: {\n        faultTolerance: FaultTolerance.FATAL_ALL\n    }\n};\nexport function validateConfig(opts) {\n    const resultingOptions = mergeOptions(DefaultConfig, opts);\n    if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {\n        throw new CodeError(messages.ERR_TRANSPORTS_REQUIRED, codes.ERR_TRANSPORTS_REQUIRED);\n    }\n    if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) { // eslint-disable-line no-undef\n        throw new CodeError(messages.ERR_PROTECTOR_REQUIRED, codes.ERR_PROTECTOR_REQUIRED);\n    }\n    return resultingOptions;\n}\n//# sourceMappingURL=config.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { isPeerId } from '@libp2p/interface/peer-id';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { codes } from './errors.js';\nconst log = logger('libp2p:get-peer');\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs\n */\nexport function getPeerAddress(peer) {\n    if (isPeerId(peer)) {\n        return { peerId: peer, multiaddrs: [] };\n    }\n    if (!Array.isArray(peer)) {\n        peer = [peer];\n    }\n    let peerId;\n    if (peer.length > 0) {\n        const peerIdStr = peer[0].getPeerId();\n        peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr);\n        // ensure PeerId is either not set or is consistent\n        peer.forEach(ma => {\n            if (!isMultiaddr(ma)) {\n                log.error('multiaddr %s was invalid', ma);\n                throw new CodeError('Invalid Multiaddr', codes.ERR_INVALID_MULTIADDR);\n            }\n            const maPeerIdStr = ma.getPeerId();\n            if (maPeerIdStr == null) {\n                if (peerId != null) {\n                    throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS);\n                }\n            }\n            else {\n                const maPeerId = peerIdFromString(maPeerIdStr);\n                if (peerId == null || !peerId.equals(maPeerId)) {\n                    throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS);\n                }\n            }\n        });\n    }\n    return {\n        peerId,\n        multiaddrs: peer\n    };\n}\n//# sourceMappingURL=get-peer.js.map","import { logger } from '@libp2p/logger';\nimport { PeerMap, PeerSet } from '@libp2p/peer-collections';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { PeerJobQueue } from '../utils/peer-job-queue.js';\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE, AUTO_DIAL_INTERVAL, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PEER_RETRY_THRESHOLD, AUTO_DIAL_PRIORITY, LAST_DIAL_FAILURE_KEY, MIN_CONNECTIONS } from './constants.js';\nconst log = logger('libp2p:connection-manager:auto-dial');\nconst defaultOptions = {\n    minConnections: MIN_CONNECTIONS,\n    maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,\n    autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n    autoDialPriority: AUTO_DIAL_PRIORITY,\n    autoDialInterval: AUTO_DIAL_INTERVAL,\n    autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,\n    autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE\n};\nexport class AutoDial {\n    connectionManager;\n    peerStore;\n    queue;\n    minConnections;\n    autoDialPriority;\n    autoDialIntervalMs;\n    autoDialMaxQueueLength;\n    autoDialPeerRetryThresholdMs;\n    autoDialDiscoveredPeersDebounce;\n    autoDialInterval;\n    started;\n    running;\n    /**\n     * Proactively tries to connect to known peers stored in the PeerStore.\n     * It will keep the number of connections below the upper limit and sort\n     * the peers to connect based on whether we know their keys and protocols.\n     */\n    constructor(components, init) {\n        this.connectionManager = components.connectionManager;\n        this.peerStore = components.peerStore;\n        this.minConnections = init.minConnections ?? defaultOptions.minConnections;\n        this.autoDialPriority = init.autoDialPriority ?? defaultOptions.autoDialPriority;\n        this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions.autoDialInterval;\n        this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions.maxQueueLength;\n        this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions.autoDialPeerRetryThreshold;\n        this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions.autoDialDiscoveredPeersDebounce;\n        this.started = false;\n        this.running = false;\n        this.queue = new PeerJobQueue({\n            concurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency\n        });\n        this.queue.addListener('error', (err) => {\n            log.error('error during auto-dial', err);\n        });\n        // check the min connection limit whenever a peer disconnects\n        components.events.addEventListener('connection:close', () => {\n            this.autoDial()\n                .catch(err => {\n                log.error(err);\n            });\n        });\n        // sometimes peers are discovered in quick succession so add a small\n        // debounce to ensure all eligible peers are autodialed\n        let debounce;\n        // when new peers are discovered, dial them if we don't have\n        // enough connections\n        components.events.addEventListener('peer:discovery', () => {\n            clearTimeout(debounce);\n            debounce = setTimeout(() => {\n                this.autoDial()\n                    .catch(err => {\n                    log.error(err);\n                });\n            }, this.autoDialDiscoveredPeersDebounce);\n        });\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.autoDialInterval = setTimeout(() => {\n            this.autoDial()\n                .catch(err => {\n                log.error('error while autodialing', err);\n            });\n        }, this.autoDialIntervalMs);\n        this.started = true;\n    }\n    afterStart() {\n        this.autoDial()\n            .catch(err => {\n            log.error('error while autodialing', err);\n        });\n    }\n    stop() {\n        // clear the queue\n        this.queue.clear();\n        clearTimeout(this.autoDialInterval);\n        this.started = false;\n        this.running = false;\n    }\n    async autoDial() {\n        if (!this.started) {\n            return;\n        }\n        const connections = this.connectionManager.getConnectionsMap();\n        const numConnections = connections.size;\n        // Already has enough connections\n        if (numConnections >= this.minConnections) {\n            if (this.minConnections > 0) {\n                log.trace('have enough connections %d/%d', numConnections, this.minConnections);\n            }\n            return;\n        }\n        if (this.queue.size > this.autoDialMaxQueueLength) {\n            log('not enough connections %d/%d but auto dial queue is full', numConnections, this.minConnections);\n            return;\n        }\n        if (this.running) {\n            log('not enough connections %d/%d - but skipping autodial as it is already running', numConnections, this.minConnections);\n            return;\n        }\n        this.running = true;\n        log('not enough connections %d/%d - will dial peers to increase the number of connections', numConnections, this.minConnections);\n        const dialQueue = new PeerSet(\n        // @ts-expect-error boolean filter removes falsy peer IDs\n        this.connectionManager.getDialQueue()\n            .map(queue => queue.peerId)\n            .filter(Boolean));\n        // Sort peers on whether we know protocols or public keys for them\n        const peers = await this.peerStore.all({\n            filters: [\n                // Remove some peers\n                (peer) => {\n                    // Remove peers without addresses\n                    if (peer.addresses.length === 0) {\n                        log.trace('not autodialing %p because they have no addresses', peer.id);\n                        return false;\n                    }\n                    // remove peers we are already connected to\n                    if (connections.has(peer.id)) {\n                        log.trace('not autodialing %p because they are already connected', peer.id);\n                        return false;\n                    }\n                    // remove peers we are already dialling\n                    if (dialQueue.has(peer.id)) {\n                        log.trace('not autodialing %p because they are already being dialed', peer.id);\n                        return false;\n                    }\n                    // remove peers already in the autodial queue\n                    if (this.queue.hasJob(peer.id)) {\n                        log.trace('not autodialing %p because they are already being autodialed', peer.id);\n                        return false;\n                    }\n                    return true;\n                }\n            ]\n        });\n        // shuffle the peers - this is so peers with the same tag values will be\n        // dialled in a different order each time\n        const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1);\n        // Sort shuffled peers by tag value\n        const peerValues = new PeerMap();\n        for (const peer of shuffledPeers) {\n            if (peerValues.has(peer.id)) {\n                continue;\n            }\n            // sum all tag values\n            peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {\n                return acc + curr.value;\n            }, 0));\n        }\n        // sort by value, highest to lowest\n        const sortedPeers = shuffledPeers.sort((a, b) => {\n            const peerAValue = peerValues.get(a.id) ?? 0;\n            const peerBValue = peerValues.get(b.id) ?? 0;\n            if (peerAValue > peerBValue) {\n                return -1;\n            }\n            if (peerAValue < peerBValue) {\n                return 1;\n            }\n            return 0;\n        });\n        const peersThatHaveNotFailed = sortedPeers.filter(peer => {\n            const lastDialFailure = peer.metadata.get(LAST_DIAL_FAILURE_KEY);\n            if (lastDialFailure == null) {\n                return true;\n            }\n            const lastDialFailureTimestamp = parseInt(uint8ArrayToString(lastDialFailure));\n            if (isNaN(lastDialFailureTimestamp)) {\n                return true;\n            }\n            // only dial if the time since the last failure is above the retry threshold\n            return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs;\n        });\n        log('selected %d/%d peers to dial', peersThatHaveNotFailed.length, peers.length);\n        for (const peer of peersThatHaveNotFailed) {\n            this.queue.add(async () => {\n                const numConnections = this.connectionManager.getConnectionsMap().size;\n                // Check to see if we still need to auto dial\n                if (numConnections >= this.minConnections) {\n                    log('got enough connections now %d/%d', numConnections, this.minConnections);\n                    this.queue.clear();\n                    return;\n                }\n                log('connecting to a peerStore stored peer %p', peer.id);\n                await this.connectionManager.openConnection(peer.id, {\n                    priority: this.autoDialPriority\n                });\n            }, {\n                peerId: peer.id\n            }).catch(err => {\n                log.error('could not connect to peerStore stored peer', err);\n            });\n        }\n        this.running = false;\n        if (this.started) {\n            this.autoDialInterval = setTimeout(() => {\n                this.autoDial()\n                    .catch(err => {\n                    log.error('error while autodialing', err);\n                });\n            }, this.autoDialIntervalMs);\n        }\n    }\n}\n//# sourceMappingURL=auto-dial.js.map","import { logger } from '@libp2p/logger';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { MAX_CONNECTIONS } from './constants.js';\nconst log = logger('libp2p:connection-manager:connection-pruner');\nconst defaultOptions = {\n    maxConnections: MAX_CONNECTIONS,\n    allow: []\n};\n/**\n * If we go over the max connections limit, choose some connections to close\n */\nexport class ConnectionPruner {\n    maxConnections;\n    connectionManager;\n    peerStore;\n    allow;\n    events;\n    constructor(components, init = {}) {\n        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;\n        this.allow = init.allow ?? defaultOptions.allow;\n        this.connectionManager = components.connectionManager;\n        this.peerStore = components.peerStore;\n        this.events = components.events;\n        // check the max connection limit whenever a peer connects\n        components.events.addEventListener('connection:open', () => {\n            this.maybePruneConnections()\n                .catch(err => {\n                log.error(err);\n            });\n        });\n    }\n    /**\n     * If we have more connections than our maximum, select some excess connections\n     * to prune based on peer value\n     */\n    async maybePruneConnections() {\n        const connections = this.connectionManager.getConnections();\n        const numConnections = connections.length;\n        const toPrune = Math.max(numConnections - this.maxConnections, 0);\n        log('checking max connections limit %d/%d', numConnections, this.maxConnections);\n        if (numConnections <= this.maxConnections) {\n            return;\n        }\n        log('max connections limit exceeded %d/%d, pruning %d connection(s)', numConnections, this.maxConnections, toPrune);\n        const peerValues = new PeerMap();\n        // work out peer values\n        for (const connection of connections) {\n            const remotePeer = connection.remotePeer;\n            if (peerValues.has(remotePeer)) {\n                continue;\n            }\n            peerValues.set(remotePeer, 0);\n            try {\n                const peer = await this.peerStore.get(remotePeer);\n                // sum all tag values\n                peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {\n                    return acc + curr.value;\n                }, 0));\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    log.error('error loading peer tags', err);\n                }\n            }\n        }\n        // sort by value, lowest to highest\n        const sortedConnections = connections.sort((a, b) => {\n            const peerAValue = peerValues.get(a.remotePeer) ?? 0;\n            const peerBValue = peerValues.get(b.remotePeer) ?? 0;\n            if (peerAValue > peerBValue) {\n                return 1;\n            }\n            if (peerAValue < peerBValue) {\n                return -1;\n            }\n            // if the peers have an equal tag value then we want to close short-lived connections first\n            const connectionALifespan = a.timeline.open;\n            const connectionBLifespan = b.timeline.open;\n            if (connectionALifespan < connectionBLifespan) {\n                return 1;\n            }\n            if (connectionALifespan > connectionBLifespan) {\n                return -1;\n            }\n            return 0;\n        });\n        // close some connections\n        const toClose = [];\n        for (const connection of sortedConnections) {\n            log('too many connections open - closing a connection to %p', connection.remotePeer);\n            // check allow list\n            const connectionInAllowList = this.allow.some((ma) => {\n                return connection.remoteAddr.toString().startsWith(ma.toString());\n            });\n            // Connections in the allow list should be excluded from pruning\n            if (!connectionInAllowList) {\n                toClose.push(connection);\n            }\n            if (toClose.length === toPrune) {\n                break;\n            }\n        }\n        // close connections\n        await Promise.all(toClose.map(async (connection) => {\n            try {\n                await connection.close();\n            }\n            catch (err) {\n                log.error(err);\n            }\n        }));\n        // despatch prune event\n        this.events.safeDispatchEvent('connection:prune', { detail: toClose });\n    }\n}\n//# sourceMappingURL=connection-pruner.js.map","import { setMaxListeners } from 'events';\nimport { logger } from '@libp2p/logger';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { anySignal } from 'any-signal';\nconst log = logger('libp2p:connection-manager:utils');\n/**\n * Resolve multiaddr recursively\n */\nexport async function resolveMultiaddrs(ma, options) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr');\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n        return [ma];\n    }\n    const resolvedMultiaddrs = await resolveRecord(ma, options);\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {\n        return resolveMultiaddrs(nm, options);\n    }));\n    const addrs = recursiveMultiaddrs.flat();\n    const output = addrs.reduce((array, newM) => {\n        if (array.find(m => m.equals(newM)) == null) {\n            array.push(newM);\n        }\n        return array;\n    }, ([]));\n    log('resolved %s to', ma, output.map(ma => ma.toString()));\n    return output;\n}\n/**\n * Resolve a given multiaddr. If this fails, an empty array will be returned\n */\nasync function resolveRecord(ma, options) {\n    try {\n        ma = multiaddr(ma.toString()); // Use current multiaddr module\n        const multiaddrs = await ma.resolve(options);\n        return multiaddrs;\n    }\n    catch (err) {\n        log.error(`multiaddr ${ma.toString()} could not be resolved`, err);\n        return [];\n    }\n}\nexport function combineSignals(...signals) {\n    const sigs = [];\n    for (const sig of signals) {\n        if (sig != null) {\n            try {\n                // fails on node < 15.4\n                setMaxListeners?.(Infinity, sig);\n            }\n            catch { }\n            sigs.push(sig);\n        }\n    }\n    // let any signal abort the dial\n    const signal = anySignal(sigs);\n    try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, signal);\n    }\n    catch { }\n    return signal;\n}\n//# sourceMappingURL=utils.js.map","import { setMaxListeners } from 'events';\nimport { AbortError, CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { defaultAddressSort } from '@libp2p/utils/address-sort';\nimport { resolvers } from '@multiformats/multiaddr';\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers';\nimport { anySignal } from 'any-signal';\nimport pDefer from 'p-defer';\nimport PQueue from 'p-queue';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { codes } from '../errors.js';\nimport { getPeerAddress } from '../get-peer.js';\nimport { DIAL_TIMEOUT, MAX_PARALLEL_DIALS_PER_PEER, MAX_PARALLEL_DIALS, MAX_PEER_ADDRS_TO_DIAL, LAST_DIAL_FAILURE_KEY } from './constants.js';\nimport { combineSignals, resolveMultiaddrs } from './utils.js';\nconst log = logger('libp2p:connection-manager:dial-queue');\nconst defaultOptions = {\n    addressSorter: defaultAddressSort,\n    maxParallelDials: MAX_PARALLEL_DIALS,\n    maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,\n    maxParallelDialsPerPeer: MAX_PARALLEL_DIALS_PER_PEER,\n    dialTimeout: DIAL_TIMEOUT,\n    resolvers: {\n        dnsaddr: dnsaddrResolver\n    }\n};\nexport class DialQueue {\n    pendingDials;\n    queue;\n    peerId;\n    peerStore;\n    connectionGater;\n    transportManager;\n    addressSorter;\n    maxPeerAddrsToDial;\n    maxParallelDialsPerPeer;\n    dialTimeout;\n    inProgressDialCount;\n    pendingDialCount;\n    shutDownController;\n    constructor(components, init = {}) {\n        this.addressSorter = init.addressSorter ?? defaultOptions.addressSorter;\n        this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial;\n        this.maxParallelDialsPerPeer = init.maxParallelDialsPerPeer ?? defaultOptions.maxParallelDialsPerPeer;\n        this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout;\n        this.peerId = components.peerId;\n        this.peerStore = components.peerStore;\n        this.connectionGater = components.connectionGater;\n        this.transportManager = components.transportManager;\n        this.shutDownController = new AbortController();\n        try {\n            // This emitter gets listened to a lot\n            setMaxListeners?.(Infinity, this.shutDownController.signal);\n        }\n        catch { }\n        this.pendingDialCount = components.metrics?.registerMetric('libp2p_dialler_pending_dials');\n        this.inProgressDialCount = components.metrics?.registerMetric('libp2p_dialler_in_progress_dials');\n        this.pendingDials = [];\n        for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n            resolvers.set(key, value);\n        }\n        // controls dial concurrency\n        this.queue = new PQueue({\n            concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials\n        });\n        // a job was added to the queue\n        this.queue.on('add', () => {\n            this.pendingDialCount?.update(this.queue.size);\n            this.inProgressDialCount?.update(this.queue.pending);\n        });\n        // a queued job started\n        this.queue.on('active', () => {\n            this.pendingDialCount?.update(this.queue.size);\n            this.inProgressDialCount?.update(this.queue.pending);\n        });\n        // a started job completed without error\n        this.queue.on('completed', () => {\n            this.pendingDialCount?.update(this.queue.size);\n            this.inProgressDialCount?.update(this.queue.pending);\n        });\n        // a started job errored\n        this.queue.on('error', (err) => {\n            log.error('error in dial queue', err);\n            this.pendingDialCount?.update(this.queue.size);\n            this.inProgressDialCount?.update(this.queue.pending);\n        });\n        // all queued jobs have been started\n        this.queue.on('empty', () => {\n            this.pendingDialCount?.update(this.queue.size);\n            this.inProgressDialCount?.update(this.queue.pending);\n        });\n        // add started jobs have run and the queue is empty\n        this.queue.on('idle', () => {\n            this.pendingDialCount?.update(this.queue.size);\n            this.inProgressDialCount?.update(this.queue.pending);\n        });\n    }\n    /**\n     * Clears any pending dials\n     */\n    stop() {\n        this.shutDownController.abort();\n    }\n    /**\n     * Connects to a given peer, multiaddr or list of multiaddrs.\n     *\n     * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n     * multiaddrs are passed only those will be dialled.\n     *\n     * Where a list of multiaddrs is passed, if any contain a peer id then all\n     * multiaddrs in the list must contain the same peer id.\n     *\n     * The dial to the first address that is successfully able to upgrade a connection\n     * will be used, all other dials will be aborted when that happens.\n     */\n    async dial(peerIdOrMultiaddr, options = {}) {\n        const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);\n        const addrs = multiaddrs.map(multiaddr => ({\n            multiaddr,\n            isCertified: false\n        }));\n        // create abort conditions - need to do this before `calculateMultiaddrs` as we may be about to\n        // resolve a dns addr which can time out\n        const signal = this.createDialAbortControllers(options.signal);\n        let addrsToDial;\n        try {\n            // load addresses from address book, resolve and dnsaddrs, filter undiallables, add peer IDs, etc\n            addrsToDial = await this.calculateMultiaddrs(peerId, addrs, {\n                ...options,\n                signal\n            });\n        }\n        catch (err) {\n            signal.clear();\n            throw err;\n        }\n        // ready to dial, all async work finished - make sure we don't have any\n        // pending dials in progress for this peer or set of multiaddrs\n        const existingDial = this.pendingDials.find(dial => {\n            // is the dial for the same peer id?\n            if (dial.peerId != null && peerId != null && dial.peerId.equals(peerId)) {\n                return true;\n            }\n            // is the dial for the same set of multiaddrs?\n            if (addrsToDial.map(({ multiaddr }) => multiaddr.toString()).join() === dial.multiaddrs.map(multiaddr => multiaddr.toString()).join()) {\n                return true;\n            }\n            return false;\n        });\n        if (existingDial != null) {\n            log('joining existing dial target for %p', peerId);\n            signal.clear();\n            return existingDial.promise;\n        }\n        log('creating dial target for', addrsToDial.map(({ multiaddr }) => multiaddr.toString()));\n        // @ts-expect-error .promise property is set below\n        const pendingDial = {\n            id: randomId(),\n            status: 'queued',\n            peerId,\n            multiaddrs: addrsToDial.map(({ multiaddr }) => multiaddr)\n        };\n        pendingDial.promise = this.performDial(pendingDial, {\n            ...options,\n            signal\n        })\n            .finally(() => {\n            // remove our pending dial entry\n            this.pendingDials = this.pendingDials.filter(p => p.id !== pendingDial.id);\n            // clean up abort signals/controllers\n            signal.clear();\n        })\n            .catch(async (err) => {\n            log.error('dial failed to %s', pendingDial.multiaddrs.map(ma => ma.toString()).join(', '), err);\n            if (peerId != null) {\n                // record the last failed dial\n                try {\n                    await this.peerStore.patch(peerId, {\n                        metadata: {\n                            [LAST_DIAL_FAILURE_KEY]: uint8ArrayFromString(Date.now().toString())\n                        }\n                    });\n                }\n                catch (err) {\n                    log.error('could not update last dial failure key for %p', peerId, err);\n                }\n            }\n            // Error is a timeout\n            if (signal.aborted) {\n                const error = new CodeError(err.message, codes.ERR_TIMEOUT);\n                throw error;\n            }\n            throw err;\n        });\n        // let other dials join this one\n        this.pendingDials.push(pendingDial);\n        return pendingDial.promise;\n    }\n    createDialAbortControllers(userSignal) {\n        // let any signal abort the dial\n        const signal = anySignal([AbortSignal.timeout(this.dialTimeout),\n            this.shutDownController.signal,\n            userSignal\n        ]);\n        try {\n            // This emitter gets listened to a lot\n            setMaxListeners?.(Infinity, signal);\n        }\n        catch { }\n        return signal;\n    }\n    // eslint-disable-next-line complexity\n    async calculateMultiaddrs(peerId, addrs = [], options = {}) {\n        // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n        if (peerId != null) {\n            if (this.peerId.equals(peerId)) {\n                throw new CodeError('Tried to dial self', codes.ERR_DIALED_SELF);\n            }\n            if ((await this.connectionGater.denyDialPeer?.(peerId)) === true) {\n                throw new CodeError('The dial request is blocked by gater.allowDialPeer', codes.ERR_PEER_DIAL_INTERCEPTED);\n            }\n            // if just a peer id was passed, load available multiaddrs for this peer from the address book\n            if (addrs.length === 0) {\n                log('loading multiaddrs for %p', peerId);\n                try {\n                    const peer = await this.peerStore.get(peerId);\n                    addrs.push(...peer.addresses);\n                    log('loaded multiaddrs for %p', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()));\n                }\n                catch (err) {\n                    if (err.code !== codes.ERR_NOT_FOUND) {\n                        throw err;\n                    }\n                }\n            }\n        }\n        // resolve addresses - this can result in a one-to-many translation when dnsaddrs are resolved\n        const resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {\n            const result = await resolveMultiaddrs(addr.multiaddr, options);\n            if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n                return addr;\n            }\n            return result.map(multiaddr => ({\n                multiaddr,\n                isCertified: false\n            }));\n        })))\n            .flat();\n        const filteredAddrs = resolvedAddresses.filter(addr => {\n            // filter out any multiaddrs that we do not have transports for\n            if (this.transportManager.transportForMultiaddr(addr.multiaddr) == null) {\n                return false;\n            }\n            // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n            // - this can happen with addresses like bootstrap.libp2p.io that resolve\n            // to multiple different peers\n            const addrPeerId = addr.multiaddr.getPeerId();\n            if (peerId != null && addrPeerId != null) {\n                return peerId.equals(addrPeerId);\n            }\n            return true;\n        });\n        // deduplicate addresses\n        const dedupedAddrs = new Map();\n        for (const addr of filteredAddrs) {\n            const maStr = addr.multiaddr.toString();\n            const existing = dedupedAddrs.get(maStr);\n            if (existing != null) {\n                existing.isCertified = existing.isCertified || addr.isCertified || false;\n                continue;\n            }\n            dedupedAddrs.set(maStr, addr);\n        }\n        let dedupedMultiaddrs = [...dedupedAddrs.values()];\n        if (dedupedMultiaddrs.length === 0 || dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {\n            log('addresses for %p before filtering', peerId ?? 'unknown peer', resolvedAddresses.map(({ multiaddr }) => multiaddr.toString()));\n            log('addresses for %p after filtering', peerId ?? 'unknown peer', dedupedMultiaddrs.map(({ multiaddr }) => multiaddr.toString()));\n        }\n        // make sure we actually have some addresses to dial\n        if (dedupedMultiaddrs.length === 0) {\n            throw new CodeError('The dial request has no valid addresses', codes.ERR_NO_VALID_ADDRESSES);\n        }\n        // make sure we don't have too many addresses to dial\n        if (dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {\n            throw new CodeError('dial with more addresses than allowed', codes.ERR_TOO_MANY_ADDRESSES);\n        }\n        // ensure the peer id is appended to the multiaddr\n        if (peerId != null) {\n            const peerIdMultiaddr = `/p2p/${peerId.toString()}`;\n            dedupedMultiaddrs = dedupedMultiaddrs.map(addr => {\n                const addressPeerId = addr.multiaddr.getPeerId();\n                const lastProto = addr.multiaddr.protos().pop();\n                // do not append peer id to path multiaddrs\n                if (lastProto?.path === true) {\n                    return addr;\n                }\n                // append peer id to multiaddr if it is not already present\n                if (addressPeerId !== peerId.toString()) {\n                    return {\n                        multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n                        isCertified: addr.isCertified\n                    };\n                }\n                return addr;\n            });\n        }\n        const gatedAdrs = [];\n        for (const addr of dedupedMultiaddrs) {\n            if (this.connectionGater.denyDialMultiaddr != null && await this.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n                continue;\n            }\n            gatedAdrs.push(addr);\n        }\n        const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);\n        // make sure we actually have some addresses to dial\n        if (sortedGatedAddrs.length === 0) {\n            throw new CodeError('The connection gater denied all addresses in the dial request', codes.ERR_NO_VALID_ADDRESSES);\n        }\n        return sortedGatedAddrs;\n    }\n    async performDial(pendingDial, options = {}) {\n        const dialAbortControllers = pendingDial.multiaddrs.map(() => new AbortController());\n        try {\n            // internal peer dial queue to ensure we only dial the configured number of addresses\n            // per peer at the same time to prevent one peer with a lot of addresses swamping\n            // the dial queue\n            const peerDialQueue = new PQueue({\n                concurrency: this.maxParallelDialsPerPeer\n            });\n            peerDialQueue.on('error', (err) => {\n                log.error('error dialling', err);\n            });\n            const conn = await Promise.any(pendingDial.multiaddrs.map(async (addr, i) => {\n                const controller = dialAbortControllers[i];\n                if (controller == null) {\n                    throw new CodeError('dialAction did not come with an AbortController', codes.ERR_INVALID_PARAMETERS);\n                }\n                // let any signal abort the dial\n                const signal = combineSignals(controller.signal, options.signal);\n                signal.addEventListener('abort', () => {\n                    log('dial to %a aborted', addr);\n                });\n                const deferred = pDefer();\n                await peerDialQueue.add(async () => {\n                    if (signal.aborted) {\n                        log('dial to %a was aborted before reaching the head of the peer dial queue', addr);\n                        deferred.reject(new AbortError());\n                        return;\n                    }\n                    // add the individual dial to the dial queue so we don't breach maxConcurrentDials\n                    await this.queue.add(async () => {\n                        try {\n                            if (signal.aborted) {\n                                log('dial to %a was aborted before reaching the head of the dial queue', addr);\n                                deferred.reject(new AbortError());\n                                return;\n                            }\n                            // update dial status\n                            pendingDial.status = 'active';\n                            const conn = await this.transportManager.dial(addr, {\n                                ...options,\n                                signal\n                            });\n                            if (controller.signal.aborted) {\n                                // another dial succeeded faster than this one\n                                log('multiple dials succeeded, closing superfluous connection');\n                                conn.close().catch(err => {\n                                    log.error('error closing superfluous connection', err);\n                                });\n                                deferred.reject(new AbortError());\n                                return;\n                            }\n                            // remove the successful AbortController so it is not aborted\n                            dialAbortControllers[i] = undefined;\n                            // immediately abort any other dials\n                            dialAbortControllers.forEach(c => {\n                                if (c !== undefined) {\n                                    c.abort();\n                                }\n                            });\n                            log('dial to %a succeeded', addr);\n                            // resolve the connection promise\n                            deferred.resolve(conn);\n                        }\n                        catch (err) {\n                            // something only went wrong if our signal was not aborted\n                            log.error('error during dial of %a', addr, err);\n                            deferred.reject(err);\n                        }\n                    }, {\n                        ...options,\n                        signal\n                    }).catch(err => {\n                        deferred.reject(err);\n                    });\n                }, {\n                    signal\n                }).catch(err => {\n                    deferred.reject(err);\n                }).finally(() => {\n                    signal.clear();\n                });\n                return deferred.promise;\n            }));\n            // dial succeeded or failed\n            if (conn == null) {\n                throw new CodeError('successful dial led to empty object returned from peer dial queue', codes.ERR_TRANSPORT_DIAL_FAILED);\n            }\n            pendingDial.status = 'success';\n            return conn;\n        }\n        catch (err) {\n            pendingDial.status = 'error';\n            // if we only dialled one address, unwrap the AggregateError to provide more\n            // useful feedback to the user\n            if (pendingDial.multiaddrs.length === 1 && err.name === 'AggregateError') {\n                throw err.errors[0];\n            }\n            throw err;\n        }\n    }\n}\n/**\n * Returns a random string\n */\nfunction randomId() {\n    return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`;\n}\n//# sourceMappingURL=dial-queue.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { KEEP_ALIVE } from '@libp2p/interface/peer-store/tags';\nimport { logger } from '@libp2p/logger';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { defaultAddressSort } from '@libp2p/utils/address-sort';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers';\nimport { RateLimiterMemory } from 'rate-limiter-flexible';\nimport { codes } from '../errors.js';\nimport { getPeerAddress } from '../get-peer.js';\nimport { AutoDial } from './auto-dial.js';\nimport { ConnectionPruner } from './connection-pruner.js';\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PRIORITY, DIAL_TIMEOUT, INBOUND_CONNECTION_THRESHOLD, MAX_CONNECTIONS, MAX_INCOMING_PENDING_CONNECTIONS, MAX_PARALLEL_DIALS, MAX_PARALLEL_DIALS_PER_PEER, MAX_PEER_ADDRS_TO_DIAL, MIN_CONNECTIONS } from './constants.js';\nimport { DialQueue } from './dial-queue.js';\nconst log = logger('libp2p:connection-manager');\nconst DEFAULT_DIAL_PRIORITY = 50;\nconst defaultOptions = {\n    minConnections: MIN_CONNECTIONS,\n    maxConnections: MAX_CONNECTIONS,\n    inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,\n    maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,\n    autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n    autoDialPriority: AUTO_DIAL_PRIORITY,\n    autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH\n};\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager {\n    started;\n    connections;\n    allow;\n    deny;\n    maxIncomingPendingConnections;\n    incomingPendingConnections;\n    maxConnections;\n    dialQueue;\n    autoDial;\n    connectionPruner;\n    inboundConnectionRateLimiter;\n    peerStore;\n    metrics;\n    events;\n    constructor(components, init = {}) {\n        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;\n        const minConnections = init.minConnections ?? defaultOptions.minConnections;\n        if (this.maxConnections < minConnections) {\n            throw new CodeError('Connection Manager maxConnections must be greater than minConnections', codes.ERR_INVALID_PARAMETERS);\n        }\n        /**\n         * Map of connections per peer\n         */\n        this.connections = new PeerMap();\n        this.started = false;\n        this.peerStore = components.peerStore;\n        this.metrics = components.metrics;\n        this.events = components.events;\n        this.onConnect = this.onConnect.bind(this);\n        this.onDisconnect = this.onDisconnect.bind(this);\n        this.events.addEventListener('connection:open', this.onConnect);\n        this.events.addEventListener('connection:close', this.onDisconnect);\n        // allow/deny lists\n        this.allow = (init.allow ?? []).map(ma => multiaddr(ma));\n        this.deny = (init.deny ?? []).map(ma => multiaddr(ma));\n        this.incomingPendingConnections = 0;\n        this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections;\n        // controls individual peers trying to dial us too quickly\n        this.inboundConnectionRateLimiter = new RateLimiterMemory({\n            points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n            duration: 1\n        });\n        // controls what happens when we don't have enough connections\n        this.autoDial = new AutoDial({\n            connectionManager: this,\n            peerStore: components.peerStore,\n            events: components.events\n        }, {\n            minConnections,\n            autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n            autoDialPriority: init.autoDialPriority ?? defaultOptions.autoDialPriority,\n            maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength\n        });\n        // controls what happens when we have too many connections\n        this.connectionPruner = new ConnectionPruner({\n            connectionManager: this,\n            peerStore: components.peerStore,\n            events: components.events\n        }, {\n            maxConnections: this.maxConnections,\n            allow: this.allow\n        });\n        this.dialQueue = new DialQueue({\n            peerId: components.peerId,\n            metrics: components.metrics,\n            peerStore: components.peerStore,\n            transportManager: components.transportManager,\n            connectionGater: components.connectionGater\n        }, {\n            addressSorter: init.addressSorter ?? defaultAddressSort,\n            maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,\n            maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,\n            maxParallelDialsPerPeer: init.maxParallelDialsPerPeer ?? MAX_PARALLEL_DIALS_PER_PEER,\n            dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,\n            resolvers: init.resolvers ?? {\n                dnsaddr: dnsaddrResolver\n            }\n        });\n    }\n    isStarted() {\n        return this.started;\n    }\n    /**\n     * Starts the Connection Manager. If Metrics are not enabled on libp2p\n     * only event loop and connection limits will be monitored.\n     */\n    async start() {\n        // track inbound/outbound connections\n        this.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n            calculate: () => {\n                const metric = {\n                    inbound: 0,\n                    outbound: 0\n                };\n                for (const conns of this.connections.values()) {\n                    for (const conn of conns) {\n                        if (conn.direction === 'inbound') {\n                            metric.inbound++;\n                        }\n                        else {\n                            metric.outbound++;\n                        }\n                    }\n                }\n                return metric;\n            }\n        });\n        // track total number of streams per protocol\n        this.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n            label: 'protocol',\n            calculate: () => {\n                const metric = {};\n                for (const conns of this.connections.values()) {\n                    for (const conn of conns) {\n                        for (const stream of conn.streams) {\n                            const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`;\n                            metric[key] = (metric[key] ?? 0) + 1;\n                        }\n                    }\n                }\n                return metric;\n            }\n        });\n        // track 90th percentile of streams per protocol\n        this.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n            label: 'protocol',\n            calculate: () => {\n                const allStreams = {};\n                for (const conns of this.connections.values()) {\n                    for (const conn of conns) {\n                        const streams = {};\n                        for (const stream of conn.streams) {\n                            const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`;\n                            streams[key] = (streams[key] ?? 0) + 1;\n                        }\n                        for (const [protocol, count] of Object.entries(streams)) {\n                            allStreams[protocol] = allStreams[protocol] ?? [];\n                            allStreams[protocol].push(count);\n                        }\n                    }\n                }\n                const metric = {};\n                for (let [protocol, counts] of Object.entries(allStreams)) {\n                    counts = counts.sort((a, b) => a - b);\n                    const index = Math.floor(counts.length * 0.9);\n                    metric[protocol] = counts[index];\n                }\n                return metric;\n            }\n        });\n        this.autoDial.start();\n        this.started = true;\n        log('started');\n    }\n    async afterStart() {\n        // re-connect to any peers with the KEEP_ALIVE tag\n        void Promise.resolve()\n            .then(async () => {\n            const keepAlivePeers = await this.peerStore.all({\n                filters: [(peer) => {\n                        return peer.tags.has(KEEP_ALIVE);\n                    }]\n            });\n            await Promise.all(keepAlivePeers.map(async (peer) => {\n                await this.openConnection(peer.id)\n                    .catch(err => {\n                    log.error(err);\n                });\n            }));\n        })\n            .catch(err => {\n            log.error(err);\n        });\n        this.autoDial.afterStart();\n    }\n    /**\n     * Stops the Connection Manager\n     */\n    async stop() {\n        this.dialQueue.stop();\n        this.autoDial.stop();\n        // Close all connections we're tracking\n        const tasks = [];\n        for (const connectionList of this.connections.values()) {\n            for (const connection of connectionList) {\n                tasks.push((async () => {\n                    try {\n                        await connection.close();\n                    }\n                    catch (err) {\n                        log.error(err);\n                    }\n                })());\n            }\n        }\n        log('closing %d connections', tasks.length);\n        await Promise.all(tasks);\n        this.connections.clear();\n        log('stopped');\n    }\n    onConnect(evt) {\n        void this._onConnect(evt).catch(err => {\n            log.error(err);\n        });\n    }\n    /**\n     * Tracks the incoming connection and check the connection limit\n     */\n    async _onConnect(evt) {\n        const { detail: connection } = evt;\n        if (!this.started) {\n            // This can happen when we are in the process of shutting down the node\n            await connection.close();\n            return;\n        }\n        const peerId = connection.remotePeer;\n        const storedConns = this.connections.get(peerId);\n        let isNewPeer = false;\n        if (storedConns != null) {\n            storedConns.push(connection);\n        }\n        else {\n            isNewPeer = true;\n            this.connections.set(peerId, [connection]);\n        }\n        // only need to store RSA public keys, all other types are embedded in the peer id\n        if (peerId.publicKey != null && peerId.type === 'RSA') {\n            await this.peerStore.patch(peerId, {\n                publicKey: peerId.publicKey\n            });\n        }\n        if (isNewPeer) {\n            this.events.safeDispatchEvent('peer:connect', { detail: connection.remotePeer });\n        }\n    }\n    /**\n     * Removes the connection from tracking\n     */\n    onDisconnect(evt) {\n        const { detail: connection } = evt;\n        if (!this.started) {\n            // This can happen when we are in the process of shutting down the node\n            return;\n        }\n        const peerId = connection.remotePeer;\n        let storedConn = this.connections.get(peerId);\n        if (storedConn != null && storedConn.length > 1) {\n            storedConn = storedConn.filter((conn) => conn.id !== connection.id);\n            this.connections.set(peerId, storedConn);\n        }\n        else if (storedConn != null) {\n            this.connections.delete(peerId);\n            this.events.safeDispatchEvent('peer:disconnect', { detail: connection.remotePeer });\n        }\n    }\n    getConnections(peerId) {\n        if (peerId != null) {\n            return this.connections.get(peerId) ?? [];\n        }\n        let conns = [];\n        for (const c of this.connections.values()) {\n            conns = conns.concat(c);\n        }\n        return conns;\n    }\n    getConnectionsMap() {\n        return this.connections;\n    }\n    async openConnection(peerIdOrMultiaddr, options = {}) {\n        if (!this.isStarted()) {\n            throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED);\n        }\n        options.signal?.throwIfAborted();\n        const { peerId } = getPeerAddress(peerIdOrMultiaddr);\n        if (peerId != null && options.force !== true) {\n            log('dial %p', peerId);\n            const existingConnections = this.getConnections(peerId);\n            if (existingConnections.length > 0) {\n                log('had an existing connection to %p', peerId);\n                return existingConnections[0];\n            }\n        }\n        const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n            ...options,\n            priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n        });\n        let peerConnections = this.connections.get(connection.remotePeer);\n        if (peerConnections == null) {\n            peerConnections = [];\n            this.connections.set(connection.remotePeer, peerConnections);\n        }\n        // we get notified of connections via the Upgrader emitting \"connection\"\n        // events, double check we aren't already tracking this connection before\n        // storing it\n        let trackedConnection = false;\n        for (const conn of peerConnections) {\n            if (conn.id === connection.id) {\n                trackedConnection = true;\n            }\n        }\n        if (!trackedConnection) {\n            peerConnections.push(connection);\n        }\n        return connection;\n    }\n    async closeConnections(peerId, options = {}) {\n        const connections = this.connections.get(peerId) ?? [];\n        await Promise.all(connections.map(async (connection) => {\n            try {\n                await connection.close(options);\n            }\n            catch (err) {\n                connection.abort(err);\n            }\n        }));\n    }\n    async acceptIncomingConnection(maConn) {\n        // check deny list\n        const denyConnection = this.deny.some(ma => {\n            return maConn.remoteAddr.toString().startsWith(ma.toString());\n        });\n        if (denyConnection) {\n            log('connection from %a refused - connection remote address was in deny list', maConn.remoteAddr);\n            return false;\n        }\n        // check allow list\n        const allowConnection = this.allow.some(ma => {\n            return maConn.remoteAddr.toString().startsWith(ma.toString());\n        });\n        if (allowConnection) {\n            this.incomingPendingConnections++;\n            return true;\n        }\n        // check pending connections\n        if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n            log('connection from %a refused - incomingPendingConnections exceeded by host', maConn.remoteAddr);\n            return false;\n        }\n        if (maConn.remoteAddr.isThinWaistAddress()) {\n            const host = maConn.remoteAddr.nodeAddress().address;\n            try {\n                await this.inboundConnectionRateLimiter.consume(host, 1);\n            }\n            catch {\n                log('connection from %a refused - inboundConnectionThreshold exceeded by host %s', maConn.remoteAddr, host);\n                return false;\n            }\n        }\n        if (this.getConnections().length < this.maxConnections) {\n            this.incomingPendingConnections++;\n            return true;\n        }\n        log('connection from %a refused - maxConnections exceeded', maConn.remoteAddr);\n        return false;\n    }\n    afterUpgradeInbound() {\n        this.incomingPendingConnections--;\n    }\n    getDialQueue() {\n        return this.dialQueue.pendingDials;\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport filter from 'it-filter';\nimport first from 'it-first';\nimport merge from 'it-merge';\nimport { pipe } from 'it-pipe';\nimport { storeAddresses, uniquePeers, requirePeers } from './content-routing/utils.js';\nimport { codes, messages } from './errors.js';\nconst log = logger('libp2p:peer-routing');\nexport class DefaultPeerRouting {\n    components;\n    routers;\n    constructor(components, init) {\n        this.components = components;\n        this.routers = init.routers ?? [];\n    }\n    /**\n     * Iterates over all peer routers in parallel to find the given peer\n     */\n    async findPeer(id, options) {\n        if (this.routers.length === 0) {\n            throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        if (id.toString() === this.components.peerId.toString()) {\n            throw new CodeError('Should not try to find self', codes.ERR_FIND_SELF);\n        }\n        const output = await pipe(merge(...this.routers.map(router => (async function* () {\n            try {\n                yield await router.findPeer(id, options);\n            }\n            catch (err) {\n                log.error(err);\n            }\n        })())), (source) => filter(source, Boolean), (source) => storeAddresses(source, this.components.peerStore), async (source) => first(source));\n        if (output != null) {\n            return output;\n        }\n        throw new CodeError(messages.NOT_FOUND, codes.ERR_NOT_FOUND);\n    }\n    /**\n     * Attempt to find the closest peers on the network to the given key\n     */\n    async *getClosestPeers(key, options) {\n        if (this.routers.length === 0) {\n            throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        yield* pipe(merge(...this.routers.map(router => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));\n    }\n}\n//# sourceMappingURL=peer-routing.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport merge from 'merge-options';\nimport { codes } from './errors.js';\nconst log = logger('libp2p:registrar');\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32;\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64;\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class DefaultRegistrar {\n    topologies;\n    handlers;\n    components;\n    constructor(components) {\n        this.topologies = new Map();\n        this.handlers = new Map();\n        this.components = components;\n        this._onDisconnect = this._onDisconnect.bind(this);\n        this._onPeerUpdate = this._onPeerUpdate.bind(this);\n        this._onConnect = this._onConnect.bind(this);\n        this.components.events.addEventListener('peer:disconnect', this._onDisconnect);\n        this.components.events.addEventListener('peer:connect', this._onConnect);\n        this.components.events.addEventListener('peer:update', this._onPeerUpdate);\n    }\n    getProtocols() {\n        return Array.from(new Set([\n            ...this.handlers.keys()\n        ])).sort();\n    }\n    getHandler(protocol) {\n        const handler = this.handlers.get(protocol);\n        if (handler == null) {\n            throw new CodeError(`No handler registered for protocol ${protocol}`, codes.ERR_NO_HANDLER_FOR_PROTOCOL);\n        }\n        return handler;\n    }\n    getTopologies(protocol) {\n        const topologies = this.topologies.get(protocol);\n        if (topologies == null) {\n            return [];\n        }\n        return [\n            ...topologies.values()\n        ];\n    }\n    /**\n     * Registers the `handler` for each protocol\n     */\n    async handle(protocol, handler, opts) {\n        if (this.handlers.has(protocol)) {\n            throw new CodeError(`Handler already registered for protocol ${protocol}`, codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);\n        }\n        const options = merge.bind({ ignoreUndefined: true })({\n            maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n            maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n        }, opts);\n        this.handlers.set(protocol, {\n            handler,\n            options\n        });\n        // Add new protocol to self protocols in the peer store\n        await this.components.peerStore.merge(this.components.peerId, {\n            protocols: [protocol]\n        });\n    }\n    /**\n     * Removes the handler for each protocol. The protocol\n     * will no longer be supported on streams.\n     */\n    async unhandle(protocols) {\n        const protocolList = Array.isArray(protocols) ? protocols : [protocols];\n        protocolList.forEach(protocol => {\n            this.handlers.delete(protocol);\n        });\n        // Update self protocols in the peer store\n        await this.components.peerStore.patch(this.components.peerId, {\n            protocols: this.getProtocols()\n        });\n    }\n    /**\n     * Register handlers for a set of multicodecs given\n     */\n    async register(protocol, topology) {\n        if (topology == null) {\n            throw new CodeError('invalid topology', codes.ERR_INVALID_PARAMETERS);\n        }\n        // Create topology\n        const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;\n        let topologies = this.topologies.get(protocol);\n        if (topologies == null) {\n            topologies = new Map();\n            this.topologies.set(protocol, topologies);\n        }\n        topologies.set(id, topology);\n        return id;\n    }\n    /**\n     * Unregister topology\n     */\n    unregister(id) {\n        for (const [protocol, topologies] of this.topologies.entries()) {\n            if (topologies.has(id)) {\n                topologies.delete(id);\n                if (topologies.size === 0) {\n                    this.topologies.delete(protocol);\n                }\n            }\n        }\n    }\n    /**\n     * Remove a disconnected peer from the record\n     */\n    _onDisconnect(evt) {\n        const remotePeer = evt.detail;\n        void this.components.peerStore.get(remotePeer)\n            .then(peer => {\n            for (const protocol of peer.protocols) {\n                const topologies = this.topologies.get(protocol);\n                if (topologies == null) {\n                    // no topologies are interested in this protocol\n                    continue;\n                }\n                for (const topology of topologies.values()) {\n                    topology.onDisconnect?.(remotePeer);\n                }\n            }\n        })\n            .catch(err => {\n            if (err.code === codes.ERR_NOT_FOUND) {\n                // peer has not completed identify so they are not in the peer store\n                return;\n            }\n            log.error('could not inform topologies of disconnecting peer %p', remotePeer, err);\n        });\n    }\n    /**\n     * On peer connected if we already have their protocols. Usually used for reconnects\n     * as change:protocols event won't be emitted due to identical protocols.\n     */\n    _onConnect(evt) {\n        const remotePeer = evt.detail;\n        void this.components.peerStore.get(remotePeer)\n            .then(peer => {\n            const connection = this.components.connectionManager.getConnections(peer.id)[0];\n            if (connection == null) {\n                log('peer %p connected but the connection manager did not have a connection', peer);\n                // peer disconnected while we were loading their details from the peer store\n                return;\n            }\n            for (const protocol of peer.protocols) {\n                const topologies = this.topologies.get(protocol);\n                if (topologies == null) {\n                    // no topologies are interested in this protocol\n                    continue;\n                }\n                for (const topology of topologies.values()) {\n                    topology.onConnect?.(remotePeer, connection);\n                }\n            }\n        })\n            .catch(err => {\n            if (err.code === codes.ERR_NOT_FOUND) {\n                // peer has not completed identify so they are not in the peer store\n                return;\n            }\n            log.error('could not inform topologies of connecting peer %p', remotePeer, err);\n        });\n    }\n    /**\n     * Check if a new peer support the multicodecs for this topology\n     */\n    _onPeerUpdate(evt) {\n        const { peer, previous } = evt.detail;\n        const removed = (previous?.protocols ?? []).filter(protocol => !peer.protocols.includes(protocol));\n        const added = peer.protocols.filter(protocol => !(previous?.protocols ?? []).includes(protocol));\n        for (const protocol of removed) {\n            const topologies = this.topologies.get(protocol);\n            if (topologies == null) {\n                // no topologies are interested in this protocol\n                continue;\n            }\n            for (const topology of topologies.values()) {\n                topology.onDisconnect?.(peer.id);\n            }\n        }\n        for (const protocol of added) {\n            const topologies = this.topologies.get(protocol);\n            if (topologies == null) {\n                // no topologies are interested in this protocol\n                continue;\n            }\n            for (const topology of topologies.values()) {\n                const connection = this.components.connectionManager.getConnections(peer.id)[0];\n                if (connection == null) {\n                    continue;\n                }\n                topology.onConnect?.(peer.id, connection);\n            }\n        }\n    }\n}\n//# sourceMappingURL=registrar.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { trackedMap } from '@libp2p/interface/metrics/tracked-map';\nimport { FaultTolerance } from '@libp2p/interface/transport';\nimport { logger } from '@libp2p/logger';\nimport { codes } from './errors.js';\nconst log = logger('libp2p:transports');\nexport class DefaultTransportManager {\n    components;\n    transports;\n    listeners;\n    faultTolerance;\n    started;\n    constructor(components, init = {}) {\n        this.components = components;\n        this.started = false;\n        this.transports = new Map();\n        this.listeners = trackedMap({\n            name: 'libp2p_transport_manager_listeners',\n            metrics: this.components.metrics\n        });\n        this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;\n    }\n    /**\n     * Adds a `Transport` to the manager\n     */\n    add(transport) {\n        const tag = transport[Symbol.toStringTag];\n        if (tag == null) {\n            throw new CodeError('Transport must have a valid tag', codes.ERR_INVALID_KEY);\n        }\n        if (this.transports.has(tag)) {\n            throw new CodeError(`There is already a transport with the tag ${tag}`, codes.ERR_DUPLICATE_TRANSPORT);\n        }\n        log('adding transport %s', tag);\n        this.transports.set(tag, transport);\n        if (!this.listeners.has(tag)) {\n            this.listeners.set(tag, []);\n        }\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.started = true;\n    }\n    async afterStart() {\n        // Listen on the provided transports for the provided addresses\n        const addrs = this.components.addressManager.getListenAddrs();\n        await this.listen(addrs);\n    }\n    /**\n     * Stops all listeners\n     */\n    async stop() {\n        const tasks = [];\n        for (const [key, listeners] of this.listeners) {\n            log('closing listeners for %s', key);\n            while (listeners.length > 0) {\n                const listener = listeners.pop();\n                if (listener == null) {\n                    continue;\n                }\n                tasks.push(listener.close());\n            }\n        }\n        await Promise.all(tasks);\n        log('all listeners closed');\n        for (const key of this.listeners.keys()) {\n            this.listeners.set(key, []);\n        }\n        this.started = false;\n    }\n    /**\n     * Dials the given Multiaddr over it's supported transport\n     */\n    async dial(ma, options) {\n        const transport = this.transportForMultiaddr(ma);\n        if (transport == null) {\n            throw new CodeError(`No transport available for address ${String(ma)}`, codes.ERR_TRANSPORT_UNAVAILABLE);\n        }\n        try {\n            return await transport.dial(ma, {\n                ...options,\n                upgrader: this.components.upgrader\n            });\n        }\n        catch (err) {\n            if (err.code == null) {\n                err.code = codes.ERR_TRANSPORT_DIAL_FAILED;\n            }\n            throw err;\n        }\n    }\n    /**\n     * Returns all Multiaddr's the listeners are using\n     */\n    getAddrs() {\n        let addrs = [];\n        for (const listeners of this.listeners.values()) {\n            for (const listener of listeners) {\n                addrs = [...addrs, ...listener.getAddrs()];\n            }\n        }\n        return addrs;\n    }\n    /**\n     * Returns all the transports instances\n     */\n    getTransports() {\n        return Array.of(...this.transports.values());\n    }\n    /**\n     * Returns all the listener instances\n     */\n    getListeners() {\n        return Array.of(...this.listeners.values()).flat();\n    }\n    /**\n     * Finds a transport that matches the given Multiaddr\n     */\n    transportForMultiaddr(ma) {\n        for (const transport of this.transports.values()) {\n            const addrs = transport.filter([ma]);\n            if (addrs.length > 0) {\n                return transport;\n            }\n        }\n    }\n    /**\n     * Starts listeners for each listen Multiaddr\n     */\n    async listen(addrs) {\n        if (!this.isStarted()) {\n            throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED);\n        }\n        if (addrs == null || addrs.length === 0) {\n            log('no addresses were provided for listening, this node is dial only');\n            return;\n        }\n        const couldNotListen = [];\n        for (const [key, transport] of this.transports.entries()) {\n            const supportedAddrs = transport.filter(addrs);\n            const tasks = [];\n            // For each supported multiaddr, create a listener\n            for (const addr of supportedAddrs) {\n                log('creating listener for %s on %a', key, addr);\n                const listener = transport.createListener({\n                    upgrader: this.components.upgrader\n                });\n                let listeners = this.listeners.get(key) ?? [];\n                if (listeners == null) {\n                    listeners = [];\n                    this.listeners.set(key, listeners);\n                }\n                listeners.push(listener);\n                // Track listen/close events\n                listener.addEventListener('listening', () => {\n                    this.components.events.safeDispatchEvent('transport:listening', {\n                        detail: listener\n                    });\n                });\n                listener.addEventListener('close', () => {\n                    const index = listeners.findIndex(l => l === listener);\n                    // remove the listener\n                    listeners.splice(index, 1);\n                    this.components.events.safeDispatchEvent('transport:close', {\n                        detail: listener\n                    });\n                });\n                // We need to attempt to listen on everything\n                tasks.push(listener.listen(addr));\n            }\n            // Keep track of transports we had no addresses for\n            if (tasks.length === 0) {\n                couldNotListen.push(key);\n                continue;\n            }\n            const results = await Promise.allSettled(tasks);\n            // If we are listening on at least 1 address, succeed.\n            // TODO: we should look at adding a retry (`p-retry`) here to better support\n            // listening on remote addresses as they may be offline. We could then potentially\n            // just wait for any (`p-any`) listener to succeed on each transport before returning\n            const isListening = results.find(r => r.status === 'fulfilled');\n            if ((isListening == null) && this.faultTolerance !== FaultTolerance.NO_FATAL) {\n                throw new CodeError(`Transport (${key}) could not listen on any available address`, codes.ERR_NO_VALID_ADDRESSES);\n            }\n        }\n        // If no transports were able to listen, throw an error. This likely\n        // means we were given addresses we do not have transports for\n        if (couldNotListen.length === this.transports.size) {\n            const message = `no valid addresses were provided for transports [${couldNotListen.join(', ')}]`;\n            if (this.faultTolerance === FaultTolerance.FATAL_ALL) {\n                throw new CodeError(message, codes.ERR_NO_VALID_ADDRESSES);\n            }\n            log(`libp2p in dial mode only: ${message}`);\n        }\n    }\n    /**\n     * Removes the given transport from the manager.\n     * If a transport has any running listeners, they will be closed.\n     */\n    async remove(key) {\n        const listeners = this.listeners.get(key) ?? [];\n        log.trace('removing transport %s', key);\n        // Close any running listeners\n        const tasks = [];\n        log.trace('closing listeners for %s', key);\n        while (listeners.length > 0) {\n            const listener = listeners.pop();\n            if (listener == null) {\n                continue;\n            }\n            tasks.push(listener.close());\n        }\n        await Promise.all(tasks);\n        this.transports.delete(key);\n        this.listeners.delete(key);\n    }\n    /**\n     * Removes all transports from the manager.\n     * If any listeners are running, they will be closed.\n     *\n     * @async\n     */\n    async removeAll() {\n        const tasks = [];\n        for (const key of this.transports.keys()) {\n            tasks.push(this.remove(key));\n        }\n        await Promise.all(tasks);\n    }\n}\n//# sourceMappingURL=transport-manager.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { abortableSource } from 'abortable-iterator';\nimport first from 'it-first';\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { MAX_PROTOCOL_LENGTH } from './constants.js';\nconst log = logger('libp2p:mss');\nconst NewLine = uint8ArrayFromString('\\n');\nexport function encode(buffer) {\n    const list = new Uint8ArrayList(buffer, NewLine);\n    return lp.encode.single(list);\n}\n/**\n * `write` encodes and writes a single buffer\n */\nexport function write(writer, buffer, options = {}) {\n    const encoded = encode(buffer);\n    if (options.writeBytes === true) {\n        writer.push(encoded.subarray());\n    }\n    else {\n        writer.push(encoded);\n    }\n}\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport function writeAll(writer, buffers, options = {}) {\n    const list = new Uint8ArrayList();\n    for (const buf of buffers) {\n        list.append(encode(buf));\n    }\n    if (options.writeBytes === true) {\n        writer.push(list.subarray());\n    }\n    else {\n        writer.push(list);\n    }\n}\nexport async function read(reader, options) {\n    let byteLength = 1; // Read single byte chunks until the length is known\n    const varByteSource = {\n        [Symbol.asyncIterator]: () => varByteSource,\n        next: async () => reader.next(byteLength)\n    };\n    let input = varByteSource;\n    // If we have been passed an abort signal, wrap the input source in an abortable\n    // iterator that will throw if the operation is aborted\n    if (options?.signal != null) {\n        input = abortableSource(varByteSource, options.signal);\n    }\n    // Once the length has been parsed, read chunk for that length\n    const onLength = (l) => {\n        byteLength = l;\n    };\n    const buf = await pipe(input, (source) => lp.decode(source, { onLength, maxDataLength: MAX_PROTOCOL_LENGTH }), async (source) => first(source));\n    if (buf == null || buf.length === 0) {\n        throw new CodeError('no buffer returned', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n    }\n    if (buf.get(buf.byteLength - 1) !== NewLine[0]) {\n        log.error('Invalid mss message - missing newline - %s', buf.subarray());\n        throw new CodeError('missing newline', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n    }\n    return buf.sublist(0, -1); // Remove newline\n}\nexport async function readString(reader, options) {\n    const buf = await read(reader, options);\n    return uint8ArrayToString(buf.subarray());\n}\n//# sourceMappingURL=multistream.js.map","import { asUint8Array } from './util/as-uint8array.js';\nimport bases, {} from './util/bases.js';\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString(string, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n        return asUint8Array(globalThis.Buffer.from(string, 'utf-8'));\n    }\n    // add multibase prefix\n    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n//# sourceMappingURL=from-string.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport { handshake } from 'it-handshake';\nimport merge from 'it-merge';\nimport { pushable } from 'it-pushable';\nimport { reader } from 'it-reader';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport * as multistream from './multistream.js';\nimport { PROTOCOL_ID } from './index.js';\nconst log = logger('libp2p:mss:select');\nexport async function select(stream, protocols, options = {}) {\n    protocols = Array.isArray(protocols) ? [...protocols] : [protocols];\n    const { reader, writer, rest, stream: shakeStream } = handshake(stream);\n    const protocol = protocols.shift();\n    if (protocol == null) {\n        throw new Error('At least one protocol must be specified');\n    }\n    log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol);\n    const p1 = uint8ArrayFromString(PROTOCOL_ID);\n    const p2 = uint8ArrayFromString(protocol);\n    multistream.writeAll(writer, [p1, p2], options);\n    let response = await multistream.readString(reader, options);\n    log.trace('select: read \"%s\"', response);\n    // Read the protocol response if we got the protocolId in return\n    if (response === PROTOCOL_ID) {\n        response = await multistream.readString(reader, options);\n        log.trace('select: read \"%s\"', response);\n    }\n    // We're done\n    if (response === protocol) {\n        rest();\n        return { stream: shakeStream, protocol };\n    }\n    // We haven't gotten a valid ack, try the other protocols\n    for (const protocol of protocols) {\n        log.trace('select: write \"%s\"', protocol);\n        multistream.write(writer, uint8ArrayFromString(protocol), options);\n        const response = await multistream.readString(reader, options);\n        log.trace('select: read \"%s\" for \"%s\"', response, protocol);\n        if (response === protocol) {\n            rest(); // End our writer so others can start writing to stream\n            return { stream: shakeStream, protocol };\n        }\n    }\n    rest();\n    throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n}\nexport function lazySelect(stream, protocol) {\n    // This is a signal to write the multistream headers if the consumer tries to\n    // read from the source\n    const negotiateTrigger = pushable();\n    let negotiated = false;\n    return {\n        stream: {\n            sink: async (source) => {\n                await stream.sink((async function* () {\n                    let first = true;\n                    for await (const chunk of merge(source, negotiateTrigger)) {\n                        if (first) {\n                            first = false;\n                            negotiated = true;\n                            negotiateTrigger.end();\n                            const p1 = uint8ArrayFromString(PROTOCOL_ID);\n                            const p2 = uint8ArrayFromString(protocol);\n                            const list = new Uint8ArrayList(multistream.encode(p1), multistream.encode(p2));\n                            if (chunk.length > 0)\n                                list.append(chunk);\n                            yield* list;\n                        }\n                        else {\n                            yield chunk;\n                        }\n                    }\n                })());\n            },\n            source: (async function* () {\n                if (!negotiated)\n                    negotiateTrigger.push(new Uint8Array());\n                const byteReader = reader(stream.source);\n                let response = await multistream.readString(byteReader);\n                if (response === PROTOCOL_ID) {\n                    response = await multistream.readString(byteReader);\n                }\n                if (response !== protocol) {\n                    throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n                }\n                for await (const chunk of byteReader) {\n                    yield* chunk;\n                }\n            })()\n        },\n        protocol\n    };\n}\n//# sourceMappingURL=select.js.map","import { logger } from '@libp2p/logger';\nimport { handshake } from 'it-handshake';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { PROTOCOL_ID } from './constants.js';\nimport * as multistream from './multistream.js';\nconst log = logger('libp2p:mss:handle');\nexport async function handle(stream, protocols, options) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    const { writer, reader, rest, stream: shakeStream } = handshake(stream);\n    while (true) {\n        const protocol = await multistream.readString(reader, options);\n        log.trace('read \"%s\"', protocol);\n        if (protocol === PROTOCOL_ID) {\n            log.trace('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol);\n            multistream.write(writer, uint8ArrayFromString(PROTOCOL_ID), options);\n            continue;\n        }\n        if (protocols.includes(protocol)) {\n            multistream.write(writer, uint8ArrayFromString(protocol), options);\n            log.trace('respond with \"%s\" for \"%s\"', protocol, protocol);\n            rest();\n            return { stream: shakeStream, protocol };\n        }\n        if (protocol === 'ls') {\n            // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n            multistream.write(writer, new Uint8ArrayList(...protocols.map(p => multistream.encode(uint8ArrayFromString(p)))), options);\n            // multistream.writeAll(writer, protocols.map(p => uint8ArrayFromString(p)))\n            log.trace('respond with \"%s\" for %s', protocols, protocol);\n            continue;\n        }\n        multistream.write(writer, uint8ArrayFromString('na'), options);\n        log('respond with \"na\" for \"%s\"', protocol);\n    }\n}\n//# sourceMappingURL=handle.js.map","import { setMaxListeners } from 'events';\nimport { symbol } from '@libp2p/interface/connection';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:connection');\nconst CLOSE_TIMEOUT = 500;\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl {\n    /**\n     * Connection identifier.\n     */\n    id;\n    /**\n     * Observed multiaddr of the remote peer\n     */\n    remoteAddr;\n    /**\n     * Remote peer id\n     */\n    remotePeer;\n    direction;\n    timeline;\n    multiplexer;\n    encryption;\n    status;\n    transient;\n    /**\n     * User provided tags\n     *\n     */\n    tags;\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n    _newStream;\n    /**\n     * Reference to the close function of the raw connection\n     */\n    _close;\n    _abort;\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n    _getStreams;\n    /**\n     * An implementation of the js-libp2p connection.\n     * Any libp2p transport should use an upgrader to return this connection.\n     */\n    constructor(init) {\n        const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;\n        this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`;\n        this.remoteAddr = remoteAddr;\n        this.remotePeer = remotePeer;\n        this.direction = init.direction;\n        this.status = 'open';\n        this.timeline = init.timeline;\n        this.multiplexer = init.multiplexer;\n        this.encryption = init.encryption;\n        this.transient = init.transient ?? false;\n        this._newStream = newStream;\n        this._close = close;\n        this._abort = abort;\n        this._getStreams = getStreams;\n        this.tags = [];\n    }\n    [Symbol.toStringTag] = 'Connection';\n    [symbol] = true;\n    /**\n     * Get all the streams of the muxer\n     */\n    get streams() {\n        return this._getStreams();\n    }\n    /**\n     * Create a new stream from this connection\n     */\n    async newStream(protocols, options) {\n        if (this.status === 'closing') {\n            throw new CodeError('the connection is being closed', 'ERR_CONNECTION_BEING_CLOSED');\n        }\n        if (this.status === 'closed') {\n            throw new CodeError('the connection is closed', 'ERR_CONNECTION_CLOSED');\n        }\n        if (!Array.isArray(protocols)) {\n            protocols = [protocols];\n        }\n        if (this.transient && options?.runOnTransientConnection !== true) {\n            throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION');\n        }\n        const stream = await this._newStream(protocols, options);\n        stream.direction = 'outbound';\n        return stream;\n    }\n    /**\n     * Close the connection\n     */\n    async close(options = {}) {\n        if (this.status === 'closed' || this.status === 'closing') {\n            return;\n        }\n        log('closing connection to %a', this.remoteAddr);\n        this.status = 'closing';\n        options.signal = options?.signal ?? AbortSignal.timeout(CLOSE_TIMEOUT);\n        try {\n            // fails on node < 15.4\n            setMaxListeners?.(Infinity, options.signal);\n        }\n        catch { }\n        try {\n            // close all streams gracefully - this can throw if we're not multiplexed\n            await Promise.all(this.streams.map(async (s) => s.close(options)));\n            // Close raw connection\n            await this._close(options);\n            this.timeline.close = Date.now();\n            this.status = 'closed';\n        }\n        catch (err) {\n            log.error('error encountered during graceful close of connection to %a', this.remoteAddr, err);\n            this.abort(err);\n        }\n    }\n    abort(err) {\n        log.error('aborting connection to %a due to error', this.remoteAddr, err);\n        this.status = 'closing';\n        this.streams.forEach(s => { s.abort(err); });\n        log.error('all streams aborted', this.streams.length);\n        // Abort raw connection\n        this._abort(err);\n        this.timeline.close = Date.now();\n        this.status = 'closed';\n    }\n}\nexport function createConnection(init) {\n    return new ConnectionImpl(init);\n}\n//# sourceMappingURL=index.js.map","import { setMaxListeners } from 'events';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport * as mss from '@libp2p/multistream-select';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { createConnection } from './connection/index.js';\nimport { INBOUND_UPGRADE_TIMEOUT } from './connection-manager/constants.js';\nimport { codes } from './errors.js';\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js';\nconst log = logger('libp2p:upgrader');\nfunction findIncomingStreamLimit(protocol, registrar) {\n    try {\n        const { options } = registrar.getHandler(protocol);\n        return options.maxInboundStreams;\n    }\n    catch (err) {\n        if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n            throw err;\n        }\n    }\n    return DEFAULT_MAX_INBOUND_STREAMS;\n}\nfunction findOutgoingStreamLimit(protocol, registrar, options = {}) {\n    try {\n        const { options } = registrar.getHandler(protocol);\n        if (options.maxOutboundStreams != null) {\n            return options.maxOutboundStreams;\n        }\n    }\n    catch (err) {\n        if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n            throw err;\n        }\n    }\n    return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n}\nfunction countStreams(protocol, direction, connection) {\n    let streamCount = 0;\n    connection.streams.forEach(stream => {\n        if (stream.direction === direction && stream.protocol === protocol) {\n            streamCount++;\n        }\n    });\n    return streamCount;\n}\nexport class DefaultUpgrader {\n    components;\n    connectionEncryption;\n    muxers;\n    inboundUpgradeTimeout;\n    events;\n    constructor(components, init) {\n        this.components = components;\n        this.connectionEncryption = new Map();\n        init.connectionEncryption.forEach(encrypter => {\n            this.connectionEncryption.set(encrypter.protocol, encrypter);\n        });\n        this.muxers = new Map();\n        init.muxers.forEach(muxer => {\n            this.muxers.set(muxer.protocol, muxer);\n        });\n        this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;\n        this.events = components.events;\n    }\n    async shouldBlockConnection(remotePeer, maConn, connectionType) {\n        const connectionGater = this.components.connectionGater[connectionType];\n        if (connectionGater !== undefined) {\n            if (await connectionGater(remotePeer, maConn)) {\n                throw new CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, codes.ERR_CONNECTION_INTERCEPTED);\n            }\n        }\n    }\n    /**\n     * Upgrades an inbound connection\n     */\n    async upgradeInbound(maConn, opts) {\n        const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);\n        if (!accept) {\n            throw new CodeError('connection denied', codes.ERR_CONNECTION_DENIED);\n        }\n        let encryptedConn;\n        let remotePeer;\n        let upgradedConn;\n        let muxerFactory;\n        let cryptoProtocol;\n        const signal = AbortSignal.timeout(this.inboundUpgradeTimeout);\n        const onAbort = () => {\n            maConn.abort(new CodeError('inbound upgrade timeout', codes.ERR_TIMEOUT));\n        };\n        signal.addEventListener('abort', onAbort, { once: true });\n        try {\n            // fails on node < 15.4\n            setMaxListeners?.(Infinity, signal);\n        }\n        catch { }\n        try {\n            if ((await this.components.connectionGater.denyInboundConnection?.(maConn)) === true) {\n                throw new CodeError('The multiaddr connection is blocked by gater.acceptConnection', codes.ERR_CONNECTION_INTERCEPTED);\n            }\n            this.components.metrics?.trackMultiaddrConnection(maConn);\n            log('starting the inbound connection upgrade');\n            // Protect\n            let protectedConn = maConn;\n            if (opts?.skipProtection !== true) {\n                const protector = this.components.connectionProtector;\n                if (protector != null) {\n                    log('protecting the inbound connection');\n                    protectedConn = await protector.protect(maConn);\n                }\n            }\n            try {\n                // Encrypt the connection\n                encryptedConn = protectedConn;\n                if (opts?.skipEncryption !== true) {\n                    ({\n                        conn: encryptedConn,\n                        remotePeer,\n                        protocol: cryptoProtocol\n                    } = await this._encryptInbound(protectedConn));\n                    const maConn = {\n                        ...protectedConn,\n                        ...encryptedConn\n                    };\n                    await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundEncryptedConnection');\n                }\n                else {\n                    const idStr = maConn.remoteAddr.getPeerId();\n                    if (idStr == null) {\n                        throw new CodeError('inbound connection that skipped encryption must have a peer id', codes.ERR_INVALID_MULTIADDR);\n                    }\n                    const remotePeerId = peerIdFromString(idStr);\n                    cryptoProtocol = 'native';\n                    remotePeer = remotePeerId;\n                }\n                upgradedConn = encryptedConn;\n                if (opts?.muxerFactory != null) {\n                    muxerFactory = opts.muxerFactory;\n                }\n                else if (this.muxers.size > 0) {\n                    // Multiplex the connection\n                    const multiplexed = await this._multiplexInbound({\n                        ...protectedConn,\n                        ...encryptedConn\n                    }, this.muxers);\n                    muxerFactory = multiplexed.muxerFactory;\n                    upgradedConn = multiplexed.stream;\n                }\n            }\n            catch (err) {\n                log.error('Failed to upgrade inbound connection', err);\n                throw err;\n            }\n            await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundUpgradedConnection');\n            log('Successfully upgraded inbound connection');\n            return this._createConnection({\n                cryptoProtocol,\n                direction: 'inbound',\n                maConn,\n                upgradedConn,\n                muxerFactory,\n                remotePeer,\n                transient: opts?.transient\n            });\n        }\n        finally {\n            signal.removeEventListener('abort', onAbort);\n            this.components.connectionManager.afterUpgradeInbound();\n        }\n    }\n    /**\n     * Upgrades an outbound connection\n     */\n    async upgradeOutbound(maConn, opts) {\n        const idStr = maConn.remoteAddr.getPeerId();\n        let remotePeerId;\n        if (idStr != null) {\n            remotePeerId = peerIdFromString(idStr);\n            await this.shouldBlockConnection(remotePeerId, maConn, 'denyOutboundConnection');\n        }\n        let encryptedConn;\n        let remotePeer;\n        let upgradedConn;\n        let cryptoProtocol;\n        let muxerFactory;\n        this.components.metrics?.trackMultiaddrConnection(maConn);\n        log('Starting the outbound connection upgrade');\n        // If the transport natively supports encryption, skip connection\n        // protector and encryption\n        // Protect\n        let protectedConn = maConn;\n        if (opts?.skipProtection !== true) {\n            const protector = this.components.connectionProtector;\n            if (protector != null) {\n                protectedConn = await protector.protect(maConn);\n            }\n        }\n        try {\n            // Encrypt the connection\n            encryptedConn = protectedConn;\n            if (opts?.skipEncryption !== true) {\n                ({\n                    conn: encryptedConn,\n                    remotePeer,\n                    protocol: cryptoProtocol\n                } = await this._encryptOutbound(protectedConn, remotePeerId));\n                const maConn = {\n                    ...protectedConn,\n                    ...encryptedConn\n                };\n                await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundEncryptedConnection');\n            }\n            else {\n                if (remotePeerId == null) {\n                    throw new CodeError('Encryption was skipped but no peer id was passed', codes.ERR_INVALID_PEER);\n                }\n                cryptoProtocol = 'native';\n                remotePeer = remotePeerId;\n            }\n            upgradedConn = encryptedConn;\n            if (opts?.muxerFactory != null) {\n                muxerFactory = opts.muxerFactory;\n            }\n            else if (this.muxers.size > 0) {\n                // Multiplex the connection\n                const multiplexed = await this._multiplexOutbound({\n                    ...protectedConn,\n                    ...encryptedConn\n                }, this.muxers);\n                muxerFactory = multiplexed.muxerFactory;\n                upgradedConn = multiplexed.stream;\n            }\n        }\n        catch (err) {\n            log.error('Failed to upgrade outbound connection', err);\n            await maConn.close(err);\n            throw err;\n        }\n        await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundUpgradedConnection');\n        log('Successfully upgraded outbound connection');\n        return this._createConnection({\n            cryptoProtocol,\n            direction: 'outbound',\n            maConn,\n            upgradedConn,\n            muxerFactory,\n            remotePeer,\n            transient: opts?.transient\n        });\n    }\n    /**\n     * A convenience method for generating a new `Connection`\n     */\n    _createConnection(opts) {\n        const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, transient } = opts;\n        let muxer;\n        let newStream;\n        let connection; // eslint-disable-line prefer-const\n        if (muxerFactory != null) {\n            // Create the muxer\n            muxer = muxerFactory.createStreamMuxer({\n                direction,\n                // Run anytime a remote stream is created\n                onIncomingStream: muxedStream => {\n                    if (connection == null) {\n                        return;\n                    }\n                    void Promise.resolve()\n                        .then(async () => {\n                        const protocols = this.components.registrar.getProtocols();\n                        const { stream, protocol } = await mss.handle(muxedStream, protocols);\n                        log('%s: incoming stream opened on %s', direction, protocol);\n                        if (connection == null) {\n                            return;\n                        }\n                        const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);\n                        const streamCount = countStreams(protocol, 'inbound', connection);\n                        if (streamCount === incomingLimit) {\n                            const err = new CodeError(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`, codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);\n                            muxedStream.abort(err);\n                            throw err;\n                        }\n                        // after the handshake the returned stream can have early data so override\n                        // the souce/sink\n                        muxedStream.source = stream.source;\n                        muxedStream.sink = stream.sink;\n                        muxedStream.protocol = protocol;\n                        // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                        // the peerstore should ensure that the peer is registered with that protocol\n                        await this.components.peerStore.merge(remotePeer, {\n                            protocols: [protocol]\n                        });\n                        this.components.metrics?.trackProtocolStream(muxedStream, connection);\n                        this._onStream({ connection, stream: muxedStream, protocol });\n                    })\n                        .catch(async (err) => {\n                        log.error(err);\n                        if (muxedStream.timeline.close == null) {\n                            await muxedStream.close();\n                        }\n                    });\n                }\n            });\n            newStream = async (protocols, options = {}) => {\n                if (muxer == null) {\n                    throw new CodeError('Stream is not multiplexed', codes.ERR_MUXER_UNAVAILABLE);\n                }\n                log('%s: starting new stream on %s', direction, protocols);\n                const muxedStream = await muxer.newStream();\n                try {\n                    if (options.signal == null) {\n                        log('No abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols);\n                        options.signal = AbortSignal.timeout(30000);\n                        try {\n                            // fails on node < 15.4\n                            setMaxListeners?.(Infinity, options.signal);\n                        }\n                        catch { }\n                    }\n                    const { stream, protocol } = await mss.select(muxedStream, protocols, options);\n                    const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);\n                    const streamCount = countStreams(protocol, 'outbound', connection);\n                    if (streamCount >= outgoingLimit) {\n                        const err = new CodeError(`Too many outbound protocol streams for protocol \"${protocol}\" - limit ${outgoingLimit}`, codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);\n                        muxedStream.abort(err);\n                        throw err;\n                    }\n                    // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                    // the peerstore should ensure that the peer is registered with that protocol\n                    await this.components.peerStore.merge(remotePeer, {\n                        protocols: [protocol]\n                    });\n                    // after the handshake the returned stream can have early data so override\n                    // the souce/sink\n                    muxedStream.source = stream.source;\n                    muxedStream.sink = stream.sink;\n                    muxedStream.protocol = protocol;\n                    this.components.metrics?.trackProtocolStream(muxedStream, connection);\n                    return muxedStream;\n                }\n                catch (err) {\n                    log.error('could not create new stream for protocols %s on connection with address %a', protocols, connection.remoteAddr, err);\n                    if (muxedStream.timeline.close == null) {\n                        muxedStream.abort(err);\n                    }\n                    if (err.code != null) {\n                        throw err;\n                    }\n                    throw new CodeError(String(err), codes.ERR_UNSUPPORTED_PROTOCOL);\n                }\n            };\n            // Pipe all data through the muxer\n            void Promise.all([\n                muxer.sink(upgradedConn.source),\n                upgradedConn.sink(muxer.source)\n            ]).catch(err => {\n                log.error(err);\n            });\n        }\n        const _timeline = maConn.timeline;\n        maConn.timeline = new Proxy(_timeline, {\n            set: (...args) => {\n                if (connection != null && args[1] === 'close' && args[2] != null && _timeline.close == null) {\n                    // Wait for close to finish before notifying of the closure\n                    (async () => {\n                        try {\n                            if (connection.status === 'open') {\n                                await connection.close();\n                            }\n                        }\n                        catch (err) {\n                            log.error(err);\n                        }\n                        finally {\n                            this.events.safeDispatchEvent('connection:close', {\n                                detail: connection\n                            });\n                        }\n                    })().catch(err => {\n                        log.error(err);\n                    });\n                }\n                return Reflect.set(...args);\n            }\n        });\n        maConn.timeline.upgraded = Date.now();\n        const errConnectionNotMultiplexed = () => {\n            throw new CodeError('connection is not multiplexed', codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n        };\n        // Create the connection\n        connection = createConnection({\n            remoteAddr: maConn.remoteAddr,\n            remotePeer,\n            status: 'open',\n            direction,\n            timeline: maConn.timeline,\n            multiplexer: muxer?.protocol,\n            encryption: cryptoProtocol,\n            transient,\n            newStream: newStream ?? errConnectionNotMultiplexed,\n            getStreams: () => { if (muxer != null) {\n                return muxer.streams;\n            }\n            else {\n                return [];\n            } },\n            close: async (options) => {\n                await maConn.close(options);\n                // Ensure remaining streams are closed gracefully\n                if (muxer != null) {\n                    await muxer.close(options);\n                }\n            },\n            abort: (err) => {\n                maConn.abort(err);\n                // Ensure remaining streams are aborted\n                if (muxer != null) {\n                    muxer.abort(err);\n                }\n            }\n        });\n        this.events.safeDispatchEvent('connection:open', {\n            detail: connection\n        });\n        return connection;\n    }\n    /**\n     * Routes incoming streams to the correct handler\n     */\n    _onStream(opts) {\n        const { connection, stream, protocol } = opts;\n        const { handler, options } = this.components.registrar.getHandler(protocol);\n        if (connection.transient && options.runOnTransientConnection !== true) {\n            throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION');\n        }\n        handler({ connection, stream });\n    }\n    /**\n     * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n     */\n    async _encryptInbound(connection) {\n        const protocols = Array.from(this.connectionEncryption.keys());\n        log('handling inbound crypto protocol selection', protocols);\n        try {\n            const { stream, protocol } = await mss.handle(connection, protocols, {\n                writeBytes: true\n            });\n            const encrypter = this.connectionEncryption.get(protocol);\n            if (encrypter == null) {\n                throw new Error(`no crypto module found for ${protocol}`);\n            }\n            log('encrypting inbound connection...');\n            return {\n                ...await encrypter.secureInbound(this.components.peerId, stream),\n                protocol\n            };\n        }\n        catch (err) {\n            throw new CodeError(String(err), codes.ERR_ENCRYPTION_FAILED);\n        }\n    }\n    /**\n     * Attempts to encrypt the given `connection` with the provided connection encrypters.\n     * The first `ConnectionEncrypter` module to succeed will be used\n     */\n    async _encryptOutbound(connection, remotePeerId) {\n        const protocols = Array.from(this.connectionEncryption.keys());\n        log('selecting outbound crypto protocol', protocols);\n        try {\n            const { stream, protocol } = await mss.select(connection, protocols, {\n                writeBytes: true\n            });\n            const encrypter = this.connectionEncryption.get(protocol);\n            if (encrypter == null) {\n                throw new Error(`no crypto module found for ${protocol}`);\n            }\n            log('encrypting outbound connection to %p', remotePeerId);\n            return {\n                ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),\n                protocol\n            };\n        }\n        catch (err) {\n            throw new CodeError(String(err), codes.ERR_ENCRYPTION_FAILED);\n        }\n    }\n    /**\n     * Selects one of the given muxers via multistream-select. That\n     * muxer will be used for all future streams on the connection.\n     */\n    async _multiplexOutbound(connection, muxers) {\n        const protocols = Array.from(muxers.keys());\n        log('outbound selecting muxer %s', protocols);\n        try {\n            const { stream, protocol } = await mss.select(connection, protocols, {\n                writeBytes: true\n            });\n            log('%s selected as muxer protocol', protocol);\n            const muxerFactory = muxers.get(protocol);\n            return { stream, muxerFactory };\n        }\n        catch (err) {\n            log.error('error multiplexing outbound stream', err);\n            throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE);\n        }\n    }\n    /**\n     * Registers support for one of the given muxers via multistream-select. The\n     * selected muxer will be used for all future streams on the connection.\n     */\n    async _multiplexInbound(connection, muxers) {\n        const protocols = Array.from(muxers.keys());\n        log('inbound handling muxers %s', protocols);\n        try {\n            const { stream, protocol } = await mss.handle(connection, protocols, {\n                writeBytes: true\n            });\n            const muxerFactory = muxers.get(protocol);\n            return { stream, muxerFactory };\n        }\n        catch (err) {\n            log.error('error multiplexing inbound stream', err);\n            throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE);\n        }\n    }\n}\n//# sourceMappingURL=upgrader.js.map","import { setMaxListeners } from 'events';\nimport { unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { contentRouting } from '@libp2p/interface/content-routing';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { EventEmitter, CustomEvent } from '@libp2p/interface/events';\nimport { peerDiscovery } from '@libp2p/interface/peer-discovery';\nimport { peerRouting } from '@libp2p/interface/peer-routing';\nimport { DefaultKeyChain } from '@libp2p/keychain';\nimport { logger } from '@libp2p/logger';\nimport { PeerSet } from '@libp2p/peer-collections';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { createEd25519PeerId } from '@libp2p/peer-id-factory';\nimport { PersistentPeerStore } from '@libp2p/peer-store';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { MemoryDatastore } from 'datastore-core/memory';\nimport mergeOptions from 'merge-options';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { DefaultAddressManager } from './address-manager/index.js';\nimport { defaultComponents } from './components.js';\nimport { connectionGater } from './config/connection-gater.js';\nimport { validateConfig } from './config.js';\nimport { DefaultConnectionManager } from './connection-manager/index.js';\nimport { CompoundContentRouting } from './content-routing/index.js';\nimport { codes } from './errors.js';\nimport { DefaultPeerRouting } from './peer-routing.js';\nimport { DefaultRegistrar } from './registrar.js';\nimport { DefaultTransportManager } from './transport-manager.js';\nimport { DefaultUpgrader } from './upgrader.js';\nconst log = logger('libp2p');\nexport class Libp2pNode extends EventEmitter {\n    peerId;\n    peerStore;\n    contentRouting;\n    peerRouting;\n    keychain;\n    metrics;\n    services;\n    components;\n    #started;\n    constructor(init) {\n        super();\n        // event bus - components can listen to this emitter to be notified of system events\n        // and also cause them to be emitted\n        const events = new EventEmitter();\n        const originalDispatch = events.dispatchEvent.bind(events);\n        events.dispatchEvent = (evt) => {\n            const internalResult = originalDispatch(evt);\n            const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));\n            return internalResult || externalResult;\n        };\n        try {\n            // This emitter gets listened to a lot\n            setMaxListeners?.(Infinity, events);\n        }\n        catch { }\n        this.#started = false;\n        this.peerId = init.peerId;\n        // @ts-expect-error {} may not be of type T\n        this.services = {};\n        const components = this.components = defaultComponents({\n            peerId: init.peerId,\n            events,\n            datastore: init.datastore ?? new MemoryDatastore(),\n            connectionGater: connectionGater(init.connectionGater)\n        });\n        this.peerStore = this.configureComponent('peerStore', new PersistentPeerStore(components, {\n            addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n            ...init.peerStore\n        }));\n        // Create Metrics\n        if (init.metrics != null) {\n            this.metrics = this.configureComponent('metrics', init.metrics(this.components));\n        }\n        components.events.addEventListener('peer:update', evt => {\n            // if there was no peer previously in the peer store this is a new peer\n            if (evt.detail.previous == null) {\n                const peerInfo = {\n                    id: evt.detail.peer.id,\n                    multiaddrs: evt.detail.peer.addresses.map(a => a.multiaddr),\n                    protocols: evt.detail.peer.protocols\n                };\n                components.events.safeDispatchEvent('peer:discovery', { detail: peerInfo });\n            }\n        });\n        // Set up connection protector if configured\n        if (init.connectionProtector != null) {\n            this.configureComponent('connectionProtector', init.connectionProtector(components));\n        }\n        // Set up the Upgrader\n        this.components.upgrader = new DefaultUpgrader(this.components, {\n            connectionEncryption: (init.connectionEncryption ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n            muxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n            inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout\n        });\n        // Setup the transport manager\n        this.configureComponent('transportManager', new DefaultTransportManager(this.components, init.transportManager));\n        // Create the Connection Manager\n        this.configureComponent('connectionManager', new DefaultConnectionManager(this.components, init.connectionManager));\n        // Create the Registrar\n        this.configureComponent('registrar', new DefaultRegistrar(this.components));\n        // Addresses {listen, announce, noAnnounce}\n        this.configureComponent('addressManager', new DefaultAddressManager(this.components, init.addresses));\n        // Create keychain\n        const keychainOpts = DefaultKeyChain.generateOptions();\n        this.keychain = this.configureComponent('keyChain', new DefaultKeyChain(this.components, {\n            ...keychainOpts,\n            ...init.keychain\n        }));\n        // Peer routers\n        const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));\n        this.peerRouting = this.components.peerRouting = this.configureComponent('peerRouting', new DefaultPeerRouting(this.components, {\n            routers: peerRouters\n        }));\n        // Content routers\n        const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));\n        this.contentRouting = this.components.contentRouting = this.configureComponent('contentRouting', new CompoundContentRouting(this.components, {\n            routers: contentRouters\n        }));\n        (init.peerDiscovery ?? []).forEach((fn, index) => {\n            const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));\n            service.addEventListener('peer', (evt) => {\n                this.#onDiscoveryPeer(evt);\n            });\n        });\n        // Transport modules\n        init.transports.forEach((fn, index) => {\n            this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));\n        });\n        // User defined modules\n        if (init.services != null) {\n            for (const name of Object.keys(init.services)) {\n                const createService = init.services[name];\n                const service = createService(this.components);\n                if (service == null) {\n                    log.error('service factory %s returned null or undefined instance', name);\n                    continue;\n                }\n                this.services[name] = service;\n                this.configureComponent(name, service);\n                if (service[contentRouting] != null) {\n                    log('registering service %s for content routing', name);\n                    contentRouters.push(service[contentRouting]);\n                }\n                if (service[peerRouting] != null) {\n                    log('registering service %s for peer routing', name);\n                    peerRouters.push(service[peerRouting]);\n                }\n                if (service[peerDiscovery] != null) {\n                    log('registering service %s for peer discovery', name);\n                    service[peerDiscovery].addEventListener('peer', (evt) => {\n                        this.#onDiscoveryPeer(evt);\n                    });\n                }\n            }\n        }\n    }\n    configureComponent(name, component) {\n        if (component == null) {\n            log.error('component %s was null or undefined', name);\n        }\n        this.components[name] = component;\n        return component;\n    }\n    /**\n     * Starts the libp2p node and all its subsystems\n     */\n    async start() {\n        if (this.#started) {\n            return;\n        }\n        this.#started = true;\n        log('libp2p is starting');\n        const keys = await this.keychain.listKeys();\n        if (keys.find(key => key.name === 'self') == null) {\n            log('importing self key into keychain');\n            await this.keychain.importPeer('self', this.components.peerId);\n        }\n        try {\n            await this.components.beforeStart?.();\n            await this.components.start();\n            await this.components.afterStart?.();\n            this.safeDispatchEvent('start', { detail: this });\n            log('libp2p has started');\n        }\n        catch (err) {\n            log.error('An error occurred starting libp2p', err);\n            await this.stop();\n            throw err;\n        }\n    }\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     */\n    async stop() {\n        if (!this.#started) {\n            return;\n        }\n        log('libp2p is stopping');\n        this.#started = false;\n        await this.components.beforeStop?.();\n        await this.components.stop();\n        await this.components.afterStop?.();\n        this.safeDispatchEvent('stop', { detail: this });\n        log('libp2p has stopped');\n    }\n    isStarted() {\n        return this.#started;\n    }\n    getConnections(peerId) {\n        return this.components.connectionManager.getConnections(peerId);\n    }\n    getDialQueue() {\n        return this.components.connectionManager.getDialQueue();\n    }\n    getPeers() {\n        const peerSet = new PeerSet();\n        for (const conn of this.components.connectionManager.getConnections()) {\n            peerSet.add(conn.remotePeer);\n        }\n        return Array.from(peerSet);\n    }\n    async dial(peer, options = {}) {\n        return this.components.connectionManager.openConnection(peer, options);\n    }\n    async dialProtocol(peer, protocols, options = {}) {\n        if (protocols == null) {\n            throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n        }\n        protocols = Array.isArray(protocols) ? protocols : [protocols];\n        if (protocols.length === 0) {\n            throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n        }\n        const connection = await this.dial(peer, options);\n        return connection.newStream(protocols, options);\n    }\n    getMultiaddrs() {\n        return this.components.addressManager.getAddresses();\n    }\n    getProtocols() {\n        return this.components.registrar.getProtocols();\n    }\n    async hangUp(peer, options = {}) {\n        if (isMultiaddr(peer)) {\n            peer = peerIdFromString(peer.getPeerId() ?? '');\n        }\n        await this.components.connectionManager.closeConnections(peer, options);\n    }\n    /**\n     * Get the public key for the given peer id\n     */\n    async getPublicKey(peer, options = {}) {\n        log('getPublicKey %p', peer);\n        if (peer.publicKey != null) {\n            return peer.publicKey;\n        }\n        const peerInfo = await this.peerStore.get(peer);\n        if (peerInfo.id.publicKey != null) {\n            return peerInfo.id.publicKey;\n        }\n        const peerKey = uint8ArrayConcat([\n            uint8ArrayFromString('/pk/'),\n            peer.multihash.digest\n        ]);\n        // search any available content routing methods\n        const bytes = await this.contentRouting.get(peerKey, options);\n        // ensure the returned key is valid\n        unmarshalPublicKey(bytes);\n        await this.peerStore.patch(peer, {\n            publicKey: bytes\n        });\n        return bytes;\n    }\n    async handle(protocols, handler, options) {\n        if (!Array.isArray(protocols)) {\n            protocols = [protocols];\n        }\n        await Promise.all(protocols.map(async (protocol) => {\n            await this.components.registrar.handle(protocol, handler, options);\n        }));\n    }\n    async unhandle(protocols) {\n        if (!Array.isArray(protocols)) {\n            protocols = [protocols];\n        }\n        await Promise.all(protocols.map(async (protocol) => {\n            await this.components.registrar.unhandle(protocol);\n        }));\n    }\n    async register(protocol, topology) {\n        return this.components.registrar.register(protocol, topology);\n    }\n    unregister(id) {\n        this.components.registrar.unregister(id);\n    }\n    /**\n     * Called whenever peer discovery services emit `peer` events and adds peers\n     * to the peer store.\n     */\n    #onDiscoveryPeer(evt) {\n        const { detail: peer } = evt;\n        if (peer.id.toString() === this.peerId.toString()) {\n            log.error(new Error(codes.ERR_DISCOVERED_SELF));\n            return;\n        }\n        void this.components.peerStore.merge(peer.id, {\n            multiaddrs: peer.multiaddrs,\n            protocols: peer.protocols\n        })\n            .catch(err => { log.error(err); });\n    }\n}\n/**\n * Returns a new Libp2pNode instance - this exposes more of the internals than the\n * libp2p interface and is useful for testing and debugging.\n */\nexport async function createLibp2pNode(options) {\n    if (options.peerId == null) {\n        const datastore = options.datastore;\n        if (datastore != null) {\n            try {\n                // try load the peer id from the keychain\n                const keyChain = new DefaultKeyChain({\n                    datastore\n                }, mergeOptions(DefaultKeyChain.generateOptions(), options.keychain));\n                options.peerId = await keyChain.exportPeerId('self');\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n        }\n    }\n    if (options.peerId == null) {\n        // no peer id in the keychain, create a new peer id\n        options.peerId = await createEd25519PeerId();\n    }\n    return new Libp2pNode(validateConfig(options));\n}\n//# sourceMappingURL=libp2p.js.map","import { randomBytes } from '@libp2p/crypto';\nimport { CodeError } from '@libp2p/interface/errors';\nimport { logger } from '@libp2p/logger';\nimport first from 'it-first';\nimport { pipe } from 'it-pipe';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { codes } from '../errors.js';\nimport { PROTOCOL_PREFIX, PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION, TIMEOUT, MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS } from './constants.js';\nconst log = logger('libp2p:ping');\nclass DefaultPingService {\n    protocol;\n    components;\n    started;\n    timeout;\n    maxInboundStreams;\n    maxOutboundStreams;\n    runOnTransientConnection;\n    constructor(components, init) {\n        this.components = components;\n        this.started = false;\n        this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;\n        this.timeout = init.timeout ?? TIMEOUT;\n        this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;\n        this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;\n        this.runOnTransientConnection = init.runOnTransientConnection ?? true;\n    }\n    async start() {\n        await this.components.registrar.handle(this.protocol, this.handleMessage, {\n            maxInboundStreams: this.maxInboundStreams,\n            maxOutboundStreams: this.maxOutboundStreams,\n            runOnTransientConnection: this.runOnTransientConnection\n        });\n        this.started = true;\n    }\n    async stop() {\n        await this.components.registrar.unhandle(this.protocol);\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    /**\n     * A handler to register with Libp2p to process ping messages\n     */\n    handleMessage(data) {\n        log('incoming ping from %p', data.connection.remotePeer);\n        const { stream } = data;\n        const start = Date.now();\n        void pipe(stream, stream)\n            .catch(err => {\n            log.error('incoming ping from %p failed with error', data.connection.remotePeer, err);\n        })\n            .finally(() => {\n            const ms = Date.now() - start;\n            log('incoming ping from %p complete in %dms', data.connection.remotePeer, ms);\n        });\n    }\n    /**\n     * Ping a given peer and wait for its response, getting the operation latency.\n     *\n     * @param {PeerId|Multiaddr} peer\n     * @returns {Promise<number>}\n     */\n    async ping(peer, options = {}) {\n        log('pinging %p', peer);\n        const start = Date.now();\n        const data = randomBytes(PING_LENGTH);\n        const connection = await this.components.connectionManager.openConnection(peer, options);\n        let stream;\n        let onAbort = () => { };\n        options.signal = options.signal ?? AbortSignal.timeout(this.timeout);\n        try {\n            stream = await connection.newStream(this.protocol, {\n                ...options,\n                runOnTransientConnection: this.runOnTransientConnection\n            });\n            onAbort = () => {\n                stream?.abort(new CodeError('ping timeout', codes.ERR_TIMEOUT));\n            };\n            // make stream abortable\n            options.signal.addEventListener('abort', onAbort, { once: true });\n            const result = await pipe([data], stream, async (source) => first(source));\n            const ms = Date.now() - start;\n            if (result == null) {\n                throw new CodeError(`Did not receive a ping ack after ${ms}ms`, codes.ERR_WRONG_PING_ACK);\n            }\n            if (!uint8ArrayEquals(data, result.subarray())) {\n                throw new CodeError(`Received wrong ping ack after ${ms}ms`, codes.ERR_WRONG_PING_ACK);\n            }\n            log('ping %p complete in %dms', connection.remotePeer, ms);\n            return ms;\n        }\n        catch (err) {\n            log.error('error while pinging %p', connection.remotePeer, err);\n            stream?.abort(err);\n            throw err;\n        }\n        finally {\n            options.signal.removeEventListener('abort', onAbort);\n            if (stream != null) {\n                await stream.close();\n            }\n        }\n    }\n}\nexport function pingService(init = {}) {\n    return (components) => new DefaultPingService(components, init);\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { randomBytes as randB } from '@noble/hashes/utils';\nexport default function randomBytes(length) {\n    if (isNaN(length) || length <= 0) {\n        throw new CodeError('random bytes length must be a Number bigger than 0', 'ERR_INVALID_LENGTH');\n    }\n    return randB(length);\n}\n//# sourceMappingURL=random-bytes.js.map","import { CodeError } from '@libp2p/interface/errors';\nimport { symbol } from '@libp2p/interface/peer-id';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [symbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Envelope;\n(function (Envelope) {\n    let _codec;\n    Envelope.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.publicKey);\n                }\n                if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.payloadType);\n                }\n                if ((obj.payload != null && obj.payload.byteLength > 0)) {\n                    w.uint32(26);\n                    w.bytes(obj.payload);\n                }\n                if ((obj.signature != null && obj.signature.byteLength > 0)) {\n                    w.uint32(42);\n                    w.bytes(obj.signature);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    publicKey: new Uint8Array(0),\n                    payloadType: new Uint8Array(0),\n                    payload: new Uint8Array(0),\n                    signature: new Uint8Array(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.publicKey = reader.bytes();\n                            break;\n                        case 2:\n                            obj.payloadType = reader.bytes();\n                            break;\n                        case 3:\n                            obj.payload = reader.bytes();\n                            break;\n                        case 5:\n                            obj.signature = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Envelope.encode = (obj) => {\n        return encodeMessage(obj, Envelope.codec());\n    };\n    Envelope.decode = (buf) => {\n        return decodeMessage(buf, Envelope.codec());\n    };\n})(Envelope || (Envelope = {}));\n//# sourceMappingURL=envelope.js.map","// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record';\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);\n//# sourceMappingURL=consts.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var PeerRecord;\n(function (PeerRecord) {\n    let AddressInfo;\n    (function (AddressInfo) {\n        let _codec;\n        AddressInfo.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n                        w.uint32(10);\n                        w.bytes(obj.multiaddr);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        multiaddr: new Uint8Array(0)\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.multiaddr = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        AddressInfo.encode = (obj) => {\n            return encodeMessage(obj, AddressInfo.codec());\n        };\n        AddressInfo.decode = (buf) => {\n            return decodeMessage(buf, AddressInfo.codec());\n        };\n    })(AddressInfo = PeerRecord.AddressInfo || (PeerRecord.AddressInfo = {}));\n    let _codec;\n    PeerRecord.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.peerId);\n                }\n                if ((obj.seq != null && obj.seq !== 0n)) {\n                    w.uint32(16);\n                    w.uint64(obj.seq);\n                }\n                if (obj.addresses != null) {\n                    for (const value of obj.addresses) {\n                        w.uint32(26);\n                        PeerRecord.AddressInfo.codec().encode(value, w);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    peerId: new Uint8Array(0),\n                    seq: 0n,\n                    addresses: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.peerId = reader.bytes();\n                            break;\n                        case 2:\n                            obj.seq = reader.uint64();\n                            break;\n                        case 3:\n                            obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PeerRecord.encode = (obj) => {\n        return encodeMessage(obj, PeerRecord.codec());\n    };\n    PeerRecord.decode = (buf) => {\n        return decodeMessage(buf, PeerRecord.codec());\n    };\n})(PeerRecord || (PeerRecord = {}));\n//# sourceMappingURL=peer-record.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new DefaultMultiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass DefaultMultiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new DefaultMultiaddr(addr);\n        return new DefaultMultiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new DefaultMultiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new DefaultMultiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new DefaultMultiaddr(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_queue;\nimport lowerBound from './lower-bound.js';\nclass PriorityQueue {\n    constructor() {\n        _PriorityQueue_queue.set(this, []);\n    }\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\")[this.size - 1].priority >= options.priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").push(element);\n            return;\n        }\n        const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, \"f\"), element, (a, b) => b.priority - a.priority);\n        __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").splice(index, 0, element);\n    }\n    dequeue() {\n        const item = __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").length;\n    }\n}\n_PriorityQueue_queue = new WeakMap();\nexport default PriorityQueue;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\nexport default PQueue;\n","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\n\tconst cancelablePromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tresolve(promise);\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t} finally {\n\t\t\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\t\t}\n\t\t})();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","const events = {};\nconst observable = (worker) => {\n    worker.addEventListener('message', (event) => {\n        observable.dispatchEvent('message', worker, event);\n    });\n    if (worker.port != null) {\n        worker.port.addEventListener('message', (event) => {\n            observable.dispatchEvent('message', worker, event);\n        });\n    }\n};\nobservable.addEventListener = (type, fn) => {\n    if (events[type] == null) {\n        events[type] = [];\n    }\n    events[type].push(fn);\n};\nobservable.removeEventListener = (type, fn) => {\n    if (events[type] == null) {\n        return;\n    }\n    events[type] = events[type]\n        .filter(listener => listener === fn);\n};\nobservable.dispatchEvent = function (type, worker, event) {\n    if (events[type] == null) {\n        return;\n    }\n    events[type].forEach(fn => fn(worker, event));\n};\nexport default observable;\n//# sourceMappingURL=index.js.map","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","// @ts-check\n\nimport * as identityBase from './bases/identity.js'\nimport * as base2 from './bases/base2.js'\nimport * as base8 from './bases/base8.js'\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as sha2 from './hashes/sha2.js'\nimport * as identity from './hashes/identity.js'\n\nimport * as raw from './codecs/raw.js'\nimport * as json from './codecs/json.js'\n\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n","// @ts-check\n\nimport { coerce } from '../bytes.js'\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nexport const name = 'raw'\nexport const code = 0x55\n\n/**\n * @param {Uint8Array} node\n * @returns {ByteView<Uint8Array>}\n */\nexport const encode = (node) => coerce(node)\n\n/**\n * @param {ByteView<Uint8Array>} data\n * @returns {Uint8Array}\n */\nexport const decode = (data) => coerce(data)\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_queue;\nimport lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    constructor() {\n        _PriorityQueue_queue.set(this, []);\n    }\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\")[this.size - 1].priority >= options.priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").push(element);\n            return;\n        }\n        const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, \"f\"), element, (a, b) => b.priority - a.priority);\n        __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").splice(index, 0, element);\n    }\n    dequeue() {\n        const item = __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").length;\n    }\n}\n_PriorityQueue_queue = new WeakMap();\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport EventEmitter from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\n","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined ?\n\tnew AbortError(errorMessage) :\n\tnew DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined ?\n\t\tgetDOMException('This operation was aborted.') :\n\t\tsignal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, milliseconds, fallback, options) {\n\tlet timer;\n\n\tconst cancelablePromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tresolve(promise);\n\t\t\treturn;\n\t\t}\n\n\t\toptions = {\n\t\t\tcustomTimers: {setTimeout, clearTimeout},\n\t\t\t...options\n\t\t};\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\ttimer = options.customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (typeof fallback === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\treject(timeoutError);\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t} finally {\n\t\t\t\toptions.customTimers.clearTimeout.call(undefined, timer);\n\t\t\t}\n\t\t})();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tclearTimeout(timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","import { Netmask } from 'netmask';\nimport ip_regex from 'ip-regex';\nimport { isIP } from '@chainsafe/is-ip';\nimport ipaddr from 'ipaddr.js';\nconst { isValid: is_valid, parse } = ipaddr;\nconst PRIVATE_IP_RANGES = [\n    '0.0.0.0/8',\n    '10.0.0.0/8',\n    '100.64.0.0/10',\n    '127.0.0.0/8',\n    '169.254.0.0/16',\n    '172.16.0.0/12',\n    '192.0.0.0/24',\n    '192.0.0.0/29',\n    '192.0.0.8/32',\n    '192.0.0.9/32',\n    '192.0.0.10/32',\n    '192.0.0.170/32',\n    '192.0.0.171/32',\n    '192.0.2.0/24',\n    '192.31.196.0/24',\n    '192.52.193.0/24',\n    '192.88.99.0/24',\n    '192.168.0.0/16',\n    '192.175.48.0/24',\n    '198.18.0.0/15',\n    '198.51.100.0/24',\n    '203.0.113.0/24',\n    '240.0.0.0/4',\n    '255.255.255.255/32'\n];\nconst NETMASK_RANGES = PRIVATE_IP_RANGES.map(ip_range => new Netmask(ip_range));\nfunction ipv4_check(ip_addr) {\n    for (let r of NETMASK_RANGES) {\n        if (r.contains(ip_addr))\n            return true;\n    }\n    return false;\n}\nfunction ipv6_check(ip_addr) {\n    return /^::$/.test(ip_addr) ||\n        /^::1$/.test(ip_addr) ||\n        /^::f{4}:([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ip_addr) ||\n        /^::f{4}:0.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ip_addr) ||\n        /^64:ff9b::([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ip_addr) ||\n        /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) ||\n        /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) ||\n        /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);\n}\nexport default (ip) => {\n    if (is_valid(ip)) {\n        const parsed = parse(ip);\n        if (parsed.kind() === 'ipv4')\n            return ipv4_check(parsed.toNormalizedString());\n        else if (parsed.kind() === 'ipv6')\n            return ipv6_check(ip);\n    }\n    else if (isIP(ip) && ip_regex.v6().test(ip))\n        return ipv6_check(ip);\n    return undefined;\n};\n","'use strict'\n\nimport is_ip_private from './lib/index.js'\nexport default is_ip_private","/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent extends Event {\n    constructor(type, detail) {\n        super(type);\n        this.detail = detail;\n    }\n}\n//# sourceMappingURL=index.js.map","import { concat } from 'uint8arrays/concat';\nimport { equals } from 'uint8arrays/equals';\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc';\nconst symbol = Symbol.for('@achingbrain/uint8arraylist');\nfunction findBufAndOffset(bufs, index) {\n    if (index == null || index < 0) {\n        throw new RangeError('index is out of bounds');\n    }\n    let offset = 0;\n    for (const buf of bufs) {\n        const bufEnd = offset + buf.byteLength;\n        if (index < bufEnd) {\n            return {\n                buf,\n                index: index - offset\n            };\n        }\n        offset = bufEnd;\n    }\n    throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList(value) {\n    return Boolean(value?.[symbol]);\n}\nexport class Uint8ArrayList {\n    constructor(...data) {\n        // Define symbol\n        Object.defineProperty(this, symbol, { value: true });\n        this.bufs = [];\n        this.length = 0;\n        if (data.length > 0) {\n            this.appendAll(data);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this.bufs;\n    }\n    get byteLength() {\n        return this.length;\n    }\n    /**\n     * Add one or more `bufs` to the end of this Uint8ArrayList\n     */\n    append(...bufs) {\n        this.appendAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the end of this Uint8ArrayList\n     */\n    appendAll(bufs) {\n        let length = 0;\n        for (const buf of bufs) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.push(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.push(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Add one or more `bufs` to the start of this Uint8ArrayList\n     */\n    prepend(...bufs) {\n        this.prependAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the start of this Uint8ArrayList\n     */\n    prependAll(bufs) {\n        let length = 0;\n        for (const buf of bufs.reverse()) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.unshift(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.unshift(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Read the value at `index`\n     */\n    get(index) {\n        const res = findBufAndOffset(this.bufs, index);\n        return res.buf[res.index];\n    }\n    /**\n     * Set the value at `index` to `value`\n     */\n    set(index, value) {\n        const res = findBufAndOffset(this.bufs, index);\n        res.buf[res.index] = value;\n    }\n    /**\n     * Copy bytes from `buf` to the index specified by `offset`\n     */\n    write(buf, offset = 0) {\n        if (buf instanceof Uint8Array) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf[i]);\n            }\n        }\n        else if (isUint8ArrayList(buf)) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf.get(i));\n            }\n        }\n        else {\n            throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n        }\n    }\n    /**\n     * Remove bytes from the front of the pool\n     */\n    consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes);\n        // do nothing if not a positive number\n        if (Number.isNaN(bytes) || bytes <= 0) {\n            return;\n        }\n        // if consuming all bytes, skip iterating\n        if (bytes === this.byteLength) {\n            this.bufs = [];\n            this.length = 0;\n            return;\n        }\n        while (this.bufs.length > 0) {\n            if (bytes >= this.bufs[0].byteLength) {\n                bytes -= this.bufs[0].byteLength;\n                this.length -= this.bufs[0].byteLength;\n                this.bufs.shift();\n            }\n            else {\n                this.bufs[0] = this.bufs[0].subarray(bytes);\n                this.length -= bytes;\n                break;\n            }\n        }\n    }\n    /**\n     * Extracts a section of an array and returns a new array.\n     *\n     * This is a copy operation as it is with Uint8Arrays and Arrays\n     * - note this is different to the behaviour of Node Buffers.\n     */\n    slice(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a alloc from the given start and end element index.\n     *\n     * In the best case where the data extracted comes from a single Uint8Array\n     * internally this is a no-copy operation otherwise it is a copy operation.\n     */\n    subarray(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        if (bufs.length === 1) {\n            return bufs[0];\n        }\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a allocList from the given start and end element index.\n     *\n     * This is a no-copy operation.\n     */\n    sublist(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        const list = new Uint8ArrayList();\n        list.length = length;\n        // don't loop, just set the bufs\n        list.bufs = bufs;\n        return list;\n    }\n    _subList(beginInclusive, endExclusive) {\n        beginInclusive = beginInclusive ?? 0;\n        endExclusive = endExclusive ?? this.length;\n        if (beginInclusive < 0) {\n            beginInclusive = this.length + beginInclusive;\n        }\n        if (endExclusive < 0) {\n            endExclusive = this.length + endExclusive;\n        }\n        if (beginInclusive < 0 || endExclusive > this.length) {\n            throw new RangeError('index is out of bounds');\n        }\n        if (beginInclusive === endExclusive) {\n            return { bufs: [], length: 0 };\n        }\n        if (beginInclusive === 0 && endExclusive === this.length) {\n            return { bufs: [...this.bufs], length: this.length };\n        }\n        const bufs = [];\n        let offset = 0;\n        for (let i = 0; i < this.bufs.length; i++) {\n            const buf = this.bufs[i];\n            const bufStart = offset;\n            const bufEnd = bufStart + buf.byteLength;\n            // for next loop\n            offset = bufEnd;\n            if (beginInclusive >= bufEnd) {\n                // start after this buf\n                continue;\n            }\n            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n            if (sliceStartInBuf && sliceEndsInBuf) {\n                // slice is wholly contained within this buffer\n                if (beginInclusive === bufStart && endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                const start = beginInclusive - bufStart;\n                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n                break;\n            }\n            if (sliceStartInBuf) {\n                // slice starts in this buffer\n                if (beginInclusive === 0) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    continue;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(beginInclusive - bufStart));\n                continue;\n            }\n            if (sliceEndsInBuf) {\n                if (endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(0, endExclusive - bufStart));\n                break;\n            }\n            // slice started before this buffer and ends after it\n            bufs.push(buf);\n        }\n        return { bufs, length: endExclusive - beginInclusive };\n    }\n    indexOf(search, offset = 0) {\n        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n            throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n        }\n        const needle = search instanceof Uint8Array ? search : search.subarray();\n        offset = Number(offset ?? 0);\n        if (isNaN(offset)) {\n            offset = 0;\n        }\n        if (offset < 0) {\n            offset = this.length + offset;\n        }\n        if (offset < 0) {\n            offset = 0;\n        }\n        if (search.length === 0) {\n            return offset > this.length ? this.length : offset;\n        }\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n        const M = needle.byteLength;\n        if (M === 0) {\n            throw new TypeError('search must be at least 1 byte long');\n        }\n        // radix\n        const radix = 256;\n        const rightmostPositions = new Int32Array(radix);\n        // position of the rightmost occurrence of the byte c in the pattern\n        for (let c = 0; c < radix; c++) {\n            // -1 for bytes not in pattern\n            rightmostPositions[c] = -1;\n        }\n        for (let j = 0; j < M; j++) {\n            // rightmost position for bytes in pattern\n            rightmostPositions[needle[j]] = j;\n        }\n        // Return offset of first match, -1 if no match\n        const right = rightmostPositions;\n        const lastIndex = this.byteLength - needle.byteLength;\n        const lastPatIndex = needle.byteLength - 1;\n        let skip;\n        for (let i = offset; i <= lastIndex; i += skip) {\n            skip = 0;\n            for (let j = lastPatIndex; j >= 0; j--) {\n                const char = this.get(i + j);\n                if (needle[j] !== char) {\n                    skip = Math.max(1, j - right[char]);\n                    break;\n                }\n            }\n            if (skip === 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getInt8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt8(0);\n    }\n    setInt8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getInt16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt16(0, littleEndian);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getInt32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt32(0, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigInt64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigInt64(0, littleEndian);\n    }\n    setBigInt64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigInt64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint8(0);\n    }\n    setUint8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getUint16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint16(0, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint32(0, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigUint64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigUint64(0, littleEndian);\n    }\n    setBigUint64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigUint64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat32(0, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat64(0, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof Uint8ArrayList)) {\n            return false;\n        }\n        if (other.bufs.length !== this.bufs.length) {\n            return false;\n        }\n        for (let i = 0; i < this.bufs.length; i++) {\n            if (!equals(this.bufs[i], other.bufs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n     * method if you know the total size of all the Uint8Arrays ahead of time.\n     */\n    static fromUint8Arrays(bufs, length) {\n        const list = new Uint8ArrayList();\n        list.bufs = bufs;\n        if (length == null) {\n            length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);\n        }\n        list.length = length;\n        return list;\n    }\n}\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n//# sourceMappingURL=index.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import detectElectron from 'is-electron'\n\nexport const isEnvWithDom = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9\nexport const isElectron = detectElectron()\n\n/**\n * Detects browser main thread  **NOT** web worker or service worker\n */\nexport const isBrowser = isEnvWithDom && !isElectron\nexport const isElectronMain = isElectron && !isEnvWithDom\nexport const isElectronRenderer = isElectron && isEnvWithDom\nexport const isNode = typeof globalThis.process !== 'undefined' && typeof globalThis.process.release !== 'undefined' && globalThis.process.release.name === 'node' && !isElectron\n// @ts-ignore\n// eslint-disable-next-line no-undef\nexport const isWebWorker = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n\n// defeat bundlers replacing process.env.NODE_ENV with \"development\" or whatever\nexport const isTest = typeof globalThis.process !== 'undefined' && typeof globalThis.process.env !== 'undefined' && globalThis.process.env['NODE' + (() => '_')() + 'ENV'] === 'test'\nexport const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'\n"],"names":["module","exports","has","Object","prototype","hasOwnProperty","prefix","Events","EE","fn","context","once","this","addListener","emitter","event","TypeError","listener","evt","_events","push","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","name","names","call","slice","getOwnPropertySymbols","concat","listeners","handlers","i","l","length","ee","Array","listenerCount","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","on","removeAllListeners","off","prefixed","multibase","varint","toString","uint8ArrayToString","fromString","uint8ArrayFromString","uint8ArrayConcat","codes","key","decode","bytes","Uint8Array","Error","code","isValidCode","digest","coerceCode","isAppCode","validate","multihash","freeze","toHexString","hash","fromHexString","toB58String","encode","fromB58String","encoded","hashfn","subarray","encodingLength","exp","Math","timespan","ma","previousTime","v","d","f","ret","time","value","a","diff","sqrt","movingAverage","variance","deviation","forecast","Denque","array","options","_capacity","capacity","_head","_tail","isArray","_fromArray","_capacityMask","_list","peekAt","index","size","get","peek","peekFront","peekBack","defineProperty","unshift","item","_growArray","pop","shift","head","_shrinkArray","tail","removeOne","k","remove","count","removed","del_count","toArray","clear","splice","temp","arg_len","arguments_index","leng","isEmpty","_copyArray","_nextPowerOf2","fullCopy","src","dest","newList","num","nextPow2","log","max","event_iterator_1","EventIterator","cache","_cache","update","set","RateLimiterRedis","RateLimiterMongo","RateLimiterMySQL","RateLimiterPostgres","RateLimiterClusterMaster","RateLimiterClusterMasterPM2","RateLimiterCluster","RateLimiterMemory","RateLimiterMemcache","RLWrapperBlackAndWhite","RateLimiterUnion","RateLimiterQueue","BurstyRateLimiter","RateLimiterRes","read","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","s","NaN","Infinity","pow","write","c","rt","abs","isNaN","floor","LN2","URLWithLegacySupport","format","URLSearchParams","defaultBase","relative","URL","source","matcher","decoder","TextDecoder","chunk","TextEncoder","stream","parts","split","JSON","parse","obj","stringify","isOptionObject","propertyIsEnumerable","object","writable","enumerable","configurable","globalThis","defaultMergeOptions","concatArrays","ignoreUndefined","getEnumerableOwnPropertyKeys","keys","symbols","symbol","clone","result","forEach","cloneArray","getPrototypeOf","cloneOptionObject","mergeKeys","merged","config","merge","resultIndex","indices","String","filter","includes","_","option","truncate","illegalRe","controlRe","reservedRe","windowsReservedRe","windowsTrailingRe","sanitize","input","replacement","sanitized","replace","output","AbortController","retimer","TimeoutController","constructor","ms","super","_ms","_timer","abort","setPrototypeOf","reset","T","g","h","u","trunc","n","t","o","fromDate","fromInt64BE","r","fromInt64LE","year","nano","substr","Date","UTC","p","fromTimeT","y","addNano","getNano","getTimeT","getYear","toDate","getUTCFullYear","M","toJSON","H","C","getUTCHours","L","D","getUTCMilliseconds","getUTCMinutes","N","S","getUTCSeconds","Y","getUTCDay","b","getUTCMonth","getUTCDate","writeInt64BE","writeInt64LE","F","R","X","Z","z","setUTCFullYear","setTime","w","RangeError","KeyType","__KeyTypeValues","PublicKey","PrivateKey","codec","_codec","opts","lengthDelimited","fork","Type","uint32","Data","ldelim","reader","end","pos","tag","skipType","buf","randomBytes","createCodec","encoder","string","str","substring","ascii","fromCharCode","charCodeAt","coerce","ArrayBuffer","isView","byteOffset","byteLength","WeakMap","CID","version","asCID","toV0","DAG_PB_CODE","SHA_256_CODE","createV0","toV1","Digest","createV1","equals","other","static","self","unknown","base","link","toStringTag","Symbol","for","encodeCID","cidSymbol","cid","remainder","decodeFirst","specs","inspectBytes","prefixSize","multihashSize","multihashBytes","digestBytes","digestSize","multihashCode","initialBytes","next","parseCIDtoBytes","baseCache","sizeOffset","digestOffset","identity","encode_1","out","oldOffset","INT","MSB","MSBALL","res","counter","REST$1","MSB$1","N1","N2","N3","N4","N5","N6","N7","N8","N9","encodeTo","int","target","BASES","utf8","hex","latin1","binary","DUMP_SESSION_KEYS","Boolean","process","env","Buffer","allocUnsafe","DataView","setUint16","values","map","reduce","acc","curr","or","PeerIdImpl","type","privateKey","publicKey","init","base58btc","toCID","LIBP2P_KEY_CODE","toBytes","id","uint8ArrayEquals","baseDecoder","charAt","startsWith","Ed25519PeerIdImpl","Secp256k1PeerIdImpl","RSAPeerIdImpl","MARSHALLED_ED225519_PUBLIC_KEY_LENGTH","MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH","sha256","peerIdFromCID","peerIdFromBytes","peerIdFromString","inspect","NoiseExtensions","webtransportCerthashes","NoiseHandshakePayload","writeDefaults","identityKey","identitySig","extensions","keyLogger","assign","enabled","trace","error","base32","alphabet","bitsPerChar","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","base58flickr","sha","async","crypto","subtle","data","sha512","base58","base64","message","Set","namespace","logger","color","destroy","extend","createDisabledLogger","find","FrameType","Flag","x","GoAwayCode","StreamState","CID_CBOR_TAG","decodeOptions","allowIndefinite","coerceUndefinedToNull","allowNaN","allowInfinity","allowBigInt","strict","useMaps","rejectDuplicateMapKeys","tags","Bootstrap","timer","list","timeout","components","_init","candidate","P2P","matches","multiaddr","peerIdStr","getPeerId","peerData","multiaddrs","protocols","isStarted","start","setTimeout","_discoverBootstrapPeers","catch","err","peerStore","tagName","tagValue","ttl","tagTTL","safeDispatchEvent","detail","stop","clearTimeout","decoders","Map","V","getProtocol","proto","row","resolvable","path","createProtocol","contentRouting","AbortError","CodeError","props","UnexpectedPeerError","InvalidCryptoExchangeError","InvalidCryptoTransmissionError","EventTarget","addEventListener","callback","removeEventListener","dispatchEvent","CustomEvent","CustomEventPolyfill","Event","TrackedMap","metric","metrics","registerMetric","updateComponentMetric","delete","deleted","peerDiscovery","peerRouting","TopicValidatorResult","FaultTolerance","_PQueue_instances","_PQueue_carryoverConcurrencyCount","_PQueue_isIntervalIgnored","_PQueue_intervalCount","_PQueue_intervalCap","_PQueue_interval","_PQueue_intervalEnd","_PQueue_intervalId","_PQueue_timeoutId","_PQueue_queue","_PQueue_pending","_PQueue_concurrency","_PQueue_isPaused","_PQueue_doesIntervalAllowAnother_get","_PQueue_doesConcurrentAllowAnother_get","_PQueue_onResumeInterval","_PQueue_isIntervalPaused_get","_PQueue_tryToStartAnother","_PQueue_initializeIntervalIfNeeded","_PQueue_onInterval","_PQueue_processQueue","__classPrivateFieldSet","receiver","state","kind","WeakSet","now","delay","clearInterval","canInitializeInterval","job","dequeue","setInterval","second","Number","Record","timeReceived","alloc","pathSepS","pathSepB","_buf","clean","pathSep","encoding","uint8Array","join","nanoid","fill","less","list1","list2","c1","c2","reverse","withNamespaces","namespaces","baseNamespace","ns","namespaceType","namespaceValue","instance","parent","endsWith","child","isAncestorOf","isDecendantOf","isTopLevel","arr","bits","BigInt","wan","lan","DefaultKadDHT","protocolPrefix","clientMode","DHTContentRouting","DHTPeerRouting","hasPublicAddress","peer","addresses","some","isPublic","tuples","stringTuples","tuple","isPrivate","multiaddrIsPublic","getMode","then","mode","setMode","Promise","all","put","queriedPeers","foundValue","queryErrorEvent","from","peerId","sent","success","errors","dhts","dht","provide","messageName","findProviders","findPeer","getClosestPeers","refreshRoutingTable","EventTypes","MessageType","derivedEmptyPasswordKey","alg","ext","key_ops","kty","algorithm","keyLength","nonceLength","saltLength","iterations","encrypt","password","salt","getRandomValues","nonce","aesGcm","iv","cryptoKey","importKey","deriveParams","runtimeDerivedEmptyPassword","deriveKey","rawKey","ciphertext","decrypt","plaintext","bigIntegerToUintBase64url","toByteArray","base64urlToBigInteger","base64urlToBuffer","base64pad","base64url","base64urlpad","PeerMap","entries","iterator","mapIterable","val","PeerSet","add","predicate","intersection","difference","union","RTCPeerConnection","RTCSessionDescription","RTCIceCandidate","Message","__FlagValues","flag","__TypeValues","_started","dialerEvents","registerCounterGroup","label","help","listenerEvents","registrar","handle","SIGNALING_PROTO_ID","_onProtocol","connection","remotePeer","runOnTransientConnection","unhandle","cleanup","createListener","WebRTCPeerListener","WebRTC","exactMatch","baseAddr","addrs","WEBRTC_TRANSPORT","ERR_INVALID_MULTIADDR","CIRCUIT_RELAY_TRANSPORT","remoteAddr","destinationIdString","lastProtoInRemote","protos","encapsulate","splitAddr","signal","controller","increment","open","transportManager","dial","signalingStream","newStream","pc","muxerFactory","remoteAddress","initiateConnection","rtcConfiguration","dataChannelOptions","dataChannel","upgrader","upgradeOutbound","WebRTCMultiaddrConnection","peerConnection","timeline","skipProtection","skipEncryption","close","handleIncomingStream","upgradeInbound","getTime","rawConn","_connect","unimplemented","WebRTCDirect","remotePeerString","inappropriateMultiaddr","theirPeerId","remoteCerthash","sdp","decodeCerthash","certhash","certificate","generateCertificate","namedCurve","toSupportedHashFunction","certificates","dataChannelOpenPromise","resolve","reject","handshakeDataChannel","createDataChannel","negotiated","handshakeTimeout","readyState","open_error","dataChannelError","onopen","onerror","unknown_error","ufrag","genUfrag","offerSdp","createOffer","mungedOfferSdp","munge","setLocalDescription","answerSdp","fromMultiAddr","setRemoteDescription","myPeerId","fingerprintsPrologue","generateNoisePrologue","noise","Noise","prologueBytes","wrappedChannel","createStream","channel","direction","wrappedDuplex","sink","bind","maConn","eventListeningName","isFirefox","connectionState","finally","peer_connection","DataChannelMuxerFactory","secureInbound","hashCode","getConfiguration","invalidArgument","localFingerprint","getLocalFingerprint","localFpString","trim","toLowerCase","replaceAll","localFpArray","uint8arrayFromString","local","multihashes","remote","mbdecoder","WebSockets","socket","socketToMaConn","conn","aborted","cOpts","toOptions","host","port","errorPromise","pDefer","rawSocket","connect","toUri","race","connected","promise","onAbort","isBrowser","isWebWorker","filters","wss","WebTransportTransport","maxInboundStreams","throwIfAborted","localPeer","url","certhashes","parseMultiaddr","abortListener","cleanUpWTSession","closed","ready","authenticated","pending","wt","WebTransport","serverCertificateHashes","authenticateWebTransport","inertDuplex","webtransportMuxer","createBidirectionalStream","writer","getWriter","readable","getReader","duplex","done","remoteExtensions","secureOutbound","cancel","isSubset","ch","streamIDCounter","protocol","createStreamMuxer","onIncomingStream","activeStreams","incomingBidirectionalStreams","wtStream","webtransportBiDiStreamToStream","onStreamEnd","streams","WebTransportMatcher","bases","base2","base8","base10","base16","base36","base256emoji","DNS4","DNS6","DNSADDR","DNS","IP","TCP","and","UDP","UTP","QUIC","QUICV1","_WebSockets","_WebSocketsSecure","WebSocketsSecure","HTTP","HTTPS","_WebRTCDirect","_WebTransport","P2PWebRTCStar","P2PWebRTCDirect","Reliable","_P2P","_Circuit","CircuitRecursive","Circuit","makeMatchesFunction","partialMatch","protoNames","arg","pnames","func","match","vals","pattern","literal","number","parseInt","optional","matchers","fmt","toParts","_DNS4","_DNS6","_DNSADDR","_DNS","_IP4","_IP6","_IP","IP_OR_DOMAIN","_TCP","_UDP","TCP_OR_UDP","_QUIC","_QUICV1","QUIC_V0_OR_V1","_WEB","DefaultMultiaddr","addr","_DefaultMultiaddr_string","_DefaultMultiaddr_tuples","_DefaultMultiaddr_stringTuples","_a","fromBytes","isMultiaddr","__classPrivateFieldGet","bytesToString","family","transport","zone","tcp","udp","ip4","ip6","dns6","ip6zone","DNS_CODES","protoCodes","sizeForAddr","bytesToTuples","tuplesToStringTuples","decapsulate","addrString","lastIndexOf","decapsulateCode","tuplesToBytes","ipfs","getPath","resolvableProto","resolver","resolvers","errCode","nodeAddress","address","isThinWaistAddress","openFailedError","closeFailedError","putFailedError","getFailedError","deleteFailedError","hasFailedError","notFoundError","abortedError","useBuffer","browser","isBuffer","textDecoder","textEncoder","utf8Slice","utf8ToBytes","fromArray","chunks","compare","b1","b2","units","codePoint","leadSurrogate","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","decodeCodePointsArray","decodeErrPrefix","encodeErrPrefix","uintMinorPrefixBytes","assertEnoughData","need","cborEncoders","encoders","makeCborEncoders","Bl","Ref","stack","simpleTokens","null","true","false","emptyArray","emptyMap","typeEncoders","_typ","_options","_refStack","isInteger","isSafeInteger","bigint","boolean","_obj","refStack","addBreakTokens","createCheck","objectToTokens","typ","isMap","mapSorter","sort","sortMapEntries","is","customTypeEncoder","tokens","typeEncoder","invalidMinor","minor","errorer","msg","jump","quick","quickEncodeToken","token","major","terminal","majorEncoded","uint","negint","float","break","Token","encodedLength","encodedBytes","byteValue","BitswapMessage","Block","Have","DontHave","raw","hashLoader","decoded","isFull","wantlist","full","entry","block","addEntry","priority","wantType","sendDontHave","blockPresences","blockPresence","BlockPresenceType","addHave","addDontHave","blocks","addBlock","payload","cidVersion","multicodec","hashAlg","hasher","getHasher","setPendingBytes","pendingBytes","empty","WantType","cidStr","serializeToBitswap100","serializeToBitswap110","digestLength","bpType","isMapEqual","_cmp","_keys","cmp","_defaultSort","newIdx","_find","indexOf","lower","upper","pivot","_kCmp","cb","thisArg","RPC","SignaturePolicy","PublishConfigType","RejectReason","ValidateError","MessageStatus","DeliveryRecordStatus","getDefault","getOrDefault","MessageSource","ScoreThreshold","InclusionReason","ChurnReason","ScorePenalty","IHaveIgnoreReason","Protocol","GossipStatusCode","MessageTypes","NEW_STREAM","MESSAGE","MESSAGE_INITIATOR","CLOSE","CLOSE_INITIATOR","RESET","RESET_INITIATOR","MESSAGE_RECEIVER","CLOSE_RECEIVER","RESET_RECEIVER","POOL_SIZE","_pool","_poolOffset","pool","header","append","IpnsEntry","ValidityType","__ValidityTypeValues","signatureV1","validityType","validity","sequence","uint64","pubKey","signatureV2","defaultDecodeOptions","allowUndefined","Tokeniser","_pos","byt","padStart","DONE","BREAK","tokensToObject","tokeniser","tokenToArray","tokenToMap","tagged","tokenizer","base36upper","word","boundry","includeBoundaries","v4","v6segment","v6","v46Exact","RegExp","v4exact","v6exact","ipRegex","exact","WantListEntry","_refCounter","inc","dec","hasRefs","aa","bb","ii","defaultLengthDecoder","defaultEncoder","lengthLength","lengthBuf","ReadMode","defaultDecoder","LENGTH","dataLength","lengthDecoder","maxLengthLength","maxDataLength","maybeYield","dataLengthLength","consume","onLength","DATA","sublist","onData","fromReader","__MessageTypeValues","ResponseStatus","__ResponseStatusValues","PeerInfo","Dial","DialResponse","status","statusText","dialResponse","CircuitRelayTransport","discovery","connectionManager","addressManager","connectionGater","reservationStore","maxInboundStopStreams","maxOutboundStopStreams","stopTimeout","started","defaults","discoverRelays","RelayDiscovery","addRelay","ReservationStore","discover","RELAY_V2_STOP_CODEC","onStop","maxOutboundStreams","CIRCUIT_PROTO_CODE","errMsg","ERR_RELAYED_DIAL","relayAddr","destinationAddr","relayId","destinationId","relayPeer","destinationPeer","disconnectOnFailure","relayConnection","getConnections","openConnection","RELAY_V2_HOP_CODEC","connectV2","pbstr","pbStream","hopstr","pb","HopMessage","CONNECT","Status","OK","ERR_HOP_REQUEST_FAILED","streamToMaConnection","unwrap","localAddr","transient","relayStore","mafmt","AbortSignal","StopMessage","request","STATUS","MALFORMED_MESSAGE","UNEXPECTED_MESSAGE","isValidStop","remotePeerId","denyInboundRelayedConnection","PERMISSION_DENIED","getAddresses","Peer","Reservation","Limit","__StatusValues","ReservationVoucher","reservation","limit","expire","voucher","duration","relay","expiration","DIAL_TIMEOUT","MAX_PEER_ADDRS_TO_DIAL","MAX_PARALLEL_DIALS_PER_PEER","AUTO_DIAL_INTERVAL","AUTO_DIAL_CONCURRENCY","AUTO_DIAL_PRIORITY","AUTO_DIAL_MAX_QUEUE_LENGTH","AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE","INBOUND_CONNECTION_THRESHOLD","MAX_INCOMING_PENDING_CONNECTIONS","createAbortError","clearMethods","HolePunch","observedAddresses","messages","Identify","protocolVersion","agentVersion","listenAddrs","observedAddr","signedPeerRecord","Envelope","payloadType","signature","PeerRecord","AddressInfo","seq","Address","Tag","Peer$metadataEntry","Peer$tagsEntry","peerRecordEnvelope","metadata","isCertified","bool","expiry","publicResult","isAPrivate","isBPrivate","publicAddressesFirst","relayResult","isACircuit","isBCircuit","circuitRelayAddressesLast","certifiedResult","certifiedAddressesFirst","dnsaddrCode","hostname","resolveTxt","flat","ConnectionImpl","multiplexer","encryption","_newStream","_close","_abort","_getStreams","getStreams","random","setMaxListeners","TimeoutError","observable","worker","node","isValid","is_valid","ipaddr","NETMASK_RANGES","ip_range","Netmask","ipv6_check","ip_addr","test","ip","parsed","contains","ipv4_check","toNormalizedString","ip_regex","CustomProgressEvent","findBufAndOffset","bufs","bufEnd","isUint8ArrayList","Uint8ArrayList","appendAll","prepend","prependAll","beginInclusive","endExclusive","_subList","bufStart","sliceStartInBuf","sliceEndsInBuf","search","needle","rightmostPositions","Int32Array","right","lastIndex","lastPatIndex","skip","char","getInt8","setInt8","getInt16","littleEndian","setInt16","getInt32","setInt32","getBigInt64","setBigInt64","getUint8","setUint8","getUint16","getUint32","setUint32","getBigUint64","setBigUint64","getFloat32","setFloat32","getFloat64","setFloat64","window","document","nodeType","isElectron","release","importScripts","WorkerGlobalScope","navigator","product"],"sourceRoot":""}